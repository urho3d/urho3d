// DO NOT EDIT. This file is generated

#pragma once

#include "../AngelScript/APITemplates.h"

#include "../AngelScript/Generated_Includes.h"
#include "../AngelScript/Manual.h"

namespace Urho3D
{

// struct AllocatorBlock | File: ../Container/Allocator.h
template <class T> void RegisterMembers_AllocatorBlock(asIScriptEngine* engine, const char* className)
{
    // AllocatorNode* AllocatorBlock::free_
    // Not registered because pointer
    // AllocatorBlock* AllocatorBlock::next_
    // Not registered because pointer

    // unsigned AllocatorBlock::nodeSize_
    engine->RegisterObjectProperty(className, "uint nodeSize", offsetof(T, nodeSize_));

    // unsigned AllocatorBlock::capacity_
    engine->RegisterObjectProperty(className, "uint capacity", offsetof(T, capacity_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AllocatorBlock
        REGISTER_MEMBERS_MANUAL_PART_AllocatorBlock();
    #endif
}

// struct AllocatorNode | File: ../Container/Allocator.h
template <class T> void RegisterMembers_AllocatorNode(asIScriptEngine* engine, const char* className)
{
    // AllocatorNode* AllocatorNode::next_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AllocatorNode
        REGISTER_MEMBERS_MANUAL_PART_AllocatorNode();
    #endif
}

// struct AnimationControl | File: ../Graphics/AnimationController.h
template <class T> void RegisterMembers_AnimationControl(asIScriptEngine* engine, const char* className)
{
    // String AnimationControl::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // StringHash AnimationControl::hash_
    engine->RegisterObjectProperty(className, "StringHash hash", offsetof(T, hash_));

    // float AnimationControl::speed_
    engine->RegisterObjectProperty(className, "float speed", offsetof(T, speed_));

    // float AnimationControl::targetWeight_
    engine->RegisterObjectProperty(className, "float targetWeight", offsetof(T, targetWeight_));

    // float AnimationControl::fadeTime_
    engine->RegisterObjectProperty(className, "float fadeTime", offsetof(T, fadeTime_));

    // float AnimationControl::autoFadeTime_
    engine->RegisterObjectProperty(className, "float autoFadeTime", offsetof(T, autoFadeTime_));

    // float AnimationControl::setTimeTtl_
    engine->RegisterObjectProperty(className, "float setTimeTtl", offsetof(T, setTimeTtl_));

    // float AnimationControl::setWeightTtl_
    engine->RegisterObjectProperty(className, "float setWeightTtl", offsetof(T, setWeightTtl_));

    // unsigned short AnimationControl::setTime_
    engine->RegisterObjectProperty(className, "uint16 setTime", offsetof(T, setTime_));

    // unsigned char AnimationControl::setWeight_
    engine->RegisterObjectProperty(className, "uint8 setWeight", offsetof(T, setWeight_));

    // unsigned char AnimationControl::setTimeRev_
    engine->RegisterObjectProperty(className, "uint8 setTimeRev", offsetof(T, setTimeRev_));

    // unsigned char AnimationControl::setWeightRev_
    engine->RegisterObjectProperty(className, "uint8 setWeightRev", offsetof(T, setWeightRev_));

    // bool AnimationControl::removeOnCompletion_
    engine->RegisterObjectProperty(className, "bool removeOnCompletion", offsetof(T, removeOnCompletion_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationControl
        REGISTER_MEMBERS_MANUAL_PART_AnimationControl();
    #endif
}

// struct AnimationKeyFrame | File: ../Graphics/Animation.h
template <class T> void RegisterMembers_AnimationKeyFrame(asIScriptEngine* engine, const char* className)
{
    // float AnimationKeyFrame::time_
    engine->RegisterObjectProperty(className, "float time", offsetof(T, time_));

    // Vector3 AnimationKeyFrame::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Quaternion AnimationKeyFrame::rotation_
    engine->RegisterObjectProperty(className, "Quaternion rotation", offsetof(T, rotation_));

    // Vector3 AnimationKeyFrame::scale_
    engine->RegisterObjectProperty(className, "Vector3 scale", offsetof(T, scale_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationKeyFrame
        REGISTER_MEMBERS_MANUAL_PART_AnimationKeyFrame();
    #endif
}

// struct AnimationStateTrack | File: ../Graphics/AnimationState.h
template <class T> void RegisterMembers_AnimationStateTrack(asIScriptEngine* engine, const char* className)
{
    // const AnimationTrack* AnimationStateTrack::track_
    // Not registered because pointer
    // Bone* AnimationStateTrack::bone_
    // Not registered because pointer
    // WeakPtr<Node> AnimationStateTrack::node_
    // Error: type "WeakPtr<Node>" can not automatically bind

    // float AnimationStateTrack::weight_
    engine->RegisterObjectProperty(className, "float weight", offsetof(T, weight_));

    // unsigned AnimationStateTrack::keyFrame_
    engine->RegisterObjectProperty(className, "uint keyFrame", offsetof(T, keyFrame_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationStateTrack
        REGISTER_MEMBERS_MANUAL_PART_AnimationStateTrack();
    #endif
}

// struct AnimationTrack | File: ../Graphics/Animation.h
template <class T> void RegisterMembers_AnimationTrack(asIScriptEngine* engine, const char* className)
{
    // AnimationKeyFrame* AnimationTrack::GetKeyFrame(unsigned index)
    // Error: type "AnimationKeyFrame*" can not automatically bind

    // void AnimationTrack::AddKeyFrame(const AnimationKeyFrame& keyFrame)
    engine->RegisterObjectMethod(className, "void AddKeyFrame(const AnimationKeyFrame&in)", AS_METHODPR(T, AddKeyFrame, (const AnimationKeyFrame&), void), AS_CALL_THISCALL);

    // bool AnimationTrack::GetKeyFrameIndex(float time, unsigned& index) const
    engine->RegisterObjectMethod(className, "bool GetKeyFrameIndex(float, uint&) const", AS_METHODPR(T, GetKeyFrameIndex, (float, unsigned&) const, bool), AS_CALL_THISCALL);

    // unsigned AnimationTrack::GetNumKeyFrames() const
    engine->RegisterObjectMethod(className, "uint GetNumKeyFrames() const", AS_METHODPR(T, GetNumKeyFrames, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numKeyFrames() const", AS_METHODPR(T, GetNumKeyFrames, () const, unsigned), AS_CALL_THISCALL);

    // void AnimationTrack::InsertKeyFrame(unsigned index, const AnimationKeyFrame& keyFrame)
    engine->RegisterObjectMethod(className, "void InsertKeyFrame(uint, const AnimationKeyFrame&in)", AS_METHODPR(T, InsertKeyFrame, (unsigned, const AnimationKeyFrame&), void), AS_CALL_THISCALL);

    // void AnimationTrack::RemoveAllKeyFrames()
    engine->RegisterObjectMethod(className, "void RemoveAllKeyFrames()", AS_METHODPR(T, RemoveAllKeyFrames, (), void), AS_CALL_THISCALL);

    // void AnimationTrack::RemoveKeyFrame(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveKeyFrame(uint)", AS_METHODPR(T, RemoveKeyFrame, (unsigned), void), AS_CALL_THISCALL);

    // void AnimationTrack::SetKeyFrame(unsigned index, const AnimationKeyFrame& keyFrame)
    engine->RegisterObjectMethod(className, "void SetKeyFrame(uint, const AnimationKeyFrame&in)", AS_METHODPR(T, SetKeyFrame, (unsigned, const AnimationKeyFrame&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_keyFrames(uint, const AnimationKeyFrame&in)", AS_METHODPR(T, SetKeyFrame, (unsigned, const AnimationKeyFrame&), void), AS_CALL_THISCALL);

    // Vector<AnimationKeyFrame> AnimationTrack::keyFrames_
    // Error: type "Vector<AnimationKeyFrame>" can not automatically bind

    // String AnimationTrack::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // StringHash AnimationTrack::nameHash_
    engine->RegisterObjectProperty(className, "StringHash nameHash", offsetof(T, nameHash_));

    // AnimationChannelFlags AnimationTrack::channelMask_
    engine->RegisterObjectProperty(className, "AnimationChannelFlags channelMask", offsetof(T, channelMask_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationTrack
        REGISTER_MEMBERS_MANUAL_PART_AnimationTrack();
    #endif
}

// struct AnimationTriggerPoint | File: ../Graphics/Animation.h
template <class T> void RegisterMembers_AnimationTriggerPoint(asIScriptEngine* engine, const char* className)
{
    // float AnimationTriggerPoint::time_
    engine->RegisterObjectProperty(className, "float time", offsetof(T, time_));

    // Variant AnimationTriggerPoint::data_
    engine->RegisterObjectProperty(className, "Variant data", offsetof(T, data_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationTriggerPoint
        REGISTER_MEMBERS_MANUAL_PART_AnimationTriggerPoint();
    #endif
}

// class AreaAllocator | File: ../Math/AreaAllocator.h
template <class T> void RegisterMembers_AreaAllocator(asIScriptEngine* engine, const char* className)
{
    // bool AreaAllocator::Allocate(int width, int height, int& x, int& y)
    engine->RegisterObjectMethod(className, "bool Allocate(int, int, int&, int&)", AS_METHODPR(T, Allocate, (int, int, int&, int&), bool), AS_CALL_THISCALL);

    // bool AreaAllocator::GetFastMode() const
    engine->RegisterObjectMethod(className, "bool GetFastMode() const", AS_METHODPR(T, GetFastMode, () const, bool), AS_CALL_THISCALL);

    // int AreaAllocator::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // int AreaAllocator::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // void AreaAllocator::Reset(int width, int height, int maxWidth = 0, int maxHeight = 0, bool fastMode = true)
    engine->RegisterObjectMethod(className, "void Reset(int, int, int = 0, int = 0, bool = true)", AS_METHODPR(T, Reset, (int, int, int, int, bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AreaAllocator
        REGISTER_MEMBERS_MANUAL_PART_AreaAllocator();
    #endif
}

// struct AsyncProgress | File: ../Scene/Scene.h
template <class T> void RegisterMembers_AsyncProgress(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<File> AsyncProgress::file_
    // Error: type "SharedPtr<File>" can not automatically bind
    // SharedPtr<XMLFile> AsyncProgress::xmlFile_
    // Error: type "SharedPtr<XMLFile>" can not automatically bind
    // SharedPtr<JSONFile> AsyncProgress::jsonFile_
    // Error: type "SharedPtr<JSONFile>" can not automatically bind
    // HashSet<StringHash> AsyncProgress::resources_
    // Error: type "HashSet<StringHash>" can not automatically bind

    // XMLElement AsyncProgress::xmlElement_
    engine->RegisterObjectProperty(className, "XMLElement xmlElement", offsetof(T, xmlElement_));

    // unsigned AsyncProgress::jsonIndex_
    engine->RegisterObjectProperty(className, "uint jsonIndex", offsetof(T, jsonIndex_));

    // LoadMode AsyncProgress::mode_
    engine->RegisterObjectProperty(className, "LoadMode mode", offsetof(T, mode_));

    // unsigned AsyncProgress::loadedResources_
    engine->RegisterObjectProperty(className, "uint loadedResources", offsetof(T, loadedResources_));

    // unsigned AsyncProgress::totalResources_
    engine->RegisterObjectProperty(className, "uint totalResources", offsetof(T, totalResources_));

    // unsigned AsyncProgress::loadedNodes_
    engine->RegisterObjectProperty(className, "uint loadedNodes", offsetof(T, loadedNodes_));

    // unsigned AsyncProgress::totalNodes_
    engine->RegisterObjectProperty(className, "uint totalNodes", offsetof(T, totalNodes_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AsyncProgress
        REGISTER_MEMBERS_MANUAL_PART_AsyncProgress();
    #endif
}

// struct AttributeHandle | File: ../Core/Attribute.h
template <class T> void RegisterMembers_AttributeHandle(asIScriptEngine* engine, const char* className)
{
    // AttributeHandle& AttributeHandle::SetMetadata(StringHash key, const Variant& value)
    // Error: type "AttributeHandle" can not automatically bind bacause have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AttributeHandle
        REGISTER_MEMBERS_MANUAL_PART_AttributeHandle();
    #endif
}

// struct AttributeInfo | File: ../Core/Attribute.h
template <class T> void RegisterMembers_AttributeInfo(asIScriptEngine* engine, const char* className)
{
    // const Variant& AttributeInfo::GetMetadata(const StringHash& key) const
    engine->RegisterObjectMethod(className, "const Variant& GetMetadata(const StringHash&in) const", AS_METHODPR(T, GetMetadata, (const StringHash&) const, const Variant&), AS_CALL_THISCALL);

    // template <class T> T AttributeInfo::GetMetadata(const StringHash& key) const
    // Not registered because template

    // const char** AttributeInfo::enumNames_
    // Error: type "const char**" can not automatically bind
    // SharedPtr<AttributeAccessor> AttributeInfo::accessor_
    // Error: type "SharedPtr<AttributeAccessor>" can not automatically bind
    // void* AttributeInfo::ptr_
    // Not registered because pointer

    // VariantType AttributeInfo::type_
    engine->RegisterObjectProperty(className, "VariantType type", offsetof(T, type_));

    // String AttributeInfo::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // Variant AttributeInfo::defaultValue_
    engine->RegisterObjectProperty(className, "Variant defaultValue", offsetof(T, defaultValue_));

    // AttributeModeFlags AttributeInfo::mode_
    engine->RegisterObjectProperty(className, "AttributeModeFlags mode", offsetof(T, mode_));

    // VariantMap AttributeInfo::metadata_
    engine->RegisterObjectProperty(className, "VariantMap metadata", offsetof(T, metadata_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AttributeInfo
        REGISTER_MEMBERS_MANUAL_PART_AttributeInfo();
    #endif
}

// class AutoProfileBlock | File: ../Core/Profiler.h
template <class T> void RegisterMembers_AutoProfileBlock(asIScriptEngine* engine, const char* className)
{
    #ifdef REGISTER_MEMBERS_MANUAL_PART_AutoProfileBlock
        REGISTER_MEMBERS_MANUAL_PART_AutoProfileBlock();
    #endif
}

// struct BackgroundLoadItem | File: ../Resource/BackgroundLoader.h
template <class T> void RegisterMembers_BackgroundLoadItem(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<Resource> BackgroundLoadItem::resource_
    // Error: type "SharedPtr<Resource>" can not automatically bind
    // HashSet<Pair<StringHash, StringHash>> BackgroundLoadItem::dependencies_
    // Error: type "HashSet<Pair<StringHash, StringHash>>" can not automatically bind
    // HashSet<Pair<StringHash, StringHash>> BackgroundLoadItem::dependents_
    // Error: type "HashSet<Pair<StringHash, StringHash>>" can not automatically bind

    // bool BackgroundLoadItem::sendEventOnFailure_
    engine->RegisterObjectProperty(className, "bool sendEventOnFailure", offsetof(T, sendEventOnFailure_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BackgroundLoadItem
        REGISTER_MEMBERS_MANUAL_PART_BackgroundLoadItem();
    #endif
}

// struct Batch | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_Batch(asIScriptEngine* engine, const char* className)
{
    // void Batch::CalculateSortKey()
    engine->RegisterObjectMethod(className, "void CalculateSortKey()", AS_METHODPR(T, CalculateSortKey, (), void), AS_CALL_THISCALL);

    // void Batch::Draw(View* view, Camera* camera, bool allowDepthWrite) const
    engine->RegisterObjectMethod(className, "void Draw(View@+, Camera@+, bool) const", AS_METHODPR(T, Draw, (View*, Camera*, bool) const, void), AS_CALL_THISCALL);

    // void Batch::Prepare(View* view, Camera* camera, bool setModelTransform, bool allowDepthWrite) const
    engine->RegisterObjectMethod(className, "void Prepare(View@+, Camera@+, bool, bool) const", AS_METHODPR(T, Prepare, (View*, Camera*, bool, bool) const, void), AS_CALL_THISCALL);

    // Geometry* Batch::geometry_
    // Not registered because pointer
    // Material* Batch::material_
    // Not registered because pointer
    // const Matrix3x4* Batch::worldTransform_
    // Not registered because pointer
    // void* Batch::instancingData_
    // Not registered because pointer
    // Zone* Batch::zone_
    // Not registered because pointer
    // LightBatchQueue* Batch::lightQueue_
    // Not registered because pointer
    // Pass* Batch::pass_
    // Not registered because pointer
    // ShaderVariation* Batch::vertexShader_
    // Not registered because pointer
    // ShaderVariation* Batch::pixelShader_
    // Not registered because pointer

    // unsigned long long Batch::sortKey_
    engine->RegisterObjectProperty(className, "uint64 sortKey", offsetof(T, sortKey_));

    // float Batch::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    // unsigned char Batch::renderOrder_
    engine->RegisterObjectProperty(className, "uint8 renderOrder", offsetof(T, renderOrder_));

    // unsigned char Batch::lightMask_
    engine->RegisterObjectProperty(className, "uint8 lightMask", offsetof(T, lightMask_));

    // bool Batch::isBase_
    engine->RegisterObjectProperty(className, "bool isBase", offsetof(T, isBase_));

    // unsigned Batch::numWorldTransforms_
    engine->RegisterObjectProperty(className, "uint numWorldTransforms", offsetof(T, numWorldTransforms_));

    // GeometryType Batch::geometryType_
    engine->RegisterObjectProperty(className, "GeometryType geometryType", offsetof(T, geometryType_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Batch
        REGISTER_MEMBERS_MANUAL_PART_Batch();
    #endif
}

// struct BatchGroupKey | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_BatchGroupKey(asIScriptEngine* engine, const char* className)
{
    // bool BatchGroupKey::operator !=(const BatchGroupKey& rhs) const
    // Only operator == is needed

    // bool BatchGroupKey::operator ==(const BatchGroupKey& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const BatchGroupKey&in) const", AS_METHODPR(T, operator==, (const BatchGroupKey&) const, bool), AS_CALL_THISCALL);

    // unsigned BatchGroupKey::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // Zone* BatchGroupKey::zone_
    // Not registered because pointer
    // LightBatchQueue* BatchGroupKey::lightQueue_
    // Not registered because pointer
    // Pass* BatchGroupKey::pass_
    // Not registered because pointer
    // Material* BatchGroupKey::material_
    // Not registered because pointer
    // Geometry* BatchGroupKey::geometry_
    // Not registered because pointer

    // unsigned char BatchGroupKey::renderOrder_
    engine->RegisterObjectProperty(className, "uint8 renderOrder", offsetof(T, renderOrder_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BatchGroupKey
        REGISTER_MEMBERS_MANUAL_PART_BatchGroupKey();
    #endif
}

// struct BatchQueue | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_BatchQueue(asIScriptEngine* engine, const char* className)
{
    // void BatchQueue::SetInstancingData(void* lockedData, unsigned stride, unsigned& freeIndex)
    // Error: type "void*" can not automatically bind
    // void BatchQueue::SortFrontToBack2Pass(PODVector<Batch*>& batches)
    // Error: type "PODVector<Batch*>&" can not automatically bind

    // void BatchQueue::Clear(int maxSortedInstances)
    engine->RegisterObjectMethod(className, "void Clear(int)", AS_METHODPR(T, Clear, (int), void), AS_CALL_THISCALL);

    // void BatchQueue::Draw(View* view, Camera* camera, bool markToStencil, bool usingLightOptimization, bool allowDepthWrite) const
    engine->RegisterObjectMethod(className, "void Draw(View@+, Camera@+, bool, bool, bool) const", AS_METHODPR(T, Draw, (View*, Camera*, bool, bool, bool) const, void), AS_CALL_THISCALL);

    // unsigned BatchQueue::GetNumInstances() const
    engine->RegisterObjectMethod(className, "uint GetNumInstances() const", AS_METHODPR(T, GetNumInstances, () const, unsigned), AS_CALL_THISCALL);

    // bool BatchQueue::IsEmpty() const
    engine->RegisterObjectMethod(className, "bool IsEmpty() const", AS_METHODPR(T, IsEmpty, () const, bool), AS_CALL_THISCALL);

    // void BatchQueue::SortBackToFront()
    engine->RegisterObjectMethod(className, "void SortBackToFront()", AS_METHODPR(T, SortBackToFront, (), void), AS_CALL_THISCALL);

    // void BatchQueue::SortFrontToBack()
    engine->RegisterObjectMethod(className, "void SortFrontToBack()", AS_METHODPR(T, SortFrontToBack, (), void), AS_CALL_THISCALL);

    // HashMap<BatchGroupKey, BatchGroup> BatchQueue::batchGroups_
    // Error: type "HashMap<BatchGroupKey, BatchGroup>" can not automatically bind
    // HashMap<unsigned, unsigned> BatchQueue::shaderRemapping_
    // Error: type "HashMap<unsigned, unsigned>" can not automatically bind
    // HashMap<unsigned short, unsigned short> BatchQueue::materialRemapping_
    // Error: type "HashMap<unsigned short, unsigned short>" can not automatically bind
    // HashMap<unsigned short, unsigned short> BatchQueue::geometryRemapping_
    // Error: type "HashMap<unsigned short, unsigned short>" can not automatically bind
    // PODVector<Batch> BatchQueue::batches_
    // Error: type "PODVector<Batch>" can not automatically bind
    // PODVector<Batch*> BatchQueue::sortedBatches_
    // Error: type "PODVector<Batch*>" can not automatically bind
    // PODVector<BatchGroup*> BatchQueue::sortedBatchGroups_
    // Error: type "PODVector<BatchGroup*>" can not automatically bind

    // unsigned BatchQueue::maxSortedInstances_
    engine->RegisterObjectProperty(className, "uint maxSortedInstances", offsetof(T, maxSortedInstances_));

    // bool BatchQueue::hasExtraDefines_
    engine->RegisterObjectProperty(className, "bool hasExtraDefines", offsetof(T, hasExtraDefines_));

    // String BatchQueue::vsExtraDefines_
    engine->RegisterObjectProperty(className, "String vsExtraDefines", offsetof(T, vsExtraDefines_));

    // String BatchQueue::psExtraDefines_
    engine->RegisterObjectProperty(className, "String psExtraDefines", offsetof(T, psExtraDefines_));

    // StringHash BatchQueue::vsExtraDefinesHash_
    engine->RegisterObjectProperty(className, "StringHash vsExtraDefinesHash", offsetof(T, vsExtraDefinesHash_));

    // StringHash BatchQueue::psExtraDefinesHash_
    engine->RegisterObjectProperty(className, "StringHash psExtraDefinesHash", offsetof(T, psExtraDefinesHash_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BatchQueue
        REGISTER_MEMBERS_MANUAL_PART_BatchQueue();
    #endif
}

// struct BiasParameters | File: ../Graphics/Light.h
template <class T> void RegisterMembers_BiasParameters(asIScriptEngine* engine, const char* className)
{
    // void BiasParameters::Validate()
    engine->RegisterObjectMethod(className, "void Validate()", AS_METHODPR(T, Validate, (), void), AS_CALL_THISCALL);

    // float BiasParameters::constantBias_
    engine->RegisterObjectProperty(className, "float constantBias", offsetof(T, constantBias_));

    // float BiasParameters::slopeScaledBias_
    engine->RegisterObjectProperty(className, "float slopeScaledBias", offsetof(T, slopeScaledBias_));

    // float BiasParameters::normalOffset_
    engine->RegisterObjectProperty(className, "float normalOffset", offsetof(T, normalOffset_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BiasParameters
        REGISTER_MEMBERS_MANUAL_PART_BiasParameters();
    #endif
}

// struct Billboard | File: ../Graphics/BillboardSet.h
template <class T> void RegisterMembers_Billboard(asIScriptEngine* engine, const char* className)
{
    // Vector3 Billboard::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Vector2 Billboard::size_
    engine->RegisterObjectProperty(className, "Vector2 size", offsetof(T, size_));

    // Rect Billboard::uv_
    engine->RegisterObjectProperty(className, "Rect uv", offsetof(T, uv_));

    // Color Billboard::color_
    engine->RegisterObjectProperty(className, "Color color", offsetof(T, color_));

    // float Billboard::rotation_
    engine->RegisterObjectProperty(className, "float rotation", offsetof(T, rotation_));

    // Vector3 Billboard::direction_
    engine->RegisterObjectProperty(className, "Vector3 direction", offsetof(T, direction_));

    // bool Billboard::enabled_
    engine->RegisterObjectProperty(className, "bool enabled", offsetof(T, enabled_));

    // float Billboard::sortDistance_
    engine->RegisterObjectProperty(className, "float sortDistance", offsetof(T, sortDistance_));

    // float Billboard::screenScaleFactor_
    engine->RegisterObjectProperty(className, "float screenScaleFactor", offsetof(T, screenScaleFactor_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Billboard
        REGISTER_MEMBERS_MANUAL_PART_Billboard();
    #endif
}

// struct Bone | File: ../Graphics/Skeleton.h
template <class T> void RegisterMembers_Bone(asIScriptEngine* engine, const char* className)
{
    // WeakPtr<Node> Bone::node_
    // Error: type "WeakPtr<Node>" can not automatically bind

    // String Bone::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // StringHash Bone::nameHash_
    engine->RegisterObjectProperty(className, "StringHash nameHash", offsetof(T, nameHash_));

    // unsigned Bone::parentIndex_
    engine->RegisterObjectProperty(className, "uint parentIndex", offsetof(T, parentIndex_));

    // Vector3 Bone::initialPosition_
    engine->RegisterObjectProperty(className, "Vector3 initialPosition", offsetof(T, initialPosition_));

    // Quaternion Bone::initialRotation_
    engine->RegisterObjectProperty(className, "Quaternion initialRotation", offsetof(T, initialRotation_));

    // Vector3 Bone::initialScale_
    engine->RegisterObjectProperty(className, "Vector3 initialScale", offsetof(T, initialScale_));

    // Matrix3x4 Bone::offsetMatrix_
    engine->RegisterObjectProperty(className, "Matrix3x4 offsetMatrix", offsetof(T, offsetMatrix_));

    // bool Bone::animated_
    engine->RegisterObjectProperty(className, "bool animated", offsetof(T, animated_));

    // BoneCollisionShapeFlags Bone::collisionMask_
    engine->RegisterObjectProperty(className, "BoneCollisionShapeFlags collisionMask", offsetof(T, collisionMask_));

    // float Bone::radius_
    engine->RegisterObjectProperty(className, "float radius", offsetof(T, radius_));

    // BoundingBox Bone::boundingBox_
    engine->RegisterObjectProperty(className, "BoundingBox boundingBox", offsetof(T, boundingBox_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Bone
        REGISTER_MEMBERS_MANUAL_PART_Bone();
    #endif
}

// class BoundingBox | File: ../Math/BoundingBox.h
template <class T> void RegisterMembers_BoundingBox(asIScriptEngine* engine, const char* className)
{
    // void BoundingBox::Define(const Vector3* vertices, unsigned count)
    // Error: type "const Vector3*" can not automatically bind
    // void BoundingBox::Merge(const Vector3* vertices, unsigned count)
    // Error: type "const Vector3*" can not automatically bind
    // bool BoundingBox::operator !=(const BoundingBox& rhs) const
    // Only operator == is needed

    // Vector3 BoundingBox::Center() const
    engine->RegisterObjectMethod(className, "Vector3 Center() const", AS_METHODPR(T, Center, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_center() const", AS_METHODPR(T, Center, () const, Vector3), AS_CALL_THISCALL);

    // void BoundingBox::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void BoundingBox::Clip(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Clip(const BoundingBox&in)", AS_METHODPR(T, Clip, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Define(const BoundingBox&in)", AS_METHODPR(T, Define, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const Rect& rect)
    engine->RegisterObjectMethod(className, "void Define(const Rect&in)", AS_METHODPR(T, Define, (const Rect&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const Vector3& min, const Vector3& max)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in, const Vector3&in)", AS_METHODPR(T, Define, (const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(float min, float max)
    engine->RegisterObjectMethod(className, "void Define(float, float)", AS_METHODPR(T, Define, (float, float), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const Vector3& point)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in)", AS_METHODPR(T, Define, (const Vector3&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const Frustum& frustum)
    engine->RegisterObjectMethod(className, "void Define(const Frustum&in)", AS_METHODPR(T, Define, (const Frustum&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const Polyhedron& poly)
    engine->RegisterObjectMethod(className, "void Define(const Polyhedron&in)", AS_METHODPR(T, Define, (const Polyhedron&), void), AS_CALL_THISCALL);

    // void BoundingBox::Define(const Sphere& sphere)
    engine->RegisterObjectMethod(className, "void Define(const Sphere&in)", AS_METHODPR(T, Define, (const Sphere&), void), AS_CALL_THISCALL);

    // bool BoundingBox::Defined() const
    engine->RegisterObjectMethod(className, "bool Defined() const", AS_METHODPR(T, Defined, () const, bool), AS_CALL_THISCALL);

    // float BoundingBox::DistanceToPoint(const Vector3& point) const
    engine->RegisterObjectMethod(className, "float DistanceToPoint(const Vector3&in) const", AS_METHODPR(T, DistanceToPoint, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Vector3 BoundingBox::HalfSize() const
    engine->RegisterObjectMethod(className, "Vector3 HalfSize() const", AS_METHODPR(T, HalfSize, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_halfSize() const", AS_METHODPR(T, HalfSize, () const, Vector3), AS_CALL_THISCALL);

    // Intersection BoundingBox::IsInside(const Vector3& point) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Vector3&in) const", AS_METHODPR(T, IsInside, (const Vector3&) const, Intersection), AS_CALL_THISCALL);

    // Intersection BoundingBox::IsInside(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const BoundingBox&in) const", AS_METHODPR(T, IsInside, (const BoundingBox&) const, Intersection), AS_CALL_THISCALL);

    // Intersection BoundingBox::IsInside(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Sphere&in) const", AS_METHODPR(T, IsInside, (const Sphere&) const, Intersection), AS_CALL_THISCALL);

    // Intersection BoundingBox::IsInsideFast(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "Intersection IsInsideFast(const BoundingBox&in) const", AS_METHODPR(T, IsInsideFast, (const BoundingBox&) const, Intersection), AS_CALL_THISCALL);

    // Intersection BoundingBox::IsInsideFast(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "Intersection IsInsideFast(const Sphere&in) const", AS_METHODPR(T, IsInsideFast, (const Sphere&) const, Intersection), AS_CALL_THISCALL);

    // void BoundingBox::Merge(const Vector3& point)
    engine->RegisterObjectMethod(className, "void Merge(const Vector3&in)", AS_METHODPR(T, Merge, (const Vector3&), void), AS_CALL_THISCALL);

    // void BoundingBox::Merge(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Merge(const BoundingBox&in)", AS_METHODPR(T, Merge, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void BoundingBox::Merge(const Frustum& frustum)
    engine->RegisterObjectMethod(className, "void Merge(const Frustum&in)", AS_METHODPR(T, Merge, (const Frustum&), void), AS_CALL_THISCALL);

    // void BoundingBox::Merge(const Polyhedron& poly)
    engine->RegisterObjectMethod(className, "void Merge(const Polyhedron&in)", AS_METHODPR(T, Merge, (const Polyhedron&), void), AS_CALL_THISCALL);

    // void BoundingBox::Merge(const Sphere& sphere)
    engine->RegisterObjectMethod(className, "void Merge(const Sphere&in)", AS_METHODPR(T, Merge, (const Sphere&), void), AS_CALL_THISCALL);

    // BoundingBox& BoundingBox::operator =(const BoundingBox& rhs) noexcept
    engine->RegisterObjectMethod(className, "BoundingBox& opAssign(const BoundingBox&in)", AS_METHODPR(T, operator=, (const BoundingBox&), BoundingBox&), AS_CALL_THISCALL);

    // BoundingBox& BoundingBox::operator =(const Rect& rhs) noexcept
    engine->RegisterObjectMethod(className, "BoundingBox& opAssign(const Rect&in)", AS_METHODPR(T, operator=, (const Rect&), BoundingBox&), AS_CALL_THISCALL);

    // bool BoundingBox::operator ==(const BoundingBox& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const BoundingBox&in) const", AS_METHODPR(T, operator==, (const BoundingBox&) const, bool), AS_CALL_THISCALL);

    // Rect BoundingBox::Projected(const Matrix4& projection) const
    engine->RegisterObjectMethod(className, "Rect Projected(const Matrix4&in) const", AS_METHODPR(T, Projected, (const Matrix4&) const, Rect), AS_CALL_THISCALL);

    // Vector3 BoundingBox::Size() const
    engine->RegisterObjectMethod(className, "Vector3 Size() const", AS_METHODPR(T, Size, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_size() const", AS_METHODPR(T, Size, () const, Vector3), AS_CALL_THISCALL);

    // String BoundingBox::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // void BoundingBox::Transform(const Matrix3& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3&in)", AS_METHODPR(T, Transform, (const Matrix3&), void), AS_CALL_THISCALL);

    // void BoundingBox::Transform(const Matrix3x4& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3x4&in)", AS_METHODPR(T, Transform, (const Matrix3x4&), void), AS_CALL_THISCALL);

    // BoundingBox BoundingBox::Transformed(const Matrix3& transform) const
    engine->RegisterObjectMethod(className, "BoundingBox Transformed(const Matrix3&in) const", AS_METHODPR(T, Transformed, (const Matrix3&) const, BoundingBox), AS_CALL_THISCALL);

    // BoundingBox BoundingBox::Transformed(const Matrix3x4& transform) const
    engine->RegisterObjectMethod(className, "BoundingBox Transformed(const Matrix3x4&in) const", AS_METHODPR(T, Transformed, (const Matrix3x4&) const, BoundingBox), AS_CALL_THISCALL);

    // Vector3 BoundingBox::min_
    engine->RegisterObjectProperty(className, "Vector3 min", offsetof(T, min_));

    // float BoundingBox::dummyMin_
    engine->RegisterObjectProperty(className, "float dummyMin", offsetof(T, dummyMin_));

    // Vector3 BoundingBox::max_
    engine->RegisterObjectProperty(className, "Vector3 max", offsetof(T, max_));

    // float BoundingBox::dummyMax_
    engine->RegisterObjectProperty(className, "float dummyMax", offsetof(T, dummyMax_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BoundingBox
        REGISTER_MEMBERS_MANUAL_PART_BoundingBox();
    #endif
}

// struct CascadeParameters | File: ../Graphics/Light.h
template <class T> void RegisterMembers_CascadeParameters(asIScriptEngine* engine, const char* className)
{
    // float CascadeParameters::GetShadowRange() const
    engine->RegisterObjectMethod(className, "float GetShadowRange() const", AS_METHODPR(T, GetShadowRange, () const, float), AS_CALL_THISCALL);

    // void CascadeParameters::Validate()
    engine->RegisterObjectMethod(className, "void Validate()", AS_METHODPR(T, Validate, (), void), AS_CALL_THISCALL);

    // Vector4 CascadeParameters::splits_
    engine->RegisterObjectProperty(className, "Vector4 splits", offsetof(T, splits_));

    // float CascadeParameters::fadeStart_
    engine->RegisterObjectProperty(className, "float fadeStart", offsetof(T, fadeStart_));

    // float CascadeParameters::biasAutoAdjust_
    engine->RegisterObjectProperty(className, "float biasAutoAdjust", offsetof(T, biasAutoAdjust_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CascadeParameters
        REGISTER_MEMBERS_MANUAL_PART_CascadeParameters();
    #endif
}

// struct CharLocation | File: ../UI/Text.h
template <class T> void RegisterMembers_CharLocation(asIScriptEngine* engine, const char* className)
{
    // Vector2 CharLocation::position_
    engine->RegisterObjectProperty(className, "Vector2 position", offsetof(T, position_));

    // Vector2 CharLocation::size_
    engine->RegisterObjectProperty(className, "Vector2 size", offsetof(T, size_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CharLocation
        REGISTER_MEMBERS_MANUAL_PART_CharLocation();
    #endif
}

// class Color | File: ../Math/Color.h
template <class T> void RegisterMembers_Color(asIScriptEngine* engine, const char* className)
{
    // void Color::Bounds(float* min, float* max, bool clipped = false) const
    // Error: type "float*" can not automatically bind
    // const float* Color::Data() const
    // Error: type "const float*" can not automatically bind
    // void Color::FromUIntMask(unsigned color, const ChannelMask& mask)
    // Error: type "const ChannelMask&" can not automatically bind
    // bool Color::operator !=(const Color& rhs) const
    // Only operator == is needed
    // unsigned Color::ToUIntMask(const ChannelMask& mask) const
    // Error: type "const ChannelMask&" can not automatically bind

    // Color Color::Abs() const
    engine->RegisterObjectMethod(className, "Color Abs() const", AS_METHODPR(T, Abs, () const, Color), AS_CALL_THISCALL);

    // float Color::Average() const
    engine->RegisterObjectMethod(className, "float Average() const", AS_METHODPR(T, Average, () const, float), AS_CALL_THISCALL);

    // float Color::Chroma() const
    engine->RegisterObjectMethod(className, "float Chroma() const", AS_METHODPR(T, Chroma, () const, float), AS_CALL_THISCALL);

    // void Color::Clip(bool clipAlpha = false)
    engine->RegisterObjectMethod(className, "void Clip(bool = false)", AS_METHODPR(T, Clip, (bool), void), AS_CALL_THISCALL);

    // bool Color::Equals(const Color& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Color&in) const", AS_METHODPR(T, Equals, (const Color&) const, bool), AS_CALL_THISCALL);

    // void Color::FromHSL(float h, float s, float l, float a = 1.0f)
    engine->RegisterObjectMethod(className, "void FromHSL(float, float, float, float = 1.0f)", AS_METHODPR(T, FromHSL, (float, float, float, float), void), AS_CALL_THISCALL);

    // void Color::FromHSV(float h, float s, float v, float a = 1.0f)
    engine->RegisterObjectMethod(className, "void FromHSV(float, float, float, float = 1.0f)", AS_METHODPR(T, FromHSV, (float, float, float, float), void), AS_CALL_THISCALL);

    // void Color::FromUInt(unsigned color)
    engine->RegisterObjectMethod(className, "void FromUInt(uint)", AS_METHODPR(T, FromUInt, (unsigned), void), AS_CALL_THISCALL);

    // Color Color::GammaToLinear() const
    engine->RegisterObjectMethod(className, "Color GammaToLinear() const", AS_METHODPR(T, GammaToLinear, () const, Color), AS_CALL_THISCALL);

    // float Color::Hue() const
    engine->RegisterObjectMethod(className, "float Hue() const", AS_METHODPR(T, Hue, () const, float), AS_CALL_THISCALL);

    // void Color::Invert(bool invertAlpha = false)
    engine->RegisterObjectMethod(className, "void Invert(bool = false)", AS_METHODPR(T, Invert, (bool), void), AS_CALL_THISCALL);

    // Color Color::Lerp(const Color& rhs, float t) const
    engine->RegisterObjectMethod(className, "Color Lerp(const Color&in, float) const", AS_METHODPR(T, Lerp, (const Color&, float) const, Color), AS_CALL_THISCALL);

    // float Color::Lightness() const
    engine->RegisterObjectMethod(className, "float Lightness() const", AS_METHODPR(T, Lightness, () const, float), AS_CALL_THISCALL);

    // Color Color::LinearToGamma() const
    engine->RegisterObjectMethod(className, "Color LinearToGamma() const", AS_METHODPR(T, LinearToGamma, () const, Color), AS_CALL_THISCALL);

    // float Color::Luma() const
    engine->RegisterObjectMethod(className, "float Luma() const", AS_METHODPR(T, Luma, () const, float), AS_CALL_THISCALL);

    // float Color::MaxRGB() const
    engine->RegisterObjectMethod(className, "float MaxRGB() const", AS_METHODPR(T, MaxRGB, () const, float), AS_CALL_THISCALL);

    // float Color::MinRGB() const
    engine->RegisterObjectMethod(className, "float MinRGB() const", AS_METHODPR(T, MinRGB, () const, float), AS_CALL_THISCALL);

    // Color Color::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Color opMul(float) const", AS_METHODPR(T, operator*, (float) const, Color), AS_CALL_THISCALL);

    // Color Color::operator +(const Color& rhs) const
    engine->RegisterObjectMethod(className, "Color opAdd(const Color&in) const", AS_METHODPR(T, operator+, (const Color&) const, Color), AS_CALL_THISCALL);

    // Color& Color::operator +=(const Color& rhs)
    engine->RegisterObjectMethod(className, "Color& opAddAssign(const Color&in)", AS_METHODPR(T, operator+=, (const Color&), Color&), AS_CALL_THISCALL);

    // Color Color::operator -() const
    engine->RegisterObjectMethod(className, "Color opNeg() const", AS_METHODPR(T, operator-, () const, Color), AS_CALL_THISCALL);

    // Color Color::operator -(const Color& rhs) const
    engine->RegisterObjectMethod(className, "Color opSub(const Color&in) const", AS_METHODPR(T, operator-, (const Color&) const, Color), AS_CALL_THISCALL);

    // Color& Color::operator =(const Color& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Color& opAssign(const Color&in)", AS_METHODPR(T, operator=, (const Color&), Color&), AS_CALL_THISCALL);

    // bool Color::operator ==(const Color& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Color&in) const", AS_METHODPR(T, operator==, (const Color&) const, bool), AS_CALL_THISCALL);

    // float Color::Range() const
    engine->RegisterObjectMethod(className, "float Range() const", AS_METHODPR(T, Range, () const, float), AS_CALL_THISCALL);

    // float Color::SaturationHSL() const
    engine->RegisterObjectMethod(className, "float SaturationHSL() const", AS_METHODPR(T, SaturationHSL, () const, float), AS_CALL_THISCALL);

    // float Color::SaturationHSV() const
    engine->RegisterObjectMethod(className, "float SaturationHSV() const", AS_METHODPR(T, SaturationHSV, () const, float), AS_CALL_THISCALL);

    // float Color::SumRGB() const
    engine->RegisterObjectMethod(className, "float SumRGB() const", AS_METHODPR(T, SumRGB, () const, float), AS_CALL_THISCALL);

    // unsigned Color::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // Vector3 Color::ToHSL() const
    engine->RegisterObjectMethod(className, "Vector3 ToHSL() const", AS_METHODPR(T, ToHSL, () const, Vector3), AS_CALL_THISCALL);

    // Vector3 Color::ToHSV() const
    engine->RegisterObjectMethod(className, "Vector3 ToHSV() const", AS_METHODPR(T, ToHSV, () const, Vector3), AS_CALL_THISCALL);

    // String Color::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // unsigned Color::ToUInt() const
    engine->RegisterObjectMethod(className, "uint ToUInt() const", AS_METHODPR(T, ToUInt, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Color::ToUIntArgb() const
    engine->RegisterObjectMethod(className, "uint ToUIntArgb() const", AS_METHODPR(T, ToUIntArgb, () const, unsigned), AS_CALL_THISCALL);

    // Vector3 Color::ToVector3() const
    engine->RegisterObjectMethod(className, "Vector3 ToVector3() const", AS_METHODPR(T, ToVector3, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_rgb() const", AS_METHODPR(T, ToVector3, () const, Vector3), AS_CALL_THISCALL);

    // Vector4 Color::ToVector4() const
    engine->RegisterObjectMethod(className, "Vector4 ToVector4() const", AS_METHODPR(T, ToVector4, () const, Vector4), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector4 get_rgba() const", AS_METHODPR(T, ToVector4, () const, Vector4), AS_CALL_THISCALL);

    // float Color::Value() const
    engine->RegisterObjectMethod(className, "float Value() const", AS_METHODPR(T, Value, () const, float), AS_CALL_THISCALL);

    // static float Color::ConvertGammaToLinear(float value)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("float ConvertGammaToLinear(float)", AS_FUNCTIONPR(T::ConvertGammaToLinear, (float), float), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static float Color::ConvertLinearToGamma(float value)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("float ConvertLinearToGamma(float)", AS_FUNCTIONPR(T::ConvertLinearToGamma, (float), float), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // float Color::r_
    engine->RegisterObjectProperty(className, "float r", offsetof(T, r_));

    // float Color::g_
    engine->RegisterObjectProperty(className, "float g", offsetof(T, g_));

    // float Color::b_
    engine->RegisterObjectProperty(className, "float b", offsetof(T, b_));

    // float Color::a_
    engine->RegisterObjectProperty(className, "float a", offsetof(T, a_));

    // static const ChannelMask Color::ABGR
    // Error: type "const ChannelMask" can not automatically bind
    // static const ChannelMask Color::ARGB
    // Error: type "const ChannelMask" can not automatically bind

    // static const Color Color::WHITE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color WHITE", (void*)&T::WHITE);engine->SetDefaultNamespace("");

    // static const Color Color::GRAY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color GRAY", (void*)&T::GRAY);engine->SetDefaultNamespace("");

    // static const Color Color::BLACK
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color BLACK", (void*)&T::BLACK);engine->SetDefaultNamespace("");

    // static const Color Color::RED
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color RED", (void*)&T::RED);engine->SetDefaultNamespace("");

    // static const Color Color::GREEN
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color GREEN", (void*)&T::GREEN);engine->SetDefaultNamespace("");

    // static const Color Color::BLUE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color BLUE", (void*)&T::BLUE);engine->SetDefaultNamespace("");

    // static const Color Color::CYAN
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color CYAN", (void*)&T::CYAN);engine->SetDefaultNamespace("");

    // static const Color Color::MAGENTA
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color MAGENTA", (void*)&T::MAGENTA);engine->SetDefaultNamespace("");

    // static const Color Color::YELLOW
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color YELLOW", (void*)&T::YELLOW);engine->SetDefaultNamespace("");

    // static const Color Color::TRANSPARENT_BLACK
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Color TRANSPARENT_BLACK", (void*)&T::TRANSPARENT_BLACK);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Color
        REGISTER_MEMBERS_MANUAL_PART_Color();
    #endif
}

// struct ColorFrame | File: ../Graphics/ParticleEffect.h
template <class T> void RegisterMembers_ColorFrame(asIScriptEngine* engine, const char* className)
{
    // Color ColorFrame::Interpolate(const ColorFrame& next, float time) const
    engine->RegisterObjectMethod(className, "Color Interpolate(const ColorFrame&in, float) const", AS_METHODPR(T, Interpolate, (const ColorFrame&, float) const, Color), AS_CALL_THISCALL);

    // Color ColorFrame::color_
    engine->RegisterObjectProperty(className, "Color color", offsetof(T, color_));

    // float ColorFrame::time_
    engine->RegisterObjectProperty(className, "float time", offsetof(T, time_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ColorFrame
        REGISTER_MEMBERS_MANUAL_PART_ColorFrame();
    #endif
}

// struct CompressedLevel | File: ../Resource/Image.h
template <class T> void RegisterMembers_CompressedLevel(asIScriptEngine* engine, const char* className)
{
    // bool CompressedLevel::Decompress(unsigned char* dest) const
    // Error: type "unsigned char*" can not automatically bind

    // unsigned char* CompressedLevel::data_
    // Not registered because pointer

    // CompressedFormat CompressedLevel::format_
    engine->RegisterObjectProperty(className, "CompressedFormat format", offsetof(T, format_));

    // int CompressedLevel::width_
    engine->RegisterObjectProperty(className, "int width", offsetof(T, width_));

    // int CompressedLevel::height_
    engine->RegisterObjectProperty(className, "int height", offsetof(T, height_));

    // int CompressedLevel::depth_
    engine->RegisterObjectProperty(className, "int depth", offsetof(T, depth_));

    // unsigned CompressedLevel::blockSize_
    engine->RegisterObjectProperty(className, "uint blockSize", offsetof(T, blockSize_));

    // unsigned CompressedLevel::dataSize_
    engine->RegisterObjectProperty(className, "uint dataSize", offsetof(T, dataSize_));

    // unsigned CompressedLevel::rowSize_
    engine->RegisterObjectProperty(className, "uint rowSize", offsetof(T, rowSize_));

    // unsigned CompressedLevel::rows_
    engine->RegisterObjectProperty(className, "uint rows", offsetof(T, rows_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CompressedLevel
        REGISTER_MEMBERS_MANUAL_PART_CompressedLevel();
    #endif
}

// class Condition | File: ../Core/Condition.h
template <class T> void RegisterMembers_Condition(asIScriptEngine* engine, const char* className)
{
    // void Condition::Set()
    engine->RegisterObjectMethod(className, "void Set()", AS_METHODPR(T, Set, (), void), AS_CALL_THISCALL);

    // void Condition::Wait()
    engine->RegisterObjectMethod(className, "void Wait()", AS_METHODPR(T, Wait, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Condition
        REGISTER_MEMBERS_MANUAL_PART_Condition();
    #endif
}

// class Controls | File: ../Input/Controls.h
template <class T> void RegisterMembers_Controls(asIScriptEngine* engine, const char* className)
{
    // bool Controls::IsDown(unsigned button) const
    engine->RegisterObjectMethod(className, "bool IsDown(uint) const", AS_METHODPR(T, IsDown, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool Controls::IsPressed(unsigned button, const Controls& previousControls) const
    engine->RegisterObjectMethod(className, "bool IsPressed(uint, const Controls&in) const", AS_METHODPR(T, IsPressed, (unsigned, const Controls&) const, bool), AS_CALL_THISCALL);

    // void Controls::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void Controls::Set(unsigned buttons, bool down = true)
    engine->RegisterObjectMethod(className, "void Set(uint, bool = true)", AS_METHODPR(T, Set, (unsigned, bool), void), AS_CALL_THISCALL);

    // unsigned Controls::buttons_
    engine->RegisterObjectProperty(className, "uint buttons", offsetof(T, buttons_));

    // float Controls::yaw_
    engine->RegisterObjectProperty(className, "float yaw", offsetof(T, yaw_));

    // float Controls::pitch_
    engine->RegisterObjectProperty(className, "float pitch", offsetof(T, pitch_));

    // VariantMap Controls::extraData_
    engine->RegisterObjectProperty(className, "VariantMap extraData", offsetof(T, extraData_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Controls
        REGISTER_MEMBERS_MANUAL_PART_Controls();
    #endif
}

// struct CursorShapeInfo | File: ../UI/Cursor.h
template <class T> void RegisterMembers_CursorShapeInfo(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<Image> CursorShapeInfo::image_
    // Error: type "SharedPtr<Image>" can not automatically bind
    // SharedPtr<Texture> CursorShapeInfo::texture_
    // Error: type "SharedPtr<Texture>" can not automatically bind
    // SDL_Cursor* CursorShapeInfo::osCursor_
    // Not registered because pointer

    // IntRect CursorShapeInfo::imageRect_
    engine->RegisterObjectProperty(className, "IntRect imageRect", offsetof(T, imageRect_));

    // IntVector2 CursorShapeInfo::hotSpot_
    engine->RegisterObjectProperty(className, "IntVector2 hotSpot", offsetof(T, hotSpot_));

    // bool CursorShapeInfo::systemDefined_
    engine->RegisterObjectProperty(className, "bool systemDefined", offsetof(T, systemDefined_));

    // int CursorShapeInfo::systemCursor_
    engine->RegisterObjectProperty(className, "int systemCursor", offsetof(T, systemCursor_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CursorShapeInfo
        REGISTER_MEMBERS_MANUAL_PART_CursorShapeInfo();
    #endif
}

// struct CustomGeometryVertex | File: ../Graphics/CustomGeometry.h
template <class T> void RegisterMembers_CustomGeometryVertex(asIScriptEngine* engine, const char* className)
{
    // Vector3 CustomGeometryVertex::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Vector3 CustomGeometryVertex::normal_
    engine->RegisterObjectProperty(className, "Vector3 normal", offsetof(T, normal_));

    // unsigned CustomGeometryVertex::color_
    engine->RegisterObjectProperty(className, "uint color", offsetof(T, color_));

    // Vector2 CustomGeometryVertex::texCoord_
    engine->RegisterObjectProperty(className, "Vector2 texCoord", offsetof(T, texCoord_));

    // Vector4 CustomGeometryVertex::tangent_
    engine->RegisterObjectProperty(className, "Vector4 tangent", offsetof(T, tangent_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CustomGeometryVertex
        REGISTER_MEMBERS_MANUAL_PART_CustomGeometryVertex();
    #endif
}

// class CustomVariantValue | File: ../Core/Variant.h
template <class T> void RegisterMembers_CustomVariantValue(asIScriptEngine* engine, const char* className)
{
    // virtual bool CustomVariantValue::Assign(const CustomVariantValue& rhs)
    // Error: type "CustomVariantValue" can not automatically bind bacause have @nobind mark
    // virtual CustomVariantValue* CustomVariantValue::Clone() const
    // Error: type "CustomVariantValue" can not automatically bind bacause have @nobind mark
    // virtual void CustomVariantValue::Clone(void* dest) const
    // Error: type "void*" can not automatically bind
    // virtual bool CustomVariantValue::Compare(const CustomVariantValue& rhs) const
    // Error: type "CustomVariantValue" can not automatically bind bacause have @nobind mark
    // const std::type_info& CustomVariantValue::GetTypeInfo() const
    // Error: type "const std::type_info&" can not automatically bind

    // virtual unsigned CustomVariantValue::GetSize() const
    engine->RegisterObjectMethod(className, "uint GetSize() const", AS_METHODPR(T, GetSize, () const, unsigned), AS_CALL_THISCALL);

    // virtual bool CustomVariantValue::IsZero() const
    engine->RegisterObjectMethod(className, "bool IsZero() const", AS_METHODPR(T, IsZero, () const, bool), AS_CALL_THISCALL);

    // virtual String CustomVariantValue::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // template <class T> T* CustomVariantValue::GetValuePtr()
    // Not registered because template
    // template <class T> const T* CustomVariantValue::GetValuePtr() const
    // Not registered because template
    // template <class T> bool CustomVariantValue::IsType() const
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CustomVariantValue
        REGISTER_MEMBERS_MANUAL_PART_CustomVariantValue();
    #endif
}

// struct DebugLine | File: ../Graphics/DebugRenderer.h
template <class T> void RegisterMembers_DebugLine(asIScriptEngine* engine, const char* className)
{
    // Vector3 DebugLine::start_
    engine->RegisterObjectProperty(className, "Vector3 start", offsetof(T, start_));

    // Vector3 DebugLine::end_
    engine->RegisterObjectProperty(className, "Vector3 end", offsetof(T, end_));

    // unsigned DebugLine::color_
    engine->RegisterObjectProperty(className, "uint color", offsetof(T, color_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DebugLine
        REGISTER_MEMBERS_MANUAL_PART_DebugLine();
    #endif
}

// struct DebugTriangle | File: ../Graphics/DebugRenderer.h
template <class T> void RegisterMembers_DebugTriangle(asIScriptEngine* engine, const char* className)
{
    // Vector3 DebugTriangle::v1_
    engine->RegisterObjectProperty(className, "Vector3 v1", offsetof(T, v1_));

    // Vector3 DebugTriangle::v2_
    engine->RegisterObjectProperty(className, "Vector3 v2", offsetof(T, v2_));

    // Vector3 DebugTriangle::v3_
    engine->RegisterObjectProperty(className, "Vector3 v3", offsetof(T, v3_));

    // unsigned DebugTriangle::color_
    engine->RegisterObjectProperty(className, "uint color", offsetof(T, color_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DebugTriangle
        REGISTER_MEMBERS_MANUAL_PART_DebugTriangle();
    #endif
}

// struct Decal | File: ../Graphics/DecalSet.h
template <class T> void RegisterMembers_Decal(asIScriptEngine* engine, const char* className)
{
    // void Decal::AddVertex(const DecalVertex& vertex)
    engine->RegisterObjectMethod(className, "void AddVertex(const DecalVertex&in)", AS_METHODPR(T, AddVertex, (const DecalVertex&), void), AS_CALL_THISCALL);

    // void Decal::CalculateBoundingBox()
    engine->RegisterObjectMethod(className, "void CalculateBoundingBox()", AS_METHODPR(T, CalculateBoundingBox, (), void), AS_CALL_THISCALL);

    // PODVector<DecalVertex> Decal::vertices_
    // Error: type "PODVector<DecalVertex>" can not automatically bind
    // PODVector<unsigned short> Decal::indices_
    // Error: type "PODVector<unsigned short>" can not automatically bind

    // float Decal::timer_
    engine->RegisterObjectProperty(className, "float timer", offsetof(T, timer_));

    // float Decal::timeToLive_
    engine->RegisterObjectProperty(className, "float timeToLive", offsetof(T, timeToLive_));

    // BoundingBox Decal::boundingBox_
    engine->RegisterObjectProperty(className, "BoundingBox boundingBox", offsetof(T, boundingBox_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Decal
        REGISTER_MEMBERS_MANUAL_PART_Decal();
    #endif
}

// struct DecalVertex | File: ../Graphics/DecalSet.h
template <class T> void RegisterMembers_DecalVertex(asIScriptEngine* engine, const char* className)
{
    // float DecalVertex::blendWeights_[4]
    // Not registered because array
    // unsigned char DecalVertex::blendIndices_[4]
    // Not registered because array

    // Vector3 DecalVertex::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Vector3 DecalVertex::normal_
    engine->RegisterObjectProperty(className, "Vector3 normal", offsetof(T, normal_));

    // Vector2 DecalVertex::texCoord_
    engine->RegisterObjectProperty(className, "Vector2 texCoord", offsetof(T, texCoord_));

    // Vector4 DecalVertex::tangent_
    engine->RegisterObjectProperty(className, "Vector4 tangent", offsetof(T, tangent_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DecalVertex
        REGISTER_MEMBERS_MANUAL_PART_DecalVertex();
    #endif
}

// struct DepthValue | File: ../Graphics/OcclusionBuffer.h
template <class T> void RegisterMembers_DepthValue(asIScriptEngine* engine, const char* className)
{
    // int DepthValue::min_
    engine->RegisterObjectProperty(className, "int min", offsetof(T, min_));

    // int DepthValue::max_
    engine->RegisterObjectProperty(className, "int max", offsetof(T, max_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DepthValue
        REGISTER_MEMBERS_MANUAL_PART_DepthValue();
    #endif
}

// StringVector Deserializer::ReadStringVector()
template <class T> CScriptArray* Deserializer_StringVector_ReadStringVector_void_template(T* _ptr)
{
    StringVector result = _ptr->ReadStringVector();
    return VectorToArray<String>(result, "Array<String>");
}

// class Deserializer | File: ../IO/Deserializer.h
template <class T> void RegisterMembers_Deserializer(asIScriptEngine* engine, const char* className)
{
    // virtual unsigned Deserializer::Read(void* dest, unsigned size) = 0
    // Error: type "void*" can not automatically bind
    // PODVector<unsigned char> Deserializer::ReadBuffer()
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // VariantVector Deserializer::ReadVariantVector()
    // Error: type "VariantVector" can not automatically bind

    // virtual unsigned Deserializer::GetChecksum()
    engine->RegisterObjectMethod(className, "uint GetChecksum()", AS_METHODPR(T, GetChecksum, (), unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_checksum()", AS_METHODPR(T, GetChecksum, (), unsigned), AS_CALL_THISCALL);

    // virtual const String& Deserializer::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // unsigned Deserializer::GetPosition() const
    engine->RegisterObjectMethod(className, "uint GetPosition() const", AS_METHODPR(T, GetPosition, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_position() const", AS_METHODPR(T, GetPosition, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Deserializer::GetSize() const
    engine->RegisterObjectMethod(className, "uint GetSize() const", AS_METHODPR(T, GetSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_size() const", AS_METHODPR(T, GetSize, () const, unsigned), AS_CALL_THISCALL);

    // virtual bool Deserializer::IsEof() const
    engine->RegisterObjectMethod(className, "bool IsEof() const", AS_METHODPR(T, IsEof, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_eof() const", AS_METHODPR(T, IsEof, () const, bool), AS_CALL_THISCALL);

    // bool Deserializer::ReadBool()
    engine->RegisterObjectMethod(className, "bool ReadBool()", AS_METHODPR(T, ReadBool, (), bool), AS_CALL_THISCALL);

    // BoundingBox Deserializer::ReadBoundingBox()
    engine->RegisterObjectMethod(className, "BoundingBox ReadBoundingBox()", AS_METHODPR(T, ReadBoundingBox, (), BoundingBox), AS_CALL_THISCALL);

    // signed char Deserializer::ReadByte()
    engine->RegisterObjectMethod(className, "int8 ReadByte()", AS_METHODPR(T, ReadByte, (), signed char), AS_CALL_THISCALL);

    // Color Deserializer::ReadColor()
    engine->RegisterObjectMethod(className, "Color ReadColor()", AS_METHODPR(T, ReadColor, (), Color), AS_CALL_THISCALL);

    // double Deserializer::ReadDouble()
    engine->RegisterObjectMethod(className, "double ReadDouble()", AS_METHODPR(T, ReadDouble, (), double), AS_CALL_THISCALL);

    // String Deserializer::ReadFileID()
    engine->RegisterObjectMethod(className, "String ReadFileID()", AS_METHODPR(T, ReadFileID, (), String), AS_CALL_THISCALL);

    // float Deserializer::ReadFloat()
    engine->RegisterObjectMethod(className, "float ReadFloat()", AS_METHODPR(T, ReadFloat, (), float), AS_CALL_THISCALL);

    // int Deserializer::ReadInt()
    engine->RegisterObjectMethod(className, "int ReadInt()", AS_METHODPR(T, ReadInt, (), int), AS_CALL_THISCALL);

    // long long Deserializer::ReadInt64()
    engine->RegisterObjectMethod(className, "int64 ReadInt64()", AS_METHODPR(T, ReadInt64, (), long long), AS_CALL_THISCALL);

    // IntRect Deserializer::ReadIntRect()
    engine->RegisterObjectMethod(className, "IntRect ReadIntRect()", AS_METHODPR(T, ReadIntRect, (), IntRect), AS_CALL_THISCALL);

    // IntVector2 Deserializer::ReadIntVector2()
    engine->RegisterObjectMethod(className, "IntVector2 ReadIntVector2()", AS_METHODPR(T, ReadIntVector2, (), IntVector2), AS_CALL_THISCALL);

    // IntVector3 Deserializer::ReadIntVector3()
    engine->RegisterObjectMethod(className, "IntVector3 ReadIntVector3()", AS_METHODPR(T, ReadIntVector3, (), IntVector3), AS_CALL_THISCALL);

    // String Deserializer::ReadLine()
    engine->RegisterObjectMethod(className, "String ReadLine()", AS_METHODPR(T, ReadLine, (), String), AS_CALL_THISCALL);

    // Matrix3 Deserializer::ReadMatrix3()
    engine->RegisterObjectMethod(className, "Matrix3 ReadMatrix3()", AS_METHODPR(T, ReadMatrix3, (), Matrix3), AS_CALL_THISCALL);

    // Matrix3x4 Deserializer::ReadMatrix3x4()
    engine->RegisterObjectMethod(className, "Matrix3x4 ReadMatrix3x4()", AS_METHODPR(T, ReadMatrix3x4, (), Matrix3x4), AS_CALL_THISCALL);

    // Matrix4 Deserializer::ReadMatrix4()
    engine->RegisterObjectMethod(className, "Matrix4 ReadMatrix4()", AS_METHODPR(T, ReadMatrix4, (), Matrix4), AS_CALL_THISCALL);

    // unsigned Deserializer::ReadNetID()
    engine->RegisterObjectMethod(className, "uint ReadNetID()", AS_METHODPR(T, ReadNetID, (), unsigned), AS_CALL_THISCALL);

    // Quaternion Deserializer::ReadPackedQuaternion()
    engine->RegisterObjectMethod(className, "Quaternion ReadPackedQuaternion()", AS_METHODPR(T, ReadPackedQuaternion, (), Quaternion), AS_CALL_THISCALL);

    // Vector3 Deserializer::ReadPackedVector3(float maxAbsCoord)
    engine->RegisterObjectMethod(className, "Vector3 ReadPackedVector3(float)", AS_METHODPR(T, ReadPackedVector3, (float), Vector3), AS_CALL_THISCALL);

    // Quaternion Deserializer::ReadQuaternion()
    engine->RegisterObjectMethod(className, "Quaternion ReadQuaternion()", AS_METHODPR(T, ReadQuaternion, (), Quaternion), AS_CALL_THISCALL);

    // Rect Deserializer::ReadRect()
    engine->RegisterObjectMethod(className, "Rect ReadRect()", AS_METHODPR(T, ReadRect, (), Rect), AS_CALL_THISCALL);

    // ResourceRef Deserializer::ReadResourceRef()
    engine->RegisterObjectMethod(className, "ResourceRef ReadResourceRef()", AS_METHODPR(T, ReadResourceRef, (), ResourceRef), AS_CALL_THISCALL);

    // ResourceRefList Deserializer::ReadResourceRefList()
    engine->RegisterObjectMethod(className, "ResourceRefList ReadResourceRefList()", AS_METHODPR(T, ReadResourceRefList, (), ResourceRefList), AS_CALL_THISCALL);

    // short Deserializer::ReadShort()
    engine->RegisterObjectMethod(className, "int16 ReadShort()", AS_METHODPR(T, ReadShort, (), short), AS_CALL_THISCALL);

    // String Deserializer::ReadString()
    engine->RegisterObjectMethod(className, "String ReadString()", AS_METHODPR(T, ReadString, (), String), AS_CALL_THISCALL);

    // StringHash Deserializer::ReadStringHash()
    engine->RegisterObjectMethod(className, "StringHash ReadStringHash()", AS_METHODPR(T, ReadStringHash, (), StringHash), AS_CALL_THISCALL);

    // StringVector Deserializer::ReadStringVector()
    engine->RegisterObjectMethod(className, "Array<String>@ ReadStringVector()", AS_FUNCTION_OBJFIRST(Deserializer_StringVector_ReadStringVector_void_template<Deserializer>), AS_CALL_CDECL_OBJFIRST);

    // unsigned char Deserializer::ReadUByte()
    engine->RegisterObjectMethod(className, "uint8 ReadUByte()", AS_METHODPR(T, ReadUByte, (), unsigned char), AS_CALL_THISCALL);

    // unsigned Deserializer::ReadUInt()
    engine->RegisterObjectMethod(className, "uint ReadUInt()", AS_METHODPR(T, ReadUInt, (), unsigned), AS_CALL_THISCALL);

    // unsigned long long Deserializer::ReadUInt64()
    engine->RegisterObjectMethod(className, "uint64 ReadUInt64()", AS_METHODPR(T, ReadUInt64, (), unsigned long long), AS_CALL_THISCALL);

    // unsigned short Deserializer::ReadUShort()
    engine->RegisterObjectMethod(className, "uint16 ReadUShort()", AS_METHODPR(T, ReadUShort, (), unsigned short), AS_CALL_THISCALL);

    // Variant Deserializer::ReadVariant()
    engine->RegisterObjectMethod(className, "Variant ReadVariant()", AS_METHODPR(T, ReadVariant, (), Variant), AS_CALL_THISCALL);

    // Variant Deserializer::ReadVariant(VariantType type)
    engine->RegisterObjectMethod(className, "Variant ReadVariant(VariantType)", AS_METHODPR(T, ReadVariant, (VariantType), Variant), AS_CALL_THISCALL);

    // VariantMap Deserializer::ReadVariantMap()
    engine->RegisterObjectMethod(className, "VariantMap ReadVariantMap()", AS_METHODPR(T, ReadVariantMap, (), VariantMap), AS_CALL_THISCALL);

    // Vector2 Deserializer::ReadVector2()
    engine->RegisterObjectMethod(className, "Vector2 ReadVector2()", AS_METHODPR(T, ReadVector2, (), Vector2), AS_CALL_THISCALL);

    // Vector3 Deserializer::ReadVector3()
    engine->RegisterObjectMethod(className, "Vector3 ReadVector3()", AS_METHODPR(T, ReadVector3, (), Vector3), AS_CALL_THISCALL);

    // Vector4 Deserializer::ReadVector4()
    engine->RegisterObjectMethod(className, "Vector4 ReadVector4()", AS_METHODPR(T, ReadVector4, (), Vector4), AS_CALL_THISCALL);

    // unsigned Deserializer::ReadVLE()
    engine->RegisterObjectMethod(className, "uint ReadVLE()", AS_METHODPR(T, ReadVLE, (), unsigned), AS_CALL_THISCALL);

    // virtual unsigned Deserializer::Seek(unsigned position) = 0
    engine->RegisterObjectMethod(className, "uint Seek(uint)", AS_METHODPR(T, Seek, (unsigned), unsigned), AS_CALL_THISCALL);

    // unsigned Deserializer::SeekRelative(int delta)
    engine->RegisterObjectMethod(className, "uint SeekRelative(int)", AS_METHODPR(T, SeekRelative, (int), unsigned), AS_CALL_THISCALL);

    // unsigned Deserializer::Tell() const
    engine->RegisterObjectMethod(className, "uint Tell() const", AS_METHODPR(T, Tell, () const, unsigned), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Deserializer
        REGISTER_MEMBERS_MANUAL_PART_Deserializer();
    #endif
}

// struct DirtyBits | File: ../Scene/ReplicationState.h
template <class T> void RegisterMembers_DirtyBits(asIScriptEngine* engine, const char* className)
{
    // void DirtyBits::Clear(unsigned index)
    engine->RegisterObjectMethod(className, "void Clear(uint)", AS_METHODPR(T, Clear, (unsigned), void), AS_CALL_THISCALL);

    // void DirtyBits::ClearAll()
    engine->RegisterObjectMethod(className, "void ClearAll()", AS_METHODPR(T, ClearAll, (), void), AS_CALL_THISCALL);

    // unsigned DirtyBits::Count() const
    engine->RegisterObjectMethod(className, "uint Count() const", AS_METHODPR(T, Count, () const, unsigned), AS_CALL_THISCALL);

    // bool DirtyBits::IsSet(unsigned index) const
    engine->RegisterObjectMethod(className, "bool IsSet(uint) const", AS_METHODPR(T, IsSet, (unsigned) const, bool), AS_CALL_THISCALL);

    // void DirtyBits::Set(unsigned index)
    engine->RegisterObjectMethod(className, "void Set(uint)", AS_METHODPR(T, Set, (unsigned), void), AS_CALL_THISCALL);

    // unsigned char DirtyBits::data_[MAX_NETWORK_ATTRIBUTES/8]
    // Not registered because array

    // unsigned char DirtyBits::count_
    engine->RegisterObjectProperty(className, "uint8 count", offsetof(T, count_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DirtyBits
        REGISTER_MEMBERS_MANUAL_PART_DirtyBits();
    #endif
}

// struct FileSelectorEntry | File: ../UI/FileSelector.h
template <class T> void RegisterMembers_FileSelectorEntry(asIScriptEngine* engine, const char* className)
{
    // String FileSelectorEntry::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // bool FileSelectorEntry::directory_
    engine->RegisterObjectProperty(className, "bool directory", offsetof(T, directory_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FileSelectorEntry
        REGISTER_MEMBERS_MANUAL_PART_FileSelectorEntry();
    #endif
}

// struct FocusParameters | File: ../Graphics/Light.h
template <class T> void RegisterMembers_FocusParameters(asIScriptEngine* engine, const char* className)
{
    // void FocusParameters::Validate()
    engine->RegisterObjectMethod(className, "void Validate()", AS_METHODPR(T, Validate, (), void), AS_CALL_THISCALL);

    // bool FocusParameters::focus_
    engine->RegisterObjectProperty(className, "bool focus", offsetof(T, focus_));

    // bool FocusParameters::nonUniform_
    engine->RegisterObjectProperty(className, "bool nonUniform", offsetof(T, nonUniform_));

    // bool FocusParameters::autoSize_
    engine->RegisterObjectProperty(className, "bool autoSize", offsetof(T, autoSize_));

    // float FocusParameters::quantize_
    engine->RegisterObjectProperty(className, "float quantize", offsetof(T, quantize_));

    // float FocusParameters::minView_
    engine->RegisterObjectProperty(className, "float minView", offsetof(T, minView_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FocusParameters
        REGISTER_MEMBERS_MANUAL_PART_FocusParameters();
    #endif
}

// struct FontGlyph | File: ../UI/FontFace.h
template <class T> void RegisterMembers_FontGlyph(asIScriptEngine* engine, const char* className)
{
    // short FontGlyph::x_
    engine->RegisterObjectProperty(className, "int16 x", offsetof(T, x_));

    // short FontGlyph::y_
    engine->RegisterObjectProperty(className, "int16 y", offsetof(T, y_));

    // short FontGlyph::texWidth_
    engine->RegisterObjectProperty(className, "int16 texWidth", offsetof(T, texWidth_));

    // short FontGlyph::texHeight_
    engine->RegisterObjectProperty(className, "int16 texHeight", offsetof(T, texHeight_));

    // float FontGlyph::width_
    engine->RegisterObjectProperty(className, "float width", offsetof(T, width_));

    // float FontGlyph::height_
    engine->RegisterObjectProperty(className, "float height", offsetof(T, height_));

    // float FontGlyph::offsetX_
    engine->RegisterObjectProperty(className, "float offsetX", offsetof(T, offsetX_));

    // float FontGlyph::offsetY_
    engine->RegisterObjectProperty(className, "float offsetY", offsetof(T, offsetY_));

    // float FontGlyph::advanceX_
    engine->RegisterObjectProperty(className, "float advanceX", offsetof(T, advanceX_));

    // unsigned FontGlyph::page_
    engine->RegisterObjectProperty(className, "uint page", offsetof(T, page_));

    // bool FontGlyph::used_
    engine->RegisterObjectProperty(className, "bool used", offsetof(T, used_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FontGlyph
        REGISTER_MEMBERS_MANUAL_PART_FontGlyph();
    #endif
}

// struct FrameInfo | File: ../Graphics/Drawable.h
template <class T> void RegisterMembers_FrameInfo(asIScriptEngine* engine, const char* className)
{
    // Camera* FrameInfo::camera_
    // Not registered because pointer

    // unsigned FrameInfo::frameNumber_
    engine->RegisterObjectProperty(className, "uint frameNumber", offsetof(T, frameNumber_));

    // float FrameInfo::timeStep_
    engine->RegisterObjectProperty(className, "float timeStep", offsetof(T, timeStep_));

    // IntVector2 FrameInfo::viewSize_
    engine->RegisterObjectProperty(className, "IntVector2 viewSize", offsetof(T, viewSize_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FrameInfo
        REGISTER_MEMBERS_MANUAL_PART_FrameInfo();
    #endif
}

// class Frustum | File: ../Math/Frustum.h
template <class T> void RegisterMembers_Frustum(asIScriptEngine* engine, const char* className)
{
    // void Frustum::Define(float fov, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform = Matrix3x4::IDENTITY)
    engine->RegisterObjectMethod(className, "void Define(float, float, float, float, float, const Matrix3x4&in = Matrix3x4::IDENTITY)", AS_METHODPR(T, Define, (float, float, float, float, float, const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Frustum::Define(const Vector3& near, const Vector3& far, const Matrix3x4& transform = Matrix3x4::IDENTITY)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in, const Vector3&in, const Matrix3x4&in = Matrix3x4::IDENTITY)", AS_METHODPR(T, Define, (const Vector3&, const Vector3&, const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Frustum::Define(const BoundingBox& box, const Matrix3x4& transform = Matrix3x4::IDENTITY)
    engine->RegisterObjectMethod(className, "void Define(const BoundingBox&in, const Matrix3x4&in = Matrix3x4::IDENTITY)", AS_METHODPR(T, Define, (const BoundingBox&, const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Frustum::Define(const Matrix4& projection)
    engine->RegisterObjectMethod(className, "void Define(const Matrix4&in)", AS_METHODPR(T, Define, (const Matrix4&), void), AS_CALL_THISCALL);

    // void Frustum::DefineOrtho(float orthoSize, float aspectRatio, float zoom, float nearZ, float farZ, const Matrix3x4& transform = Matrix3x4::IDENTITY)
    engine->RegisterObjectMethod(className, "void DefineOrtho(float, float, float, float, float, const Matrix3x4&in = Matrix3x4::IDENTITY)", AS_METHODPR(T, DefineOrtho, (float, float, float, float, float, const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Frustum::DefineSplit(const Matrix4& projection, float near, float far)
    engine->RegisterObjectMethod(className, "void DefineSplit(const Matrix4&in, float, float)", AS_METHODPR(T, DefineSplit, (const Matrix4&, float, float), void), AS_CALL_THISCALL);

    // float Frustum::Distance(const Vector3& point) const
    engine->RegisterObjectMethod(className, "float Distance(const Vector3&in) const", AS_METHODPR(T, Distance, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Intersection Frustum::IsInside(const Vector3& point) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Vector3&in) const", AS_METHODPR(T, IsInside, (const Vector3&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Frustum::IsInside(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Sphere&in) const", AS_METHODPR(T, IsInside, (const Sphere&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Frustum::IsInside(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const BoundingBox&in) const", AS_METHODPR(T, IsInside, (const BoundingBox&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Frustum::IsInsideFast(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "Intersection IsInsideFast(const Sphere&in) const", AS_METHODPR(T, IsInsideFast, (const Sphere&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Frustum::IsInsideFast(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "Intersection IsInsideFast(const BoundingBox&in) const", AS_METHODPR(T, IsInsideFast, (const BoundingBox&) const, Intersection), AS_CALL_THISCALL);

    // Frustum& Frustum::operator =(const Frustum& rhs) noexcept
    engine->RegisterObjectMethod(className, "Frustum& opAssign(const Frustum&in)", AS_METHODPR(T, operator=, (const Frustum&), Frustum&), AS_CALL_THISCALL);

    // Rect Frustum::Projected(const Matrix4& projection) const
    engine->RegisterObjectMethod(className, "Rect Projected(const Matrix4&in) const", AS_METHODPR(T, Projected, (const Matrix4&) const, Rect), AS_CALL_THISCALL);

    // void Frustum::Transform(const Matrix3& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3&in)", AS_METHODPR(T, Transform, (const Matrix3&), void), AS_CALL_THISCALL);

    // void Frustum::Transform(const Matrix3x4& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3x4&in)", AS_METHODPR(T, Transform, (const Matrix3x4&), void), AS_CALL_THISCALL);

    // Frustum Frustum::Transformed(const Matrix3& transform) const
    engine->RegisterObjectMethod(className, "Frustum Transformed(const Matrix3&in) const", AS_METHODPR(T, Transformed, (const Matrix3&) const, Frustum), AS_CALL_THISCALL);

    // Frustum Frustum::Transformed(const Matrix3x4& transform) const
    engine->RegisterObjectMethod(className, "Frustum Transformed(const Matrix3x4&in) const", AS_METHODPR(T, Transformed, (const Matrix3x4&) const, Frustum), AS_CALL_THISCALL);

    // void Frustum::UpdatePlanes()
    engine->RegisterObjectMethod(className, "void UpdatePlanes()", AS_METHODPR(T, UpdatePlanes, (), void), AS_CALL_THISCALL);

    // Plane Frustum::planes_[NUM_FRUSTUM_PLANES]
    // Not registered because array
    // Vector3 Frustum::vertices_[NUM_FRUSTUM_VERTICES]
    // Not registered because array

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Frustum
        REGISTER_MEMBERS_MANUAL_PART_Frustum();
    #endif
}

// class GPUObject | File: ../Graphics/GPUObject.h
template <class T> void RegisterMembers_GPUObject(asIScriptEngine* engine, const char* className)
{
    // void* GPUObject::GetGPUObject() const
    // Error: type "void*" can not automatically bind

    // void GPUObject::ClearDataLost()
    engine->RegisterObjectMethod(className, "void ClearDataLost()", AS_METHODPR(T, ClearDataLost, (), void), AS_CALL_THISCALL);

    // unsigned GPUObject::GetGPUObjectName() const
    engine->RegisterObjectMethod(className, "uint GetGPUObjectName() const", AS_METHODPR(T, GetGPUObjectName, () const, unsigned), AS_CALL_THISCALL);

    // Graphics* GPUObject::GetGraphics() const
    engine->RegisterObjectMethod(className, "Graphics@+ GetGraphics() const", AS_METHODPR(T, GetGraphics, () const, Graphics*), AS_CALL_THISCALL);

    // bool GPUObject::HasPendingData() const
    engine->RegisterObjectMethod(className, "bool HasPendingData() const", AS_METHODPR(T, HasPendingData, () const, bool), AS_CALL_THISCALL);

    // bool GPUObject::IsDataLost() const
    engine->RegisterObjectMethod(className, "bool IsDataLost() const", AS_METHODPR(T, IsDataLost, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dataLost() const", AS_METHODPR(T, IsDataLost, () const, bool), AS_CALL_THISCALL);

    // virtual void GPUObject::OnDeviceLost()
    engine->RegisterObjectMethod(className, "void OnDeviceLost()", AS_METHODPR(T, OnDeviceLost, (), void), AS_CALL_THISCALL);

    // virtual void GPUObject::OnDeviceReset()
    engine->RegisterObjectMethod(className, "void OnDeviceReset()", AS_METHODPR(T, OnDeviceReset, (), void), AS_CALL_THISCALL);

    // virtual void GPUObject::Release()
    engine->RegisterObjectMethod(className, "void Release()", AS_METHODPR(T, Release, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_GPUObject
        REGISTER_MEMBERS_MANUAL_PART_GPUObject();
    #endif
}

// struct GeometryDesc | File: ../Graphics/Model.h
template <class T> void RegisterMembers_GeometryDesc(asIScriptEngine* engine, const char* className)
{
    // PrimitiveType GeometryDesc::type_
    engine->RegisterObjectProperty(className, "PrimitiveType type", offsetof(T, type_));

    // unsigned GeometryDesc::vbRef_
    engine->RegisterObjectProperty(className, "uint vbRef", offsetof(T, vbRef_));

    // unsigned GeometryDesc::ibRef_
    engine->RegisterObjectProperty(className, "uint ibRef", offsetof(T, ibRef_));

    // unsigned GeometryDesc::indexStart_
    engine->RegisterObjectProperty(className, "uint indexStart", offsetof(T, indexStart_));

    // unsigned GeometryDesc::indexCount_
    engine->RegisterObjectProperty(className, "uint indexCount", offsetof(T, indexCount_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_GeometryDesc
        REGISTER_MEMBERS_MANUAL_PART_GeometryDesc();
    #endif
}

// struct GlyphLocation | File: ../UI/Text.h
template <class T> void RegisterMembers_GlyphLocation(asIScriptEngine* engine, const char* className)
{
    // const FontGlyph* GlyphLocation::glyph_
    // Not registered because pointer

    // float GlyphLocation::x_
    engine->RegisterObjectProperty(className, "float x", offsetof(T, x_));

    // float GlyphLocation::y_
    engine->RegisterObjectProperty(className, "float y", offsetof(T, y_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_GlyphLocation
        REGISTER_MEMBERS_MANUAL_PART_GlyphLocation();
    #endif
}

// class HashBase | File: ../Container/HashBase.h
template <class T> void RegisterMembers_HashBase(asIScriptEngine* engine, const char* className)
{
    // bool HashBase::Empty() const
    engine->RegisterObjectMethod(className, "bool Empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);

    // unsigned HashBase::NumBuckets() const
    engine->RegisterObjectMethod(className, "uint NumBuckets() const", AS_METHODPR(T, NumBuckets, () const, unsigned), AS_CALL_THISCALL);

    // unsigned HashBase::Size() const
    engine->RegisterObjectMethod(className, "uint Size() const", AS_METHODPR(T, Size, () const, unsigned), AS_CALL_THISCALL);

    // void HashBase::Swap(HashBase& rhs)
    engine->RegisterObjectMethod(className, "void Swap(HashBase&)", AS_METHODPR(T, Swap, (HashBase&), void), AS_CALL_THISCALL);

    // static const unsigned HashBase::MIN_BUCKETS
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const uint MIN_BUCKETS", (void*)&T::MIN_BUCKETS);engine->SetDefaultNamespace("");

    // static const unsigned HashBase::MAX_LOAD_FACTOR
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const uint MAX_LOAD_FACTOR", (void*)&T::MAX_LOAD_FACTOR);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_HashBase
        REGISTER_MEMBERS_MANUAL_PART_HashBase();
    #endif
}

// struct HashIteratorBase | File: ../Container/HashBase.h
template <class T> void RegisterMembers_HashIteratorBase(asIScriptEngine* engine, const char* className)
{
    // bool HashIteratorBase::operator !=(const HashIteratorBase& rhs) const
    // Only operator == is needed

    // void HashIteratorBase::GotoNext()
    engine->RegisterObjectMethod(className, "void GotoNext()", AS_METHODPR(T, GotoNext, (), void), AS_CALL_THISCALL);

    // void HashIteratorBase::GotoPrev()
    engine->RegisterObjectMethod(className, "void GotoPrev()", AS_METHODPR(T, GotoPrev, (), void), AS_CALL_THISCALL);

    // bool HashIteratorBase::operator ==(const HashIteratorBase& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const HashIteratorBase&in) const", AS_METHODPR(T, operator==, (const HashIteratorBase&) const, bool), AS_CALL_THISCALL);

    // HashNodeBase* HashIteratorBase::ptr_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_HashIteratorBase
        REGISTER_MEMBERS_MANUAL_PART_HashIteratorBase();
    #endif
}

// struct HashNodeBase | File: ../Container/HashBase.h
template <class T> void RegisterMembers_HashNodeBase(asIScriptEngine* engine, const char* className)
{
    // HashNodeBase* HashNodeBase::down_
    // Not registered because pointer
    // HashNodeBase* HashNodeBase::prev_
    // Not registered because pointer
    // HashNodeBase* HashNodeBase::next_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_HashNodeBase
        REGISTER_MEMBERS_MANUAL_PART_HashNodeBase();
    #endif
}

// class HiresTimer | File: ../Core/Timer.h
template <class T> void RegisterMembers_HiresTimer(asIScriptEngine* engine, const char* className)
{
    // long long HiresTimer::GetUSec(bool reset)
    engine->RegisterObjectMethod(className, "int64 GetUSec(bool)", AS_METHODPR(T, GetUSec, (bool), long long), AS_CALL_THISCALL);

    // void HiresTimer::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // static bool HiresTimer::IsSupported()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool IsSupported()", AS_FUNCTIONPR(T::IsSupported, (), bool), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static long long HiresTimer::GetFrequency()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("int64 GetFrequency()", AS_FUNCTIONPR(T::GetFrequency, (), long long), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_HiresTimer
        REGISTER_MEMBERS_MANUAL_PART_HiresTimer();
    #endif
}

// struct IndexBufferDesc | File: ../Graphics/Model.h
template <class T> void RegisterMembers_IndexBufferDesc(asIScriptEngine* engine, const char* className)
{
    // SharedArrayPtr<unsigned char> IndexBufferDesc::data_
    // Error: type "SharedArrayPtr<unsigned char>" can not automatically bind

    // unsigned IndexBufferDesc::indexCount_
    engine->RegisterObjectProperty(className, "uint indexCount", offsetof(T, indexCount_));

    // unsigned IndexBufferDesc::indexSize_
    engine->RegisterObjectProperty(className, "uint indexSize", offsetof(T, indexSize_));

    // unsigned IndexBufferDesc::dataSize_
    engine->RegisterObjectProperty(className, "uint dataSize", offsetof(T, dataSize_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IndexBufferDesc
        REGISTER_MEMBERS_MANUAL_PART_IndexBufferDesc();
    #endif
}

// struct InstanceData | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_InstanceData(asIScriptEngine* engine, const char* className)
{
    // const Matrix3x4* InstanceData::worldTransform_
    // Not registered because pointer
    // const void* InstanceData::instancingData_
    // Not registered because pointer

    // float InstanceData::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_InstanceData
        REGISTER_MEMBERS_MANUAL_PART_InstanceData();
    #endif
}

// class IntRect | File: ../Math/Rect.h
template <class T> void RegisterMembers_IntRect(asIScriptEngine* engine, const char* className)
{
    // const int* IntRect::Data() const
    // Error: type "const int*" can not automatically bind
    // bool IntRect::operator !=(const IntRect& rhs) const
    // Only operator == is needed

    // int IntRect::Bottom() const
    engine->RegisterObjectMethod(className, "int Bottom() const", AS_METHODPR(T, Bottom, () const, int), AS_CALL_THISCALL);

    // void IntRect::Clip(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void Clip(const IntRect&in)", AS_METHODPR(T, Clip, (const IntRect&), void), AS_CALL_THISCALL);

    // int IntRect::Height() const
    engine->RegisterObjectMethod(className, "int Height() const", AS_METHODPR(T, Height, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, Height, () const, int), AS_CALL_THISCALL);

    // Intersection IntRect::IsInside(const IntVector2& point) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const IntVector2&in) const", AS_METHODPR(T, IsInside, (const IntVector2&) const, Intersection), AS_CALL_THISCALL);

    // Intersection IntRect::IsInside(const IntRect& rect) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const IntRect&in) const", AS_METHODPR(T, IsInside, (const IntRect&) const, Intersection), AS_CALL_THISCALL);

    // int IntRect::Left() const
    engine->RegisterObjectMethod(className, "int Left() const", AS_METHODPR(T, Left, () const, int), AS_CALL_THISCALL);

    // IntVector2 IntRect::Max() const
    engine->RegisterObjectMethod(className, "IntVector2 Max() const", AS_METHODPR(T, Max, () const, IntVector2), AS_CALL_THISCALL);

    // void IntRect::Merge(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void Merge(const IntRect&in)", AS_METHODPR(T, Merge, (const IntRect&), void), AS_CALL_THISCALL);

    // IntVector2 IntRect::Min() const
    engine->RegisterObjectMethod(className, "IntVector2 Min() const", AS_METHODPR(T, Min, () const, IntVector2), AS_CALL_THISCALL);

    // IntRect IntRect::operator *(float value) const
    engine->RegisterObjectMethod(className, "IntRect opMul(float) const", AS_METHODPR(T, operator*, (float) const, IntRect), AS_CALL_THISCALL);

    // IntRect& IntRect::operator *=(float value)
    engine->RegisterObjectMethod(className, "IntRect& opMulAssign(float)", AS_METHODPR(T, operator*=, (float), IntRect&), AS_CALL_THISCALL);

    // IntRect IntRect::operator +(const IntRect& rhs) const
    engine->RegisterObjectMethod(className, "IntRect opAdd(const IntRect&in) const", AS_METHODPR(T, operator+, (const IntRect&) const, IntRect), AS_CALL_THISCALL);

    // IntRect& IntRect::operator +=(const IntRect& rhs)
    engine->RegisterObjectMethod(className, "IntRect& opAddAssign(const IntRect&in)", AS_METHODPR(T, operator+=, (const IntRect&), IntRect&), AS_CALL_THISCALL);

    // IntRect IntRect::operator -(const IntRect& rhs) const
    engine->RegisterObjectMethod(className, "IntRect opSub(const IntRect&in) const", AS_METHODPR(T, operator-, (const IntRect&) const, IntRect), AS_CALL_THISCALL);

    // IntRect& IntRect::operator -=(const IntRect& rhs)
    engine->RegisterObjectMethod(className, "IntRect& opSubAssign(const IntRect&in)", AS_METHODPR(T, operator-=, (const IntRect&), IntRect&), AS_CALL_THISCALL);

    // IntRect IntRect::operator /(float value) const
    engine->RegisterObjectMethod(className, "IntRect opDiv(float) const", AS_METHODPR(T, operator/, (float) const, IntRect), AS_CALL_THISCALL);

    // IntRect& IntRect::operator /=(float value)
    engine->RegisterObjectMethod(className, "IntRect& opDivAssign(float)", AS_METHODPR(T, operator/=, (float), IntRect&), AS_CALL_THISCALL);

    // bool IntRect::operator ==(const IntRect& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const IntRect&in) const", AS_METHODPR(T, operator==, (const IntRect&) const, bool), AS_CALL_THISCALL);

    // int IntRect::Right() const
    engine->RegisterObjectMethod(className, "int Right() const", AS_METHODPR(T, Right, () const, int), AS_CALL_THISCALL);

    // IntVector2 IntRect::Size() const
    engine->RegisterObjectMethod(className, "IntVector2 Size() const", AS_METHODPR(T, Size, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_size() const", AS_METHODPR(T, Size, () const, IntVector2), AS_CALL_THISCALL);

    // int IntRect::Top() const
    engine->RegisterObjectMethod(className, "int Top() const", AS_METHODPR(T, Top, () const, int), AS_CALL_THISCALL);

    // String IntRect::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // int IntRect::Width() const
    engine->RegisterObjectMethod(className, "int Width() const", AS_METHODPR(T, Width, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, Width, () const, int), AS_CALL_THISCALL);

    // int IntRect::left_
    engine->RegisterObjectProperty(className, "int left", offsetof(T, left_));

    // int IntRect::top_
    engine->RegisterObjectProperty(className, "int top", offsetof(T, top_));

    // int IntRect::right_
    engine->RegisterObjectProperty(className, "int right", offsetof(T, right_));

    // int IntRect::bottom_
    engine->RegisterObjectProperty(className, "int bottom", offsetof(T, bottom_));

    // static const IntRect IntRect::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntRect ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IntRect
        REGISTER_MEMBERS_MANUAL_PART_IntRect();
    #endif
}

// class IntVector2 | File: ../Math/Vector2.h
template <class T> void RegisterMembers_IntVector2(asIScriptEngine* engine, const char* className)
{
    // const int* IntVector2::Data() const
    // Error: type "const int*" can not automatically bind
    // bool IntVector2::operator !=(const IntVector2& rhs) const
    // Only operator == is needed

    // float IntVector2::Length() const
    engine->RegisterObjectMethod(className, "float Length() const", AS_METHODPR(T, Length, () const, float), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator *(int rhs) const
    engine->RegisterObjectMethod(className, "IntVector2 opMul(int) const", AS_METHODPR(T, operator*, (int) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator *(const IntVector2& rhs) const
    engine->RegisterObjectMethod(className, "IntVector2 opMul(const IntVector2&in) const", AS_METHODPR(T, operator*, (const IntVector2&) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator *=(int rhs)
    engine->RegisterObjectMethod(className, "IntVector2& opMulAssign(int)", AS_METHODPR(T, operator*=, (int), IntVector2&), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator *=(const IntVector2& rhs)
    engine->RegisterObjectMethod(className, "IntVector2& opMulAssign(const IntVector2&in)", AS_METHODPR(T, operator*=, (const IntVector2&), IntVector2&), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator +(const IntVector2& rhs) const
    engine->RegisterObjectMethod(className, "IntVector2 opAdd(const IntVector2&in) const", AS_METHODPR(T, operator+, (const IntVector2&) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator +=(const IntVector2& rhs)
    engine->RegisterObjectMethod(className, "IntVector2& opAddAssign(const IntVector2&in)", AS_METHODPR(T, operator+=, (const IntVector2&), IntVector2&), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator -() const
    engine->RegisterObjectMethod(className, "IntVector2 opNeg() const", AS_METHODPR(T, operator-, () const, IntVector2), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator -(const IntVector2& rhs) const
    engine->RegisterObjectMethod(className, "IntVector2 opSub(const IntVector2&in) const", AS_METHODPR(T, operator-, (const IntVector2&) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator -=(const IntVector2& rhs)
    engine->RegisterObjectMethod(className, "IntVector2& opSubAssign(const IntVector2&in)", AS_METHODPR(T, operator-=, (const IntVector2&), IntVector2&), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator /(int rhs) const
    engine->RegisterObjectMethod(className, "IntVector2 opDiv(int) const", AS_METHODPR(T, operator/, (int) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2 IntVector2::operator /(const IntVector2& rhs) const
    engine->RegisterObjectMethod(className, "IntVector2 opDiv(const IntVector2&in) const", AS_METHODPR(T, operator/, (const IntVector2&) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator /=(int rhs)
    engine->RegisterObjectMethod(className, "IntVector2& opDivAssign(int)", AS_METHODPR(T, operator/=, (int), IntVector2&), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator /=(const IntVector2& rhs)
    engine->RegisterObjectMethod(className, "IntVector2& opDivAssign(const IntVector2&in)", AS_METHODPR(T, operator/=, (const IntVector2&), IntVector2&), AS_CALL_THISCALL);

    // IntVector2& IntVector2::operator =(const IntVector2& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "IntVector2& opAssign(const IntVector2&in)", AS_METHODPR(T, operator=, (const IntVector2&), IntVector2&), AS_CALL_THISCALL);

    // bool IntVector2::operator ==(const IntVector2& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const IntVector2&in) const", AS_METHODPR(T, operator==, (const IntVector2&) const, bool), AS_CALL_THISCALL);

    // unsigned IntVector2::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // String IntVector2::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // int IntVector2::x_
    engine->RegisterObjectProperty(className, "int x", offsetof(T, x_));

    // int IntVector2::y_
    engine->RegisterObjectProperty(className, "int y", offsetof(T, y_));

    // static const IntVector2 IntVector2::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector2 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const IntVector2 IntVector2::LEFT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector2 LEFT", (void*)&T::LEFT);engine->SetDefaultNamespace("");

    // static const IntVector2 IntVector2::RIGHT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector2 RIGHT", (void*)&T::RIGHT);engine->SetDefaultNamespace("");

    // static const IntVector2 IntVector2::UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector2 UP", (void*)&T::UP);engine->SetDefaultNamespace("");

    // static const IntVector2 IntVector2::DOWN
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector2 DOWN", (void*)&T::DOWN);engine->SetDefaultNamespace("");

    // static const IntVector2 IntVector2::ONE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector2 ONE", (void*)&T::ONE);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IntVector2
        REGISTER_MEMBERS_MANUAL_PART_IntVector2();
    #endif
}

// class IntVector3 | File: ../Math/Vector3.h
template <class T> void RegisterMembers_IntVector3(asIScriptEngine* engine, const char* className)
{
    // const int* IntVector3::Data() const
    // Error: type "const int*" can not automatically bind
    // bool IntVector3::operator !=(const IntVector3& rhs) const
    // Only operator == is needed

    // float IntVector3::Length() const
    engine->RegisterObjectMethod(className, "float Length() const", AS_METHODPR(T, Length, () const, float), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator *(int rhs) const
    engine->RegisterObjectMethod(className, "IntVector3 opMul(int) const", AS_METHODPR(T, operator*, (int) const, IntVector3), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator *(const IntVector3& rhs) const
    engine->RegisterObjectMethod(className, "IntVector3 opMul(const IntVector3&in) const", AS_METHODPR(T, operator*, (const IntVector3&) const, IntVector3), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator *=(int rhs)
    engine->RegisterObjectMethod(className, "IntVector3& opMulAssign(int)", AS_METHODPR(T, operator*=, (int), IntVector3&), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator *=(const IntVector3& rhs)
    engine->RegisterObjectMethod(className, "IntVector3& opMulAssign(const IntVector3&in)", AS_METHODPR(T, operator*=, (const IntVector3&), IntVector3&), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator +(const IntVector3& rhs) const
    engine->RegisterObjectMethod(className, "IntVector3 opAdd(const IntVector3&in) const", AS_METHODPR(T, operator+, (const IntVector3&) const, IntVector3), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator +=(const IntVector3& rhs)
    engine->RegisterObjectMethod(className, "IntVector3& opAddAssign(const IntVector3&in)", AS_METHODPR(T, operator+=, (const IntVector3&), IntVector3&), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator -() const
    engine->RegisterObjectMethod(className, "IntVector3 opNeg() const", AS_METHODPR(T, operator-, () const, IntVector3), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator -(const IntVector3& rhs) const
    engine->RegisterObjectMethod(className, "IntVector3 opSub(const IntVector3&in) const", AS_METHODPR(T, operator-, (const IntVector3&) const, IntVector3), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator -=(const IntVector3& rhs)
    engine->RegisterObjectMethod(className, "IntVector3& opSubAssign(const IntVector3&in)", AS_METHODPR(T, operator-=, (const IntVector3&), IntVector3&), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator /(int rhs) const
    engine->RegisterObjectMethod(className, "IntVector3 opDiv(int) const", AS_METHODPR(T, operator/, (int) const, IntVector3), AS_CALL_THISCALL);

    // IntVector3 IntVector3::operator /(const IntVector3& rhs) const
    engine->RegisterObjectMethod(className, "IntVector3 opDiv(const IntVector3&in) const", AS_METHODPR(T, operator/, (const IntVector3&) const, IntVector3), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator /=(int rhs)
    engine->RegisterObjectMethod(className, "IntVector3& opDivAssign(int)", AS_METHODPR(T, operator/=, (int), IntVector3&), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator /=(const IntVector3& rhs)
    engine->RegisterObjectMethod(className, "IntVector3& opDivAssign(const IntVector3&in)", AS_METHODPR(T, operator/=, (const IntVector3&), IntVector3&), AS_CALL_THISCALL);

    // IntVector3& IntVector3::operator =(const IntVector3& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "IntVector3& opAssign(const IntVector3&in)", AS_METHODPR(T, operator=, (const IntVector3&), IntVector3&), AS_CALL_THISCALL);

    // bool IntVector3::operator ==(const IntVector3& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const IntVector3&in) const", AS_METHODPR(T, operator==, (const IntVector3&) const, bool), AS_CALL_THISCALL);

    // unsigned IntVector3::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // String IntVector3::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // int IntVector3::x_
    engine->RegisterObjectProperty(className, "int x", offsetof(T, x_));

    // int IntVector3::y_
    engine->RegisterObjectProperty(className, "int y", offsetof(T, y_));

    // int IntVector3::z_
    engine->RegisterObjectProperty(className, "int z", offsetof(T, z_));

    // static const IntVector3 IntVector3::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::LEFT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 LEFT", (void*)&T::LEFT);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::RIGHT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 RIGHT", (void*)&T::RIGHT);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 UP", (void*)&T::UP);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::DOWN
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 DOWN", (void*)&T::DOWN);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::FORWARD
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 FORWARD", (void*)&T::FORWARD);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::BACK
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 BACK", (void*)&T::BACK);engine->SetDefaultNamespace("");

    // static const IntVector3 IntVector3::ONE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 ONE", (void*)&T::ONE);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IntVector3
        REGISTER_MEMBERS_MANUAL_PART_IntVector3();
    #endif
}

// void JSONValue::SetVariant(const Variant& variant, Context* context = nullptr)
template <class T> void JSONValue_void_SetVariant_constspVariantamp_Contextstar_template(T* _ptr, const Variant& variant)
{
    Context* context = GetScriptContext();
    _ptr->SetVariant(variant, context);
}

// void JSONValue::SetVariantMap(const VariantMap& variantMap, Context* context = nullptr)
template <class T> void JSONValue_void_SetVariantMap_constspVariantMapamp_Contextstar_template(T* _ptr, const VariantMap& variantMap)
{
    Context* context = GetScriptContext();
    _ptr->SetVariantMap(variantMap, context);
}

// void JSONValue::SetVariantValue(const Variant& variant, Context* context = nullptr)
template <class T> void JSONValue_void_SetVariantValue_constspVariantamp_Contextstar_template(T* _ptr, const Variant& variant)
{
    Context* context = GetScriptContext();
    _ptr->SetVariantValue(variant, context);
}

// class JSONValue | File: ../Resource/JSONValue.h
template <class T> void RegisterMembers_JSONValue(asIScriptEngine* engine, const char* className)
{
    // JSONObjectIterator JSONValue::Begin()
    // Error: type "JSONObjectIterator" can not automatically bind
    // ConstJSONObjectIterator JSONValue::Begin() const
    // Error: type "ConstJSONObjectIterator" can not automatically bind
    // JSONObjectIterator JSONValue::End()
    // Error: type "JSONObjectIterator" can not automatically bind
    // ConstJSONObjectIterator JSONValue::End() const
    // Error: type "ConstJSONObjectIterator" can not automatically bind
    // const JSONArray& JSONValue::GetArray() const
    // Error: type "const JSONArray&" can not automatically bind
    // const char* JSONValue::GetCString(const char* defaultValue = "") const
    // Error: type "const char*" can not automatically bind
    // const JSONObject& JSONValue::GetObject() const
    // Error: type "const JSONObject&" can not automatically bind
    // VariantVector JSONValue::GetVariantVector() const
    // Error: type "VariantVector" can not automatically bind
    // JSONValue& JSONValue::operator =(const char* rhs)
    // Error: type "const char*" can not automatically bind
    // JSONValue& JSONValue::operator =(const JSONArray& rhs)
    // Error: type "const JSONArray&" can not automatically bind
    // JSONValue& JSONValue::operator =(const JSONObject& rhs)
    // Error: type "const JSONObject&" can not automatically bind
    // void JSONValue::SetVariantVector(const VariantVector& variantVector, Context* context = nullptr)
    // Error: type "const VariantVector&" can not automatically bind

    // void JSONValue::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // bool JSONValue::Contains(const String& key) const
    engine->RegisterObjectMethod(className, "bool Contains(const String&in) const", AS_METHODPR(T, Contains, (const String&) const, bool), AS_CALL_THISCALL);

    // void JSONValue::Erase(unsigned pos, unsigned length = 1)
    engine->RegisterObjectMethod(className, "void Erase(uint, uint = 1)", AS_METHODPR(T, Erase, (unsigned, unsigned), void), AS_CALL_THISCALL);

    // bool JSONValue::Erase(const String& key)
    engine->RegisterObjectMethod(className, "bool Erase(const String&in)", AS_METHODPR(T, Erase, (const String&), bool), AS_CALL_THISCALL);

    // const JSONValue& JSONValue::Get(const String& key) const
    engine->RegisterObjectMethod(className, "const JSONValue& Get(const String&in) const", AS_METHODPR(T, Get, (const String&) const, const JSONValue&), AS_CALL_THISCALL);

    // bool JSONValue::GetBool(bool defaultValue = false) const
    engine->RegisterObjectMethod(className, "bool GetBool(bool = false) const", AS_METHODPR(T, GetBool, (bool) const, bool), AS_CALL_THISCALL);

    // double JSONValue::GetDouble(double defaultValue = 0.0) const
    engine->RegisterObjectMethod(className, "double GetDouble(double = 0.0) const", AS_METHODPR(T, GetDouble, (double) const, double), AS_CALL_THISCALL);

    // float JSONValue::GetFloat(float defaultValue = 0.0f) const
    engine->RegisterObjectMethod(className, "float GetFloat(float = 0.0f) const", AS_METHODPR(T, GetFloat, (float) const, float), AS_CALL_THISCALL);

    // int JSONValue::GetInt(int defaultValue = 0) const
    engine->RegisterObjectMethod(className, "int GetInt(int = 0) const", AS_METHODPR(T, GetInt, (int) const, int), AS_CALL_THISCALL);

    // JSONNumberType JSONValue::GetNumberType() const
    engine->RegisterObjectMethod(className, "JSONNumberType GetNumberType() const", AS_METHODPR(T, GetNumberType, () const, JSONNumberType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "JSONNumberType get_numberType() const", AS_METHODPR(T, GetNumberType, () const, JSONNumberType), AS_CALL_THISCALL);

    // String JSONValue::GetNumberTypeName() const
    engine->RegisterObjectMethod(className, "String GetNumberTypeName() const", AS_METHODPR(T, GetNumberTypeName, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_numberTypeName() const", AS_METHODPR(T, GetNumberTypeName, () const, String), AS_CALL_THISCALL);

    // const String& JSONValue::GetString(const String& defaultValue = String::EMPTY) const
    engine->RegisterObjectMethod(className, "const String& GetString(const String&in = String::EMPTY) const", AS_METHODPR(T, GetString, (const String&) const, const String&), AS_CALL_THISCALL);

    // unsigned JSONValue::GetUInt(unsigned defaultValue = 0) const
    engine->RegisterObjectMethod(className, "uint GetUInt(uint = 0) const", AS_METHODPR(T, GetUInt, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // JSONValueType JSONValue::GetValueType() const
    engine->RegisterObjectMethod(className, "JSONValueType GetValueType() const", AS_METHODPR(T, GetValueType, () const, JSONValueType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "JSONValueType get_valueType() const", AS_METHODPR(T, GetValueType, () const, JSONValueType), AS_CALL_THISCALL);

    // String JSONValue::GetValueTypeName() const
    engine->RegisterObjectMethod(className, "String GetValueTypeName() const", AS_METHODPR(T, GetValueTypeName, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_valueTypeName() const", AS_METHODPR(T, GetValueTypeName, () const, String), AS_CALL_THISCALL);

    // Variant JSONValue::GetVariant() const
    engine->RegisterObjectMethod(className, "Variant GetVariant() const", AS_METHODPR(T, GetVariant, () const, Variant), AS_CALL_THISCALL);

    // VariantMap JSONValue::GetVariantMap() const
    engine->RegisterObjectMethod(className, "VariantMap GetVariantMap() const", AS_METHODPR(T, GetVariantMap, () const, VariantMap), AS_CALL_THISCALL);

    // Variant JSONValue::GetVariantValue(VariantType type) const
    engine->RegisterObjectMethod(className, "Variant GetVariantValue(VariantType) const", AS_METHODPR(T, GetVariantValue, (VariantType) const, Variant), AS_CALL_THISCALL);

    // void JSONValue::Insert(unsigned pos, const JSONValue& value)
    engine->RegisterObjectMethod(className, "void Insert(uint, const JSONValue&in)", AS_METHODPR(T, Insert, (unsigned, const JSONValue&), void), AS_CALL_THISCALL);

    // bool JSONValue::IsArray() const
    engine->RegisterObjectMethod(className, "bool IsArray() const", AS_METHODPR(T, IsArray, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isArray() const", AS_METHODPR(T, IsArray, () const, bool), AS_CALL_THISCALL);

    // bool JSONValue::IsBool() const
    engine->RegisterObjectMethod(className, "bool IsBool() const", AS_METHODPR(T, IsBool, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isBool() const", AS_METHODPR(T, IsBool, () const, bool), AS_CALL_THISCALL);

    // bool JSONValue::IsNull() const
    engine->RegisterObjectMethod(className, "bool IsNull() const", AS_METHODPR(T, IsNull, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isNull() const", AS_METHODPR(T, IsNull, () const, bool), AS_CALL_THISCALL);

    // bool JSONValue::IsNumber() const
    engine->RegisterObjectMethod(className, "bool IsNumber() const", AS_METHODPR(T, IsNumber, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isNumber() const", AS_METHODPR(T, IsNumber, () const, bool), AS_CALL_THISCALL);

    // bool JSONValue::IsObject() const
    engine->RegisterObjectMethod(className, "bool IsObject() const", AS_METHODPR(T, IsObject, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isObject() const", AS_METHODPR(T, IsObject, () const, bool), AS_CALL_THISCALL);

    // bool JSONValue::IsString() const
    engine->RegisterObjectMethod(className, "bool IsString() const", AS_METHODPR(T, IsString, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isString() const", AS_METHODPR(T, IsString, () const, bool), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(bool rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(bool)", AS_METHODPR(T, operator=, (bool), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(int rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(int)", AS_METHODPR(T, operator=, (int), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(unsigned rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(uint)", AS_METHODPR(T, operator=, (unsigned), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(float rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(float)", AS_METHODPR(T, operator=, (float), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(double rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(double)", AS_METHODPR(T, operator=, (double), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(const String& rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(const String&in)", AS_METHODPR(T, operator=, (const String&), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator =(const JSONValue& rhs)
    engine->RegisterObjectMethod(className, "JSONValue& opAssign(const JSONValue&in)", AS_METHODPR(T, operator=, (const JSONValue&), JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator [](unsigned index)
    engine->RegisterObjectMethod(className, "JSONValue& opIndex(uint)", AS_METHODPR(T, operator[], (unsigned), JSONValue&), AS_CALL_THISCALL);

    // const JSONValue& JSONValue::operator [](unsigned index) const
    engine->RegisterObjectMethod(className, "const JSONValue& opIndex(uint) const", AS_METHODPR(T, operator[], (unsigned) const, const JSONValue&), AS_CALL_THISCALL);

    // JSONValue& JSONValue::operator [](const String& key)
    engine->RegisterObjectMethod(className, "JSONValue& opIndex(const String&in)", AS_METHODPR(T, operator[], (const String&), JSONValue&), AS_CALL_THISCALL);

    // const JSONValue& JSONValue::operator [](const String& key) const
    engine->RegisterObjectMethod(className, "const JSONValue& opIndex(const String&in) const", AS_METHODPR(T, operator[], (const String&) const, const JSONValue&), AS_CALL_THISCALL);

    // void JSONValue::Pop()
    engine->RegisterObjectMethod(className, "void Pop()", AS_METHODPR(T, Pop, (), void), AS_CALL_THISCALL);

    // void JSONValue::Push(const JSONValue& value)
    engine->RegisterObjectMethod(className, "void Push(const JSONValue&in)", AS_METHODPR(T, Push, (const JSONValue&), void), AS_CALL_THISCALL);

    // void JSONValue::Resize(unsigned newSize)
    engine->RegisterObjectMethod(className, "void Resize(uint)", AS_METHODPR(T, Resize, (unsigned), void), AS_CALL_THISCALL);

    // void JSONValue::Set(const String& key, const JSONValue& value)
    engine->RegisterObjectMethod(className, "void Set(const String&in, const JSONValue&in)", AS_METHODPR(T, Set, (const String&, const JSONValue&), void), AS_CALL_THISCALL);

    // void JSONValue::SetType(JSONValueType valueType, JSONNumberType numberType = JSONNT_NAN)
    engine->RegisterObjectMethod(className, "void SetType(JSONValueType, JSONNumberType = JSONNT_NAN)", AS_METHODPR(T, SetType, (JSONValueType, JSONNumberType), void), AS_CALL_THISCALL);

    // void JSONValue::SetVariant(const Variant& variant, Context* context = nullptr)
    engine->RegisterObjectMethod(className, "void SetVariant(const Variant&in)", AS_FUNCTION_OBJFIRST(JSONValue_void_SetVariant_constspVariantamp_Contextstar_template<JSONValue>), AS_CALL_CDECL_OBJFIRST);

    // void JSONValue::SetVariantMap(const VariantMap& variantMap, Context* context = nullptr)
    engine->RegisterObjectMethod(className, "void SetVariantMap(const VariantMap&in)", AS_FUNCTION_OBJFIRST(JSONValue_void_SetVariantMap_constspVariantMapamp_Contextstar_template<JSONValue>), AS_CALL_CDECL_OBJFIRST);

    // void JSONValue::SetVariantValue(const Variant& variant, Context* context = nullptr)
    engine->RegisterObjectMethod(className, "void SetVariantValue(const Variant&in)", AS_FUNCTION_OBJFIRST(JSONValue_void_SetVariantValue_constspVariantamp_Contextstar_template<JSONValue>), AS_CALL_CDECL_OBJFIRST);

    // unsigned JSONValue::Size() const
    engine->RegisterObjectMethod(className, "uint Size() const", AS_METHODPR(T, Size, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_size() const", AS_METHODPR(T, Size, () const, unsigned), AS_CALL_THISCALL);

    // static JSONValueType JSONValue::GetValueTypeFromName(const char* typeName)
    // Error: type "const char*" can not automatically bind
    // static JSONNumberType JSONValue::GetNumberTypeFromName(const char* typeName)
    // Error: type "const char*" can not automatically bind

    // static String JSONValue::GetValueTypeName(JSONValueType type)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("String GetValueTypeName(JSONValueType)", AS_FUNCTIONPR(T::GetValueTypeName, (JSONValueType), String), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static String JSONValue::GetNumberTypeName(JSONNumberType type)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("String GetNumberTypeName(JSONNumberType)", AS_FUNCTIONPR(T::GetNumberTypeName, (JSONNumberType), String), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static JSONValueType JSONValue::GetValueTypeFromName(const String& typeName)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("JSONValueType GetValueTypeFromName(const String&in)", AS_FUNCTIONPR(T::GetValueTypeFromName, (const String&), JSONValueType), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static JSONNumberType JSONValue::GetNumberTypeFromName(const String& typeName)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("JSONNumberType GetNumberTypeFromName(const String&in)", AS_FUNCTIONPR(T::GetNumberTypeFromName, (const String&), JSONNumberType), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // bool JSONValue::boolValue_
    // Not registered because have @nobind mark
    // double JSONValue::numberValue_
    // Not registered because have @nobind mark
    // String* JSONValue::stringValue_
    // Not registered because have @nobind mark
    // JSONArray* JSONValue::arrayValue_
    // Not registered because have @nobind mark
    // JSONObject* JSONValue::objectValue_
    // Not registered because have @nobind mark

    // static const JSONArray JSONValue::emptyArray
    // Error: type "const JSONArray" can not automatically bind
    // static const JSONObject JSONValue::emptyObject
    // Error: type "const JSONObject" can not automatically bind

    // static const JSONValue JSONValue::EMPTY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const JSONValue EMPTY", (void*)&T::EMPTY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_JSONValue
        REGISTER_MEMBERS_MANUAL_PART_JSONValue();
    #endif
}

// struct JoystickState | File: ../Input/Input.h
template <class T> void RegisterMembers_JoystickState(asIScriptEngine* engine, const char* className)
{
    // float JoystickState::GetAxisPosition(unsigned index) const
    engine->RegisterObjectMethod(className, "float GetAxisPosition(uint) const", AS_METHODPR(T, GetAxisPosition, (unsigned) const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_axisPosition(uint) const", AS_METHODPR(T, GetAxisPosition, (unsigned) const, float), AS_CALL_THISCALL);

    // bool JoystickState::GetButtonDown(unsigned index) const
    engine->RegisterObjectMethod(className, "bool GetButtonDown(uint) const", AS_METHODPR(T, GetButtonDown, (unsigned) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_buttonDown(uint) const", AS_METHODPR(T, GetButtonDown, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool JoystickState::GetButtonPress(unsigned index) const
    engine->RegisterObjectMethod(className, "bool GetButtonPress(uint) const", AS_METHODPR(T, GetButtonPress, (unsigned) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_buttonPress(uint) const", AS_METHODPR(T, GetButtonPress, (unsigned) const, bool), AS_CALL_THISCALL);

    // int JoystickState::GetHatPosition(unsigned index) const
    engine->RegisterObjectMethod(className, "int GetHatPosition(uint) const", AS_METHODPR(T, GetHatPosition, (unsigned) const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_hatPosition(uint) const", AS_METHODPR(T, GetHatPosition, (unsigned) const, int), AS_CALL_THISCALL);

    // unsigned JoystickState::GetNumAxes() const
    engine->RegisterObjectMethod(className, "uint GetNumAxes() const", AS_METHODPR(T, GetNumAxes, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAxes() const", AS_METHODPR(T, GetNumAxes, () const, unsigned), AS_CALL_THISCALL);

    // unsigned JoystickState::GetNumButtons() const
    engine->RegisterObjectMethod(className, "uint GetNumButtons() const", AS_METHODPR(T, GetNumButtons, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numButtons() const", AS_METHODPR(T, GetNumButtons, () const, unsigned), AS_CALL_THISCALL);

    // unsigned JoystickState::GetNumHats() const
    engine->RegisterObjectMethod(className, "uint GetNumHats() const", AS_METHODPR(T, GetNumHats, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numHats() const", AS_METHODPR(T, GetNumHats, () const, unsigned), AS_CALL_THISCALL);

    // void JoystickState::Initialize(unsigned numButtons, unsigned numAxes, unsigned numHats)
    engine->RegisterObjectMethod(className, "void Initialize(uint, uint, uint)", AS_METHODPR(T, Initialize, (unsigned, unsigned, unsigned), void), AS_CALL_THISCALL);

    // bool JoystickState::IsController() const
    engine->RegisterObjectMethod(className, "bool IsController() const", AS_METHODPR(T, IsController, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_controller() const", AS_METHODPR(T, IsController, () const, bool), AS_CALL_THISCALL);

    // void JoystickState::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // SDL_Joystick* JoystickState::joystick_
    // Not registered because pointer
    // SDL_GameController* JoystickState::controller_
    // Not registered because pointer
    // UIElement* JoystickState::screenJoystick_
    // Not registered because pointer
    // PODVector<bool> JoystickState::buttons_
    // Error: type "PODVector<bool>" can not automatically bind
    // PODVector<bool> JoystickState::buttonPress_
    // Error: type "PODVector<bool>" can not automatically bind
    // PODVector<float> JoystickState::axes_
    // Error: type "PODVector<float>" can not automatically bind
    // PODVector<int> JoystickState::hats_
    // Error: type "PODVector<int>" can not automatically bind

    // SDL_JoystickID JoystickState::joystickID_
    engine->RegisterObjectProperty(className, "SDL_JoystickID joystickID", offsetof(T, joystickID_));

    // String JoystickState::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_JoystickState
        REGISTER_MEMBERS_MANUAL_PART_JoystickState();
    #endif
}

// struct LightBatchQueue | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_LightBatchQueue(asIScriptEngine* engine, const char* className)
{
    // Light* LightBatchQueue::light_
    // Not registered because pointer
    // Texture2D* LightBatchQueue::shadowMap_
    // Not registered because pointer
    // Vector<ShadowBatchQueue> LightBatchQueue::shadowSplits_
    // Error: type "Vector<ShadowBatchQueue>" can not automatically bind
    // PODVector<Light*> LightBatchQueue::vertexLights_
    // Error: type "PODVector<Light*>" can not automatically bind
    // PODVector<Batch> LightBatchQueue::volumeBatches_
    // Error: type "PODVector<Batch>" can not automatically bind

    // bool LightBatchQueue::negative_
    engine->RegisterObjectProperty(className, "bool negative", offsetof(T, negative_));

    // BatchQueue LightBatchQueue::litBaseBatches_
    engine->RegisterObjectProperty(className, "BatchQueue litBaseBatches", offsetof(T, litBaseBatches_));

    // BatchQueue LightBatchQueue::litBatches_
    engine->RegisterObjectProperty(className, "BatchQueue litBatches", offsetof(T, litBatches_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_LightBatchQueue
        REGISTER_MEMBERS_MANUAL_PART_LightBatchQueue();
    #endif
}

// struct LightQueryResult | File: ../Graphics/View.h
template <class T> void RegisterMembers_LightQueryResult(asIScriptEngine* engine, const char* className)
{
    // Light* LightQueryResult::light_
    // Not registered because pointer
    // PODVector<Drawable*> LightQueryResult::litGeometries_
    // Error: type "PODVector<Drawable*>" can not automatically bind
    // PODVector<Drawable*> LightQueryResult::shadowCasters_
    // Error: type "PODVector<Drawable*>" can not automatically bind
    // Camera* LightQueryResult::shadowCameras_[MAX_LIGHT_SPLITS]
    // Not registered because array
    // unsigned LightQueryResult::shadowCasterBegin_[MAX_LIGHT_SPLITS]
    // Not registered because array
    // unsigned LightQueryResult::shadowCasterEnd_[MAX_LIGHT_SPLITS]
    // Not registered because array
    // BoundingBox LightQueryResult::shadowCasterBox_[MAX_LIGHT_SPLITS]
    // Not registered because array
    // float LightQueryResult::shadowNearSplits_[MAX_LIGHT_SPLITS]
    // Not registered because array
    // float LightQueryResult::shadowFarSplits_[MAX_LIGHT_SPLITS]
    // Not registered because array

    // unsigned LightQueryResult::numSplits_
    engine->RegisterObjectProperty(className, "uint numSplits", offsetof(T, numSplits_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_LightQueryResult
        REGISTER_MEMBERS_MANUAL_PART_LightQueryResult();
    #endif
}

// struct LinkedListNode | File: ../Container/LinkedList.h
template <class T> void RegisterMembers_LinkedListNode(asIScriptEngine* engine, const char* className)
{
    // LinkedListNode* LinkedListNode::next_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_LinkedListNode
        REGISTER_MEMBERS_MANUAL_PART_LinkedListNode();
    #endif
}

// class ListBase | File: ../Container/ListBase.h
template <class T> void RegisterMembers_ListBase(asIScriptEngine* engine, const char* className)
{
    // void ListBase::Swap(ListBase& rhs)
    engine->RegisterObjectMethod(className, "void Swap(ListBase&)", AS_METHODPR(T, Swap, (ListBase&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ListBase
        REGISTER_MEMBERS_MANUAL_PART_ListBase();
    #endif
}

// struct ListIteratorBase | File: ../Container/ListBase.h
template <class T> void RegisterMembers_ListIteratorBase(asIScriptEngine* engine, const char* className)
{
    // bool ListIteratorBase::operator !=(const ListIteratorBase& rhs) const
    // Only operator == is needed

    // void ListIteratorBase::GotoNext()
    engine->RegisterObjectMethod(className, "void GotoNext()", AS_METHODPR(T, GotoNext, (), void), AS_CALL_THISCALL);

    // void ListIteratorBase::GotoPrev()
    engine->RegisterObjectMethod(className, "void GotoPrev()", AS_METHODPR(T, GotoPrev, (), void), AS_CALL_THISCALL);

    // bool ListIteratorBase::operator ==(const ListIteratorBase& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const ListIteratorBase&in) const", AS_METHODPR(T, operator==, (const ListIteratorBase&) const, bool), AS_CALL_THISCALL);

    // ListNodeBase* ListIteratorBase::ptr_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ListIteratorBase
        REGISTER_MEMBERS_MANUAL_PART_ListIteratorBase();
    #endif
}

// struct ListNodeBase | File: ../Container/ListBase.h
template <class T> void RegisterMembers_ListNodeBase(asIScriptEngine* engine, const char* className)
{
    // ListNodeBase* ListNodeBase::prev_
    // Not registered because pointer
    // ListNodeBase* ListNodeBase::next_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ListNodeBase
        REGISTER_MEMBERS_MANUAL_PART_ListNodeBase();
    #endif
}

// struct MaterialShaderParameter | File: ../Graphics/Material.h
template <class T> void RegisterMembers_MaterialShaderParameter(asIScriptEngine* engine, const char* className)
{
    // String MaterialShaderParameter::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // Variant MaterialShaderParameter::value_
    engine->RegisterObjectProperty(className, "Variant value", offsetof(T, value_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_MaterialShaderParameter
        REGISTER_MEMBERS_MANUAL_PART_MaterialShaderParameter();
    #endif
}

// class Matrix2 | File: ../Math/Matrix2.h
template <class T> void RegisterMembers_Matrix2(asIScriptEngine* engine, const char* className)
{
    // const float* Matrix2::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Matrix2::operator !=(const Matrix2& rhs) const
    // Only operator == is needed

    // bool Matrix2::Equals(const Matrix2& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Matrix2&in) const", AS_METHODPR(T, Equals, (const Matrix2&) const, bool), AS_CALL_THISCALL);

    // Matrix2 Matrix2::Inverse() const
    engine->RegisterObjectMethod(className, "Matrix2 Inverse() const", AS_METHODPR(T, Inverse, () const, Matrix2), AS_CALL_THISCALL);

    // bool Matrix2::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Matrix2::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // Vector2 Matrix2::operator *(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opMul(const Vector2&in) const", AS_METHODPR(T, operator*, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // Matrix2 Matrix2::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Matrix2 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Matrix2), AS_CALL_THISCALL);

    // Matrix2 Matrix2::operator *(const Matrix2& rhs) const
    engine->RegisterObjectMethod(className, "Matrix2 opMul(const Matrix2&in) const", AS_METHODPR(T, operator*, (const Matrix2&) const, Matrix2), AS_CALL_THISCALL);

    // Matrix2 Matrix2::operator +(const Matrix2& rhs) const
    engine->RegisterObjectMethod(className, "Matrix2 opAdd(const Matrix2&in) const", AS_METHODPR(T, operator+, (const Matrix2&) const, Matrix2), AS_CALL_THISCALL);

    // Matrix2 Matrix2::operator -(const Matrix2& rhs) const
    engine->RegisterObjectMethod(className, "Matrix2 opSub(const Matrix2&in) const", AS_METHODPR(T, operator-, (const Matrix2&) const, Matrix2), AS_CALL_THISCALL);

    // Matrix2& Matrix2::operator =(const Matrix2& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Matrix2& opAssign(const Matrix2&in)", AS_METHODPR(T, operator=, (const Matrix2&), Matrix2&), AS_CALL_THISCALL);

    // bool Matrix2::operator ==(const Matrix2& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix2&in) const", AS_METHODPR(T, operator==, (const Matrix2&) const, bool), AS_CALL_THISCALL);

    // Vector2 Matrix2::Scale() const
    engine->RegisterObjectMethod(className, "Vector2 Scale() const", AS_METHODPR(T, Scale, () const, Vector2), AS_CALL_THISCALL);

    // Matrix2 Matrix2::Scaled(const Vector2& scale) const
    engine->RegisterObjectMethod(className, "Matrix2 Scaled(const Vector2&in) const", AS_METHODPR(T, Scaled, (const Vector2&) const, Matrix2), AS_CALL_THISCALL);

    // void Matrix2::SetScale(const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetScale(const Vector2&in)", AS_METHODPR(T, SetScale, (const Vector2&), void), AS_CALL_THISCALL);

    // void Matrix2::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // String Matrix2::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // Matrix2 Matrix2::Transpose() const
    engine->RegisterObjectMethod(className, "Matrix2 Transpose() const", AS_METHODPR(T, Transpose, () const, Matrix2), AS_CALL_THISCALL);

    // static void Matrix2::BulkTranspose(float* dest, const float* src, unsigned count)
    // Error: type "float*" can not automatically bind

    // float Matrix2::m00_
    engine->RegisterObjectProperty(className, "float m00", offsetof(T, m00_));

    // float Matrix2::m01_
    engine->RegisterObjectProperty(className, "float m01", offsetof(T, m01_));

    // float Matrix2::m10_
    engine->RegisterObjectProperty(className, "float m10", offsetof(T, m10_));

    // float Matrix2::m11_
    engine->RegisterObjectProperty(className, "float m11", offsetof(T, m11_));

    // static const Matrix2 Matrix2::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix2 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Matrix2 Matrix2::IDENTITY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix2 IDENTITY", (void*)&T::IDENTITY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Matrix2
        REGISTER_MEMBERS_MANUAL_PART_Matrix2();
    #endif
}

// class Matrix3 | File: ../Math/Matrix3.h
template <class T> void RegisterMembers_Matrix3(asIScriptEngine* engine, const char* className)
{
    // const float* Matrix3::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Matrix3::operator !=(const Matrix3& rhs) const
    // Only operator == is needed

    // Vector3 Matrix3::Column(unsigned j) const
    engine->RegisterObjectMethod(className, "Vector3 Column(uint) const", AS_METHODPR(T, Column, (unsigned) const, Vector3), AS_CALL_THISCALL);

    // float Matrix3::Element(unsigned i, unsigned j) const
    engine->RegisterObjectMethod(className, "float Element(uint, uint) const", AS_METHODPR(T, Element, (unsigned, unsigned) const, float), AS_CALL_THISCALL);

    // bool Matrix3::Equals(const Matrix3& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Matrix3&in) const", AS_METHODPR(T, Equals, (const Matrix3&) const, bool), AS_CALL_THISCALL);

    // Matrix3 Matrix3::Inverse() const
    engine->RegisterObjectMethod(className, "Matrix3 Inverse() const", AS_METHODPR(T, Inverse, () const, Matrix3), AS_CALL_THISCALL);

    // bool Matrix3::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Matrix3::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // Vector3 Matrix3::operator *(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(const Vector3&in) const", AS_METHODPR(T, operator*, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Matrix3 Matrix3::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Matrix3 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Matrix3), AS_CALL_THISCALL);

    // Matrix3 Matrix3::operator *(const Matrix3& rhs) const
    engine->RegisterObjectMethod(className, "Matrix3 opMul(const Matrix3&in) const", AS_METHODPR(T, operator*, (const Matrix3&) const, Matrix3), AS_CALL_THISCALL);

    // Matrix3 Matrix3::operator +(const Matrix3& rhs) const
    engine->RegisterObjectMethod(className, "Matrix3 opAdd(const Matrix3&in) const", AS_METHODPR(T, operator+, (const Matrix3&) const, Matrix3), AS_CALL_THISCALL);

    // Matrix3 Matrix3::operator -(const Matrix3& rhs) const
    engine->RegisterObjectMethod(className, "Matrix3 opSub(const Matrix3&in) const", AS_METHODPR(T, operator-, (const Matrix3&) const, Matrix3), AS_CALL_THISCALL);

    // Matrix3& Matrix3::operator =(const Matrix3& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Matrix3& opAssign(const Matrix3&in)", AS_METHODPR(T, operator=, (const Matrix3&), Matrix3&), AS_CALL_THISCALL);

    // bool Matrix3::operator ==(const Matrix3& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix3&in) const", AS_METHODPR(T, operator==, (const Matrix3&) const, bool), AS_CALL_THISCALL);

    // Vector3 Matrix3::Row(unsigned i) const
    engine->RegisterObjectMethod(className, "Vector3 Row(uint) const", AS_METHODPR(T, Row, (unsigned) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Matrix3::Scale() const
    engine->RegisterObjectMethod(className, "Vector3 Scale() const", AS_METHODPR(T, Scale, () const, Vector3), AS_CALL_THISCALL);

    // Matrix3 Matrix3::Scaled(const Vector3& scale) const
    engine->RegisterObjectMethod(className, "Matrix3 Scaled(const Vector3&in) const", AS_METHODPR(T, Scaled, (const Vector3&) const, Matrix3), AS_CALL_THISCALL);

    // void Matrix3::SetScale(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetScale(const Vector3&in)", AS_METHODPR(T, SetScale, (const Vector3&), void), AS_CALL_THISCALL);

    // void Matrix3::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // Vector3 Matrix3::SignedScale(const Matrix3& rotation) const
    engine->RegisterObjectMethod(className, "Vector3 SignedScale(const Matrix3&in) const", AS_METHODPR(T, SignedScale, (const Matrix3&) const, Vector3), AS_CALL_THISCALL);

    // String Matrix3::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // Matrix3 Matrix3::Transpose() const
    engine->RegisterObjectMethod(className, "Matrix3 Transpose() const", AS_METHODPR(T, Transpose, () const, Matrix3), AS_CALL_THISCALL);

    // static void Matrix3::BulkTranspose(float* dest, const float* src, unsigned count)
    // Error: type "float*" can not automatically bind

    // float Matrix3::m00_
    engine->RegisterObjectProperty(className, "float m00", offsetof(T, m00_));

    // float Matrix3::m01_
    engine->RegisterObjectProperty(className, "float m01", offsetof(T, m01_));

    // float Matrix3::m02_
    engine->RegisterObjectProperty(className, "float m02", offsetof(T, m02_));

    // float Matrix3::m10_
    engine->RegisterObjectProperty(className, "float m10", offsetof(T, m10_));

    // float Matrix3::m11_
    engine->RegisterObjectProperty(className, "float m11", offsetof(T, m11_));

    // float Matrix3::m12_
    engine->RegisterObjectProperty(className, "float m12", offsetof(T, m12_));

    // float Matrix3::m20_
    engine->RegisterObjectProperty(className, "float m20", offsetof(T, m20_));

    // float Matrix3::m21_
    engine->RegisterObjectProperty(className, "float m21", offsetof(T, m21_));

    // float Matrix3::m22_
    engine->RegisterObjectProperty(className, "float m22", offsetof(T, m22_));

    // static const Matrix3 Matrix3::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix3 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Matrix3 Matrix3::IDENTITY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix3 IDENTITY", (void*)&T::IDENTITY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Matrix3
        REGISTER_MEMBERS_MANUAL_PART_Matrix3();
    #endif
}

// class Matrix3x4 | File: ../Math/Matrix3x4.h
template <class T> void RegisterMembers_Matrix3x4(asIScriptEngine* engine, const char* className)
{
    // const float* Matrix3x4::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Matrix3x4::operator !=(const Matrix3x4& rhs) const
    // Only operator == is needed

    // Vector3 Matrix3x4::Column(unsigned j) const
    engine->RegisterObjectMethod(className, "Vector3 Column(uint) const", AS_METHODPR(T, Column, (unsigned) const, Vector3), AS_CALL_THISCALL);

    // void Matrix3x4::Decompose(Vector3& translation, Quaternion& rotation, Vector3& scale) const
    engine->RegisterObjectMethod(className, "void Decompose(Vector3&, Quaternion&, Vector3&) const", AS_METHODPR(T, Decompose, (Vector3&, Quaternion&, Vector3&) const, void), AS_CALL_THISCALL);

    // float Matrix3x4::Element(unsigned i, unsigned j) const
    engine->RegisterObjectMethod(className, "float Element(uint, uint) const", AS_METHODPR(T, Element, (unsigned, unsigned) const, float), AS_CALL_THISCALL);

    // bool Matrix3x4::Equals(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Matrix3x4&in) const", AS_METHODPR(T, Equals, (const Matrix3x4&) const, bool), AS_CALL_THISCALL);

    // Matrix3x4 Matrix3x4::Inverse() const
    engine->RegisterObjectMethod(className, "Matrix3x4 Inverse() const", AS_METHODPR(T, Inverse, () const, Matrix3x4), AS_CALL_THISCALL);

    // bool Matrix3x4::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Matrix3x4::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // Vector3 Matrix3x4::operator *(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(const Vector3&in) const", AS_METHODPR(T, operator*, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Matrix3x4::operator *(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(const Vector4&in) const", AS_METHODPR(T, operator*, (const Vector4&) const, Vector3), AS_CALL_THISCALL);

    // Matrix3x4 Matrix3x4::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Matrix3x4 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Matrix3x4), AS_CALL_THISCALL);

    // Matrix3x4 Matrix3x4::operator *(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix3x4 opMul(const Matrix3x4&in) const", AS_METHODPR(T, operator*, (const Matrix3x4&) const, Matrix3x4), AS_CALL_THISCALL);

    // Matrix4 Matrix3x4::operator *(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix4 opMul(const Matrix4&in) const", AS_METHODPR(T, operator*, (const Matrix4&) const, Matrix4), AS_CALL_THISCALL);

    // Matrix3x4 Matrix3x4::operator +(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix3x4 opAdd(const Matrix3x4&in) const", AS_METHODPR(T, operator+, (const Matrix3x4&) const, Matrix3x4), AS_CALL_THISCALL);

    // Matrix3x4 Matrix3x4::operator -(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix3x4 opSub(const Matrix3x4&in) const", AS_METHODPR(T, operator-, (const Matrix3x4&) const, Matrix3x4), AS_CALL_THISCALL);

    // Matrix3x4& Matrix3x4::operator =(const Matrix3x4& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Matrix3x4& opAssign(const Matrix3x4&in)", AS_METHODPR(T, operator=, (const Matrix3x4&), Matrix3x4&), AS_CALL_THISCALL);

    // Matrix3x4& Matrix3x4::operator =(const Matrix3& rhs) noexcept
    engine->RegisterObjectMethod(className, "Matrix3x4& opAssign(const Matrix3&in)", AS_METHODPR(T, operator=, (const Matrix3&), Matrix3x4&), AS_CALL_THISCALL);

    // Matrix3x4& Matrix3x4::operator =(const Matrix4& rhs) noexcept
    engine->RegisterObjectMethod(className, "Matrix3x4& opAssign(const Matrix4&in)", AS_METHODPR(T, operator=, (const Matrix4&), Matrix3x4&), AS_CALL_THISCALL);

    // bool Matrix3x4::operator ==(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix3x4&in) const", AS_METHODPR(T, operator==, (const Matrix3x4&) const, bool), AS_CALL_THISCALL);

    // Quaternion Matrix3x4::Rotation() const
    engine->RegisterObjectMethod(className, "Quaternion Rotation() const", AS_METHODPR(T, Rotation, () const, Quaternion), AS_CALL_THISCALL);

    // Matrix3 Matrix3x4::RotationMatrix() const
    engine->RegisterObjectMethod(className, "Matrix3 RotationMatrix() const", AS_METHODPR(T, RotationMatrix, () const, Matrix3), AS_CALL_THISCALL);

    // Vector4 Matrix3x4::Row(unsigned i) const
    engine->RegisterObjectMethod(className, "Vector4 Row(uint) const", AS_METHODPR(T, Row, (unsigned) const, Vector4), AS_CALL_THISCALL);

    // Vector3 Matrix3x4::Scale() const
    engine->RegisterObjectMethod(className, "Vector3 Scale() const", AS_METHODPR(T, Scale, () const, Vector3), AS_CALL_THISCALL);

    // void Matrix3x4::SetRotation(const Matrix3& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Matrix3&in)", AS_METHODPR(T, SetRotation, (const Matrix3&), void), AS_CALL_THISCALL);

    // void Matrix3x4::SetScale(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetScale(const Vector3&in)", AS_METHODPR(T, SetScale, (const Vector3&), void), AS_CALL_THISCALL);

    // void Matrix3x4::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // void Matrix3x4::SetTranslation(const Vector3& translation)
    engine->RegisterObjectMethod(className, "void SetTranslation(const Vector3&in)", AS_METHODPR(T, SetTranslation, (const Vector3&), void), AS_CALL_THISCALL);

    // Vector3 Matrix3x4::SignedScale(const Matrix3& rotation) const
    engine->RegisterObjectMethod(className, "Vector3 SignedScale(const Matrix3&in) const", AS_METHODPR(T, SignedScale, (const Matrix3&) const, Vector3), AS_CALL_THISCALL);

    // Matrix3 Matrix3x4::ToMatrix3() const
    engine->RegisterObjectMethod(className, "Matrix3 ToMatrix3() const", AS_METHODPR(T, ToMatrix3, () const, Matrix3), AS_CALL_THISCALL);

    // Matrix4 Matrix3x4::ToMatrix4() const
    engine->RegisterObjectMethod(className, "Matrix4 ToMatrix4() const", AS_METHODPR(T, ToMatrix4, () const, Matrix4), AS_CALL_THISCALL);

    // String Matrix3x4::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // Vector3 Matrix3x4::Translation() const
    engine->RegisterObjectMethod(className, "Vector3 Translation() const", AS_METHODPR(T, Translation, () const, Vector3), AS_CALL_THISCALL);

    // float Matrix3x4::m00_
    engine->RegisterObjectProperty(className, "float m00", offsetof(T, m00_));

    // float Matrix3x4::m01_
    engine->RegisterObjectProperty(className, "float m01", offsetof(T, m01_));

    // float Matrix3x4::m02_
    engine->RegisterObjectProperty(className, "float m02", offsetof(T, m02_));

    // float Matrix3x4::m03_
    engine->RegisterObjectProperty(className, "float m03", offsetof(T, m03_));

    // float Matrix3x4::m10_
    engine->RegisterObjectProperty(className, "float m10", offsetof(T, m10_));

    // float Matrix3x4::m11_
    engine->RegisterObjectProperty(className, "float m11", offsetof(T, m11_));

    // float Matrix3x4::m12_
    engine->RegisterObjectProperty(className, "float m12", offsetof(T, m12_));

    // float Matrix3x4::m13_
    engine->RegisterObjectProperty(className, "float m13", offsetof(T, m13_));

    // float Matrix3x4::m20_
    engine->RegisterObjectProperty(className, "float m20", offsetof(T, m20_));

    // float Matrix3x4::m21_
    engine->RegisterObjectProperty(className, "float m21", offsetof(T, m21_));

    // float Matrix3x4::m22_
    engine->RegisterObjectProperty(className, "float m22", offsetof(T, m22_));

    // float Matrix3x4::m23_
    engine->RegisterObjectProperty(className, "float m23", offsetof(T, m23_));

    // static const Matrix3x4 Matrix3x4::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix3x4 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Matrix3x4 Matrix3x4::IDENTITY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix3x4 IDENTITY", (void*)&T::IDENTITY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Matrix3x4
        REGISTER_MEMBERS_MANUAL_PART_Matrix3x4();
    #endif
}

// class Matrix4 | File: ../Math/Matrix4.h
template <class T> void RegisterMembers_Matrix4(asIScriptEngine* engine, const char* className)
{
    // const float* Matrix4::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Matrix4::operator !=(const Matrix4& rhs) const
    // Only operator == is needed

    // Vector4 Matrix4::Column(unsigned j) const
    engine->RegisterObjectMethod(className, "Vector4 Column(uint) const", AS_METHODPR(T, Column, (unsigned) const, Vector4), AS_CALL_THISCALL);

    // void Matrix4::Decompose(Vector3& translation, Quaternion& rotation, Vector3& scale) const
    engine->RegisterObjectMethod(className, "void Decompose(Vector3&, Quaternion&, Vector3&) const", AS_METHODPR(T, Decompose, (Vector3&, Quaternion&, Vector3&) const, void), AS_CALL_THISCALL);

    // float Matrix4::Element(unsigned i, unsigned j) const
    engine->RegisterObjectMethod(className, "float Element(uint, uint) const", AS_METHODPR(T, Element, (unsigned, unsigned) const, float), AS_CALL_THISCALL);

    // bool Matrix4::Equals(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Matrix4&in) const", AS_METHODPR(T, Equals, (const Matrix4&) const, bool), AS_CALL_THISCALL);

    // Matrix4 Matrix4::Inverse() const
    engine->RegisterObjectMethod(className, "Matrix4 Inverse() const", AS_METHODPR(T, Inverse, () const, Matrix4), AS_CALL_THISCALL);

    // bool Matrix4::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Matrix4::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // Vector3 Matrix4::operator *(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(const Vector3&in) const", AS_METHODPR(T, operator*, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector4 Matrix4::operator *(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opMul(const Vector4&in) const", AS_METHODPR(T, operator*, (const Vector4&) const, Vector4), AS_CALL_THISCALL);

    // Matrix4 Matrix4::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Matrix4 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Matrix4), AS_CALL_THISCALL);

    // Matrix4 Matrix4::operator *(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix4 opMul(const Matrix4&in) const", AS_METHODPR(T, operator*, (const Matrix4&) const, Matrix4), AS_CALL_THISCALL);

    // Matrix4 Matrix4::operator *(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix4 opMul(const Matrix3x4&in) const", AS_METHODPR(T, operator*, (const Matrix3x4&) const, Matrix4), AS_CALL_THISCALL);

    // Matrix4 Matrix4::operator +(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix4 opAdd(const Matrix4&in) const", AS_METHODPR(T, operator+, (const Matrix4&) const, Matrix4), AS_CALL_THISCALL);

    // Matrix4 Matrix4::operator -(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "Matrix4 opSub(const Matrix4&in) const", AS_METHODPR(T, operator-, (const Matrix4&) const, Matrix4), AS_CALL_THISCALL);

    // Matrix4& Matrix4::operator =(const Matrix4& rhs) noexcept
    engine->RegisterObjectMethod(className, "Matrix4& opAssign(const Matrix4&in)", AS_METHODPR(T, operator=, (const Matrix4&), Matrix4&), AS_CALL_THISCALL);

    // Matrix4& Matrix4::operator =(const Matrix3& rhs) noexcept
    engine->RegisterObjectMethod(className, "Matrix4& opAssign(const Matrix3&in)", AS_METHODPR(T, operator=, (const Matrix3&), Matrix4&), AS_CALL_THISCALL);

    // bool Matrix4::operator ==(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix4&in) const", AS_METHODPR(T, operator==, (const Matrix4&) const, bool), AS_CALL_THISCALL);

    // Quaternion Matrix4::Rotation() const
    engine->RegisterObjectMethod(className, "Quaternion Rotation() const", AS_METHODPR(T, Rotation, () const, Quaternion), AS_CALL_THISCALL);

    // Matrix3 Matrix4::RotationMatrix() const
    engine->RegisterObjectMethod(className, "Matrix3 RotationMatrix() const", AS_METHODPR(T, RotationMatrix, () const, Matrix3), AS_CALL_THISCALL);

    // Vector4 Matrix4::Row(unsigned i) const
    engine->RegisterObjectMethod(className, "Vector4 Row(uint) const", AS_METHODPR(T, Row, (unsigned) const, Vector4), AS_CALL_THISCALL);

    // Vector3 Matrix4::Scale() const
    engine->RegisterObjectMethod(className, "Vector3 Scale() const", AS_METHODPR(T, Scale, () const, Vector3), AS_CALL_THISCALL);

    // void Matrix4::SetRotation(const Matrix3& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Matrix3&in)", AS_METHODPR(T, SetRotation, (const Matrix3&), void), AS_CALL_THISCALL);

    // void Matrix4::SetScale(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetScale(const Vector3&in)", AS_METHODPR(T, SetScale, (const Vector3&), void), AS_CALL_THISCALL);

    // void Matrix4::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // void Matrix4::SetTranslation(const Vector3& translation)
    engine->RegisterObjectMethod(className, "void SetTranslation(const Vector3&in)", AS_METHODPR(T, SetTranslation, (const Vector3&), void), AS_CALL_THISCALL);

    // Vector3 Matrix4::SignedScale(const Matrix3& rotation) const
    engine->RegisterObjectMethod(className, "Vector3 SignedScale(const Matrix3&in) const", AS_METHODPR(T, SignedScale, (const Matrix3&) const, Vector3), AS_CALL_THISCALL);

    // Matrix3 Matrix4::ToMatrix3() const
    engine->RegisterObjectMethod(className, "Matrix3 ToMatrix3() const", AS_METHODPR(T, ToMatrix3, () const, Matrix3), AS_CALL_THISCALL);

    // String Matrix4::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // Vector3 Matrix4::Translation() const
    engine->RegisterObjectMethod(className, "Vector3 Translation() const", AS_METHODPR(T, Translation, () const, Vector3), AS_CALL_THISCALL);

    // Matrix4 Matrix4::Transpose() const
    engine->RegisterObjectMethod(className, "Matrix4 Transpose() const", AS_METHODPR(T, Transpose, () const, Matrix4), AS_CALL_THISCALL);

    // static void Matrix4::BulkTranspose(float* dest, const float* src, unsigned count)
    // Error: type "float*" can not automatically bind

    // float Matrix4::m00_
    engine->RegisterObjectProperty(className, "float m00", offsetof(T, m00_));

    // float Matrix4::m01_
    engine->RegisterObjectProperty(className, "float m01", offsetof(T, m01_));

    // float Matrix4::m02_
    engine->RegisterObjectProperty(className, "float m02", offsetof(T, m02_));

    // float Matrix4::m03_
    engine->RegisterObjectProperty(className, "float m03", offsetof(T, m03_));

    // float Matrix4::m10_
    engine->RegisterObjectProperty(className, "float m10", offsetof(T, m10_));

    // float Matrix4::m11_
    engine->RegisterObjectProperty(className, "float m11", offsetof(T, m11_));

    // float Matrix4::m12_
    engine->RegisterObjectProperty(className, "float m12", offsetof(T, m12_));

    // float Matrix4::m13_
    engine->RegisterObjectProperty(className, "float m13", offsetof(T, m13_));

    // float Matrix4::m20_
    engine->RegisterObjectProperty(className, "float m20", offsetof(T, m20_));

    // float Matrix4::m21_
    engine->RegisterObjectProperty(className, "float m21", offsetof(T, m21_));

    // float Matrix4::m22_
    engine->RegisterObjectProperty(className, "float m22", offsetof(T, m22_));

    // float Matrix4::m23_
    engine->RegisterObjectProperty(className, "float m23", offsetof(T, m23_));

    // float Matrix4::m30_
    engine->RegisterObjectProperty(className, "float m30", offsetof(T, m30_));

    // float Matrix4::m31_
    engine->RegisterObjectProperty(className, "float m31", offsetof(T, m31_));

    // float Matrix4::m32_
    engine->RegisterObjectProperty(className, "float m32", offsetof(T, m32_));

    // float Matrix4::m33_
    engine->RegisterObjectProperty(className, "float m33", offsetof(T, m33_));

    // static const Matrix4 Matrix4::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix4 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Matrix4 Matrix4::IDENTITY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Matrix4 IDENTITY", (void*)&T::IDENTITY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Matrix4
        REGISTER_MEMBERS_MANUAL_PART_Matrix4();
    #endif
}

// struct ModelMorph | File: ../Graphics/Model.h
template <class T> void RegisterMembers_ModelMorph(asIScriptEngine* engine, const char* className)
{
    // HashMap<unsigned, VertexBufferMorph> ModelMorph::buffers_
    // Error: type "HashMap<unsigned, VertexBufferMorph>" can not automatically bind

    // String ModelMorph::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // StringHash ModelMorph::nameHash_
    engine->RegisterObjectProperty(className, "StringHash nameHash", offsetof(T, nameHash_));

    // float ModelMorph::weight_
    engine->RegisterObjectProperty(className, "float weight", offsetof(T, weight_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ModelMorph
        REGISTER_MEMBERS_MANUAL_PART_ModelMorph();
    #endif
}

// class Mutex | File: ../Core/Mutex.h
template <class T> void RegisterMembers_Mutex(asIScriptEngine* engine, const char* className)
{
    // void Mutex::Acquire()
    engine->RegisterObjectMethod(className, "void Acquire()", AS_METHODPR(T, Acquire, (), void), AS_CALL_THISCALL);

    // void Mutex::Release()
    engine->RegisterObjectMethod(className, "void Release()", AS_METHODPR(T, Release, (), void), AS_CALL_THISCALL);

    // bool Mutex::TryAcquire()
    engine->RegisterObjectMethod(className, "bool TryAcquire()", AS_METHODPR(T, TryAcquire, (), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Mutex
        REGISTER_MEMBERS_MANUAL_PART_Mutex();
    #endif
}

// class MutexLock | File: ../Core/Mutex.h
template <class T> void RegisterMembers_MutexLock(asIScriptEngine* engine, const char* className)
{
    // MutexLock& MutexLock::operator =(const MutexLock& rhs) = delete
    // Not registered because deleted

    #ifdef REGISTER_MEMBERS_MANUAL_PART_MutexLock
        REGISTER_MEMBERS_MANUAL_PART_MutexLock();
    #endif
}

// struct NetworkState | File: ../Scene/ReplicationState.h
template <class T> void RegisterMembers_NetworkState(asIScriptEngine* engine, const char* className)
{
    // const Vector<AttributeInfo>* NetworkState::attributes_
    // Not registered because pointer
    // Vector<Variant> NetworkState::currentValues_
    // Error: type "Vector<Variant>" can not automatically bind
    // Vector<Variant> NetworkState::previousValues_
    // Error: type "Vector<Variant>" can not automatically bind
    // PODVector<ReplicationState*> NetworkState::replicationStates_
    // Error: type "PODVector<ReplicationState*>" can not automatically bind

    // VariantMap NetworkState::previousVars_
    engine->RegisterObjectProperty(className, "VariantMap previousVars", offsetof(T, previousVars_));

    // unsigned long long NetworkState::interceptMask_
    engine->RegisterObjectProperty(className, "uint64 interceptMask", offsetof(T, interceptMask_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NetworkState
        REGISTER_MEMBERS_MANUAL_PART_NetworkState();
    #endif
}

// struct NodeImpl | File: ../Scene/Node.h
template <class T> void RegisterMembers_NodeImpl(asIScriptEngine* engine, const char* className)
{
    // PODVector<Node*> NodeImpl::dependencyNodes_
    // Error: type "PODVector<Node*>" can not automatically bind
    // Connection* NodeImpl::owner_
    // Not registered because pointer
    // StringVector NodeImpl::tags_
    // Error: type "StringVector" can not automatically bind

    // String NodeImpl::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // StringHash NodeImpl::nameHash_
    engine->RegisterObjectProperty(className, "StringHash nameHash", offsetof(T, nameHash_));

    // VectorBuffer NodeImpl::attrBuffer_
    engine->RegisterObjectProperty(className, "VectorBuffer attrBuffer", offsetof(T, attrBuffer_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NodeImpl
        REGISTER_MEMBERS_MANUAL_PART_NodeImpl();
    #endif
}

// struct OcclusionBatch | File: ../Graphics/OcclusionBuffer.h
template <class T> void RegisterMembers_OcclusionBatch(asIScriptEngine* engine, const char* className)
{
    // const void* OcclusionBatch::vertexData_
    // Not registered because pointer
    // const void* OcclusionBatch::indexData_
    // Not registered because pointer

    // Matrix3x4 OcclusionBatch::model_
    engine->RegisterObjectProperty(className, "Matrix3x4 model", offsetof(T, model_));

    // unsigned OcclusionBatch::vertexSize_
    engine->RegisterObjectProperty(className, "uint vertexSize", offsetof(T, vertexSize_));

    // unsigned OcclusionBatch::indexSize_
    engine->RegisterObjectProperty(className, "uint indexSize", offsetof(T, indexSize_));

    // unsigned OcclusionBatch::drawStart_
    engine->RegisterObjectProperty(className, "uint drawStart", offsetof(T, drawStart_));

    // unsigned OcclusionBatch::drawCount_
    engine->RegisterObjectProperty(className, "uint drawCount", offsetof(T, drawCount_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OcclusionBatch
        REGISTER_MEMBERS_MANUAL_PART_OcclusionBatch();
    #endif
}

// struct OcclusionBufferData | File: ../Graphics/OcclusionBuffer.h
template <class T> void RegisterMembers_OcclusionBufferData(asIScriptEngine* engine, const char* className)
{
    // SharedArrayPtr<int> OcclusionBufferData::dataWithSafety_
    // Error: type "SharedArrayPtr<int>" can not automatically bind
    // int* OcclusionBufferData::data_
    // Not registered because pointer

    // bool OcclusionBufferData::used_
    engine->RegisterObjectProperty(className, "bool used", offsetof(T, used_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OcclusionBufferData
        REGISTER_MEMBERS_MANUAL_PART_OcclusionBufferData();
    #endif
}

// class Octant | File: ../Graphics/Octree.h
template <class T> void RegisterMembers_Octant(asIScriptEngine* engine, const char* className)
{
    // Octant* Octant::GetOrCreateChild(unsigned index)
    // Error: type "Octant" can not automatically bind bacause have @nobind mark
    // Octant* Octant::GetParent() const
    // Error: type "Octant" can not automatically bind bacause have @nobind mark

    // void Octant::AddDrawable(Drawable* drawable)
    engine->RegisterObjectMethod(className, "void AddDrawable(Drawable@+)", AS_METHODPR(T, AddDrawable, (Drawable*), void), AS_CALL_THISCALL);

    // bool Octant::CheckDrawableFit(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "bool CheckDrawableFit(const BoundingBox&in) const", AS_METHODPR(T, CheckDrawableFit, (const BoundingBox&) const, bool), AS_CALL_THISCALL);

    // void Octant::DeleteChild(unsigned index)
    engine->RegisterObjectMethod(className, "void DeleteChild(uint)", AS_METHODPR(T, DeleteChild, (unsigned), void), AS_CALL_THISCALL);

    // const BoundingBox& Octant::GetCullingBox() const
    engine->RegisterObjectMethod(className, "const BoundingBox& GetCullingBox() const", AS_METHODPR(T, GetCullingBox, () const, const BoundingBox&), AS_CALL_THISCALL);

    // unsigned Octant::GetLevel() const
    engine->RegisterObjectMethod(className, "uint GetLevel() const", AS_METHODPR(T, GetLevel, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Octant::GetNumDrawables() const
    engine->RegisterObjectMethod(className, "uint GetNumDrawables() const", AS_METHODPR(T, GetNumDrawables, () const, unsigned), AS_CALL_THISCALL);

    // Octree* Octant::GetRoot() const
    engine->RegisterObjectMethod(className, "Octree@+ GetRoot() const", AS_METHODPR(T, GetRoot, () const, Octree*), AS_CALL_THISCALL);

    // const BoundingBox& Octant::GetWorldBoundingBox() const
    engine->RegisterObjectMethod(className, "const BoundingBox& GetWorldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_worldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);

    // void Octant::InsertDrawable(Drawable* drawable)
    engine->RegisterObjectMethod(className, "void InsertDrawable(Drawable@+)", AS_METHODPR(T, InsertDrawable, (Drawable*), void), AS_CALL_THISCALL);

    // bool Octant::IsEmpty()
    engine->RegisterObjectMethod(className, "bool IsEmpty()", AS_METHODPR(T, IsEmpty, (), bool), AS_CALL_THISCALL);

    // void Octant::RemoveDrawable(Drawable* drawable, bool resetOctant = true)
    engine->RegisterObjectMethod(className, "void RemoveDrawable(Drawable@+, bool = true)", AS_METHODPR(T, RemoveDrawable, (Drawable*, bool), void), AS_CALL_THISCALL);

    // void Octant::ResetRoot()
    engine->RegisterObjectMethod(className, "void ResetRoot()", AS_METHODPR(T, ResetRoot, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Octant
        REGISTER_MEMBERS_MANUAL_PART_Octant();
    #endif
}

// class OctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_OctreeQuery(asIScriptEngine* engine, const char* className)
{
    // virtual void OctreeQuery::TestDrawables(Drawable** start, Drawable** end, bool inside) = 0
    // Error: type "Drawable**" can not automatically bind

    // virtual Intersection OctreeQuery::TestOctant(const BoundingBox& box, bool inside) = 0
    engine->RegisterObjectMethod(className, "Intersection TestOctant(const BoundingBox&in, bool)", AS_METHODPR(T, TestOctant, (const BoundingBox&, bool), Intersection), AS_CALL_THISCALL);

    // OctreeQuery& OctreeQuery::operator =(const OctreeQuery& rhs) = delete
    // Not registered because deleted

    // PODVector<Drawable*>& OctreeQuery::result_
    // Error: type "PODVector<Drawable*>&" can not automatically bind

    // unsigned char OctreeQuery::drawableFlags_
    engine->RegisterObjectProperty(className, "uint8 drawableFlags", offsetof(T, drawableFlags_));

    // unsigned OctreeQuery::viewMask_
    engine->RegisterObjectProperty(className, "uint viewMask", offsetof(T, viewMask_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_OctreeQuery();
    #endif
}

// struct OctreeQueryResult | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_OctreeQueryResult(asIScriptEngine* engine, const char* className)
{
    // bool OctreeQueryResult::operator !=(const OctreeQueryResult& rhs) const
    // Only operator == is needed

    // Drawable* OctreeQueryResult::drawable_
    // Not registered because pointer
    // Node* OctreeQueryResult::node_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OctreeQueryResult
        REGISTER_MEMBERS_MANUAL_PART_OctreeQueryResult();
    #endif
}

// struct PackageEntry | File: ../IO/PackageFile.h
template <class T> void RegisterMembers_PackageEntry(asIScriptEngine* engine, const char* className)
{
    // unsigned PackageEntry::offset_
    engine->RegisterObjectProperty(className, "uint offset", offsetof(T, offset_));

    // unsigned PackageEntry::size_
    engine->RegisterObjectProperty(className, "uint size", offsetof(T, size_));

    // unsigned PackageEntry::checksum_
    engine->RegisterObjectProperty(className, "uint checksum", offsetof(T, checksum_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PackageEntry
        REGISTER_MEMBERS_MANUAL_PART_PackageEntry();
    #endif
}

// struct Particle | File: ../Graphics/ParticleEmitter.h
template <class T> void RegisterMembers_Particle(asIScriptEngine* engine, const char* className)
{
    // Vector3 Particle::velocity_
    engine->RegisterObjectProperty(className, "Vector3 velocity", offsetof(T, velocity_));

    // Vector2 Particle::size_
    engine->RegisterObjectProperty(className, "Vector2 size", offsetof(T, size_));

    // float Particle::timer_
    engine->RegisterObjectProperty(className, "float timer", offsetof(T, timer_));

    // float Particle::timeToLive_
    engine->RegisterObjectProperty(className, "float timeToLive", offsetof(T, timeToLive_));

    // float Particle::scale_
    engine->RegisterObjectProperty(className, "float scale", offsetof(T, scale_));

    // float Particle::rotationSpeed_
    engine->RegisterObjectProperty(className, "float rotationSpeed", offsetof(T, rotationSpeed_));

    // unsigned Particle::colorIndex_
    engine->RegisterObjectProperty(className, "uint colorIndex", offsetof(T, colorIndex_));

    // unsigned Particle::texIndex_
    engine->RegisterObjectProperty(className, "uint texIndex", offsetof(T, texIndex_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Particle
        REGISTER_MEMBERS_MANUAL_PART_Particle();
    #endif
}

// struct PerThreadSceneResult | File: ../Graphics/View.h
template <class T> void RegisterMembers_PerThreadSceneResult(asIScriptEngine* engine, const char* className)
{
    // PODVector<Drawable*> PerThreadSceneResult::geometries_
    // Error: type "PODVector<Drawable*>" can not automatically bind
    // PODVector<Light*> PerThreadSceneResult::lights_
    // Error: type "PODVector<Light*>" can not automatically bind

    // float PerThreadSceneResult::minZ_
    engine->RegisterObjectProperty(className, "float minZ", offsetof(T, minZ_));

    // float PerThreadSceneResult::maxZ_
    engine->RegisterObjectProperty(className, "float maxZ", offsetof(T, maxZ_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PerThreadSceneResult
        REGISTER_MEMBERS_MANUAL_PART_PerThreadSceneResult();
    #endif
}

// class Plane | File: ../Math/Plane.h
template <class T> void RegisterMembers_Plane(asIScriptEngine* engine, const char* className)
{
    // void Plane::Define(const Vector3& v0, const Vector3& v1, const Vector3& v2)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in, const Vector3&in, const Vector3&in)", AS_METHODPR(T, Define, (const Vector3&, const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void Plane::Define(const Vector3& normal, const Vector3& point)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in, const Vector3&in)", AS_METHODPR(T, Define, (const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void Plane::Define(const Vector4& plane)
    engine->RegisterObjectMethod(className, "void Define(const Vector4&in)", AS_METHODPR(T, Define, (const Vector4&), void), AS_CALL_THISCALL);

    // float Plane::Distance(const Vector3& point) const
    engine->RegisterObjectMethod(className, "float Distance(const Vector3&in) const", AS_METHODPR(T, Distance, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Plane& Plane::operator =(const Plane& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Plane& opAssign(const Plane&in)", AS_METHODPR(T, operator=, (const Plane&), Plane&), AS_CALL_THISCALL);

    // Vector3 Plane::Project(const Vector3& point) const
    engine->RegisterObjectMethod(className, "Vector3 Project(const Vector3&in) const", AS_METHODPR(T, Project, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Plane::Reflect(const Vector3& direction) const
    engine->RegisterObjectMethod(className, "Vector3 Reflect(const Vector3&in) const", AS_METHODPR(T, Reflect, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Matrix3x4 Plane::ReflectionMatrix() const
    engine->RegisterObjectMethod(className, "Matrix3x4 ReflectionMatrix() const", AS_METHODPR(T, ReflectionMatrix, () const, Matrix3x4), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3x4 get_reflectionMatrix() const", AS_METHODPR(T, ReflectionMatrix, () const, Matrix3x4), AS_CALL_THISCALL);

    // Vector4 Plane::ToVector4() const
    engine->RegisterObjectMethod(className, "Vector4 ToVector4() const", AS_METHODPR(T, ToVector4, () const, Vector4), AS_CALL_THISCALL);

    // void Plane::Transform(const Matrix3& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3&in)", AS_METHODPR(T, Transform, (const Matrix3&), void), AS_CALL_THISCALL);

    // void Plane::Transform(const Matrix3x4& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3x4&in)", AS_METHODPR(T, Transform, (const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Plane::Transform(const Matrix4& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix4&in)", AS_METHODPR(T, Transform, (const Matrix4&), void), AS_CALL_THISCALL);

    // Plane Plane::Transformed(const Matrix3& transform) const
    engine->RegisterObjectMethod(className, "Plane Transformed(const Matrix3&in) const", AS_METHODPR(T, Transformed, (const Matrix3&) const, Plane), AS_CALL_THISCALL);

    // Plane Plane::Transformed(const Matrix3x4& transform) const
    engine->RegisterObjectMethod(className, "Plane Transformed(const Matrix3x4&in) const", AS_METHODPR(T, Transformed, (const Matrix3x4&) const, Plane), AS_CALL_THISCALL);

    // Plane Plane::Transformed(const Matrix4& transform) const
    engine->RegisterObjectMethod(className, "Plane Transformed(const Matrix4&in) const", AS_METHODPR(T, Transformed, (const Matrix4&) const, Plane), AS_CALL_THISCALL);

    // Vector3 Plane::normal_
    engine->RegisterObjectProperty(className, "Vector3 normal", offsetof(T, normal_));

    // Vector3 Plane::absNormal_
    engine->RegisterObjectProperty(className, "Vector3 absNormal", offsetof(T, absNormal_));

    // float Plane::d_
    engine->RegisterObjectProperty(className, "float d", offsetof(T, d_));

    // static const Plane Plane::UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Plane UP", (void*)&T::UP);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Plane
        REGISTER_MEMBERS_MANUAL_PART_Plane();
    #endif
}

// void Polyhedron::AddFace(const PODVector<Vector3>& face)
template <class T> void Polyhedron_void_AddFace_constspPODVectorlesVector3greamp_template(T* _ptr, CScriptArray* face_conv)
{
    PODVector<Vector3> face = ArrayToPODVector<Vector3>(face_conv);
    _ptr->AddFace(face);
}

// class Polyhedron | File: ../Math/Polyhedron.h
template <class T> void RegisterMembers_Polyhedron(asIScriptEngine* engine, const char* className)
{
    // void Polyhedron::AddFace(const Vector3& v0, const Vector3& v1, const Vector3& v2)
    engine->RegisterObjectMethod(className, "void AddFace(const Vector3&in, const Vector3&in, const Vector3&in)", AS_METHODPR(T, AddFace, (const Vector3&, const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void Polyhedron::AddFace(const Vector3& v0, const Vector3& v1, const Vector3& v2, const Vector3& v3)
    engine->RegisterObjectMethod(className, "void AddFace(const Vector3&in, const Vector3&in, const Vector3&in, const Vector3&in)", AS_METHODPR(T, AddFace, (const Vector3&, const Vector3&, const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void Polyhedron::AddFace(const PODVector<Vector3>& face)
    engine->RegisterObjectMethod(className, "void AddFace(Array<Vector3>@+)", AS_FUNCTION_OBJFIRST(Polyhedron_void_AddFace_constspPODVectorlesVector3greamp_template<Polyhedron>), AS_CALL_CDECL_OBJFIRST);

    // void Polyhedron::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void Polyhedron::Clip(const Plane& plane)
    engine->RegisterObjectMethod(className, "void Clip(const Plane&in)", AS_METHODPR(T, Clip, (const Plane&), void), AS_CALL_THISCALL);

    // void Polyhedron::Clip(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Clip(const BoundingBox&in)", AS_METHODPR(T, Clip, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void Polyhedron::Clip(const Frustum& frustum)
    engine->RegisterObjectMethod(className, "void Clip(const Frustum&in)", AS_METHODPR(T, Clip, (const Frustum&), void), AS_CALL_THISCALL);

    // void Polyhedron::Define(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Define(const BoundingBox&in)", AS_METHODPR(T, Define, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void Polyhedron::Define(const Frustum& frustum)
    engine->RegisterObjectMethod(className, "void Define(const Frustum&in)", AS_METHODPR(T, Define, (const Frustum&), void), AS_CALL_THISCALL);

    // bool Polyhedron::Empty() const
    engine->RegisterObjectMethod(className, "bool Empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);

    // Polyhedron& Polyhedron::operator =(const Polyhedron& rhs)
    engine->RegisterObjectMethod(className, "Polyhedron& opAssign(const Polyhedron&in)", AS_METHODPR(T, operator=, (const Polyhedron&), Polyhedron&), AS_CALL_THISCALL);

    // void Polyhedron::Transform(const Matrix3& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3&in)", AS_METHODPR(T, Transform, (const Matrix3&), void), AS_CALL_THISCALL);

    // void Polyhedron::Transform(const Matrix3x4& transform)
    engine->RegisterObjectMethod(className, "void Transform(const Matrix3x4&in)", AS_METHODPR(T, Transform, (const Matrix3x4&), void), AS_CALL_THISCALL);

    // Polyhedron Polyhedron::Transformed(const Matrix3& transform) const
    engine->RegisterObjectMethod(className, "Polyhedron Transformed(const Matrix3&in) const", AS_METHODPR(T, Transformed, (const Matrix3&) const, Polyhedron), AS_CALL_THISCALL);

    // Polyhedron Polyhedron::Transformed(const Matrix3x4& transform) const
    engine->RegisterObjectMethod(className, "Polyhedron Transformed(const Matrix3x4&in) const", AS_METHODPR(T, Transformed, (const Matrix3x4&) const, Polyhedron), AS_CALL_THISCALL);

    // Vector<PODVector<Vector3>> Polyhedron::faces_
    // Error: type "Vector<PODVector<Vector3>>" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Polyhedron
        REGISTER_MEMBERS_MANUAL_PART_Polyhedron();
    #endif
}

// class ProfilerBlock | File: ../Core/Profiler.h
template <class T> void RegisterMembers_ProfilerBlock(asIScriptEngine* engine, const char* className)
{
    // ProfilerBlock* ProfilerBlock::GetChild(const char* name)
    // Can not be registered here bacause hidden in derived classes: EventProfilerBlock

    // void ProfilerBlock::Begin()
    engine->RegisterObjectMethod(className, "void Begin()", AS_METHODPR(T, Begin, (), void), AS_CALL_THISCALL);

    // void ProfilerBlock::BeginInterval()
    engine->RegisterObjectMethod(className, "void BeginInterval()", AS_METHODPR(T, BeginInterval, (), void), AS_CALL_THISCALL);

    // void ProfilerBlock::End()
    engine->RegisterObjectMethod(className, "void End()", AS_METHODPR(T, End, (), void), AS_CALL_THISCALL);

    // void ProfilerBlock::EndFrame()
    engine->RegisterObjectMethod(className, "void EndFrame()", AS_METHODPR(T, EndFrame, (), void), AS_CALL_THISCALL);

    // char* ProfilerBlock::name_
    // Not registered because pointer
    // ProfilerBlock* ProfilerBlock::parent_
    // Not registered because pointer
    // PODVector<ProfilerBlock*> ProfilerBlock::children_
    // Error: type "PODVector<ProfilerBlock*>" can not automatically bind

    // HiresTimer ProfilerBlock::timer_
    engine->RegisterObjectProperty(className, "HiresTimer timer", offsetof(T, timer_));

    // long long ProfilerBlock::time_
    engine->RegisterObjectProperty(className, "int64 time", offsetof(T, time_));

    // long long ProfilerBlock::maxTime_
    engine->RegisterObjectProperty(className, "int64 maxTime", offsetof(T, maxTime_));

    // unsigned ProfilerBlock::count_
    engine->RegisterObjectProperty(className, "uint count", offsetof(T, count_));

    // long long ProfilerBlock::frameTime_
    engine->RegisterObjectProperty(className, "int64 frameTime", offsetof(T, frameTime_));

    // long long ProfilerBlock::frameMaxTime_
    engine->RegisterObjectProperty(className, "int64 frameMaxTime", offsetof(T, frameMaxTime_));

    // unsigned ProfilerBlock::frameCount_
    engine->RegisterObjectProperty(className, "uint frameCount", offsetof(T, frameCount_));

    // long long ProfilerBlock::intervalTime_
    engine->RegisterObjectProperty(className, "int64 intervalTime", offsetof(T, intervalTime_));

    // long long ProfilerBlock::intervalMaxTime_
    engine->RegisterObjectProperty(className, "int64 intervalMaxTime", offsetof(T, intervalMaxTime_));

    // unsigned ProfilerBlock::intervalCount_
    engine->RegisterObjectProperty(className, "uint intervalCount", offsetof(T, intervalCount_));

    // long long ProfilerBlock::totalTime_
    engine->RegisterObjectProperty(className, "int64 totalTime", offsetof(T, totalTime_));

    // long long ProfilerBlock::totalMaxTime_
    engine->RegisterObjectProperty(className, "int64 totalMaxTime", offsetof(T, totalMaxTime_));

    // unsigned ProfilerBlock::totalCount_
    engine->RegisterObjectProperty(className, "uint totalCount", offsetof(T, totalCount_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ProfilerBlock
        REGISTER_MEMBERS_MANUAL_PART_ProfilerBlock();
    #endif
}

// class Quaternion | File: ../Math/Quaternion.h
template <class T> void RegisterMembers_Quaternion(asIScriptEngine* engine, const char* className)
{
    // const float* Quaternion::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Quaternion::operator !=(const Quaternion& rhs) const
    // Only operator == is needed

    // float Quaternion::Angle() const
    engine->RegisterObjectMethod(className, "float Angle() const", AS_METHODPR(T, Angle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_angle() const", AS_METHODPR(T, Angle, () const, float), AS_CALL_THISCALL);

    // Vector3 Quaternion::Axis() const
    engine->RegisterObjectMethod(className, "Vector3 Axis() const", AS_METHODPR(T, Axis, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_axis() const", AS_METHODPR(T, Axis, () const, Vector3), AS_CALL_THISCALL);

    // Quaternion Quaternion::Conjugate() const
    engine->RegisterObjectMethod(className, "Quaternion Conjugate() const", AS_METHODPR(T, Conjugate, () const, Quaternion), AS_CALL_THISCALL);

    // float Quaternion::DotProduct(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "float DotProduct(const Quaternion&in) const", AS_METHODPR(T, DotProduct, (const Quaternion&) const, float), AS_CALL_THISCALL);

    // bool Quaternion::Equals(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Quaternion&in) const", AS_METHODPR(T, Equals, (const Quaternion&) const, bool), AS_CALL_THISCALL);

    // Vector3 Quaternion::EulerAngles() const
    engine->RegisterObjectMethod(className, "Vector3 EulerAngles() const", AS_METHODPR(T, EulerAngles, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_eulerAngles() const", AS_METHODPR(T, EulerAngles, () const, Vector3), AS_CALL_THISCALL);

    // void Quaternion::FromAngleAxis(float angle, const Vector3& axis)
    engine->RegisterObjectMethod(className, "void FromAngleAxis(float, const Vector3&in)", AS_METHODPR(T, FromAngleAxis, (float, const Vector3&), void), AS_CALL_THISCALL);

    // void Quaternion::FromAxes(const Vector3& xAxis, const Vector3& yAxis, const Vector3& zAxis)
    engine->RegisterObjectMethod(className, "void FromAxes(const Vector3&in, const Vector3&in, const Vector3&in)", AS_METHODPR(T, FromAxes, (const Vector3&, const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void Quaternion::FromEulerAngles(float x, float y, float z)
    engine->RegisterObjectMethod(className, "void FromEulerAngles(float, float, float)", AS_METHODPR(T, FromEulerAngles, (float, float, float), void), AS_CALL_THISCALL);

    // bool Quaternion::FromLookRotation(const Vector3& direction, const Vector3& up = Vector3::UP)
    engine->RegisterObjectMethod(className, "bool FromLookRotation(const Vector3&in, const Vector3&in = Vector3::UP)", AS_METHODPR(T, FromLookRotation, (const Vector3&, const Vector3&), bool), AS_CALL_THISCALL);

    // void Quaternion::FromRotationMatrix(const Matrix3& matrix)
    engine->RegisterObjectMethod(className, "void FromRotationMatrix(const Matrix3&in)", AS_METHODPR(T, FromRotationMatrix, (const Matrix3&), void), AS_CALL_THISCALL);

    // void Quaternion::FromRotationTo(const Vector3& start, const Vector3& end)
    engine->RegisterObjectMethod(className, "void FromRotationTo(const Vector3&in, const Vector3&in)", AS_METHODPR(T, FromRotationTo, (const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // Quaternion Quaternion::Inverse() const
    engine->RegisterObjectMethod(className, "Quaternion Inverse() const", AS_METHODPR(T, Inverse, () const, Quaternion), AS_CALL_THISCALL);

    // bool Quaternion::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Quaternion::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // float Quaternion::LengthSquared() const
    engine->RegisterObjectMethod(className, "float LengthSquared() const", AS_METHODPR(T, LengthSquared, () const, float), AS_CALL_THISCALL);

    // Quaternion Quaternion::Nlerp(const Quaternion& rhs, float t, bool shortestPath = false) const
    engine->RegisterObjectMethod(className, "Quaternion Nlerp(const Quaternion&in, float, bool = false) const", AS_METHODPR(T, Nlerp, (const Quaternion&, float, bool) const, Quaternion), AS_CALL_THISCALL);

    // void Quaternion::Normalize()
    engine->RegisterObjectMethod(className, "void Normalize()", AS_METHODPR(T, Normalize, (), void), AS_CALL_THISCALL);

    // Quaternion Quaternion::Normalized() const
    engine->RegisterObjectMethod(className, "Quaternion Normalized() const", AS_METHODPR(T, Normalized, () const, Quaternion), AS_CALL_THISCALL);

    // Quaternion Quaternion::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Quaternion opMul(float) const", AS_METHODPR(T, operator*, (float) const, Quaternion), AS_CALL_THISCALL);

    // Quaternion Quaternion::operator *(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "Quaternion opMul(const Quaternion&in) const", AS_METHODPR(T, operator*, (const Quaternion&) const, Quaternion), AS_CALL_THISCALL);

    // Vector3 Quaternion::operator *(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(const Vector3&in) const", AS_METHODPR(T, operator*, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Quaternion& Quaternion::operator *=(float rhs)
    engine->RegisterObjectMethod(className, "Quaternion& opMulAssign(float)", AS_METHODPR(T, operator*=, (float), Quaternion&), AS_CALL_THISCALL);

    // Quaternion Quaternion::operator +(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "Quaternion opAdd(const Quaternion&in) const", AS_METHODPR(T, operator+, (const Quaternion&) const, Quaternion), AS_CALL_THISCALL);

    // Quaternion& Quaternion::operator +=(const Quaternion& rhs)
    engine->RegisterObjectMethod(className, "Quaternion& opAddAssign(const Quaternion&in)", AS_METHODPR(T, operator+=, (const Quaternion&), Quaternion&), AS_CALL_THISCALL);

    // Quaternion Quaternion::operator -() const
    engine->RegisterObjectMethod(className, "Quaternion opNeg() const", AS_METHODPR(T, operator-, () const, Quaternion), AS_CALL_THISCALL);

    // Quaternion Quaternion::operator -(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "Quaternion opSub(const Quaternion&in) const", AS_METHODPR(T, operator-, (const Quaternion&) const, Quaternion), AS_CALL_THISCALL);

    // Quaternion& Quaternion::operator =(const Quaternion& rhs) noexcept
    engine->RegisterObjectMethod(className, "Quaternion& opAssign(const Quaternion&in)", AS_METHODPR(T, operator=, (const Quaternion&), Quaternion&), AS_CALL_THISCALL);

    // bool Quaternion::operator ==(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Quaternion&in) const", AS_METHODPR(T, operator==, (const Quaternion&) const, bool), AS_CALL_THISCALL);

    // float Quaternion::PitchAngle() const
    engine->RegisterObjectMethod(className, "float PitchAngle() const", AS_METHODPR(T, PitchAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_pitch() const", AS_METHODPR(T, PitchAngle, () const, float), AS_CALL_THISCALL);

    // float Quaternion::RollAngle() const
    engine->RegisterObjectMethod(className, "float RollAngle() const", AS_METHODPR(T, RollAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_roll() const", AS_METHODPR(T, RollAngle, () const, float), AS_CALL_THISCALL);

    // Matrix3 Quaternion::RotationMatrix() const
    engine->RegisterObjectMethod(className, "Matrix3 RotationMatrix() const", AS_METHODPR(T, RotationMatrix, () const, Matrix3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3 get_rotationMatrix() const", AS_METHODPR(T, RotationMatrix, () const, Matrix3), AS_CALL_THISCALL);

    // Quaternion Quaternion::Slerp(const Quaternion& rhs, float t) const
    engine->RegisterObjectMethod(className, "Quaternion Slerp(const Quaternion&in, float) const", AS_METHODPR(T, Slerp, (const Quaternion&, float) const, Quaternion), AS_CALL_THISCALL);

    // String Quaternion::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // float Quaternion::YawAngle() const
    engine->RegisterObjectMethod(className, "float YawAngle() const", AS_METHODPR(T, YawAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_yaw() const", AS_METHODPR(T, YawAngle, () const, float), AS_CALL_THISCALL);

    // float Quaternion::w_
    engine->RegisterObjectProperty(className, "float w", offsetof(T, w_));

    // float Quaternion::x_
    engine->RegisterObjectProperty(className, "float x", offsetof(T, x_));

    // float Quaternion::y_
    engine->RegisterObjectProperty(className, "float y", offsetof(T, y_));

    // float Quaternion::z_
    engine->RegisterObjectProperty(className, "float z", offsetof(T, z_));

    // static const Quaternion Quaternion::IDENTITY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Quaternion IDENTITY", (void*)&T::IDENTITY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Quaternion
        REGISTER_MEMBERS_MANUAL_PART_Quaternion();
    #endif
}

// class Ray | File: ../Math/Ray.h
template <class T> void RegisterMembers_Ray(asIScriptEngine* engine, const char* className)
{
    // float Ray::HitDistance(const Vector3& v0, const Vector3& v1, const Vector3& v2, Vector3* outNormal = nullptr, Vector3* outBary = nullptr) const
    // Error: type "Vector3*" can not automatically bind
    // float Ray::HitDistance(const void* vertexData, unsigned vertexStride, unsigned vertexStart, unsigned vertexCount, Vector3* outNormal = nullptr, Vector2* outUV = nullptr, unsigned uvOffset = 0) const
    // Error: type "const void*" can not automatically bind
    // float Ray::HitDistance(const void* vertexData, unsigned vertexStride, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount, Vector3* outNormal = nullptr, Vector2* outUV = nullptr, unsigned uvOffset = 0) const
    // Error: type "const void*" can not automatically bind
    // bool Ray::InsideGeometry(const void* vertexData, unsigned vertexSize, unsigned vertexStart, unsigned vertexCount) const
    // Error: type "const void*" can not automatically bind
    // bool Ray::InsideGeometry(const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount) const
    // Error: type "const void*" can not automatically bind
    // bool Ray::operator !=(const Ray& rhs) const
    // Only operator == is needed

    // Vector3 Ray::ClosestPoint(const Ray& ray) const
    engine->RegisterObjectMethod(className, "Vector3 ClosestPoint(const Ray&in) const", AS_METHODPR(T, ClosestPoint, (const Ray&) const, Vector3), AS_CALL_THISCALL);

    // void Ray::Define(const Vector3& origin, const Vector3& direction)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in, const Vector3&in)", AS_METHODPR(T, Define, (const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // float Ray::Distance(const Vector3& point) const
    engine->RegisterObjectMethod(className, "float Distance(const Vector3&in) const", AS_METHODPR(T, Distance, (const Vector3&) const, float), AS_CALL_THISCALL);

    // float Ray::HitDistance(const Plane& plane) const
    engine->RegisterObjectMethod(className, "float HitDistance(const Plane&in) const", AS_METHODPR(T, HitDistance, (const Plane&) const, float), AS_CALL_THISCALL);

    // float Ray::HitDistance(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "float HitDistance(const BoundingBox&in) const", AS_METHODPR(T, HitDistance, (const BoundingBox&) const, float), AS_CALL_THISCALL);

    // float Ray::HitDistance(const Frustum& frustum, bool solidInside = true) const
    engine->RegisterObjectMethod(className, "float HitDistance(const Frustum&in, bool = true) const", AS_METHODPR(T, HitDistance, (const Frustum&, bool) const, float), AS_CALL_THISCALL);

    // float Ray::HitDistance(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "float HitDistance(const Sphere&in) const", AS_METHODPR(T, HitDistance, (const Sphere&) const, float), AS_CALL_THISCALL);

    // Ray& Ray::operator =(const Ray& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Ray& opAssign(const Ray&in)", AS_METHODPR(T, operator=, (const Ray&), Ray&), AS_CALL_THISCALL);

    // bool Ray::operator ==(const Ray& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Ray&in) const", AS_METHODPR(T, operator==, (const Ray&) const, bool), AS_CALL_THISCALL);

    // Vector3 Ray::Project(const Vector3& point) const
    engine->RegisterObjectMethod(className, "Vector3 Project(const Vector3&in) const", AS_METHODPR(T, Project, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Ray Ray::Transformed(const Matrix3x4& transform) const
    engine->RegisterObjectMethod(className, "Ray Transformed(const Matrix3x4&in) const", AS_METHODPR(T, Transformed, (const Matrix3x4&) const, Ray), AS_CALL_THISCALL);

    // Vector3 Ray::origin_
    engine->RegisterObjectProperty(className, "Vector3 origin", offsetof(T, origin_));

    // Vector3 Ray::direction_
    engine->RegisterObjectProperty(className, "Vector3 direction", offsetof(T, direction_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Ray
        REGISTER_MEMBERS_MANUAL_PART_Ray();
    #endif
}

// class RayOctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_RayOctreeQuery(asIScriptEngine* engine, const char* className)
{
    // RayOctreeQuery& RayOctreeQuery::operator =(const RayOctreeQuery& rhs) = delete
    // Not registered because deleted

    // PODVector<RayQueryResult>& RayOctreeQuery::result_
    // Error: type "PODVector<RayQueryResult>&" can not automatically bind

    // Ray RayOctreeQuery::ray_
    engine->RegisterObjectProperty(className, "Ray ray", offsetof(T, ray_));

    // unsigned char RayOctreeQuery::drawableFlags_
    engine->RegisterObjectProperty(className, "uint8 drawableFlags", offsetof(T, drawableFlags_));

    // unsigned RayOctreeQuery::viewMask_
    engine->RegisterObjectProperty(className, "uint viewMask", offsetof(T, viewMask_));

    // float RayOctreeQuery::maxDistance_
    engine->RegisterObjectProperty(className, "float maxDistance", offsetof(T, maxDistance_));

    // RayQueryLevel RayOctreeQuery::level_
    engine->RegisterObjectProperty(className, "RayQueryLevel level", offsetof(T, level_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RayOctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_RayOctreeQuery();
    #endif
}

// struct RayQueryResult | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_RayQueryResult(asIScriptEngine* engine, const char* className)
{
    // bool RayQueryResult::operator !=(const RayQueryResult& rhs) const
    // Only operator == is needed

    // Drawable* RayQueryResult::drawable_
    // Not registered because pointer
    // Node* RayQueryResult::node_
    // Not registered because pointer

    // Vector3 RayQueryResult::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Vector3 RayQueryResult::normal_
    engine->RegisterObjectProperty(className, "Vector3 normal", offsetof(T, normal_));

    // Vector2 RayQueryResult::textureUV_
    engine->RegisterObjectProperty(className, "Vector2 textureUV", offsetof(T, textureUV_));

    // float RayQueryResult::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    // unsigned RayQueryResult::subObject_
    engine->RegisterObjectProperty(className, "uint subObject", offsetof(T, subObject_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RayQueryResult
        REGISTER_MEMBERS_MANUAL_PART_RayQueryResult();
    #endif
}

// class Rect | File: ../Math/Rect.h
template <class T> void RegisterMembers_Rect(asIScriptEngine* engine, const char* className)
{
    // const float* Rect::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Rect::operator !=(const Rect& rhs) const
    // Only operator == is needed

    // float Rect::Bottom() const
    engine->RegisterObjectMethod(className, "float Bottom() const", AS_METHODPR(T, Bottom, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_bottom() const", AS_METHODPR(T, Bottom, () const, float), AS_CALL_THISCALL);

    // Vector2 Rect::Center() const
    engine->RegisterObjectMethod(className, "Vector2 Center() const", AS_METHODPR(T, Center, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_center() const", AS_METHODPR(T, Center, () const, Vector2), AS_CALL_THISCALL);

    // void Rect::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void Rect::Clip(const Rect& rect)
    engine->RegisterObjectMethod(className, "void Clip(const Rect&in)", AS_METHODPR(T, Clip, (const Rect&), void), AS_CALL_THISCALL);

    // void Rect::Define(const Rect& rect)
    engine->RegisterObjectMethod(className, "void Define(const Rect&in)", AS_METHODPR(T, Define, (const Rect&), void), AS_CALL_THISCALL);

    // void Rect::Define(const Vector2& min, const Vector2& max)
    engine->RegisterObjectMethod(className, "void Define(const Vector2&in, const Vector2&in)", AS_METHODPR(T, Define, (const Vector2&, const Vector2&), void), AS_CALL_THISCALL);

    // void Rect::Define(const Vector2& point)
    engine->RegisterObjectMethod(className, "void Define(const Vector2&in)", AS_METHODPR(T, Define, (const Vector2&), void), AS_CALL_THISCALL);

    // bool Rect::Defined() const
    engine->RegisterObjectMethod(className, "bool Defined() const", AS_METHODPR(T, Defined, () const, bool), AS_CALL_THISCALL);

    // bool Rect::Equals(const Rect& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Rect&in) const", AS_METHODPR(T, Equals, (const Rect&) const, bool), AS_CALL_THISCALL);

    // Vector2 Rect::HalfSize() const
    engine->RegisterObjectMethod(className, "Vector2 HalfSize() const", AS_METHODPR(T, HalfSize, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_halfSize() const", AS_METHODPR(T, HalfSize, () const, Vector2), AS_CALL_THISCALL);

    // Intersection Rect::IsInside(const Vector2& point) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Vector2&in) const", AS_METHODPR(T, IsInside, (const Vector2&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Rect::IsInside(const Rect& rect) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Rect&in) const", AS_METHODPR(T, IsInside, (const Rect&) const, Intersection), AS_CALL_THISCALL);

    // float Rect::Left() const
    engine->RegisterObjectMethod(className, "float Left() const", AS_METHODPR(T, Left, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_left() const", AS_METHODPR(T, Left, () const, float), AS_CALL_THISCALL);

    // Vector2 Rect::Max() const
    engine->RegisterObjectMethod(className, "Vector2 Max() const", AS_METHODPR(T, Max, () const, Vector2), AS_CALL_THISCALL);

    // void Rect::Merge(const Vector2& point)
    engine->RegisterObjectMethod(className, "void Merge(const Vector2&in)", AS_METHODPR(T, Merge, (const Vector2&), void), AS_CALL_THISCALL);

    // void Rect::Merge(const Rect& rect)
    engine->RegisterObjectMethod(className, "void Merge(const Rect&in)", AS_METHODPR(T, Merge, (const Rect&), void), AS_CALL_THISCALL);

    // Vector2 Rect::Min() const
    engine->RegisterObjectMethod(className, "Vector2 Min() const", AS_METHODPR(T, Min, () const, Vector2), AS_CALL_THISCALL);

    // Rect Rect::operator *(float value) const
    engine->RegisterObjectMethod(className, "Rect opMul(float) const", AS_METHODPR(T, operator*, (float) const, Rect), AS_CALL_THISCALL);

    // Rect& Rect::operator *=(float value)
    engine->RegisterObjectMethod(className, "Rect& opMulAssign(float)", AS_METHODPR(T, operator*=, (float), Rect&), AS_CALL_THISCALL);

    // Rect Rect::operator +(const Rect& rhs) const
    engine->RegisterObjectMethod(className, "Rect opAdd(const Rect&in) const", AS_METHODPR(T, operator+, (const Rect&) const, Rect), AS_CALL_THISCALL);

    // Rect& Rect::operator +=(const Rect& rhs)
    engine->RegisterObjectMethod(className, "Rect& opAddAssign(const Rect&in)", AS_METHODPR(T, operator+=, (const Rect&), Rect&), AS_CALL_THISCALL);

    // Rect Rect::operator -(const Rect& rhs) const
    engine->RegisterObjectMethod(className, "Rect opSub(const Rect&in) const", AS_METHODPR(T, operator-, (const Rect&) const, Rect), AS_CALL_THISCALL);

    // Rect& Rect::operator -=(const Rect& rhs)
    engine->RegisterObjectMethod(className, "Rect& opSubAssign(const Rect&in)", AS_METHODPR(T, operator-=, (const Rect&), Rect&), AS_CALL_THISCALL);

    // Rect Rect::operator /(float value) const
    engine->RegisterObjectMethod(className, "Rect opDiv(float) const", AS_METHODPR(T, operator/, (float) const, Rect), AS_CALL_THISCALL);

    // Rect& Rect::operator /=(float value)
    engine->RegisterObjectMethod(className, "Rect& opDivAssign(float)", AS_METHODPR(T, operator/=, (float), Rect&), AS_CALL_THISCALL);

    // Rect& Rect::operator =(const Rect& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Rect& opAssign(const Rect&in)", AS_METHODPR(T, operator=, (const Rect&), Rect&), AS_CALL_THISCALL);

    // bool Rect::operator ==(const Rect& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Rect&in) const", AS_METHODPR(T, operator==, (const Rect&) const, bool), AS_CALL_THISCALL);

    // float Rect::Right() const
    engine->RegisterObjectMethod(className, "float Right() const", AS_METHODPR(T, Right, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_right() const", AS_METHODPR(T, Right, () const, float), AS_CALL_THISCALL);

    // Vector2 Rect::Size() const
    engine->RegisterObjectMethod(className, "Vector2 Size() const", AS_METHODPR(T, Size, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_size() const", AS_METHODPR(T, Size, () const, Vector2), AS_CALL_THISCALL);

    // float Rect::Top() const
    engine->RegisterObjectMethod(className, "float Top() const", AS_METHODPR(T, Top, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_top() const", AS_METHODPR(T, Top, () const, float), AS_CALL_THISCALL);

    // String Rect::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // Vector4 Rect::ToVector4() const
    engine->RegisterObjectMethod(className, "Vector4 ToVector4() const", AS_METHODPR(T, ToVector4, () const, Vector4), AS_CALL_THISCALL);

    // Vector2 Rect::min_
    engine->RegisterObjectProperty(className, "Vector2 min", offsetof(T, min_));

    // Vector2 Rect::max_
    engine->RegisterObjectProperty(className, "Vector2 max", offsetof(T, max_));

    // static const Rect Rect::FULL
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Rect FULL", (void*)&T::FULL);engine->SetDefaultNamespace("");

    // static const Rect Rect::POSITIVE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Rect POSITIVE", (void*)&T::POSITIVE);engine->SetDefaultNamespace("");

    // static const Rect Rect::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Rect ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Rect
        REGISTER_MEMBERS_MANUAL_PART_Rect();
    #endif
}

// struct RefCount | File: ../Container/RefCounted.h
template <class T> void RegisterMembers_RefCount(asIScriptEngine* engine, const char* className)
{
    // int RefCount::refs_
    engine->RegisterObjectProperty(className, "int refs", offsetof(T, refs_));

    // int RefCount::weakRefs_
    engine->RegisterObjectProperty(className, "int weakRefs", offsetof(T, weakRefs_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RefCount
        REGISTER_MEMBERS_MANUAL_PART_RefCount();
    #endif
}

// class RefCounted | File: ../Container/RefCounted.h
template <class T> void RegisterMembers_RefCounted(asIScriptEngine* engine, const char* className)
{
    // void RefCounted::AddRef()
    // Not registered because have @manualbind mark
    // RefCount* RefCounted::RefCountPtr()
    // Error: type "RefCount*" can not automatically bind
    // void RefCounted::ReleaseRef()
    // Not registered because have @manualbind mark

    // int RefCounted::Refs() const
    engine->RegisterObjectMethod(className, "int Refs() const", AS_METHODPR(T, Refs, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_refs() const", AS_METHODPR(T, Refs, () const, int), AS_CALL_THISCALL);

    // int RefCounted::WeakRefs() const
    engine->RegisterObjectMethod(className, "int WeakRefs() const", AS_METHODPR(T, WeakRefs, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_weakRefs() const", AS_METHODPR(T, WeakRefs, () const, int), AS_CALL_THISCALL);

    // RefCounted& RefCounted::operator =(const RefCounted& rhs) = delete
    // Not registered because deleted

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RefCounted
        REGISTER_MEMBERS_MANUAL_PART_RefCounted();
    #endif
}

// struct RenderPathCommand | File: ../Graphics/RenderPath.h
template <class T> void RegisterMembers_RenderPathCommand(asIScriptEngine* engine, const char* className)
{
    // const String& RenderPathCommand::GetDepthStencilName() const
    engine->RegisterObjectMethod(className, "const String& GetDepthStencilName() const", AS_METHODPR(T, GetDepthStencilName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_depthStencilName() const", AS_METHODPR(T, GetDepthStencilName, () const, const String&), AS_CALL_THISCALL);

    // unsigned RenderPathCommand::GetNumOutputs() const
    engine->RegisterObjectMethod(className, "uint GetNumOutputs() const", AS_METHODPR(T, GetNumOutputs, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numOutputs() const", AS_METHODPR(T, GetNumOutputs, () const, unsigned), AS_CALL_THISCALL);

    // CubeMapFace RenderPathCommand::GetOutputFace(unsigned index) const
    engine->RegisterObjectMethod(className, "CubeMapFace GetOutputFace(uint) const", AS_METHODPR(T, GetOutputFace, (unsigned) const, CubeMapFace), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CubeMapFace get_outputFaces(uint) const", AS_METHODPR(T, GetOutputFace, (unsigned) const, CubeMapFace), AS_CALL_THISCALL);

    // const String& RenderPathCommand::GetOutputName(unsigned index) const
    engine->RegisterObjectMethod(className, "const String& GetOutputName(uint) const", AS_METHODPR(T, GetOutputName, (unsigned) const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_outputNames(uint) const", AS_METHODPR(T, GetOutputName, (unsigned) const, const String&), AS_CALL_THISCALL);

    // const Variant& RenderPathCommand::GetShaderParameter(const String& name) const
    engine->RegisterObjectMethod(className, "const Variant& GetShaderParameter(const String&in) const", AS_METHODPR(T, GetShaderParameter, (const String&) const, const Variant&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Variant& get_shaderParameters(const String&in) const", AS_METHODPR(T, GetShaderParameter, (const String&) const, const Variant&), AS_CALL_THISCALL);

    // const String& RenderPathCommand::GetTextureName(TextureUnit unit) const
    engine->RegisterObjectMethod(className, "const String& GetTextureName(TextureUnit) const", AS_METHODPR(T, GetTextureName, (TextureUnit) const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_textureNames(TextureUnit) const", AS_METHODPR(T, GetTextureName, (TextureUnit) const, const String&), AS_CALL_THISCALL);

    // void RenderPathCommand::Load(const XMLElement& element)
    engine->RegisterObjectMethod(className, "void Load(const XMLElement&in)", AS_METHODPR(T, Load, (const XMLElement&), void), AS_CALL_THISCALL);

    // void RenderPathCommand::RemoveShaderParameter(const String& name)
    engine->RegisterObjectMethod(className, "void RemoveShaderParameter(const String&in)", AS_METHODPR(T, RemoveShaderParameter, (const String&), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetDepthStencilName(const String& name)
    engine->RegisterObjectMethod(className, "void SetDepthStencilName(const String&in)", AS_METHODPR(T, SetDepthStencilName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_depthStencilName(const String&in)", AS_METHODPR(T, SetDepthStencilName, (const String&), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetNumOutputs(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumOutputs(uint)", AS_METHODPR(T, SetNumOutputs, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numOutputs(uint)", AS_METHODPR(T, SetNumOutputs, (unsigned), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetOutput(unsigned index, const String& name, CubeMapFace face = FACE_POSITIVE_X)
    engine->RegisterObjectMethod(className, "void SetOutput(uint, const String&in, CubeMapFace = FACE_POSITIVE_X)", AS_METHODPR(T, SetOutput, (unsigned, const String&, CubeMapFace), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetOutputFace(unsigned index, CubeMapFace face)
    engine->RegisterObjectMethod(className, "void SetOutputFace(uint, CubeMapFace)", AS_METHODPR(T, SetOutputFace, (unsigned, CubeMapFace), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_outputFaces(uint, CubeMapFace)", AS_METHODPR(T, SetOutputFace, (unsigned, CubeMapFace), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetOutputName(unsigned index, const String& name)
    engine->RegisterObjectMethod(className, "void SetOutputName(uint, const String&in)", AS_METHODPR(T, SetOutputName, (unsigned, const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_outputNames(uint, const String&in)", AS_METHODPR(T, SetOutputName, (unsigned, const String&), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetShaderParameter(const String& name, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(const String&in, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (const String&, const Variant&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shaderParameters(const String&in, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (const String&, const Variant&), void), AS_CALL_THISCALL);

    // void RenderPathCommand::SetTextureName(TextureUnit unit, const String& name)
    engine->RegisterObjectMethod(className, "void SetTextureName(TextureUnit, const String&in)", AS_METHODPR(T, SetTextureName, (TextureUnit, const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textureNames(TextureUnit, const String&in)", AS_METHODPR(T, SetTextureName, (TextureUnit, const String&), void), AS_CALL_THISCALL);

    // String RenderPathCommand::textureNames_[MAX_TEXTURE_UNITS]
    // Not registered because array
    // HashMap<StringHash, Variant> RenderPathCommand::shaderParameters_
    // Error: type "HashMap<StringHash, Variant>" can not automatically bind
    // Vector<Pair<String, CubeMapFace>> RenderPathCommand::outputs_
    // Error: type "Vector<Pair<String, CubeMapFace>>" can not automatically bind

    // String RenderPathCommand::tag_
    engine->RegisterObjectProperty(className, "String tag", offsetof(T, tag_));

    // RenderCommandType RenderPathCommand::type_
    engine->RegisterObjectProperty(className, "RenderCommandType type", offsetof(T, type_));

    // RenderCommandSortMode RenderPathCommand::sortMode_
    engine->RegisterObjectProperty(className, "RenderCommandSortMode sortMode", offsetof(T, sortMode_));

    // String RenderPathCommand::pass_
    engine->RegisterObjectProperty(className, "String pass", offsetof(T, pass_));

    // unsigned RenderPathCommand::passIndex_
    engine->RegisterObjectProperty(className, "uint passIndex", offsetof(T, passIndex_));

    // String RenderPathCommand::metadata_
    engine->RegisterObjectProperty(className, "String metadata", offsetof(T, metadata_));

    // String RenderPathCommand::vertexShaderName_
    engine->RegisterObjectProperty(className, "String vertexShaderName", offsetof(T, vertexShaderName_));

    // String RenderPathCommand::pixelShaderName_
    engine->RegisterObjectProperty(className, "String pixelShaderName", offsetof(T, pixelShaderName_));

    // String RenderPathCommand::vertexShaderDefines_
    engine->RegisterObjectProperty(className, "String vertexShaderDefines", offsetof(T, vertexShaderDefines_));

    // String RenderPathCommand::pixelShaderDefines_
    engine->RegisterObjectProperty(className, "String pixelShaderDefines", offsetof(T, pixelShaderDefines_));

    // String RenderPathCommand::depthStencilName_
    engine->RegisterObjectProperty(className, "String depthStencilName", offsetof(T, depthStencilName_));

    // ClearTargetFlags RenderPathCommand::clearFlags_
    engine->RegisterObjectProperty(className, "ClearTargetFlags clearFlags", offsetof(T, clearFlags_));

    // Color RenderPathCommand::clearColor_
    engine->RegisterObjectProperty(className, "Color clearColor", offsetof(T, clearColor_));

    // float RenderPathCommand::clearDepth_
    engine->RegisterObjectProperty(className, "float clearDepth", offsetof(T, clearDepth_));

    // unsigned RenderPathCommand::clearStencil_
    engine->RegisterObjectProperty(className, "uint clearStencil", offsetof(T, clearStencil_));

    // BlendMode RenderPathCommand::blendMode_
    engine->RegisterObjectProperty(className, "BlendMode blendMode", offsetof(T, blendMode_));

    // bool RenderPathCommand::enabled_
    engine->RegisterObjectProperty(className, "bool enabled", offsetof(T, enabled_));

    // bool RenderPathCommand::useFogColor_
    engine->RegisterObjectProperty(className, "bool useFogColor", offsetof(T, useFogColor_));

    // bool RenderPathCommand::markToStencil_
    engine->RegisterObjectProperty(className, "bool markToStencil", offsetof(T, markToStencil_));

    // bool RenderPathCommand::useLitBase_
    engine->RegisterObjectProperty(className, "bool useLitBase", offsetof(T, useLitBase_));

    // bool RenderPathCommand::vertexLights_
    engine->RegisterObjectProperty(className, "bool vertexLights", offsetof(T, vertexLights_));

    // String RenderPathCommand::eventName_
    engine->RegisterObjectProperty(className, "String eventName", offsetof(T, eventName_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RenderPathCommand
        REGISTER_MEMBERS_MANUAL_PART_RenderPathCommand();
    #endif
}

// struct RenderTargetInfo | File: ../Graphics/RenderPath.h
template <class T> void RegisterMembers_RenderTargetInfo(asIScriptEngine* engine, const char* className)
{
    // void RenderTargetInfo::Load(const XMLElement& element)
    engine->RegisterObjectMethod(className, "void Load(const XMLElement&in)", AS_METHODPR(T, Load, (const XMLElement&), void), AS_CALL_THISCALL);

    // String RenderTargetInfo::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // String RenderTargetInfo::tag_
    engine->RegisterObjectProperty(className, "String tag", offsetof(T, tag_));

    // unsigned RenderTargetInfo::format_
    engine->RegisterObjectProperty(className, "uint format", offsetof(T, format_));

    // Vector2 RenderTargetInfo::size_
    engine->RegisterObjectProperty(className, "Vector2 size", offsetof(T, size_));

    // RenderTargetSizeMode RenderTargetInfo::sizeMode_
    engine->RegisterObjectProperty(className, "RenderTargetSizeMode sizeMode", offsetof(T, sizeMode_));

    // int RenderTargetInfo::multiSample_
    engine->RegisterObjectProperty(className, "int multiSample", offsetof(T, multiSample_));

    // bool RenderTargetInfo::autoResolve_
    engine->RegisterObjectProperty(className, "bool autoResolve", offsetof(T, autoResolve_));

    // bool RenderTargetInfo::enabled_
    engine->RegisterObjectProperty(className, "bool enabled", offsetof(T, enabled_));

    // bool RenderTargetInfo::cubemap_
    engine->RegisterObjectProperty(className, "bool cubemap", offsetof(T, cubemap_));

    // bool RenderTargetInfo::filtered_
    engine->RegisterObjectProperty(className, "bool filtered", offsetof(T, filtered_));

    // bool RenderTargetInfo::sRGB_
    engine->RegisterObjectProperty(className, "bool sRGB", offsetof(T, sRGB_));

    // bool RenderTargetInfo::persistent_
    engine->RegisterObjectProperty(className, "bool persistent", offsetof(T, persistent_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RenderTargetInfo
        REGISTER_MEMBERS_MANUAL_PART_RenderTargetInfo();
    #endif
}

// struct ReplicationState | File: ../Scene/ReplicationState.h
template <class T> void RegisterMembers_ReplicationState(asIScriptEngine* engine, const char* className)
{
    // Connection* ReplicationState::connection_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ReplicationState
        REGISTER_MEMBERS_MANUAL_PART_ReplicationState();
    #endif
}

// struct ResourceGroup | File: ../Resource/ResourceCache.h
template <class T> void RegisterMembers_ResourceGroup(asIScriptEngine* engine, const char* className)
{
    // HashMap<StringHash, SharedPtr<Resource>> ResourceGroup::resources_
    // Error: type "HashMap<StringHash, SharedPtr<Resource>>" can not automatically bind

    // unsigned long long ResourceGroup::memoryBudget_
    engine->RegisterObjectProperty(className, "uint64 memoryBudget", offsetof(T, memoryBudget_));

    // unsigned long long ResourceGroup::memoryUse_
    engine->RegisterObjectProperty(className, "uint64 memoryUse", offsetof(T, memoryUse_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ResourceGroup
        REGISTER_MEMBERS_MANUAL_PART_ResourceGroup();
    #endif
}

// struct ResourceRef | File: ../Core/Variant.h
template <class T> void RegisterMembers_ResourceRef(asIScriptEngine* engine, const char* className)
{
    // bool ResourceRef::operator !=(const ResourceRef& rhs) const
    // Only operator == is needed

    // bool ResourceRef::operator ==(const ResourceRef& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const ResourceRef&in) const", AS_METHODPR(T, operator==, (const ResourceRef&) const, bool), AS_CALL_THISCALL);

    // StringHash ResourceRef::type_
    engine->RegisterObjectProperty(className, "StringHash type", offsetof(T, type_));

    // String ResourceRef::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ResourceRef
        REGISTER_MEMBERS_MANUAL_PART_ResourceRef();
    #endif
}

// struct ResourceRefList | File: ../Core/Variant.h
template <class T> void RegisterMembers_ResourceRefList(asIScriptEngine* engine, const char* className)
{
    // bool ResourceRefList::operator !=(const ResourceRefList& rhs) const
    // Only operator == is needed

    // bool ResourceRefList::operator ==(const ResourceRefList& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const ResourceRefList&in) const", AS_METHODPR(T, operator==, (const ResourceRefList&) const, bool), AS_CALL_THISCALL);

    // StringVector ResourceRefList::names_
    // Error: type "StringVector" can not automatically bind

    // StringHash ResourceRefList::type_
    engine->RegisterObjectProperty(className, "StringHash type", offsetof(T, type_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ResourceRefList
        REGISTER_MEMBERS_MANUAL_PART_ResourceRefList();
    #endif
}

// struct ScenePassInfo | File: ../Graphics/View.h
template <class T> void RegisterMembers_ScenePassInfo(asIScriptEngine* engine, const char* className)
{
    // BatchQueue* ScenePassInfo::batchQueue_
    // Not registered because pointer

    // unsigned ScenePassInfo::passIndex_
    engine->RegisterObjectProperty(className, "uint passIndex", offsetof(T, passIndex_));

    // bool ScenePassInfo::allowInstancing_
    engine->RegisterObjectProperty(className, "bool allowInstancing", offsetof(T, allowInstancing_));

    // bool ScenePassInfo::markToStencil_
    engine->RegisterObjectProperty(className, "bool markToStencil", offsetof(T, markToStencil_));

    // bool ScenePassInfo::vertexLights_
    engine->RegisterObjectProperty(className, "bool vertexLights", offsetof(T, vertexLights_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ScenePassInfo
        REGISTER_MEMBERS_MANUAL_PART_ScenePassInfo();
    #endif
}

// class SceneResolver | File: ../Scene/SceneResolver.h
template <class T> void RegisterMembers_SceneResolver(asIScriptEngine* engine, const char* className)
{
    // void SceneResolver::AddComponent(unsigned oldID, Component* component)
    engine->RegisterObjectMethod(className, "void AddComponent(uint, Component@+)", AS_METHODPR(T, AddComponent, (unsigned, Component*), void), AS_CALL_THISCALL);

    // void SceneResolver::AddNode(unsigned oldID, Node* node)
    engine->RegisterObjectMethod(className, "void AddNode(uint, Node@+)", AS_METHODPR(T, AddNode, (unsigned, Node*), void), AS_CALL_THISCALL);

    // void SceneResolver::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void SceneResolver::Resolve()
    engine->RegisterObjectMethod(className, "void Resolve()", AS_METHODPR(T, Resolve, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SceneResolver
        REGISTER_MEMBERS_MANUAL_PART_SceneResolver();
    #endif
}

// struct ScratchBuffer | File: ../Graphics/Graphics.h
template <class T> void RegisterMembers_ScratchBuffer(asIScriptEngine* engine, const char* className)
{
    // SharedArrayPtr<unsigned char> ScratchBuffer::data_
    // Error: type "SharedArrayPtr<unsigned char>" can not automatically bind

    // unsigned ScratchBuffer::size_
    engine->RegisterObjectProperty(className, "uint size", offsetof(T, size_));

    // bool ScratchBuffer::reserved_
    engine->RegisterObjectProperty(className, "bool reserved", offsetof(T, reserved_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ScratchBuffer
        REGISTER_MEMBERS_MANUAL_PART_ScratchBuffer();
    #endif
}

// struct ScreenModeParams | File: ../Graphics/Graphics.h
template <class T> void RegisterMembers_ScreenModeParams(asIScriptEngine* engine, const char* className)
{
    // bool ScreenModeParams::operator !=(const ScreenModeParams& rhs) const
    // Only operator == is needed

    // bool ScreenModeParams::EqualsExceptVSync(const ScreenModeParams& rhs) const
    engine->RegisterObjectMethod(className, "bool EqualsExceptVSync(const ScreenModeParams&in) const", AS_METHODPR(T, EqualsExceptVSync, (const ScreenModeParams&) const, bool), AS_CALL_THISCALL);

    // bool ScreenModeParams::operator ==(const ScreenModeParams& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const ScreenModeParams&in) const", AS_METHODPR(T, operator==, (const ScreenModeParams&) const, bool), AS_CALL_THISCALL);

    // bool ScreenModeParams::fullscreen_
    engine->RegisterObjectProperty(className, "bool fullscreen", offsetof(T, fullscreen_));

    // bool ScreenModeParams::borderless_
    engine->RegisterObjectProperty(className, "bool borderless", offsetof(T, borderless_));

    // bool ScreenModeParams::resizable_
    engine->RegisterObjectProperty(className, "bool resizable", offsetof(T, resizable_));

    // bool ScreenModeParams::highDPI_
    engine->RegisterObjectProperty(className, "bool highDPI", offsetof(T, highDPI_));

    // bool ScreenModeParams::vsync_
    engine->RegisterObjectProperty(className, "bool vsync", offsetof(T, vsync_));

    // bool ScreenModeParams::tripleBuffer_
    engine->RegisterObjectProperty(className, "bool tripleBuffer", offsetof(T, tripleBuffer_));

    // int ScreenModeParams::multiSample_
    engine->RegisterObjectProperty(className, "int multiSample", offsetof(T, multiSample_));

    // int ScreenModeParams::monitor_
    engine->RegisterObjectProperty(className, "int monitor", offsetof(T, monitor_));

    // int ScreenModeParams::refreshRate_
    engine->RegisterObjectProperty(className, "int refreshRate", offsetof(T, refreshRate_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ScreenModeParams
        REGISTER_MEMBERS_MANUAL_PART_ScreenModeParams();
    #endif
}

// bool Serializer::WriteStringVector(const StringVector& value)
template <class T> bool Serializer_bool_WriteStringVector_constspStringVectoramp_template(T* _ptr, CScriptArray* value_conv)
{
    StringVector value = ArrayToVector<String>(value_conv);
    bool result = _ptr->WriteStringVector(value);
    return result;
}

// class Serializer | File: ../IO/Serializer.h
template <class T> void RegisterMembers_Serializer(asIScriptEngine* engine, const char* className)
{
    // virtual unsigned Serializer::Write(const void* data, unsigned size) = 0
    // Error: type "const void*" can not automatically bind
    // bool Serializer::WriteBuffer(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // bool Serializer::WriteVariantVector(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // bool Serializer::WriteBool(bool value)
    engine->RegisterObjectMethod(className, "bool WriteBool(bool)", AS_METHODPR(T, WriteBool, (bool), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteBoundingBox(const BoundingBox& value)
    engine->RegisterObjectMethod(className, "bool WriteBoundingBox(const BoundingBox&in)", AS_METHODPR(T, WriteBoundingBox, (const BoundingBox&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteByte(signed char value)
    engine->RegisterObjectMethod(className, "bool WriteByte(int8)", AS_METHODPR(T, WriteByte, (signed char), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteColor(const Color& value)
    engine->RegisterObjectMethod(className, "bool WriteColor(const Color&in)", AS_METHODPR(T, WriteColor, (const Color&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteDouble(double value)
    engine->RegisterObjectMethod(className, "bool WriteDouble(double)", AS_METHODPR(T, WriteDouble, (double), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteFileID(const String& value)
    engine->RegisterObjectMethod(className, "bool WriteFileID(const String&in)", AS_METHODPR(T, WriteFileID, (const String&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteFloat(float value)
    engine->RegisterObjectMethod(className, "bool WriteFloat(float)", AS_METHODPR(T, WriteFloat, (float), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteInt(int value)
    engine->RegisterObjectMethod(className, "bool WriteInt(int)", AS_METHODPR(T, WriteInt, (int), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteInt64(long long value)
    engine->RegisterObjectMethod(className, "bool WriteInt64(int64)", AS_METHODPR(T, WriteInt64, (long long), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteIntRect(const IntRect& value)
    engine->RegisterObjectMethod(className, "bool WriteIntRect(const IntRect&in)", AS_METHODPR(T, WriteIntRect, (const IntRect&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteIntVector2(const IntVector2& value)
    engine->RegisterObjectMethod(className, "bool WriteIntVector2(const IntVector2&in)", AS_METHODPR(T, WriteIntVector2, (const IntVector2&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteIntVector3(const IntVector3& value)
    engine->RegisterObjectMethod(className, "bool WriteIntVector3(const IntVector3&in)", AS_METHODPR(T, WriteIntVector3, (const IntVector3&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteLine(const String& value)
    engine->RegisterObjectMethod(className, "bool WriteLine(const String&in)", AS_METHODPR(T, WriteLine, (const String&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteMatrix3(const Matrix3& value)
    engine->RegisterObjectMethod(className, "bool WriteMatrix3(const Matrix3&in)", AS_METHODPR(T, WriteMatrix3, (const Matrix3&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteMatrix3x4(const Matrix3x4& value)
    engine->RegisterObjectMethod(className, "bool WriteMatrix3x4(const Matrix3x4&in)", AS_METHODPR(T, WriteMatrix3x4, (const Matrix3x4&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteMatrix4(const Matrix4& value)
    engine->RegisterObjectMethod(className, "bool WriteMatrix4(const Matrix4&in)", AS_METHODPR(T, WriteMatrix4, (const Matrix4&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteNetID(unsigned value)
    engine->RegisterObjectMethod(className, "bool WriteNetID(uint)", AS_METHODPR(T, WriteNetID, (unsigned), bool), AS_CALL_THISCALL);

    // bool Serializer::WritePackedQuaternion(const Quaternion& value)
    engine->RegisterObjectMethod(className, "bool WritePackedQuaternion(const Quaternion&in)", AS_METHODPR(T, WritePackedQuaternion, (const Quaternion&), bool), AS_CALL_THISCALL);

    // bool Serializer::WritePackedVector3(const Vector3& value, float maxAbsCoord)
    engine->RegisterObjectMethod(className, "bool WritePackedVector3(const Vector3&in, float)", AS_METHODPR(T, WritePackedVector3, (const Vector3&, float), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteQuaternion(const Quaternion& value)
    engine->RegisterObjectMethod(className, "bool WriteQuaternion(const Quaternion&in)", AS_METHODPR(T, WriteQuaternion, (const Quaternion&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteRect(const Rect& value)
    engine->RegisterObjectMethod(className, "bool WriteRect(const Rect&in)", AS_METHODPR(T, WriteRect, (const Rect&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteResourceRef(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "bool WriteResourceRef(const ResourceRef&in)", AS_METHODPR(T, WriteResourceRef, (const ResourceRef&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteResourceRefList(const ResourceRefList& value)
    engine->RegisterObjectMethod(className, "bool WriteResourceRefList(const ResourceRefList&in)", AS_METHODPR(T, WriteResourceRefList, (const ResourceRefList&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteShort(short value)
    engine->RegisterObjectMethod(className, "bool WriteShort(int16)", AS_METHODPR(T, WriteShort, (short), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteString(const String& value)
    engine->RegisterObjectMethod(className, "bool WriteString(const String&in)", AS_METHODPR(T, WriteString, (const String&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteStringHash(const StringHash& value)
    engine->RegisterObjectMethod(className, "bool WriteStringHash(const StringHash&in)", AS_METHODPR(T, WriteStringHash, (const StringHash&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteStringVector(const StringVector& value)
    engine->RegisterObjectMethod(className, "bool WriteStringVector(Array<String>@+)", AS_FUNCTION_OBJFIRST(Serializer_bool_WriteStringVector_constspStringVectoramp_template<Serializer>), AS_CALL_CDECL_OBJFIRST);

    // bool Serializer::WriteUByte(unsigned char value)
    engine->RegisterObjectMethod(className, "bool WriteUByte(uint8)", AS_METHODPR(T, WriteUByte, (unsigned char), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteUInt(unsigned value)
    engine->RegisterObjectMethod(className, "bool WriteUInt(uint)", AS_METHODPR(T, WriteUInt, (unsigned), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteUInt64(unsigned long long value)
    engine->RegisterObjectMethod(className, "bool WriteUInt64(uint64)", AS_METHODPR(T, WriteUInt64, (unsigned long long), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteUShort(unsigned short value)
    engine->RegisterObjectMethod(className, "bool WriteUShort(uint16)", AS_METHODPR(T, WriteUShort, (unsigned short), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVariant(const Variant& value)
    engine->RegisterObjectMethod(className, "bool WriteVariant(const Variant&in)", AS_METHODPR(T, WriteVariant, (const Variant&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVariantData(const Variant& value)
    engine->RegisterObjectMethod(className, "bool WriteVariantData(const Variant&in)", AS_METHODPR(T, WriteVariantData, (const Variant&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVariantMap(const VariantMap& value)
    engine->RegisterObjectMethod(className, "bool WriteVariantMap(const VariantMap&in)", AS_METHODPR(T, WriteVariantMap, (const VariantMap&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVector2(const Vector2& value)
    engine->RegisterObjectMethod(className, "bool WriteVector2(const Vector2&in)", AS_METHODPR(T, WriteVector2, (const Vector2&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVector3(const Vector3& value)
    engine->RegisterObjectMethod(className, "bool WriteVector3(const Vector3&in)", AS_METHODPR(T, WriteVector3, (const Vector3&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVector4(const Vector4& value)
    engine->RegisterObjectMethod(className, "bool WriteVector4(const Vector4&in)", AS_METHODPR(T, WriteVector4, (const Vector4&), bool), AS_CALL_THISCALL);

    // bool Serializer::WriteVLE(unsigned value)
    engine->RegisterObjectMethod(className, "bool WriteVLE(uint)", AS_METHODPR(T, WriteVLE, (unsigned), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Serializer
        REGISTER_MEMBERS_MANUAL_PART_Serializer();
    #endif
}

// struct ShaderParameter | File: ../Graphics/ShaderVariation.h
template <class T> void RegisterMembers_ShaderParameter(asIScriptEngine* engine, const char* className)
{
    // union ShaderParameter::@4 Urho3D::ShaderParameter::@5
    // Error: type "union Urho3D::ShaderParameter::@4" can not automatically bind
    // union ShaderParameter::@6 Urho3D::ShaderParameter::@7
    // Error: type "union Urho3D::ShaderParameter::@6" can not automatically bind
    // ConstantBuffer* ShaderParameter::bufferPtr_
    // Not registered because pointer

    // ShaderType ShaderParameter::type_
    engine->RegisterObjectProperty(className, "ShaderType type", offsetof(T, type_));

    // String ShaderParameter::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // unsigned ShaderParameter::offset_
    engine->RegisterObjectProperty(className, "uint offset", offsetof(T, offset_));

    // int ShaderParameter::location_
    engine->RegisterObjectProperty(className, "int location", offsetof(T, location_));

    // unsigned ShaderParameter::register_
    engine->RegisterObjectProperty(className, "uint register", offsetof(T, register_));

    // unsigned ShaderParameter::size_
    engine->RegisterObjectProperty(className, "uint size", offsetof(T, size_));

    // unsigned ShaderParameter::glType_
    engine->RegisterObjectProperty(className, "uint glType", offsetof(T, glType_));

    // unsigned ShaderParameter::regCount_
    engine->RegisterObjectProperty(className, "uint regCount", offsetof(T, regCount_));

    // unsigned ShaderParameter::buffer_
    engine->RegisterObjectProperty(className, "uint buffer", offsetof(T, buffer_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ShaderParameter
        REGISTER_MEMBERS_MANUAL_PART_ShaderParameter();
    #endif
}

// struct ShadowBatchQueue | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_ShadowBatchQueue(asIScriptEngine* engine, const char* className)
{
    // Camera* ShadowBatchQueue::shadowCamera_
    // Not registered because pointer

    // IntRect ShadowBatchQueue::shadowViewport_
    engine->RegisterObjectProperty(className, "IntRect shadowViewport", offsetof(T, shadowViewport_));

    // BatchQueue ShadowBatchQueue::shadowBatches_
    engine->RegisterObjectProperty(className, "BatchQueue shadowBatches", offsetof(T, shadowBatches_));

    // float ShadowBatchQueue::nearSplit_
    engine->RegisterObjectProperty(className, "float nearSplit", offsetof(T, nearSplit_));

    // float ShadowBatchQueue::farSplit_
    engine->RegisterObjectProperty(className, "float farSplit", offsetof(T, farSplit_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ShadowBatchQueue
        REGISTER_MEMBERS_MANUAL_PART_ShadowBatchQueue();
    #endif
}

// class Skeleton | File: ../Graphics/Skeleton.h
template <class T> void RegisterMembers_Skeleton(asIScriptEngine* engine, const char* className)
{
    // Bone* Skeleton::GetBone(const char* name)
    // Error: type "const char*" can not automatically bind
    // const Vector<Bone>& Skeleton::GetBones() const
    // Error: type "const Vector<Bone>&" can not automatically bind
    // Vector<Bone>& Skeleton::GetModifiableBones()
    // Error: type "Vector<Bone>&" can not automatically bind

    // void Skeleton::ClearBones()
    engine->RegisterObjectMethod(className, "void ClearBones()", AS_METHODPR(T, ClearBones, (), void), AS_CALL_THISCALL);

    // void Skeleton::Define(const Skeleton& src)
    engine->RegisterObjectMethod(className, "void Define(const Skeleton&in)", AS_METHODPR(T, Define, (const Skeleton&), void), AS_CALL_THISCALL);

    // Bone* Skeleton::GetBone(unsigned index)
    engine->RegisterObjectMethod(className, "Bone@+ GetBone(uint)", AS_METHODPR(T, GetBone, (unsigned), Bone*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Bone@+ get_bones(uint)", AS_METHODPR(T, GetBone, (unsigned), Bone*), AS_CALL_THISCALL);

    // Bone* Skeleton::GetBone(const String& name)
    engine->RegisterObjectMethod(className, "Bone@+ GetBone(const String&in)", AS_METHODPR(T, GetBone, (const String&), Bone*), AS_CALL_THISCALL);

    // Bone* Skeleton::GetBone(const StringHash& boneNameHash)
    engine->RegisterObjectMethod(className, "Bone@+ GetBone(const StringHash&in)", AS_METHODPR(T, GetBone, (const StringHash&), Bone*), AS_CALL_THISCALL);

    // unsigned Skeleton::GetBoneIndex(const String& boneName) const
    engine->RegisterObjectMethod(className, "uint GetBoneIndex(const String&in) const", AS_METHODPR(T, GetBoneIndex, (const String&) const, unsigned), AS_CALL_THISCALL);

    // unsigned Skeleton::GetBoneIndex(const StringHash& boneNameHash) const
    engine->RegisterObjectMethod(className, "uint GetBoneIndex(const StringHash&in) const", AS_METHODPR(T, GetBoneIndex, (const StringHash&) const, unsigned), AS_CALL_THISCALL);

    // unsigned Skeleton::GetBoneIndex(const Bone* bone) const
    engine->RegisterObjectMethod(className, "uint GetBoneIndex(Bone@+) const", AS_METHODPR(T, GetBoneIndex, (const Bone*) const, unsigned), AS_CALL_THISCALL);

    // Bone* Skeleton::GetBoneParent(const Bone* bone)
    engine->RegisterObjectMethod(className, "Bone@+ GetBoneParent(Bone@+)", AS_METHODPR(T, GetBoneParent, (const Bone*), Bone*), AS_CALL_THISCALL);

    // unsigned Skeleton::GetNumBones() const
    engine->RegisterObjectMethod(className, "uint GetNumBones() const", AS_METHODPR(T, GetNumBones, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numBones() const", AS_METHODPR(T, GetNumBones, () const, unsigned), AS_CALL_THISCALL);

    // Bone* Skeleton::GetRootBone()
    engine->RegisterObjectMethod(className, "Bone@+ GetRootBone()", AS_METHODPR(T, GetRootBone, (), Bone*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Bone@+ get_rootBone()", AS_METHODPR(T, GetRootBone, (), Bone*), AS_CALL_THISCALL);

    // bool Skeleton::Load(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool Load(Deserializer&)", AS_METHODPR(T, Load, (Deserializer&), bool), AS_CALL_THISCALL);

    // void Skeleton::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void Skeleton::ResetSilent()
    engine->RegisterObjectMethod(className, "void ResetSilent()", AS_METHODPR(T, ResetSilent, (), void), AS_CALL_THISCALL);

    // bool Skeleton::Save(Serializer& dest) const
    engine->RegisterObjectMethod(className, "bool Save(Serializer&) const", AS_METHODPR(T, Save, (Serializer&) const, bool), AS_CALL_THISCALL);

    // void Skeleton::SetRootBoneIndex(unsigned index)
    engine->RegisterObjectMethod(className, "void SetRootBoneIndex(uint)", AS_METHODPR(T, SetRootBoneIndex, (unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Skeleton
        REGISTER_MEMBERS_MANUAL_PART_Skeleton();
    #endif
}

// struct SourceBatch | File: ../Graphics/Drawable.h
template <class T> void RegisterMembers_SourceBatch(asIScriptEngine* engine, const char* className)
{
    // SourceBatch& SourceBatch::operator =(const SourceBatch& rhs)
    engine->RegisterObjectMethod(className, "SourceBatch& opAssign(const SourceBatch&in)", AS_METHODPR(T, operator=, (const SourceBatch&), SourceBatch&), AS_CALL_THISCALL);

    // Geometry* SourceBatch::geometry_
    // Not registered because pointer
    // SharedPtr<Material> SourceBatch::material_
    // Error: type "SharedPtr<Material>" can not automatically bind
    // const Matrix3x4* SourceBatch::worldTransform_
    // Not registered because pointer
    // void* SourceBatch::instancingData_
    // Not registered because pointer

    // float SourceBatch::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    // unsigned SourceBatch::numWorldTransforms_
    engine->RegisterObjectProperty(className, "uint numWorldTransforms", offsetof(T, numWorldTransforms_));

    // GeometryType SourceBatch::geometryType_
    engine->RegisterObjectProperty(className, "GeometryType geometryType", offsetof(T, geometryType_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SourceBatch
        REGISTER_MEMBERS_MANUAL_PART_SourceBatch();
    #endif
}

// class Sphere | File: ../Math/Sphere.h
template <class T> void RegisterMembers_Sphere(asIScriptEngine* engine, const char* className)
{
    // void Sphere::Define(const Vector3* vertices, unsigned count)
    // Error: type "const Vector3*" can not automatically bind
    // void Sphere::Merge(const Vector3* vertices, unsigned count)
    // Error: type "const Vector3*" can not automatically bind
    // bool Sphere::operator !=(const Sphere& rhs) const
    // Only operator == is needed

    // void Sphere::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void Sphere::Define(const Sphere& sphere)
    engine->RegisterObjectMethod(className, "void Define(const Sphere&in)", AS_METHODPR(T, Define, (const Sphere&), void), AS_CALL_THISCALL);

    // void Sphere::Define(const Vector3& center, float radius)
    engine->RegisterObjectMethod(className, "void Define(const Vector3&in, float)", AS_METHODPR(T, Define, (const Vector3&, float), void), AS_CALL_THISCALL);

    // void Sphere::Define(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Define(const BoundingBox&in)", AS_METHODPR(T, Define, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void Sphere::Define(const Frustum& frustum)
    engine->RegisterObjectMethod(className, "void Define(const Frustum&in)", AS_METHODPR(T, Define, (const Frustum&), void), AS_CALL_THISCALL);

    // void Sphere::Define(const Polyhedron& poly)
    engine->RegisterObjectMethod(className, "void Define(const Polyhedron&in)", AS_METHODPR(T, Define, (const Polyhedron&), void), AS_CALL_THISCALL);

    // bool Sphere::Defined() const
    engine->RegisterObjectMethod(className, "bool Defined() const", AS_METHODPR(T, Defined, () const, bool), AS_CALL_THISCALL);

    // float Sphere::Distance(const Vector3& point) const
    engine->RegisterObjectMethod(className, "float Distance(const Vector3&in) const", AS_METHODPR(T, Distance, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Vector3 Sphere::GetLocalPoint(float theta, float phi) const
    engine->RegisterObjectMethod(className, "Vector3 GetLocalPoint(float, float) const", AS_METHODPR(T, GetLocalPoint, (float, float) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Sphere::GetPoint(float theta, float phi) const
    engine->RegisterObjectMethod(className, "Vector3 GetPoint(float, float) const", AS_METHODPR(T, GetPoint, (float, float) const, Vector3), AS_CALL_THISCALL);

    // Intersection Sphere::IsInside(const Vector3& point) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Vector3&in) const", AS_METHODPR(T, IsInside, (const Vector3&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Sphere::IsInside(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const Sphere&in) const", AS_METHODPR(T, IsInside, (const Sphere&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Sphere::IsInside(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "Intersection IsInside(const BoundingBox&in) const", AS_METHODPR(T, IsInside, (const BoundingBox&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Sphere::IsInsideFast(const Sphere& sphere) const
    engine->RegisterObjectMethod(className, "Intersection IsInsideFast(const Sphere&in) const", AS_METHODPR(T, IsInsideFast, (const Sphere&) const, Intersection), AS_CALL_THISCALL);

    // Intersection Sphere::IsInsideFast(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "Intersection IsInsideFast(const BoundingBox&in) const", AS_METHODPR(T, IsInsideFast, (const BoundingBox&) const, Intersection), AS_CALL_THISCALL);

    // void Sphere::Merge(const Vector3& point)
    engine->RegisterObjectMethod(className, "void Merge(const Vector3&in)", AS_METHODPR(T, Merge, (const Vector3&), void), AS_CALL_THISCALL);

    // void Sphere::Merge(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void Merge(const BoundingBox&in)", AS_METHODPR(T, Merge, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void Sphere::Merge(const Frustum& frustum)
    engine->RegisterObjectMethod(className, "void Merge(const Frustum&in)", AS_METHODPR(T, Merge, (const Frustum&), void), AS_CALL_THISCALL);

    // void Sphere::Merge(const Polyhedron& poly)
    engine->RegisterObjectMethod(className, "void Merge(const Polyhedron&in)", AS_METHODPR(T, Merge, (const Polyhedron&), void), AS_CALL_THISCALL);

    // void Sphere::Merge(const Sphere& sphere)
    engine->RegisterObjectMethod(className, "void Merge(const Sphere&in)", AS_METHODPR(T, Merge, (const Sphere&), void), AS_CALL_THISCALL);

    // Sphere& Sphere::operator =(const Sphere& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Sphere& opAssign(const Sphere&in)", AS_METHODPR(T, operator=, (const Sphere&), Sphere&), AS_CALL_THISCALL);

    // bool Sphere::operator ==(const Sphere& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Sphere&in) const", AS_METHODPR(T, operator==, (const Sphere&) const, bool), AS_CALL_THISCALL);

    // Vector3 Sphere::center_
    engine->RegisterObjectProperty(className, "Vector3 center", offsetof(T, center_));

    // float Sphere::radius_
    engine->RegisterObjectProperty(className, "float radius", offsetof(T, radius_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Sphere
        REGISTER_MEMBERS_MANUAL_PART_Sphere();
    #endif
}

// class Spline | File: ../Core/Spline.h
template <class T> void RegisterMembers_Spline(asIScriptEngine* engine, const char* className)
{
    // const VariantVector& Spline::GetKnots() const
    // Error: type "const VariantVector&" can not automatically bind
    // bool Spline::operator !=(const Spline& rhs) const
    // Only operator == is needed
    // void Spline::SetKnots(const Vector<Variant>& knots)
    // Error: type "const Vector<Variant>&" can not automatically bind

    // void Spline::AddKnot(const Variant& knot)
    engine->RegisterObjectMethod(className, "void AddKnot(const Variant&in)", AS_METHODPR(T, AddKnot, (const Variant&), void), AS_CALL_THISCALL);

    // void Spline::AddKnot(const Variant& knot, unsigned index)
    engine->RegisterObjectMethod(className, "void AddKnot(const Variant&in, uint)", AS_METHODPR(T, AddKnot, (const Variant&, unsigned), void), AS_CALL_THISCALL);

    // void Spline::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // InterpolationMode Spline::GetInterpolationMode() const
    engine->RegisterObjectMethod(className, "InterpolationMode GetInterpolationMode() const", AS_METHODPR(T, GetInterpolationMode, () const, InterpolationMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "InterpolationMode get_interpolationMode() const", AS_METHODPR(T, GetInterpolationMode, () const, InterpolationMode), AS_CALL_THISCALL);

    // Variant Spline::GetKnot(unsigned index) const
    engine->RegisterObjectMethod(className, "Variant GetKnot(uint) const", AS_METHODPR(T, GetKnot, (unsigned) const, Variant), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant get_knot(uint) const", AS_METHODPR(T, GetKnot, (unsigned) const, Variant), AS_CALL_THISCALL);

    // Variant Spline::GetPoint(float f) const
    engine->RegisterObjectMethod(className, "Variant GetPoint(float) const", AS_METHODPR(T, GetPoint, (float) const, Variant), AS_CALL_THISCALL);

    // Spline& Spline::operator =(const Spline& rhs) = default
    engine->RegisterObjectMethod(className, "Spline& opAssign(const Spline&in)", AS_METHODPR(T, operator=, (const Spline&), Spline&), AS_CALL_THISCALL);

    // bool Spline::operator ==(const Spline& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Spline&in) const", AS_METHODPR(T, operator==, (const Spline&) const, bool), AS_CALL_THISCALL);

    // void Spline::RemoveKnot()
    engine->RegisterObjectMethod(className, "void RemoveKnot()", AS_METHODPR(T, RemoveKnot, (), void), AS_CALL_THISCALL);

    // void Spline::RemoveKnot(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveKnot(uint)", AS_METHODPR(T, RemoveKnot, (unsigned), void), AS_CALL_THISCALL);

    // void Spline::SetInterpolationMode(InterpolationMode interpolationMode)
    engine->RegisterObjectMethod(className, "void SetInterpolationMode(InterpolationMode)", AS_METHODPR(T, SetInterpolationMode, (InterpolationMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_interpolationMode(InterpolationMode)", AS_METHODPR(T, SetInterpolationMode, (InterpolationMode), void), AS_CALL_THISCALL);

    // void Spline::SetKnot(const Variant& knot, unsigned index)
    engine->RegisterObjectMethod(className, "void SetKnot(const Variant&in, uint)", AS_METHODPR(T, SetKnot, (const Variant&, unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Spline
        REGISTER_MEMBERS_MANUAL_PART_Spline();
    #endif
}

// struct StaticModelGeometryData | File: ../Graphics/StaticModel.h
template <class T> void RegisterMembers_StaticModelGeometryData(asIScriptEngine* engine, const char* className)
{
    // Vector3 StaticModelGeometryData::center_
    engine->RegisterObjectProperty(className, "Vector3 center", offsetof(T, center_));

    // unsigned StaticModelGeometryData::lodLevel_
    engine->RegisterObjectProperty(className, "uint lodLevel", offsetof(T, lodLevel_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StaticModelGeometryData
        REGISTER_MEMBERS_MANUAL_PART_StaticModelGeometryData();
    #endif
}

// struct StoredLogMessage | File: ../IO/Log.h
template <class T> void RegisterMembers_StoredLogMessage(asIScriptEngine* engine, const char* className)
{
    // String StoredLogMessage::message_
    engine->RegisterObjectProperty(className, "String message", offsetof(T, message_));

    // int StoredLogMessage::level_
    engine->RegisterObjectProperty(className, "int level", offsetof(T, level_));

    // bool StoredLogMessage::error_
    engine->RegisterObjectProperty(className, "bool error", offsetof(T, error_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StoredLogMessage
        REGISTER_MEMBERS_MANUAL_PART_StoredLogMessage();
    #endif
}

// void String::Join(const Vector<String>& subStrings, const String& glue)
template <class T> void String_void_Join_constspVectorlesStringgreamp_constspStringamp_template(T* _ptr, CScriptArray* subStrings_conv, const String& glue)
{
    Vector<String> subStrings = ArrayToVector<String>(subStrings_conv);
    _ptr->Join(subStrings, glue);
}

// Vector<String> String::Split(char separator, bool keepEmptyStrings = false) const
template <class T> CScriptArray* String_VectorlesStringgre_Split_char_bool_template(T* _ptr, char separator, bool keepEmptyStrings)
{
    Vector<String> result = _ptr->Split(separator, keepEmptyStrings);
    return VectorToArray<String>(result, "Array<String>");
}

// bool String::operator <(const String& rhs) const
template <class T> int String_bool_operatorles_constspStringamp(const T& lhs, const T& rhs)
{
    if (lhs < rhs)
        return -1;

    if (lhs > rhs)
        return 1;

    return 0;
}

// class String | File: ../Container/Str.h
template <class T> void RegisterMembers_String(asIScriptEngine* engine, const char* className)
{
    // String& String::Append(const char* str)
    // Error: type "const char*" can not automatically bind
    // String& String::Append(const char* str, unsigned length)
    // Error: type "const char*" can not automatically bind
    // String& String::AppendWithFormat(const char* formatString,...)
    // Error: type "const char*" can not automatically bind
    // String& String::AppendWithFormatArgs(const char* formatString, va_list args)
    // Error: type "const char*" can not automatically bind
    // Iterator String::Begin()
    // Error: type "Iterator" can not automatically bind
    // ConstIterator String::Begin() const
    // Error: type "ConstIterator" can not automatically bind
    // int String::Compare(const char* str, bool caseSensitive = true) const
    // Error: type "const char*" can not automatically bind
    // const char* String::CString() const
    // Error: type "const char*" can not automatically bind
    // Iterator String::End()
    // Error: type "Iterator" can not automatically bind
    // ConstIterator String::End() const
    // Error: type "ConstIterator" can not automatically bind
    // Iterator String::Erase(const Iterator& it)
    // Error: type "const Iterator&" can not automatically bind
    // Iterator String::Erase(const Iterator& start, const Iterator& end)
    // Error: type "const Iterator&" can not automatically bind
    // Iterator String::Insert(const Iterator& dest, const String& str)
    // Error: type "const Iterator&" can not automatically bind
    // Iterator String::Insert(const Iterator& dest, const Iterator& start, const Iterator& end)
    // Error: type "const Iterator&" can not automatically bind
    // Iterator String::Insert(const Iterator& dest, char c)
    // Error: type "const Iterator&" can not automatically bind
    // bool String::operator !=(const String& rhs) const
    // Only operator == is needed
    // bool String::operator !=(const char* rhs) const
    // Error: type "const char*" can not automatically bind
    // String String::operator +(const char* rhs) const
    // Error: type "const char*" can not automatically bind
    // String& String::operator +=(const char* rhs)
    // Error: type "const char*" can not automatically bind
    // String& String::operator +=(long rhs)
    // Not registered because have @nobind mark
    // String& String::operator +=(unsigned long rhs)
    // Not registered because have @nobind mark
    // bool String::operator <(const String& rhs) const
    // Registerd as opCmp separately
    // bool String::operator <(const char* rhs) const
    // Error: type "const char*" can not automatically bind
    // String& String::operator =(String&& rhs) noexcept
    // Error: type "String&&" can not automatically bind
    // String& String::operator =(const char* rhs)
    // Error: type "const char*" can not automatically bind
    // bool String::operator ==(const char* rhs) const
    // Error: type "const char*" can not automatically bind
    // bool String::operator>(const String& rhs) const
    // Registerd as opCmp separately
    // bool String::operator>(const char* rhs) const
    // Error: type "const char*" can not automatically bind
    // void String::Replace(unsigned pos, unsigned length, const char* replaceWith)
    // Error: type "const char*" can not automatically bind
    // Iterator String::Replace(const Iterator& start, const Iterator& end, const String& replaceWith)
    // Error: type "const Iterator&" can not automatically bind
    // void String::SetUTF8FromLatin1(const char* str)
    // Error: type "const char*" can not automatically bind
    // void String::SetUTF8FromWChar(const wchar_t* str)
    // Error: type "const wchar_t*" can not automatically bind

    // String& String::Append(const String& str)
    engine->RegisterObjectMethod(className, "String& Append(const String&in)", AS_METHODPR(T, Append, (const String&), String&), AS_CALL_THISCALL);

    // String& String::Append(char c)
    engine->RegisterObjectMethod(className, "String& Append(int8)", AS_METHODPR(T, Append, (char), String&), AS_CALL_THISCALL);

    // String& String::AppendUTF8(unsigned unicodeChar)
    engine->RegisterObjectMethod(className, "String& AppendUTF8(uint)", AS_METHODPR(T, AppendUTF8, (unsigned), String&), AS_CALL_THISCALL);

    // char& String::At(unsigned index)
    engine->RegisterObjectMethod(className, "int8& At(uint)", AS_METHODPR(T, At, (unsigned), char&), AS_CALL_THISCALL);

    // const char& String::At(unsigned index) const
    engine->RegisterObjectMethod(className, "const int8& At(uint) const", AS_METHODPR(T, At, (unsigned) const, const char&), AS_CALL_THISCALL);

    // unsigned String::AtUTF8(unsigned index) const
    engine->RegisterObjectMethod(className, "uint AtUTF8(uint) const", AS_METHODPR(T, AtUTF8, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // char String::Back() const
    engine->RegisterObjectMethod(className, "int8 Back() const", AS_METHODPR(T, Back, () const, char), AS_CALL_THISCALL);

    // unsigned String::ByteOffsetUTF8(unsigned index) const
    engine->RegisterObjectMethod(className, "uint ByteOffsetUTF8(uint) const", AS_METHODPR(T, ByteOffsetUTF8, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // unsigned String::Capacity() const
    engine->RegisterObjectMethod(className, "uint Capacity() const", AS_METHODPR(T, Capacity, () const, unsigned), AS_CALL_THISCALL);

    // void String::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void String::Compact()
    engine->RegisterObjectMethod(className, "void Compact()", AS_METHODPR(T, Compact, (), void), AS_CALL_THISCALL);

    // int String::Compare(const String& str, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "int Compare(const String&in, bool = true) const", AS_METHODPR(T, Compare, (const String&, bool) const, int), AS_CALL_THISCALL);

    // bool String::Contains(const String& str, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "bool Contains(const String&in, bool = true) const", AS_METHODPR(T, Contains, (const String&, bool) const, bool), AS_CALL_THISCALL);

    // bool String::Contains(char c, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "bool Contains(int8, bool = true) const", AS_METHODPR(T, Contains, (char, bool) const, bool), AS_CALL_THISCALL);

    // bool String::Empty() const
    engine->RegisterObjectMethod(className, "bool Empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);

    // bool String::EndsWith(const String& str, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "bool EndsWith(const String&in, bool = true) const", AS_METHODPR(T, EndsWith, (const String&, bool) const, bool), AS_CALL_THISCALL);

    // void String::Erase(unsigned pos, unsigned length = 1)
    engine->RegisterObjectMethod(className, "void Erase(uint, uint = 1)", AS_METHODPR(T, Erase, (unsigned, unsigned), void), AS_CALL_THISCALL);

    // unsigned String::Find(const String& str, unsigned startPos = 0, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "uint Find(const String&in, uint = 0, bool = true) const", AS_METHODPR(T, Find, (const String&, unsigned, bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned String::Find(char c, unsigned startPos = 0, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "uint Find(int8, uint = 0, bool = true) const", AS_METHODPR(T, Find, (char, unsigned, bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned String::FindLast(const String& str, unsigned startPos = NPOS, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "uint FindLast(const String&in, uint = String::NPOS, bool = true) const", AS_METHODPR(T, FindLast, (const String&, unsigned, bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned String::FindLast(char c, unsigned startPos = NPOS, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "uint FindLast(int8, uint = String::NPOS, bool = true) const", AS_METHODPR(T, FindLast, (char, unsigned, bool) const, unsigned), AS_CALL_THISCALL);

    // char String::Front() const
    engine->RegisterObjectMethod(className, "int8 Front() const", AS_METHODPR(T, Front, () const, char), AS_CALL_THISCALL);

    // void String::Insert(unsigned pos, const String& str)
    engine->RegisterObjectMethod(className, "void Insert(uint, const String&in)", AS_METHODPR(T, Insert, (unsigned, const String&), void), AS_CALL_THISCALL);

    // void String::Insert(unsigned pos, char c)
    engine->RegisterObjectMethod(className, "void Insert(uint, int8)", AS_METHODPR(T, Insert, (unsigned, char), void), AS_CALL_THISCALL);

    // void String::Join(const Vector<String>& subStrings, const String& glue)
    engine->RegisterObjectMethod(className, "void Join(Array<String>@+, const String&in)", AS_FUNCTION_OBJFIRST(String_void_Join_constspVectorlesStringgreamp_constspStringamp_template<String>), AS_CALL_CDECL_OBJFIRST);

    // unsigned String::Length() const
    engine->RegisterObjectMethod(className, "uint Length() const", AS_METHODPR(T, Length, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_length() const", AS_METHODPR(T, Length, () const, unsigned), AS_CALL_THISCALL);

    // unsigned String::LengthUTF8() const
    engine->RegisterObjectMethod(className, "uint LengthUTF8() const", AS_METHODPR(T, LengthUTF8, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_utf8Length() const", AS_METHODPR(T, LengthUTF8, () const, unsigned), AS_CALL_THISCALL);

    // unsigned String::NextUTF8Char(unsigned& byteOffset) const
    engine->RegisterObjectMethod(className, "uint NextUTF8Char(uint&) const", AS_METHODPR(T, NextUTF8Char, (unsigned&) const, unsigned), AS_CALL_THISCALL);

    // String String::operator +(const String& rhs) const
    engine->RegisterObjectMethod(className, "String opAdd(const String&in) const", AS_METHODPR(T, operator+, (const String&) const, String), AS_CALL_THISCALL);

    // String& String::operator +=(const String& rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(const String&in)", AS_METHODPR(T, operator+=, (const String&), String&), AS_CALL_THISCALL);

    // String& String::operator +=(char rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(int8)", AS_METHODPR(T, operator+=, (char), String&), AS_CALL_THISCALL);

    // String& String::operator +=(int rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(int)", AS_METHODPR(T, operator+=, (int), String&), AS_CALL_THISCALL);

    // String& String::operator +=(short rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(int16)", AS_METHODPR(T, operator+=, (short), String&), AS_CALL_THISCALL);

    // String& String::operator +=(long long rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(int64)", AS_METHODPR(T, operator+=, (long long), String&), AS_CALL_THISCALL);

    // String& String::operator +=(unsigned rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(uint)", AS_METHODPR(T, operator+=, (unsigned), String&), AS_CALL_THISCALL);

    // String& String::operator +=(unsigned short rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(uint16)", AS_METHODPR(T, operator+=, (unsigned short), String&), AS_CALL_THISCALL);

    // String& String::operator +=(unsigned long long rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(uint64)", AS_METHODPR(T, operator+=, (unsigned long long), String&), AS_CALL_THISCALL);

    // String& String::operator +=(float rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(float)", AS_METHODPR(T, operator+=, (float), String&), AS_CALL_THISCALL);

    // String& String::operator +=(bool rhs)
    engine->RegisterObjectMethod(className, "String& opAddAssign(bool)", AS_METHODPR(T, operator+=, (bool), String&), AS_CALL_THISCALL);

    // String& String::operator =(const String& rhs)
    engine->RegisterObjectMethod(className, "String& opAssign(const String&in)", AS_METHODPR(T, operator=, (const String&), String&), AS_CALL_THISCALL);

    // bool String::operator ==(const String& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const String&in) const", AS_METHODPR(T, operator==, (const String&) const, bool), AS_CALL_THISCALL);

    // char& String::operator [](unsigned index)
    engine->RegisterObjectMethod(className, "int8& opIndex(uint)", AS_METHODPR(T, operator[], (unsigned), char&), AS_CALL_THISCALL);

    // const char& String::operator [](unsigned index) const
    engine->RegisterObjectMethod(className, "const int8& opIndex(uint) const", AS_METHODPR(T, operator[], (unsigned) const, const char&), AS_CALL_THISCALL);

    // void String::Replace(char replaceThis, char replaceWith, bool caseSensitive = true)
    engine->RegisterObjectMethod(className, "void Replace(int8, int8, bool = true)", AS_METHODPR(T, Replace, (char, char, bool), void), AS_CALL_THISCALL);

    // void String::Replace(const String& replaceThis, const String& replaceWith, bool caseSensitive = true)
    engine->RegisterObjectMethod(className, "void Replace(const String&in, const String&in, bool = true)", AS_METHODPR(T, Replace, (const String&, const String&, bool), void), AS_CALL_THISCALL);

    // void String::Replace(unsigned pos, unsigned length, const String& replaceWith)
    engine->RegisterObjectMethod(className, "void Replace(uint, uint, const String&in)", AS_METHODPR(T, Replace, (unsigned, unsigned, const String&), void), AS_CALL_THISCALL);

    // String String::Replaced(char replaceThis, char replaceWith, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "String Replaced(int8, int8, bool = true) const", AS_METHODPR(T, Replaced, (char, char, bool) const, String), AS_CALL_THISCALL);

    // String String::Replaced(const String& replaceThis, const String& replaceWith, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "String Replaced(const String&in, const String&in, bool = true) const", AS_METHODPR(T, Replaced, (const String&, const String&, bool) const, String), AS_CALL_THISCALL);

    // void String::ReplaceUTF8(unsigned index, unsigned unicodeChar)
    engine->RegisterObjectMethod(className, "void ReplaceUTF8(uint, uint)", AS_METHODPR(T, ReplaceUTF8, (unsigned, unsigned), void), AS_CALL_THISCALL);

    // void String::Reserve(unsigned newCapacity)
    engine->RegisterObjectMethod(className, "void Reserve(uint)", AS_METHODPR(T, Reserve, (unsigned), void), AS_CALL_THISCALL);

    // void String::Resize(unsigned newLength)
    engine->RegisterObjectMethod(className, "void Resize(uint)", AS_METHODPR(T, Resize, (unsigned), void), AS_CALL_THISCALL);

    // Vector<String> String::Split(char separator, bool keepEmptyStrings = false) const
    engine->RegisterObjectMethod(className, "Array<String>@ Split(int8, bool = false) const", AS_FUNCTION_OBJFIRST(String_VectorlesStringgre_Split_char_bool_template<String>), AS_CALL_CDECL_OBJFIRST);

    // bool String::StartsWith(const String& str, bool caseSensitive = true) const
    engine->RegisterObjectMethod(className, "bool StartsWith(const String&in, bool = true) const", AS_METHODPR(T, StartsWith, (const String&, bool) const, bool), AS_CALL_THISCALL);

    // String String::Substring(unsigned pos) const
    engine->RegisterObjectMethod(className, "String Substring(uint) const", AS_METHODPR(T, Substring, (unsigned) const, String), AS_CALL_THISCALL);

    // String String::Substring(unsigned pos, unsigned length) const
    engine->RegisterObjectMethod(className, "String Substring(uint, uint) const", AS_METHODPR(T, Substring, (unsigned, unsigned) const, String), AS_CALL_THISCALL);

    // String String::SubstringUTF8(unsigned pos) const
    engine->RegisterObjectMethod(className, "String SubstringUTF8(uint) const", AS_METHODPR(T, SubstringUTF8, (unsigned) const, String), AS_CALL_THISCALL);

    // String String::SubstringUTF8(unsigned pos, unsigned length) const
    engine->RegisterObjectMethod(className, "String SubstringUTF8(uint, uint) const", AS_METHODPR(T, SubstringUTF8, (unsigned, unsigned) const, String), AS_CALL_THISCALL);

    // void String::Swap(String& str)
    engine->RegisterObjectMethod(className, "void Swap(String&)", AS_METHODPR(T, Swap, (String&), void), AS_CALL_THISCALL);

    // unsigned String::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // String String::ToLower() const
    engine->RegisterObjectMethod(className, "String ToLower() const", AS_METHODPR(T, ToLower, () const, String), AS_CALL_THISCALL);

    // String String::ToUpper() const
    engine->RegisterObjectMethod(className, "String ToUpper() const", AS_METHODPR(T, ToUpper, () const, String), AS_CALL_THISCALL);

    // String String::Trimmed() const
    engine->RegisterObjectMethod(className, "String Trimmed() const", AS_METHODPR(T, Trimmed, () const, String), AS_CALL_THISCALL);

    // bool String::operator <(const String& rhs) const
    engine->RegisterObjectMethod(className, "int opCmp(const String& in) const", AS_FUNCTION_OBJFIRST(String_bool_operatorles_constspStringamp<T>), AS_CALL_CDECL_OBJFIRST);

    // template <class T> String& String::operator +=(const T& rhs)
    // Not registered because template
    // static Vector<String> String::Split(const char* str, char separator, bool keepEmptyStrings = false)
    // Error: type "const char*" can not automatically bind
    // static String String::Joined(const Vector<String>& subStrings, const String& glue)
    // Not registered because have @manualbind mark
    // static void String::EncodeUTF8(char*& dest, unsigned unicodeChar)
    // Error: type "char*&" can not automatically bind
    // static unsigned String::DecodeUTF8(const char*& src)
    // Error: type "const char*&" can not automatically bind
    // static unsigned String::CStringLength(const char* str)
    // Error: type "const char*" can not automatically bind
    // static int String::Compare(const char* lhs, const char* rhs, bool caseSensitive)
    // Error: type "const char*" can not automatically bind

    // static const unsigned String::NPOS
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const uint NPOS", (void*)&T::NPOS);engine->SetDefaultNamespace("");

    // static const unsigned String::MIN_CAPACITY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const uint MIN_CAPACITY", (void*)&T::MIN_CAPACITY);engine->SetDefaultNamespace("");

    // static const String String::EMPTY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const String EMPTY", (void*)&T::EMPTY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_String
        REGISTER_MEMBERS_MANUAL_PART_String();
    #endif
}

// bool StringHash::operator <(const StringHash& rhs) const
template <class T> int StringHash_bool_operatorles_constspStringHashamp(const T& lhs, const T& rhs)
{
    if (lhs < rhs)
        return -1;

    if (lhs > rhs)
        return 1;

    return 0;
}

// class StringHash | File: ../Math/StringHash.h
template <class T> void RegisterMembers_StringHash(asIScriptEngine* engine, const char* className)
{
    // bool StringHash::operator !=(const StringHash& rhs) const
    // Only operator == is needed
    // bool StringHash::operator <(const StringHash& rhs) const
    // Registerd as opCmp separately
    // bool StringHash::operator>(const StringHash& rhs) const
    // Registerd as opCmp separately

    // explicit StringHash::operator bool() const
    engine->RegisterObjectMethod(className, "bool opConv() const", AS_METHODPR(T, operator bool, () const, bool), AS_CALL_THISCALL);

    // StringHash StringHash::operator +(const StringHash& rhs) const
    engine->RegisterObjectMethod(className, "StringHash opAdd(const StringHash&in) const", AS_METHODPR(T, operator+, (const StringHash&) const, StringHash), AS_CALL_THISCALL);

    // StringHash& StringHash::operator +=(const StringHash& rhs)
    engine->RegisterObjectMethod(className, "StringHash& opAddAssign(const StringHash&in)", AS_METHODPR(T, operator+=, (const StringHash&), StringHash&), AS_CALL_THISCALL);

    // StringHash& StringHash::operator =(const StringHash& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "StringHash& opAssign(const StringHash&in)", AS_METHODPR(T, operator=, (const StringHash&), StringHash&), AS_CALL_THISCALL);

    // bool StringHash::operator ==(const StringHash& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const StringHash&in) const", AS_METHODPR(T, operator==, (const StringHash&) const, bool), AS_CALL_THISCALL);

    // String StringHash::Reverse() const
    engine->RegisterObjectMethod(className, "String Reverse() const", AS_METHODPR(T, Reverse, () const, String), AS_CALL_THISCALL);

    // unsigned StringHash::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // String StringHash::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // unsigned StringHash::Value() const
    engine->RegisterObjectMethod(className, "uint Value() const", AS_METHODPR(T, Value, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_value() const", AS_METHODPR(T, Value, () const, unsigned), AS_CALL_THISCALL);

    // bool StringHash::operator <(const StringHash& rhs) const
    engine->RegisterObjectMethod(className, "int opCmp(const StringHash& in) const", AS_FUNCTION_OBJFIRST(StringHash_bool_operatorles_constspStringHashamp<T>), AS_CALL_CDECL_OBJFIRST);

    // static unsigned StringHash::Calculate(const char* str, unsigned hash = 0)
    // Error: type "const char*" can not automatically bind
    // static StringHashRegister* StringHash::GetGlobalStringHashRegister()
    // Error: type "StringHashRegister*" can not automatically bind

    // static const StringHash StringHash::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const StringHash ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StringHash
        REGISTER_MEMBERS_MANUAL_PART_StringHash();
    #endif
}

// class StringHashRegister | File: ../Core/StringHashRegister.h
template <class T> void RegisterMembers_StringHashRegister(asIScriptEngine* engine, const char* className)
{
    // const StringMap& StringHashRegister::GetInternalMap() const
    // Error: type "const StringMap&" can not automatically bind
    // StringHash StringHashRegister::RegisterString(const StringHash& hash, const char* string)
    // Error: type "const char*" can not automatically bind
    // StringHash StringHashRegister::RegisterString(const char* string)
    // Error: type "const char*" can not automatically bind

    // bool StringHashRegister::Contains(const StringHash& hash) const
    engine->RegisterObjectMethod(className, "bool Contains(const StringHash&in) const", AS_METHODPR(T, Contains, (const StringHash&) const, bool), AS_CALL_THISCALL);

    // const String& StringHashRegister::GetString(const StringHash& hash) const
    engine->RegisterObjectMethod(className, "const String& GetString(const StringHash&in) const", AS_METHODPR(T, GetString, (const StringHash&) const, const String&), AS_CALL_THISCALL);

    // String StringHashRegister::GetStringCopy(const StringHash& hash) const
    engine->RegisterObjectMethod(className, "String GetStringCopy(const StringHash&in) const", AS_METHODPR(T, GetStringCopy, (const StringHash&) const, String), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StringHashRegister
        REGISTER_MEMBERS_MANUAL_PART_StringHashRegister();
    #endif
}

// struct TechniqueEntry | File: ../Graphics/Material.h
template <class T> void RegisterMembers_TechniqueEntry(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<Technique> TechniqueEntry::technique_
    // Error: type "SharedPtr<Technique>" can not automatically bind
    // SharedPtr<Technique> TechniqueEntry::original_
    // Error: type "SharedPtr<Technique>" can not automatically bind

    // MaterialQuality TechniqueEntry::qualityLevel_
    engine->RegisterObjectProperty(className, "MaterialQuality qualityLevel", offsetof(T, qualityLevel_));

    // float TechniqueEntry::lodDistance_
    engine->RegisterObjectProperty(className, "float lodDistance", offsetof(T, lodDistance_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TechniqueEntry
        REGISTER_MEMBERS_MANUAL_PART_TechniqueEntry();
    #endif
}

// struct TextureFrame | File: ../Graphics/ParticleEffect.h
template <class T> void RegisterMembers_TextureFrame(asIScriptEngine* engine, const char* className)
{
    // Rect TextureFrame::uv_
    engine->RegisterObjectProperty(className, "Rect uv", offsetof(T, uv_));

    // float TextureFrame::time_
    engine->RegisterObjectProperty(className, "float time", offsetof(T, time_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TextureFrame
        REGISTER_MEMBERS_MANUAL_PART_TextureFrame();
    #endif
}

// class Thread | File: ../Core/Thread.h
template <class T> void RegisterMembers_Thread(asIScriptEngine* engine, const char* className)
{
    // bool Thread::IsStarted() const
    engine->RegisterObjectMethod(className, "bool IsStarted() const", AS_METHODPR(T, IsStarted, () const, bool), AS_CALL_THISCALL);

    // bool Thread::Run()
    engine->RegisterObjectMethod(className, "bool Run()", AS_METHODPR(T, Run, (), bool), AS_CALL_THISCALL);

    // void Thread::SetPriority(int priority)
    engine->RegisterObjectMethod(className, "void SetPriority(int)", AS_METHODPR(T, SetPriority, (int), void), AS_CALL_THISCALL);

    // void Thread::Stop()
    engine->RegisterObjectMethod(className, "void Stop()", AS_METHODPR(T, Stop, (), void), AS_CALL_THISCALL);

    // virtual void Thread::ThreadFunction() = 0
    engine->RegisterObjectMethod(className, "void ThreadFunction()", AS_METHODPR(T, ThreadFunction, (), void), AS_CALL_THISCALL);

    // static ThreadID Thread::GetCurrentThreadID()
    // Not registered because have @nobind mark

    // static void Thread::SetMainThread()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("void SetMainThread()", AS_FUNCTIONPR(T::SetMainThread, (), void), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static bool Thread::IsMainThread()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool IsMainThread()", AS_FUNCTIONPR(T::IsMainThread, (), bool), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Thread
        REGISTER_MEMBERS_MANUAL_PART_Thread();
    #endif
}

// class Timer | File: ../Core/Timer.h
template <class T> void RegisterMembers_Timer(asIScriptEngine* engine, const char* className)
{
    // unsigned Timer::GetMSec(bool reset)
    engine->RegisterObjectMethod(className, "uint GetMSec(bool)", AS_METHODPR(T, GetMSec, (bool), unsigned), AS_CALL_THISCALL);

    // void Timer::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Timer
        REGISTER_MEMBERS_MANUAL_PART_Timer();
    #endif
}

// struct TouchState | File: ../Input/Input.h
template <class T> void RegisterMembers_TouchState(asIScriptEngine* engine, const char* className)
{
    // UIElement* TouchState::GetTouchedElement()
    engine->RegisterObjectMethod(className, "UIElement@+ GetTouchedElement()", AS_METHODPR(T, GetTouchedElement, (), UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_touchedElement()", AS_METHODPR(T, GetTouchedElement, (), UIElement*), AS_CALL_THISCALL);

    // WeakPtr<UIElement> TouchState::touchedElement_
    // Error: type "WeakPtr<UIElement>" can not automatically bind

    // int TouchState::touchID_
    engine->RegisterObjectProperty(className, "int touchID", offsetof(T, touchID_));

    // IntVector2 TouchState::position_
    engine->RegisterObjectProperty(className, "IntVector2 position", offsetof(T, position_));

    // IntVector2 TouchState::lastPosition_
    engine->RegisterObjectProperty(className, "IntVector2 lastPosition", offsetof(T, lastPosition_));

    // IntVector2 TouchState::delta_
    engine->RegisterObjectProperty(className, "IntVector2 delta", offsetof(T, delta_));

    // float TouchState::pressure_
    engine->RegisterObjectProperty(className, "float pressure", offsetof(T, pressure_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TouchState
        REGISTER_MEMBERS_MANUAL_PART_TouchState();
    #endif
}

// struct TrailPoint | File: ../Graphics/RibbonTrail.h
template <class T> void RegisterMembers_TrailPoint(asIScriptEngine* engine, const char* className)
{
    // TrailPoint* TrailPoint::next_
    // Not registered because pointer

    // Vector3 TrailPoint::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Vector3 TrailPoint::forward_
    engine->RegisterObjectProperty(className, "Vector3 forward", offsetof(T, forward_));

    // Vector3 TrailPoint::parentPos_
    engine->RegisterObjectProperty(className, "Vector3 parentPos", offsetof(T, parentPos_));

    // float TrailPoint::elapsedLength_
    engine->RegisterObjectProperty(className, "float elapsedLength", offsetof(T, elapsedLength_));

    // float TrailPoint::lifetime_
    engine->RegisterObjectProperty(className, "float lifetime", offsetof(T, lifetime_));

    // float TrailPoint::sortDistance_
    engine->RegisterObjectProperty(className, "float sortDistance", offsetof(T, sortDistance_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TrailPoint
        REGISTER_MEMBERS_MANUAL_PART_TrailPoint();
    #endif
}

// class TypeInfo | File: ../Core/Object.h
template <class T> void RegisterMembers_TypeInfo(asIScriptEngine* engine, const char* className)
{
    // const TypeInfo* TypeInfo::GetBaseTypeInfo() const
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // bool TypeInfo::IsTypeOf(const TypeInfo* typeInfo) const
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark

    // StringHash TypeInfo::GetType() const
    engine->RegisterObjectMethod(className, "StringHash GetType() const", AS_METHODPR(T, GetType, () const, StringHash), AS_CALL_THISCALL);

    // const String& TypeInfo::GetTypeName() const
    engine->RegisterObjectMethod(className, "const String& GetTypeName() const", AS_METHODPR(T, GetTypeName, () const, const String&), AS_CALL_THISCALL);

    // bool TypeInfo::IsTypeOf(StringHash type) const
    engine->RegisterObjectMethod(className, "bool IsTypeOf(StringHash) const", AS_METHODPR(T, IsTypeOf, (StringHash) const, bool), AS_CALL_THISCALL);

    // template <typename T> bool TypeInfo::IsTypeOf() const
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TypeInfo
        REGISTER_MEMBERS_MANUAL_PART_TypeInfo();
    #endif
}

// class UIBatch | File: ../UI/UIBatch.h
template <class T> void RegisterMembers_UIBatch(asIScriptEngine* engine, const char* className)
{
    // void UIBatch::AddQuad(float x, float y, float width, float height, int texOffsetX, int texOffsetY, int texWidth = 0, int texHeight = 0)
    engine->RegisterObjectMethod(className, "void AddQuad(float, float, float, float, int, int, int = 0, int = 0)", AS_METHODPR(T, AddQuad, (float, float, float, float, int, int, int, int), void), AS_CALL_THISCALL);

    // void UIBatch::AddQuad(const Matrix3x4& transform, int x, int y, int width, int height, int texOffsetX, int texOffsetY, int texWidth = 0, int texHeight = 0)
    engine->RegisterObjectMethod(className, "void AddQuad(const Matrix3x4&in, int, int, int, int, int, int, int = 0, int = 0)", AS_METHODPR(T, AddQuad, (const Matrix3x4&, int, int, int, int, int, int, int, int), void), AS_CALL_THISCALL);

    // void UIBatch::AddQuad(int x, int y, int width, int height, int texOffsetX, int texOffsetY, int texWidth, int texHeight, bool tiled)
    engine->RegisterObjectMethod(className, "void AddQuad(int, int, int, int, int, int, int, int, bool)", AS_METHODPR(T, AddQuad, (int, int, int, int, int, int, int, int, bool), void), AS_CALL_THISCALL);

    // void UIBatch::AddQuad(const Matrix3x4& transform, const IntVector2& a, const IntVector2& b, const IntVector2& c, const IntVector2& d, const IntVector2& texA, const IntVector2& texB, const IntVector2& texC, const IntVector2& texD)
    engine->RegisterObjectMethod(className, "void AddQuad(const Matrix3x4&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in)", AS_METHODPR(T, AddQuad, (const Matrix3x4&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&), void), AS_CALL_THISCALL);

    // void UIBatch::AddQuad(const Matrix3x4& transform, const IntVector2& a, const IntVector2& b, const IntVector2& c, const IntVector2& d, const IntVector2& texA, const IntVector2& texB, const IntVector2& texC, const IntVector2& texD, const Color& colA, const Color& colB, const Color& colC, const Color& colD)
    engine->RegisterObjectMethod(className, "void AddQuad(const Matrix3x4&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const IntVector2&in, const Color&in, const Color&in, const Color&in, const Color&in)", AS_METHODPR(T, AddQuad, (const Matrix3x4&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const IntVector2&, const Color&, const Color&, const Color&, const Color&), void), AS_CALL_THISCALL);

    // unsigned UIBatch::GetInterpolatedColor(float x, float y)
    engine->RegisterObjectMethod(className, "uint GetInterpolatedColor(float, float)", AS_METHODPR(T, GetInterpolatedColor, (float, float), unsigned), AS_CALL_THISCALL);

    // bool UIBatch::Merge(const UIBatch& batch)
    engine->RegisterObjectMethod(className, "bool Merge(const UIBatch&in)", AS_METHODPR(T, Merge, (const UIBatch&), bool), AS_CALL_THISCALL);

    // void UIBatch::SetColor(const Color& color, bool overrideAlpha = false)
    engine->RegisterObjectMethod(className, "void SetColor(const Color&in, bool = false)", AS_METHODPR(T, SetColor, (const Color&, bool), void), AS_CALL_THISCALL);

    // void UIBatch::SetDefaultColor()
    engine->RegisterObjectMethod(className, "void SetDefaultColor()", AS_METHODPR(T, SetDefaultColor, (), void), AS_CALL_THISCALL);

    // static void UIBatch::AddOrMerge(const UIBatch& batch, PODVector<UIBatch>& batches)
    // Error: type "PODVector<UIBatch>&" can not automatically bind

    // UIElement* UIBatch::element_
    // Not registered because pointer
    // Texture* UIBatch::texture_
    // Not registered because pointer
    // PODVector<float>* UIBatch::vertexData_
    // Not registered because pointer
    // Material* UIBatch::customMaterial_
    // Not registered because pointer

    // BlendMode UIBatch::blendMode_
    engine->RegisterObjectProperty(className, "BlendMode blendMode", offsetof(T, blendMode_));

    // IntRect UIBatch::scissor_
    engine->RegisterObjectProperty(className, "IntRect scissor", offsetof(T, scissor_));

    // Vector2 UIBatch::invTextureSize_
    engine->RegisterObjectProperty(className, "Vector2 invTextureSize", offsetof(T, invTextureSize_));

    // unsigned UIBatch::vertexStart_
    engine->RegisterObjectProperty(className, "uint vertexStart", offsetof(T, vertexStart_));

    // unsigned UIBatch::vertexEnd_
    engine->RegisterObjectProperty(className, "uint vertexEnd", offsetof(T, vertexEnd_));

    // unsigned UIBatch::color_
    engine->RegisterObjectProperty(className, "uint color", offsetof(T, color_));

    // bool UIBatch::useGradient_
    engine->RegisterObjectProperty(className, "bool useGradient", offsetof(T, useGradient_));

    // static Vector3 UIBatch::posAdjust
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("Vector3 posAdjust", (void*)&T::posAdjust);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_UIBatch
        REGISTER_MEMBERS_MANUAL_PART_UIBatch();
    #endif
}

// struct VAnimEventFrame | File: ../Scene/ValueAnimation.h
template <class T> void RegisterMembers_VAnimEventFrame(asIScriptEngine* engine, const char* className)
{
    // float VAnimEventFrame::time_
    engine->RegisterObjectProperty(className, "float time", offsetof(T, time_));

    // StringHash VAnimEventFrame::eventType_
    engine->RegisterObjectProperty(className, "StringHash eventType", offsetof(T, eventType_));

    // VariantMap VAnimEventFrame::eventData_
    engine->RegisterObjectProperty(className, "VariantMap eventData", offsetof(T, eventData_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VAnimEventFrame
        REGISTER_MEMBERS_MANUAL_PART_VAnimEventFrame();
    #endif
}

// struct VAnimKeyFrame | File: ../Scene/ValueAnimation.h
template <class T> void RegisterMembers_VAnimKeyFrame(asIScriptEngine* engine, const char* className)
{
    // float VAnimKeyFrame::time_
    engine->RegisterObjectProperty(className, "float time", offsetof(T, time_));

    // Variant VAnimKeyFrame::value_
    engine->RegisterObjectProperty(className, "Variant value", offsetof(T, value_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VAnimKeyFrame
        REGISTER_MEMBERS_MANUAL_PART_VAnimKeyFrame();
    #endif
}

// const StringVector& Variant::GetStringVector() const
template <class T> CScriptArray* Variant_constspStringVectoramp_GetStringVector_void_template(T* _ptr)
{
    const StringVector& result = _ptr->GetStringVector();
    return VectorToArray<String>(result, "Array<String>");
}

// Variant& Variant::operator =(const StringVector& rhs)
template <class T> Variant& Variant_Variantamp_operatoreq_constspStringVectoramp_template(T* _ptr, CScriptArray* rhs_conv)
{
    StringVector rhs = ArrayToVector<String>(rhs_conv);
    Variant& result = _ptr->operator=(rhs);
    return result;
}

// bool Variant::operator ==(const StringVector& rhs) const
template <class T> bool Variant_bool_operatoreqeq_constspStringVectoramp_template(T* _ptr, CScriptArray* rhs_conv)
{
    StringVector rhs = ArrayToVector<String>(rhs_conv);
    bool result = _ptr->operator==(rhs);
    return result;
}

// class Variant | File: ../Core/Variant.h
template <class T> void RegisterMembers_Variant(asIScriptEngine* engine, const char* className)
{
    // void Variant::FromString(const char* type, const char* value)
    // Error: type "const char*" can not automatically bind
    // void Variant::FromString(VariantType type, const char* value)
    // Error: type "const char*" can not automatically bind
    // const PODVector<unsigned char>& Variant::GetBuffer() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // PODVector<unsigned char>* Variant::GetBufferPtr()
    // Error: type "PODVector<unsigned char>*" can not automatically bind
    // CustomVariantValue* Variant::GetCustomVariantValuePtr()
    // Error: type "CustomVariantValue" can not automatically bind bacause have @nobind mark
    // const CustomVariantValue* Variant::GetCustomVariantValuePtr() const
    // Error: type "CustomVariantValue" can not automatically bind bacause have @nobind mark
    // StringVector* Variant::GetStringVectorPtr()
    // Error: type "StringVector*" can not automatically bind
    // VariantMap* Variant::GetVariantMapPtr()
    // Error: type "VariantMap*" can not automatically bind
    // const VariantVector& Variant::GetVariantVector() const
    // Error: type "const VariantVector&" can not automatically bind
    // VariantVector* Variant::GetVariantVectorPtr()
    // Error: type "VariantVector*" can not automatically bind
    // void* Variant::GetVoidPtr() const
    // Error: type "void*" can not automatically bind
    // bool Variant::operator !=(const Variant& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(int rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(unsigned rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(long long rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(unsigned long long rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(bool rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(float rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(double rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Vector2& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Vector3& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Vector4& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Quaternion& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const String& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const PODVector<unsigned char>& rhs) const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // bool Variant::operator !=(const VectorBuffer& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(void* rhs) const
    // Error: type "void*" can not automatically bind
    // bool Variant::operator !=(const ResourceRef& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const ResourceRefList& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const VariantVector& rhs) const
    // Error: type "const VariantVector&" can not automatically bind
    // bool Variant::operator !=(const StringVector& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const VariantMap& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Rect& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const IntRect& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const IntVector2& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const IntVector3& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const StringHash& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(RefCounted* rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Matrix3& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Matrix3x4& rhs) const
    // Only operator == is needed
    // bool Variant::operator !=(const Matrix4& rhs) const
    // Only operator == is needed
    // Variant& Variant::operator =(const char* rhs)
    // Error: type "const char*" can not automatically bind
    // Variant& Variant::operator =(const PODVector<unsigned char>& rhs)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // Variant& Variant::operator =(void* rhs)
    // Error: type "void*" can not automatically bind
    // Variant& Variant::operator =(const VariantVector& rhs)
    // Error: type "const VariantVector&" can not automatically bind
    // bool Variant::operator ==(const PODVector<unsigned char>& rhs) const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // bool Variant::operator ==(void* rhs) const
    // Error: type "void*" can not automatically bind
    // bool Variant::operator ==(const VariantVector& rhs) const
    // Error: type "const VariantVector&" can not automatically bind
    // void Variant::SetBuffer(const void* data, unsigned size)
    // Error: type "const void*" can not automatically bind
    // void Variant::SetCustomVariantValue(const CustomVariantValue& value)
    // Error: type "CustomVariantValue" can not automatically bind bacause have @nobind mark

    // void Variant::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void Variant::FromString(const String& type, const String& value)
    engine->RegisterObjectMethod(className, "void FromString(const String&in, const String&in)", AS_METHODPR(T, FromString, (const String&, const String&), void), AS_CALL_THISCALL);

    // void Variant::FromString(VariantType type, const String& value)
    engine->RegisterObjectMethod(className, "void FromString(VariantType, const String&in)", AS_METHODPR(T, FromString, (VariantType, const String&), void), AS_CALL_THISCALL);

    // bool Variant::GetBool() const
    engine->RegisterObjectMethod(className, "bool GetBool() const", AS_METHODPR(T, GetBool, () const, bool), AS_CALL_THISCALL);

    // const Color& Variant::GetColor() const
    engine->RegisterObjectMethod(className, "const Color& GetColor() const", AS_METHODPR(T, GetColor, () const, const Color&), AS_CALL_THISCALL);

    // double Variant::GetDouble() const
    engine->RegisterObjectMethod(className, "double GetDouble() const", AS_METHODPR(T, GetDouble, () const, double), AS_CALL_THISCALL);

    // float Variant::GetFloat() const
    engine->RegisterObjectMethod(className, "float GetFloat() const", AS_METHODPR(T, GetFloat, () const, float), AS_CALL_THISCALL);

    // int Variant::GetInt() const
    engine->RegisterObjectMethod(className, "int GetInt() const", AS_METHODPR(T, GetInt, () const, int), AS_CALL_THISCALL);

    // long long Variant::GetInt64() const
    engine->RegisterObjectMethod(className, "int64 GetInt64() const", AS_METHODPR(T, GetInt64, () const, long long), AS_CALL_THISCALL);

    // const IntRect& Variant::GetIntRect() const
    engine->RegisterObjectMethod(className, "const IntRect& GetIntRect() const", AS_METHODPR(T, GetIntRect, () const, const IntRect&), AS_CALL_THISCALL);

    // const IntVector2& Variant::GetIntVector2() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetIntVector2() const", AS_METHODPR(T, GetIntVector2, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector3& Variant::GetIntVector3() const
    engine->RegisterObjectMethod(className, "const IntVector3& GetIntVector3() const", AS_METHODPR(T, GetIntVector3, () const, const IntVector3&), AS_CALL_THISCALL);

    // const Matrix3& Variant::GetMatrix3() const
    engine->RegisterObjectMethod(className, "const Matrix3& GetMatrix3() const", AS_METHODPR(T, GetMatrix3, () const, const Matrix3&), AS_CALL_THISCALL);

    // const Matrix3x4& Variant::GetMatrix3x4() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetMatrix3x4() const", AS_METHODPR(T, GetMatrix3x4, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // const Matrix4& Variant::GetMatrix4() const
    engine->RegisterObjectMethod(className, "const Matrix4& GetMatrix4() const", AS_METHODPR(T, GetMatrix4, () const, const Matrix4&), AS_CALL_THISCALL);

    // RefCounted* Variant::GetPtr() const
    engine->RegisterObjectMethod(className, "RefCounted@+ GetPtr() const", AS_METHODPR(T, GetPtr, () const, RefCounted*), AS_CALL_THISCALL);

    // const Quaternion& Variant::GetQuaternion() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetQuaternion() const", AS_METHODPR(T, GetQuaternion, () const, const Quaternion&), AS_CALL_THISCALL);

    // const Rect& Variant::GetRect() const
    engine->RegisterObjectMethod(className, "const Rect& GetRect() const", AS_METHODPR(T, GetRect, () const, const Rect&), AS_CALL_THISCALL);

    // const ResourceRef& Variant::GetResourceRef() const
    engine->RegisterObjectMethod(className, "const ResourceRef& GetResourceRef() const", AS_METHODPR(T, GetResourceRef, () const, const ResourceRef&), AS_CALL_THISCALL);

    // const ResourceRefList& Variant::GetResourceRefList() const
    engine->RegisterObjectMethod(className, "const ResourceRefList& GetResourceRefList() const", AS_METHODPR(T, GetResourceRefList, () const, const ResourceRefList&), AS_CALL_THISCALL);

    // const String& Variant::GetString() const
    engine->RegisterObjectMethod(className, "const String& GetString() const", AS_METHODPR(T, GetString, () const, const String&), AS_CALL_THISCALL);

    // StringHash Variant::GetStringHash() const
    engine->RegisterObjectMethod(className, "StringHash GetStringHash() const", AS_METHODPR(T, GetStringHash, () const, StringHash), AS_CALL_THISCALL);

    // const StringVector& Variant::GetStringVector() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetStringVector() const", AS_FUNCTION_OBJFIRST(Variant_constspStringVectoramp_GetStringVector_void_template<Variant>), AS_CALL_CDECL_OBJFIRST);

    // VariantType Variant::GetType() const
    engine->RegisterObjectMethod(className, "VariantType GetType() const", AS_METHODPR(T, GetType, () const, VariantType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "VariantType get_type() const", AS_METHODPR(T, GetType, () const, VariantType), AS_CALL_THISCALL);

    // String Variant::GetTypeName() const
    engine->RegisterObjectMethod(className, "String GetTypeName() const", AS_METHODPR(T, GetTypeName, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_typeName() const", AS_METHODPR(T, GetTypeName, () const, String), AS_CALL_THISCALL);

    // unsigned Variant::GetUInt() const
    engine->RegisterObjectMethod(className, "uint GetUInt() const", AS_METHODPR(T, GetUInt, () const, unsigned), AS_CALL_THISCALL);

    // unsigned long long Variant::GetUInt64() const
    engine->RegisterObjectMethod(className, "uint64 GetUInt64() const", AS_METHODPR(T, GetUInt64, () const, unsigned long long), AS_CALL_THISCALL);

    // const VariantMap& Variant::GetVariantMap() const
    engine->RegisterObjectMethod(className, "const VariantMap& GetVariantMap() const", AS_METHODPR(T, GetVariantMap, () const, const VariantMap&), AS_CALL_THISCALL);

    // const Vector2& Variant::GetVector2() const
    engine->RegisterObjectMethod(className, "const Vector2& GetVector2() const", AS_METHODPR(T, GetVector2, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector3& Variant::GetVector3() const
    engine->RegisterObjectMethod(className, "const Vector3& GetVector3() const", AS_METHODPR(T, GetVector3, () const, const Vector3&), AS_CALL_THISCALL);

    // const Vector4& Variant::GetVector4() const
    engine->RegisterObjectMethod(className, "const Vector4& GetVector4() const", AS_METHODPR(T, GetVector4, () const, const Vector4&), AS_CALL_THISCALL);

    // VectorBuffer Variant::GetVectorBuffer() const
    engine->RegisterObjectMethod(className, "VectorBuffer GetVectorBuffer() const", AS_METHODPR(T, GetVectorBuffer, () const, VectorBuffer), AS_CALL_THISCALL);

    // bool Variant::IsCustom() const
    engine->RegisterObjectMethod(className, "bool IsCustom() const", AS_METHODPR(T, IsCustom, () const, bool), AS_CALL_THISCALL);

    // bool Variant::IsEmpty() const
    engine->RegisterObjectMethod(className, "bool IsEmpty() const", AS_METHODPR(T, IsEmpty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_empty() const", AS_METHODPR(T, IsEmpty, () const, bool), AS_CALL_THISCALL);

    // bool Variant::IsZero() const
    engine->RegisterObjectMethod(className, "bool IsZero() const", AS_METHODPR(T, IsZero, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_zero() const", AS_METHODPR(T, IsZero, () const, bool), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Variant& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Variant&in)", AS_METHODPR(T, operator=, (const Variant&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(int rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(int)", AS_METHODPR(T, operator=, (int), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(long long rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(int64)", AS_METHODPR(T, operator=, (long long), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(unsigned long long rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(uint64)", AS_METHODPR(T, operator=, (unsigned long long), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(unsigned rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(uint)", AS_METHODPR(T, operator=, (unsigned), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const StringHash& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const StringHash&in)", AS_METHODPR(T, operator=, (const StringHash&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(bool rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(bool)", AS_METHODPR(T, operator=, (bool), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(float rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(float)", AS_METHODPR(T, operator=, (float), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(double rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(double)", AS_METHODPR(T, operator=, (double), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Vector2& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Vector2&in)", AS_METHODPR(T, operator=, (const Vector2&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Vector3& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Vector3&in)", AS_METHODPR(T, operator=, (const Vector3&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Vector4& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Vector4&in)", AS_METHODPR(T, operator=, (const Vector4&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Quaternion& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Quaternion&in)", AS_METHODPR(T, operator=, (const Quaternion&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Color& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Color&in)", AS_METHODPR(T, operator=, (const Color&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const String& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const String&in)", AS_METHODPR(T, operator=, (const String&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const VectorBuffer& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const VectorBuffer&in)", AS_METHODPR(T, operator=, (const VectorBuffer&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const ResourceRef& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const ResourceRef&in)", AS_METHODPR(T, operator=, (const ResourceRef&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const ResourceRefList& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const ResourceRefList&in)", AS_METHODPR(T, operator=, (const ResourceRefList&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const StringVector& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(Array<String>@+)", AS_FUNCTION_OBJFIRST(Variant_Variantamp_operatoreq_constspStringVectoramp_template<Variant>), AS_CALL_CDECL_OBJFIRST);

    // Variant& Variant::operator =(const VariantMap& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const VariantMap&in)", AS_METHODPR(T, operator=, (const VariantMap&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Rect& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Rect&in)", AS_METHODPR(T, operator=, (const Rect&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const IntRect& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const IntRect&in)", AS_METHODPR(T, operator=, (const IntRect&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const IntVector2& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const IntVector2&in)", AS_METHODPR(T, operator=, (const IntVector2&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const IntVector3& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const IntVector3&in)", AS_METHODPR(T, operator=, (const IntVector3&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(RefCounted* rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(RefCounted@+)", AS_METHODPR(T, operator=, (RefCounted*), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Matrix3& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Matrix3&in)", AS_METHODPR(T, operator=, (const Matrix3&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Matrix3x4& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Matrix3x4&in)", AS_METHODPR(T, operator=, (const Matrix3x4&), Variant&), AS_CALL_THISCALL);

    // Variant& Variant::operator =(const Matrix4& rhs)
    engine->RegisterObjectMethod(className, "Variant& opAssign(const Matrix4&in)", AS_METHODPR(T, operator=, (const Matrix4&), Variant&), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Variant& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Variant&in) const", AS_METHODPR(T, operator==, (const Variant&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(int rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(int) const", AS_METHODPR(T, operator==, (int) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(unsigned rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(uint) const", AS_METHODPR(T, operator==, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(long long rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(int64) const", AS_METHODPR(T, operator==, (long long) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(unsigned long long rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(uint64) const", AS_METHODPR(T, operator==, (unsigned long long) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(bool rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(bool) const", AS_METHODPR(T, operator==, (bool) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(float rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(float) const", AS_METHODPR(T, operator==, (float) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(double rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(double) const", AS_METHODPR(T, operator==, (double) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Vector2&in) const", AS_METHODPR(T, operator==, (const Vector2&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Vector3&in) const", AS_METHODPR(T, operator==, (const Vector3&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Vector4&in) const", AS_METHODPR(T, operator==, (const Vector4&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Quaternion& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Quaternion&in) const", AS_METHODPR(T, operator==, (const Quaternion&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Color& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Color&in) const", AS_METHODPR(T, operator==, (const Color&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const String& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const String&in) const", AS_METHODPR(T, operator==, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const VectorBuffer& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const VectorBuffer&in) const", AS_METHODPR(T, operator==, (const VectorBuffer&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const ResourceRef& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const ResourceRef&in) const", AS_METHODPR(T, operator==, (const ResourceRef&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const ResourceRefList& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const ResourceRefList&in) const", AS_METHODPR(T, operator==, (const ResourceRefList&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const StringVector& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(Array<String>@+) const", AS_FUNCTION_OBJFIRST(Variant_bool_operatoreqeq_constspStringVectoramp_template<Variant>), AS_CALL_CDECL_OBJFIRST);

    // bool Variant::operator ==(const VariantMap& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const VariantMap&in) const", AS_METHODPR(T, operator==, (const VariantMap&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Rect& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Rect&in) const", AS_METHODPR(T, operator==, (const Rect&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const IntRect& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const IntRect&in) const", AS_METHODPR(T, operator==, (const IntRect&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const IntVector2& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const IntVector2&in) const", AS_METHODPR(T, operator==, (const IntVector2&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const IntVector3& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const IntVector3&in) const", AS_METHODPR(T, operator==, (const IntVector3&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const StringHash& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const StringHash&in) const", AS_METHODPR(T, operator==, (const StringHash&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(RefCounted* rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(RefCounted@+) const", AS_METHODPR(T, operator==, (RefCounted*) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Matrix3& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix3&in) const", AS_METHODPR(T, operator==, (const Matrix3&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Matrix3x4& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix3x4&in) const", AS_METHODPR(T, operator==, (const Matrix3x4&) const, bool), AS_CALL_THISCALL);

    // bool Variant::operator ==(const Matrix4& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Matrix4&in) const", AS_METHODPR(T, operator==, (const Matrix4&) const, bool), AS_CALL_THISCALL);

    // String Variant::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // template <class T> T Variant::Get() const
    // Not registered because template
    // template <> int Variant::Get() const
    // Not registered because template
    // template <> unsigned Variant::Get() const
    // Not registered because template
    // template <> long long Variant::Get() const
    // Not registered because template
    // template <> unsigned long long Variant::Get() const
    // Not registered because template
    // template <> StringHash Variant::Get() const
    // Not registered because template
    // template <> bool Variant::Get() const
    // Not registered because template
    // template <> float Variant::Get() const
    // Not registered because template
    // template <> double Variant::Get() const
    // Not registered because template
    // template <> const Vector2& Variant::Get() const
    // Not registered because template
    // template <> const Vector3& Variant::Get() const
    // Not registered because template
    // template <> const Vector4& Variant::Get() const
    // Not registered because template
    // template <> const Quaternion& Variant::Get() const
    // Not registered because template
    // template <> const Color& Variant::Get() const
    // Not registered because template
    // template <> const String& Variant::Get() const
    // Not registered because template
    // template <> const Rect& Variant::Get() const
    // Not registered because template
    // template <> const IntRect& Variant::Get() const
    // Not registered because template
    // template <> const IntVector2& Variant::Get() const
    // Not registered because template
    // template <> const IntVector3& Variant::Get() const
    // Not registered because template
    // template <> const PODVector<unsigned char>& Variant::Get() const
    // Not registered because template
    // template <> void* Variant::Get() const
    // Not registered because template
    // template <> RefCounted* Variant::Get() const
    // Not registered because template
    // template <> const Matrix3& Variant::Get() const
    // Not registered because template
    // template <> const Matrix3x4& Variant::Get() const
    // Not registered because template
    // template <> const Matrix4& Variant::Get() const
    // Not registered because template
    // template <> ResourceRef Variant::Get() const
    // Not registered because template
    // template <> ResourceRefList Variant::Get() const
    // Not registered because template
    // template <> VariantVector Variant::Get() const
    // Not registered because template
    // template <> StringVector Variant::Get() const
    // Not registered because template
    // template <> VariantMap Variant::Get() const
    // Not registered because template
    // template <> Vector2 Variant::Get() const
    // Not registered because template
    // template <> Vector3 Variant::Get() const
    // Not registered because template
    // template <> Vector4 Variant::Get() const
    // Not registered because template
    // template <> Quaternion Variant::Get() const
    // Not registered because template
    // template <> Color Variant::Get() const
    // Not registered because template
    // template <> String Variant::Get() const
    // Not registered because template
    // template <> Rect Variant::Get() const
    // Not registered because template
    // template <> IntRect Variant::Get() const
    // Not registered because template
    // template <> IntVector2 Variant::Get() const
    // Not registered because template
    // template <> IntVector3 Variant::Get() const
    // Not registered because template
    // template <> PODVector<unsigned char> Variant::Get() const
    // Not registered because template
    // template <> Matrix3 Variant::Get() const
    // Not registered because template
    // template <> Matrix3x4 Variant::Get() const
    // Not registered because template
    // template <> Matrix4 Variant::Get() const
    // Not registered because template
    // template <class T> T Variant::GetCustom() const
    // Not registered because template
    // template <class T> T* Variant::GetCustomPtr()
    // Not registered because template
    // template <class T> bool Variant::IsCustomType() const
    // Not registered because template
    // template <class T> Variant& Variant::operator =(const CustomVariantValueImpl<T>& value)
    // Not registered because template
    // template <class T> void Variant::SetCustom(const T& value)
    // Not registered because template
    // static VariantType Variant::GetTypeFromName(const char* typeName)
    // Error: type "const char*" can not automatically bind

    // static String Variant::GetTypeName(VariantType type)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("String GetTypeName(VariantType)", AS_FUNCTIONPR(T::GetTypeName, (VariantType), String), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static VariantType Variant::GetTypeFromName(const String& typeName)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("VariantType GetTypeFromName(const String&in)", AS_FUNCTIONPR(T::GetTypeFromName, (const String&), VariantType), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static const PODVector<unsigned char> Variant::emptyBuffer
    // Error: type "const PODVector<unsigned char>" can not automatically bind
    // static const VariantVector Variant::emptyVariantVector
    // Error: type "const VariantVector" can not automatically bind
    // static const StringVector Variant::emptyStringVector
    // Error: type "const StringVector" can not automatically bind

    // static const Variant Variant::EMPTY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Variant EMPTY", (void*)&T::EMPTY);engine->SetDefaultNamespace("");

    // static const ResourceRef Variant::emptyResourceRef
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const ResourceRef emptyResourceRef", (void*)&T::emptyResourceRef);engine->SetDefaultNamespace("");

    // static const ResourceRefList Variant::emptyResourceRefList
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const ResourceRefList emptyResourceRefList", (void*)&T::emptyResourceRefList);engine->SetDefaultNamespace("");

    // static const VariantMap Variant::emptyVariantMap
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const VariantMap emptyVariantMap", (void*)&T::emptyVariantMap);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Variant
        REGISTER_MEMBERS_MANUAL_PART_Variant();
    #endif
}

// class Vector2 | File: ../Math/Vector2.h
template <class T> void RegisterMembers_Vector2(asIScriptEngine* engine, const char* className)
{
    // const float* Vector2::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Vector2::operator !=(const Vector2& rhs) const
    // Only operator == is needed

    // Vector2 Vector2::Abs() const
    engine->RegisterObjectMethod(className, "Vector2 Abs() const", AS_METHODPR(T, Abs, () const, Vector2), AS_CALL_THISCALL);

    // float Vector2::AbsDotProduct(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "float AbsDotProduct(const Vector2&in) const", AS_METHODPR(T, AbsDotProduct, (const Vector2&) const, float), AS_CALL_THISCALL);

    // float Vector2::Angle(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "float Angle(const Vector2&in) const", AS_METHODPR(T, Angle, (const Vector2&) const, float), AS_CALL_THISCALL);

    // float Vector2::DotProduct(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "float DotProduct(const Vector2&in) const", AS_METHODPR(T, DotProduct, (const Vector2&) const, float), AS_CALL_THISCALL);

    // bool Vector2::Equals(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Vector2&in) const", AS_METHODPR(T, Equals, (const Vector2&) const, bool), AS_CALL_THISCALL);

    // bool Vector2::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Vector2::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // float Vector2::Length() const
    engine->RegisterObjectMethod(className, "float Length() const", AS_METHODPR(T, Length, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, Length, () const, float), AS_CALL_THISCALL);

    // float Vector2::LengthSquared() const
    engine->RegisterObjectMethod(className, "float LengthSquared() const", AS_METHODPR(T, LengthSquared, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lengthSquared() const", AS_METHODPR(T, LengthSquared, () const, float), AS_CALL_THISCALL);

    // Vector2 Vector2::Lerp(const Vector2& rhs, float t) const
    engine->RegisterObjectMethod(className, "Vector2 Lerp(const Vector2&in, float) const", AS_METHODPR(T, Lerp, (const Vector2&, float) const, Vector2), AS_CALL_THISCALL);

    // void Vector2::Normalize()
    engine->RegisterObjectMethod(className, "void Normalize()", AS_METHODPR(T, Normalize, (), void), AS_CALL_THISCALL);

    // Vector2 Vector2::Normalized() const
    engine->RegisterObjectMethod(className, "Vector2 Normalized() const", AS_METHODPR(T, Normalized, () const, Vector2), AS_CALL_THISCALL);

    // Vector2 Vector2::NormalizedOrDefault(const Vector2& defaultValue = Vector2::ZERO, float eps = M_LARGE_EPSILON) const
    engine->RegisterObjectMethod(className, "Vector2 NormalizedOrDefault(const Vector2&in = Vector2::ZERO, float = M_LARGE_EPSILON) const", AS_METHODPR(T, NormalizedOrDefault, (const Vector2&, float) const, Vector2), AS_CALL_THISCALL);

    // Vector2 Vector2::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Vector2), AS_CALL_THISCALL);

    // Vector2 Vector2::operator *(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opMul(const Vector2&in) const", AS_METHODPR(T, operator*, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // Vector2& Vector2::operator *=(float rhs)
    engine->RegisterObjectMethod(className, "Vector2& opMulAssign(float)", AS_METHODPR(T, operator*=, (float), Vector2&), AS_CALL_THISCALL);

    // Vector2& Vector2::operator *=(const Vector2& rhs)
    engine->RegisterObjectMethod(className, "Vector2& opMulAssign(const Vector2&in)", AS_METHODPR(T, operator*=, (const Vector2&), Vector2&), AS_CALL_THISCALL);

    // Vector2 Vector2::operator +(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opAdd(const Vector2&in) const", AS_METHODPR(T, operator+, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // Vector2& Vector2::operator +=(const Vector2& rhs)
    engine->RegisterObjectMethod(className, "Vector2& opAddAssign(const Vector2&in)", AS_METHODPR(T, operator+=, (const Vector2&), Vector2&), AS_CALL_THISCALL);

    // Vector2 Vector2::operator -() const
    engine->RegisterObjectMethod(className, "Vector2 opNeg() const", AS_METHODPR(T, operator-, () const, Vector2), AS_CALL_THISCALL);

    // Vector2 Vector2::operator -(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opSub(const Vector2&in) const", AS_METHODPR(T, operator-, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // Vector2& Vector2::operator -=(const Vector2& rhs)
    engine->RegisterObjectMethod(className, "Vector2& opSubAssign(const Vector2&in)", AS_METHODPR(T, operator-=, (const Vector2&), Vector2&), AS_CALL_THISCALL);

    // Vector2 Vector2::operator /(float rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opDiv(float) const", AS_METHODPR(T, operator/, (float) const, Vector2), AS_CALL_THISCALL);

    // Vector2 Vector2::operator /(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "Vector2 opDiv(const Vector2&in) const", AS_METHODPR(T, operator/, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // Vector2& Vector2::operator /=(float rhs)
    engine->RegisterObjectMethod(className, "Vector2& opDivAssign(float)", AS_METHODPR(T, operator/=, (float), Vector2&), AS_CALL_THISCALL);

    // Vector2& Vector2::operator /=(const Vector2& rhs)
    engine->RegisterObjectMethod(className, "Vector2& opDivAssign(const Vector2&in)", AS_METHODPR(T, operator/=, (const Vector2&), Vector2&), AS_CALL_THISCALL);

    // Vector2& Vector2::operator =(const Vector2& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Vector2& opAssign(const Vector2&in)", AS_METHODPR(T, operator=, (const Vector2&), Vector2&), AS_CALL_THISCALL);

    // bool Vector2::operator ==(const Vector2& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Vector2&in) const", AS_METHODPR(T, operator==, (const Vector2&) const, bool), AS_CALL_THISCALL);

    // float Vector2::ProjectOntoAxis(const Vector2& axis) const
    engine->RegisterObjectMethod(className, "float ProjectOntoAxis(const Vector2&in) const", AS_METHODPR(T, ProjectOntoAxis, (const Vector2&) const, float), AS_CALL_THISCALL);

    // Vector2 Vector2::ReNormalized(float minLength, float maxLength, const Vector2& defaultValue = Vector2::ZERO, float eps = M_LARGE_EPSILON) const
    engine->RegisterObjectMethod(className, "Vector2 ReNormalized(float, float, const Vector2&in = Vector2::ZERO, float = M_LARGE_EPSILON) const", AS_METHODPR(T, ReNormalized, (float, float, const Vector2&, float) const, Vector2), AS_CALL_THISCALL);

    // String Vector2::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // float Vector2::x_
    engine->RegisterObjectProperty(className, "float x", offsetof(T, x_));

    // float Vector2::y_
    engine->RegisterObjectProperty(className, "float y", offsetof(T, y_));

    // static const Vector2 Vector2::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector2 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Vector2 Vector2::LEFT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector2 LEFT", (void*)&T::LEFT);engine->SetDefaultNamespace("");

    // static const Vector2 Vector2::RIGHT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector2 RIGHT", (void*)&T::RIGHT);engine->SetDefaultNamespace("");

    // static const Vector2 Vector2::UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector2 UP", (void*)&T::UP);engine->SetDefaultNamespace("");

    // static const Vector2 Vector2::DOWN
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector2 DOWN", (void*)&T::DOWN);engine->SetDefaultNamespace("");

    // static const Vector2 Vector2::ONE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector2 ONE", (void*)&T::ONE);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Vector2
        REGISTER_MEMBERS_MANUAL_PART_Vector2();
    #endif
}

// class Vector3 | File: ../Math/Vector3.h
template <class T> void RegisterMembers_Vector3(asIScriptEngine* engine, const char* className)
{
    // const float* Vector3::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Vector3::operator !=(const Vector3& rhs) const
    // Only operator == is needed

    // Vector3 Vector3::Abs() const
    engine->RegisterObjectMethod(className, "Vector3 Abs() const", AS_METHODPR(T, Abs, () const, Vector3), AS_CALL_THISCALL);

    // float Vector3::AbsDotProduct(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "float AbsDotProduct(const Vector3&in) const", AS_METHODPR(T, AbsDotProduct, (const Vector3&) const, float), AS_CALL_THISCALL);

    // float Vector3::Angle(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "float Angle(const Vector3&in) const", AS_METHODPR(T, Angle, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Vector3 Vector3::CrossProduct(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 CrossProduct(const Vector3&in) const", AS_METHODPR(T, CrossProduct, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // float Vector3::DistanceToPlane(const Vector3& origin, const Vector3& normal) const
    engine->RegisterObjectMethod(className, "float DistanceToPlane(const Vector3&in, const Vector3&in) const", AS_METHODPR(T, DistanceToPlane, (const Vector3&, const Vector3&) const, float), AS_CALL_THISCALL);

    // float Vector3::DistanceToPoint(const Vector3& point) const
    engine->RegisterObjectMethod(className, "float DistanceToPoint(const Vector3&in) const", AS_METHODPR(T, DistanceToPoint, (const Vector3&) const, float), AS_CALL_THISCALL);

    // float Vector3::DotProduct(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "float DotProduct(const Vector3&in) const", AS_METHODPR(T, DotProduct, (const Vector3&) const, float), AS_CALL_THISCALL);

    // bool Vector3::Equals(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Vector3&in) const", AS_METHODPR(T, Equals, (const Vector3&) const, bool), AS_CALL_THISCALL);

    // bool Vector3::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Vector3::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // float Vector3::Length() const
    engine->RegisterObjectMethod(className, "float Length() const", AS_METHODPR(T, Length, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, Length, () const, float), AS_CALL_THISCALL);

    // float Vector3::LengthSquared() const
    engine->RegisterObjectMethod(className, "float LengthSquared() const", AS_METHODPR(T, LengthSquared, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lengthSquared() const", AS_METHODPR(T, LengthSquared, () const, float), AS_CALL_THISCALL);

    // Vector3 Vector3::Lerp(const Vector3& rhs, float t) const
    engine->RegisterObjectMethod(className, "Vector3 Lerp(const Vector3&in, float) const", AS_METHODPR(T, Lerp, (const Vector3&, float) const, Vector3), AS_CALL_THISCALL);

    // void Vector3::Normalize()
    engine->RegisterObjectMethod(className, "void Normalize()", AS_METHODPR(T, Normalize, (), void), AS_CALL_THISCALL);

    // Vector3 Vector3::Normalized() const
    engine->RegisterObjectMethod(className, "Vector3 Normalized() const", AS_METHODPR(T, Normalized, () const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::NormalizedOrDefault(const Vector3& defaultValue = Vector3::ZERO, float eps = M_LARGE_EPSILON) const
    engine->RegisterObjectMethod(className, "Vector3 NormalizedOrDefault(const Vector3&in = Vector3::ZERO, float = M_LARGE_EPSILON) const", AS_METHODPR(T, NormalizedOrDefault, (const Vector3&, float) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::operator *(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opMul(const Vector3&in) const", AS_METHODPR(T, operator*, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3& Vector3::operator *=(float rhs)
    engine->RegisterObjectMethod(className, "Vector3& opMulAssign(float)", AS_METHODPR(T, operator*=, (float), Vector3&), AS_CALL_THISCALL);

    // Vector3& Vector3::operator *=(const Vector3& rhs)
    engine->RegisterObjectMethod(className, "Vector3& opMulAssign(const Vector3&in)", AS_METHODPR(T, operator*=, (const Vector3&), Vector3&), AS_CALL_THISCALL);

    // Vector3 Vector3::operator +(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opAdd(const Vector3&in) const", AS_METHODPR(T, operator+, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3& Vector3::operator +=(const Vector3& rhs)
    engine->RegisterObjectMethod(className, "Vector3& opAddAssign(const Vector3&in)", AS_METHODPR(T, operator+=, (const Vector3&), Vector3&), AS_CALL_THISCALL);

    // Vector3 Vector3::operator -() const
    engine->RegisterObjectMethod(className, "Vector3 opNeg() const", AS_METHODPR(T, operator-, () const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::operator -(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opSub(const Vector3&in) const", AS_METHODPR(T, operator-, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3& Vector3::operator -=(const Vector3& rhs)
    engine->RegisterObjectMethod(className, "Vector3& opSubAssign(const Vector3&in)", AS_METHODPR(T, operator-=, (const Vector3&), Vector3&), AS_CALL_THISCALL);

    // Vector3 Vector3::operator /(float rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opDiv(float) const", AS_METHODPR(T, operator/, (float) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::operator /(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "Vector3 opDiv(const Vector3&in) const", AS_METHODPR(T, operator/, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3& Vector3::operator /=(float rhs)
    engine->RegisterObjectMethod(className, "Vector3& opDivAssign(float)", AS_METHODPR(T, operator/=, (float), Vector3&), AS_CALL_THISCALL);

    // Vector3& Vector3::operator /=(const Vector3& rhs)
    engine->RegisterObjectMethod(className, "Vector3& opDivAssign(const Vector3&in)", AS_METHODPR(T, operator/=, (const Vector3&), Vector3&), AS_CALL_THISCALL);

    // Vector3& Vector3::operator =(const Vector3& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Vector3& opAssign(const Vector3&in)", AS_METHODPR(T, operator=, (const Vector3&), Vector3&), AS_CALL_THISCALL);

    // bool Vector3::operator ==(const Vector3& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Vector3&in) const", AS_METHODPR(T, operator==, (const Vector3&) const, bool), AS_CALL_THISCALL);

    // Vector3 Vector3::Orthogonalize(const Vector3& axis) const
    engine->RegisterObjectMethod(className, "Vector3 Orthogonalize(const Vector3&in) const", AS_METHODPR(T, Orthogonalize, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // float Vector3::ProjectOntoAxis(const Vector3& axis) const
    engine->RegisterObjectMethod(className, "float ProjectOntoAxis(const Vector3&in) const", AS_METHODPR(T, ProjectOntoAxis, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Vector3 Vector3::ProjectOntoLine(const Vector3& from, const Vector3& to, bool clamped = false) const
    engine->RegisterObjectMethod(className, "Vector3 ProjectOntoLine(const Vector3&in, const Vector3&in, bool = false) const", AS_METHODPR(T, ProjectOntoLine, (const Vector3&, const Vector3&, bool) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::ProjectOntoPlane(const Vector3& origin, const Vector3& normal) const
    engine->RegisterObjectMethod(className, "Vector3 ProjectOntoPlane(const Vector3&in, const Vector3&in) const", AS_METHODPR(T, ProjectOntoPlane, (const Vector3&, const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Vector3::ReNormalized(float minLength, float maxLength, const Vector3& defaultValue = Vector3::ZERO, float eps = M_LARGE_EPSILON) const
    engine->RegisterObjectMethod(className, "Vector3 ReNormalized(float, float, const Vector3&in = Vector3::ZERO, float = M_LARGE_EPSILON) const", AS_METHODPR(T, ReNormalized, (float, float, const Vector3&, float) const, Vector3), AS_CALL_THISCALL);

    // unsigned Vector3::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // String Vector3::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // float Vector3::x_
    engine->RegisterObjectProperty(className, "float x", offsetof(T, x_));

    // float Vector3::y_
    engine->RegisterObjectProperty(className, "float y", offsetof(T, y_));

    // float Vector3::z_
    engine->RegisterObjectProperty(className, "float z", offsetof(T, z_));

    // static const Vector3 Vector3::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::LEFT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 LEFT", (void*)&T::LEFT);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::RIGHT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 RIGHT", (void*)&T::RIGHT);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 UP", (void*)&T::UP);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::DOWN
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 DOWN", (void*)&T::DOWN);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::FORWARD
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 FORWARD", (void*)&T::FORWARD);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::BACK
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 BACK", (void*)&T::BACK);engine->SetDefaultNamespace("");

    // static const Vector3 Vector3::ONE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector3 ONE", (void*)&T::ONE);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Vector3
        REGISTER_MEMBERS_MANUAL_PART_Vector3();
    #endif
}

// class Vector4 | File: ../Math/Vector4.h
template <class T> void RegisterMembers_Vector4(asIScriptEngine* engine, const char* className)
{
    // const float* Vector4::Data() const
    // Error: type "const float*" can not automatically bind
    // bool Vector4::operator !=(const Vector4& rhs) const
    // Only operator == is needed

    // Vector4 Vector4::Abs() const
    engine->RegisterObjectMethod(className, "Vector4 Abs() const", AS_METHODPR(T, Abs, () const, Vector4), AS_CALL_THISCALL);

    // float Vector4::AbsDotProduct(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "float AbsDotProduct(const Vector4&in) const", AS_METHODPR(T, AbsDotProduct, (const Vector4&) const, float), AS_CALL_THISCALL);

    // float Vector4::DotProduct(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "float DotProduct(const Vector4&in) const", AS_METHODPR(T, DotProduct, (const Vector4&) const, float), AS_CALL_THISCALL);

    // bool Vector4::Equals(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "bool Equals(const Vector4&in) const", AS_METHODPR(T, Equals, (const Vector4&) const, bool), AS_CALL_THISCALL);

    // bool Vector4::IsInf() const
    engine->RegisterObjectMethod(className, "bool IsInf() const", AS_METHODPR(T, IsInf, () const, bool), AS_CALL_THISCALL);

    // bool Vector4::IsNaN() const
    engine->RegisterObjectMethod(className, "bool IsNaN() const", AS_METHODPR(T, IsNaN, () const, bool), AS_CALL_THISCALL);

    // Vector4 Vector4::Lerp(const Vector4& rhs, float t) const
    engine->RegisterObjectMethod(className, "Vector4 Lerp(const Vector4&in, float) const", AS_METHODPR(T, Lerp, (const Vector4&, float) const, Vector4), AS_CALL_THISCALL);

    // explicit Vector4::operator Vector2() const
    engine->RegisterObjectMethod(className, "Vector2 opConv() const", AS_METHODPR(T, operator Vector2, () const, Vector2), AS_CALL_THISCALL);

    // explicit Vector4::operator Vector3() const
    engine->RegisterObjectMethod(className, "Vector3 opConv() const", AS_METHODPR(T, operator Vector3, () const, Vector3), AS_CALL_THISCALL);

    // Vector4 Vector4::operator *(float rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opMul(float) const", AS_METHODPR(T, operator*, (float) const, Vector4), AS_CALL_THISCALL);

    // Vector4 Vector4::operator *(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opMul(const Vector4&in) const", AS_METHODPR(T, operator*, (const Vector4&) const, Vector4), AS_CALL_THISCALL);

    // Vector4& Vector4::operator *=(float rhs)
    engine->RegisterObjectMethod(className, "Vector4& opMulAssign(float)", AS_METHODPR(T, operator*=, (float), Vector4&), AS_CALL_THISCALL);

    // Vector4& Vector4::operator *=(const Vector4& rhs)
    engine->RegisterObjectMethod(className, "Vector4& opMulAssign(const Vector4&in)", AS_METHODPR(T, operator*=, (const Vector4&), Vector4&), AS_CALL_THISCALL);

    // Vector4 Vector4::operator +(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opAdd(const Vector4&in) const", AS_METHODPR(T, operator+, (const Vector4&) const, Vector4), AS_CALL_THISCALL);

    // Vector4& Vector4::operator +=(const Vector4& rhs)
    engine->RegisterObjectMethod(className, "Vector4& opAddAssign(const Vector4&in)", AS_METHODPR(T, operator+=, (const Vector4&), Vector4&), AS_CALL_THISCALL);

    // Vector4 Vector4::operator -() const
    engine->RegisterObjectMethod(className, "Vector4 opNeg() const", AS_METHODPR(T, operator-, () const, Vector4), AS_CALL_THISCALL);

    // Vector4 Vector4::operator -(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opSub(const Vector4&in) const", AS_METHODPR(T, operator-, (const Vector4&) const, Vector4), AS_CALL_THISCALL);

    // Vector4& Vector4::operator -=(const Vector4& rhs)
    engine->RegisterObjectMethod(className, "Vector4& opSubAssign(const Vector4&in)", AS_METHODPR(T, operator-=, (const Vector4&), Vector4&), AS_CALL_THISCALL);

    // Vector4 Vector4::operator /(float rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opDiv(float) const", AS_METHODPR(T, operator/, (float) const, Vector4), AS_CALL_THISCALL);

    // Vector4 Vector4::operator /(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "Vector4 opDiv(const Vector4&in) const", AS_METHODPR(T, operator/, (const Vector4&) const, Vector4), AS_CALL_THISCALL);

    // Vector4& Vector4::operator /=(float rhs)
    engine->RegisterObjectMethod(className, "Vector4& opDivAssign(float)", AS_METHODPR(T, operator/=, (float), Vector4&), AS_CALL_THISCALL);

    // Vector4& Vector4::operator /=(const Vector4& rhs)
    engine->RegisterObjectMethod(className, "Vector4& opDivAssign(const Vector4&in)", AS_METHODPR(T, operator/=, (const Vector4&), Vector4&), AS_CALL_THISCALL);

    // Vector4& Vector4::operator =(const Vector4& rhs) noexcept = default
    engine->RegisterObjectMethod(className, "Vector4& opAssign(const Vector4&in)", AS_METHODPR(T, operator=, (const Vector4&), Vector4&), AS_CALL_THISCALL);

    // bool Vector4::operator ==(const Vector4& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const Vector4&in) const", AS_METHODPR(T, operator==, (const Vector4&) const, bool), AS_CALL_THISCALL);

    // float Vector4::operator [](unsigned index) const
    engine->RegisterObjectMethod(className, "float opIndex(uint) const", AS_METHODPR(T, operator[], (unsigned) const, float), AS_CALL_THISCALL);

    // float& Vector4::operator [](unsigned index)
    engine->RegisterObjectMethod(className, "float& opIndex(uint)", AS_METHODPR(T, operator[], (unsigned), float&), AS_CALL_THISCALL);

    // float Vector4::ProjectOntoAxis(const Vector3& axis) const
    engine->RegisterObjectMethod(className, "float ProjectOntoAxis(const Vector3&in) const", AS_METHODPR(T, ProjectOntoAxis, (const Vector3&) const, float), AS_CALL_THISCALL);

    // unsigned Vector4::ToHash() const
    engine->RegisterObjectMethod(className, "uint ToHash() const", AS_METHODPR(T, ToHash, () const, unsigned), AS_CALL_THISCALL);

    // String Vector4::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // float Vector4::x_
    engine->RegisterObjectProperty(className, "float x", offsetof(T, x_));

    // float Vector4::y_
    engine->RegisterObjectProperty(className, "float y", offsetof(T, y_));

    // float Vector4::z_
    engine->RegisterObjectProperty(className, "float z", offsetof(T, z_));

    // float Vector4::w_
    engine->RegisterObjectProperty(className, "float w", offsetof(T, w_));

    // static const Vector4 Vector4::ZERO
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector4 ZERO", (void*)&T::ZERO);engine->SetDefaultNamespace("");

    // static const Vector4 Vector4::ONE
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const Vector4 ONE", (void*)&T::ONE);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Vector4
        REGISTER_MEMBERS_MANUAL_PART_Vector4();
    #endif
}

// class VectorBase | File: ../Container/VectorBase.h
template <class T> void RegisterMembers_VectorBase(asIScriptEngine* engine, const char* className)
{
    // void VectorBase::Swap(VectorBase& rhs)
    engine->RegisterObjectMethod(className, "void Swap(VectorBase&)", AS_METHODPR(T, Swap, (VectorBase&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VectorBase
        REGISTER_MEMBERS_MANUAL_PART_VectorBase();
    #endif
}

// struct VertexBufferDesc | File: ../Graphics/Model.h
template <class T> void RegisterMembers_VertexBufferDesc(asIScriptEngine* engine, const char* className)
{
    // PODVector<VertexElement> VertexBufferDesc::vertexElements_
    // Error: type "PODVector<VertexElement>" can not automatically bind
    // SharedArrayPtr<unsigned char> VertexBufferDesc::data_
    // Error: type "SharedArrayPtr<unsigned char>" can not automatically bind

    // unsigned VertexBufferDesc::vertexCount_
    engine->RegisterObjectProperty(className, "uint vertexCount", offsetof(T, vertexCount_));

    // unsigned VertexBufferDesc::dataSize_
    engine->RegisterObjectProperty(className, "uint dataSize", offsetof(T, dataSize_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VertexBufferDesc
        REGISTER_MEMBERS_MANUAL_PART_VertexBufferDesc();
    #endif
}

// struct VertexBufferMorph | File: ../Graphics/Model.h
template <class T> void RegisterMembers_VertexBufferMorph(asIScriptEngine* engine, const char* className)
{
    // SharedArrayPtr<unsigned char> VertexBufferMorph::morphData_
    // Error: type "SharedArrayPtr<unsigned char>" can not automatically bind

    // VertexMaskFlags VertexBufferMorph::elementMask_
    engine->RegisterObjectProperty(className, "VertexMaskFlags elementMask", offsetof(T, elementMask_));

    // unsigned VertexBufferMorph::vertexCount_
    engine->RegisterObjectProperty(className, "uint vertexCount", offsetof(T, vertexCount_));

    // unsigned VertexBufferMorph::dataSize_
    engine->RegisterObjectProperty(className, "uint dataSize", offsetof(T, dataSize_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VertexBufferMorph
        REGISTER_MEMBERS_MANUAL_PART_VertexBufferMorph();
    #endif
}

// struct VertexElement | File: ../Graphics/GraphicsDefs.h
template <class T> void RegisterMembers_VertexElement(asIScriptEngine* engine, const char* className)
{
    // bool VertexElement::operator !=(const VertexElement& rhs) const
    // Only operator == is needed

    // bool VertexElement::operator ==(const VertexElement& rhs) const
    engine->RegisterObjectMethod(className, "bool opEquals(const VertexElement&in) const", AS_METHODPR(T, operator==, (const VertexElement&) const, bool), AS_CALL_THISCALL);

    // VertexElementType VertexElement::type_
    engine->RegisterObjectProperty(className, "VertexElementType type", offsetof(T, type_));

    // VertexElementSemantic VertexElement::semantic_
    engine->RegisterObjectProperty(className, "VertexElementSemantic semantic", offsetof(T, semantic_));

    // unsigned char VertexElement::index_
    engine->RegisterObjectProperty(className, "uint8 index", offsetof(T, index_));

    // bool VertexElement::perInstance_
    engine->RegisterObjectProperty(className, "bool perInstance", offsetof(T, perInstance_));

    // unsigned VertexElement::offset_
    engine->RegisterObjectProperty(className, "uint offset", offsetof(T, offset_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VertexElement
        REGISTER_MEMBERS_MANUAL_PART_VertexElement();
    #endif
}

// class WString | File: ../Container/Str.h
template <class T> void RegisterMembers_WString(asIScriptEngine* engine, const char* className)
{
    // wchar_t& WString::At(unsigned index)
    // Error: type "wchar_t&" can not automatically bind
    // const wchar_t& WString::At(unsigned index) const
    // Error: type "const wchar_t&" can not automatically bind
    // const wchar_t* WString::CString() const
    // Error: type "const wchar_t*" can not automatically bind
    // wchar_t& WString::operator [](unsigned index)
    // Error: type "wchar_t&" can not automatically bind
    // const wchar_t& WString::operator [](unsigned index) const
    // Error: type "const wchar_t&" can not automatically bind

    // bool WString::Empty() const
    engine->RegisterObjectMethod(className, "bool Empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);

    // unsigned WString::Length() const
    engine->RegisterObjectMethod(className, "uint Length() const", AS_METHODPR(T, Length, () const, unsigned), AS_CALL_THISCALL);

    // void WString::Resize(unsigned newLength)
    engine->RegisterObjectMethod(className, "void Resize(uint)", AS_METHODPR(T, Resize, (unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_WString
        REGISTER_MEMBERS_MANUAL_PART_WString();
    #endif
}

// struct WindowModeParams | File: ../Graphics/Graphics.h
template <class T> void RegisterMembers_WindowModeParams(asIScriptEngine* engine, const char* className)
{
    // int WindowModeParams::width_
    engine->RegisterObjectProperty(className, "int width", offsetof(T, width_));

    // int WindowModeParams::height_
    engine->RegisterObjectProperty(className, "int height", offsetof(T, height_));

    // ScreenModeParams WindowModeParams::screenParams_
    engine->RegisterObjectProperty(className, "ScreenModeParams screenParams", offsetof(T, screenParams_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_WindowModeParams
        REGISTER_MEMBERS_MANUAL_PART_WindowModeParams();
    #endif
}

// Vector<String> XMLElement::GetAttributeNames() const
template <class T> CScriptArray* XMLElement_VectorlesStringgre_GetAttributeNames_void_template(T* _ptr)
{
    Vector<String> result = _ptr->GetAttributeNames();
    return VectorToArray<String>(result, "Array<String>");
}

// StringVector XMLElement::GetStringVector() const
template <class T> CScriptArray* XMLElement_StringVector_GetStringVector_void_template(T* _ptr)
{
    StringVector result = _ptr->GetStringVector();
    return VectorToArray<String>(result, "Array<String>");
}

// bool XMLElement::SetStringVector(const StringVector& value)
template <class T> bool XMLElement_bool_SetStringVector_constspStringVectoramp_template(T* _ptr, CScriptArray* value_conv)
{
    StringVector value = ArrayToVector<String>(value_conv);
    bool result = _ptr->SetStringVector(value);
    return result;
}

// class XMLElement | File: ../Resource/XMLElement.h
template <class T> void RegisterMembers_XMLElement(asIScriptEngine* engine, const char* className)
{
    // XMLElement XMLElement::CreateChild(const char* name)
    // Error: type "const char*" can not automatically bind
    // String XMLElement::GetAttribute(const char* name) const
    // Error: type "const char*" can not automatically bind
    // const char* XMLElement::GetAttributeCString(const char* name) const
    // Error: type "const char*" can not automatically bind
    // String XMLElement::GetAttributeLower(const char* name) const
    // Error: type "const char*" can not automatically bind
    // String XMLElement::GetAttributeUpper(const char* name) const
    // Error: type "const char*" can not automatically bind
    // PODVector<unsigned char> XMLElement::GetBuffer(const String& name) const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // bool XMLElement::GetBuffer(const String& name, void* dest, unsigned size) const
    // Error: type "void*" can not automatically bind
    // XMLElement XMLElement::GetChild(const char* name) const
    // Error: type "const char*" can not automatically bind
    // XMLElement XMLElement::GetNext(const char* name) const
    // Error: type "const char*" can not automatically bind
    // pugi::xml_node_struct* XMLElement::GetNode() const
    // Error: type "pugi::xml_node_struct*" can not automatically bind
    // XMLElement XMLElement::GetOrCreateChild(const char* name)
    // Error: type "const char*" can not automatically bind
    // VariantVector XMLElement::GetVariantVector() const
    // Error: type "VariantVector" can not automatically bind
    // const pugi::xpath_node* XMLElement::GetXPathNode() const
    // Error: type "const pugi::xpath_node*" can not automatically bind
    // const XPathResultSet* XMLElement::GetXPathResultSet() const
    // Error: type "const XPathResultSet*" can not automatically bind
    // bool XMLElement::HasAttribute(const char* name) const
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::HasChild(const char* name) const
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::RemoveAttribute(const char* name)
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::RemoveChild(const char* name)
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::RemoveChildren(const char* name)
    // Error: type "const char*" can not automatically bind
    // XPathResultSet XMLElement::Select(const String& query, pugi::xpath_variable_set* variables = nullptr) const
    // Error: type "pugi::xpath_variable_set*" can not automatically bind
    // XMLElement XMLElement::SelectSingle(const String& query, pugi::xpath_variable_set* variables = nullptr) const
    // Error: type "pugi::xpath_variable_set*" can not automatically bind
    // bool XMLElement::SetAttribute(const char* name, const char* value)
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::SetAttribute(const char* value)
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::SetBuffer(const String& name, const void* data, unsigned size)
    // Error: type "const void*" can not automatically bind
    // bool XMLElement::SetBuffer(const String& name, const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // bool XMLElement::SetValue(const char* value)
    // Error: type "const char*" can not automatically bind
    // bool XMLElement::SetVariantVector(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // bool XMLElement::AppendChild(XMLElement element, bool asCopy = false)
    engine->RegisterObjectMethod(className, "bool AppendChild(XMLElement, bool = false)", AS_METHODPR(T, AppendChild, (XMLElement, bool), bool), AS_CALL_THISCALL);

    // XMLElement XMLElement::CreateChild(const String& name)
    engine->RegisterObjectMethod(className, "XMLElement CreateChild(const String&in)", AS_METHODPR(T, CreateChild, (const String&), XMLElement), AS_CALL_THISCALL);

    // String XMLElement::GetAttribute(const String& name = String::EMPTY) const
    engine->RegisterObjectMethod(className, "String GetAttribute(const String&in = String::EMPTY) const", AS_METHODPR(T, GetAttribute, (const String&) const, String), AS_CALL_THISCALL);

    // String XMLElement::GetAttributeLower(const String& name) const
    engine->RegisterObjectMethod(className, "String GetAttributeLower(const String&in) const", AS_METHODPR(T, GetAttributeLower, (const String&) const, String), AS_CALL_THISCALL);

    // Vector<String> XMLElement::GetAttributeNames() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetAttributeNames() const", AS_FUNCTION_OBJFIRST(XMLElement_VectorlesStringgre_GetAttributeNames_void_template<XMLElement>), AS_CALL_CDECL_OBJFIRST);

    // String XMLElement::GetAttributeUpper(const String& name) const
    engine->RegisterObjectMethod(className, "String GetAttributeUpper(const String&in) const", AS_METHODPR(T, GetAttributeUpper, (const String&) const, String), AS_CALL_THISCALL);

    // bool XMLElement::GetBool(const String& name) const
    engine->RegisterObjectMethod(className, "bool GetBool(const String&in) const", AS_METHODPR(T, GetBool, (const String&) const, bool), AS_CALL_THISCALL);

    // BoundingBox XMLElement::GetBoundingBox() const
    engine->RegisterObjectMethod(className, "BoundingBox GetBoundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);

    // XMLElement XMLElement::GetChild(const String& name = String::EMPTY) const
    engine->RegisterObjectMethod(className, "XMLElement GetChild(const String&in = String::EMPTY) const", AS_METHODPR(T, GetChild, (const String&) const, XMLElement), AS_CALL_THISCALL);

    // Color XMLElement::GetColor(const String& name) const
    engine->RegisterObjectMethod(className, "Color GetColor(const String&in) const", AS_METHODPR(T, GetColor, (const String&) const, Color), AS_CALL_THISCALL);

    // double XMLElement::GetDouble(const String& name) const
    engine->RegisterObjectMethod(className, "double GetDouble(const String&in) const", AS_METHODPR(T, GetDouble, (const String&) const, double), AS_CALL_THISCALL);

    // XMLFile* XMLElement::GetFile() const
    engine->RegisterObjectMethod(className, "XMLFile@+ GetFile() const", AS_METHODPR(T, GetFile, () const, XMLFile*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLFile@+ get_file() const", AS_METHODPR(T, GetFile, () const, XMLFile*), AS_CALL_THISCALL);

    // float XMLElement::GetFloat(const String& name) const
    engine->RegisterObjectMethod(className, "float GetFloat(const String&in) const", AS_METHODPR(T, GetFloat, (const String&) const, float), AS_CALL_THISCALL);

    // int XMLElement::GetInt(const String& name) const
    engine->RegisterObjectMethod(className, "int GetInt(const String&in) const", AS_METHODPR(T, GetInt, (const String&) const, int), AS_CALL_THISCALL);

    // long long XMLElement::GetInt64(const String& name) const
    engine->RegisterObjectMethod(className, "int64 GetInt64(const String&in) const", AS_METHODPR(T, GetInt64, (const String&) const, long long), AS_CALL_THISCALL);

    // IntRect XMLElement::GetIntRect(const String& name) const
    engine->RegisterObjectMethod(className, "IntRect GetIntRect(const String&in) const", AS_METHODPR(T, GetIntRect, (const String&) const, IntRect), AS_CALL_THISCALL);

    // IntVector2 XMLElement::GetIntVector2(const String& name) const
    engine->RegisterObjectMethod(className, "IntVector2 GetIntVector2(const String&in) const", AS_METHODPR(T, GetIntVector2, (const String&) const, IntVector2), AS_CALL_THISCALL);

    // IntVector3 XMLElement::GetIntVector3(const String& name) const
    engine->RegisterObjectMethod(className, "IntVector3 GetIntVector3(const String&in) const", AS_METHODPR(T, GetIntVector3, (const String&) const, IntVector3), AS_CALL_THISCALL);

    // Matrix3 XMLElement::GetMatrix3(const String& name) const
    engine->RegisterObjectMethod(className, "Matrix3 GetMatrix3(const String&in) const", AS_METHODPR(T, GetMatrix3, (const String&) const, Matrix3), AS_CALL_THISCALL);

    // Matrix3x4 XMLElement::GetMatrix3x4(const String& name) const
    engine->RegisterObjectMethod(className, "Matrix3x4 GetMatrix3x4(const String&in) const", AS_METHODPR(T, GetMatrix3x4, (const String&) const, Matrix3x4), AS_CALL_THISCALL);

    // Matrix4 XMLElement::GetMatrix4(const String& name) const
    engine->RegisterObjectMethod(className, "Matrix4 GetMatrix4(const String&in) const", AS_METHODPR(T, GetMatrix4, (const String&) const, Matrix4), AS_CALL_THISCALL);

    // String XMLElement::GetName() const
    engine->RegisterObjectMethod(className, "String GetName() const", AS_METHODPR(T, GetName, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_name() const", AS_METHODPR(T, GetName, () const, String), AS_CALL_THISCALL);

    // XMLElement XMLElement::GetNext(const String& name = String::EMPTY) const
    engine->RegisterObjectMethod(className, "XMLElement GetNext(const String&in = String::EMPTY) const", AS_METHODPR(T, GetNext, (const String&) const, XMLElement), AS_CALL_THISCALL);

    // unsigned XMLElement::GetNumAttributes() const
    engine->RegisterObjectMethod(className, "uint GetNumAttributes() const", AS_METHODPR(T, GetNumAttributes, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAttributes() const", AS_METHODPR(T, GetNumAttributes, () const, unsigned), AS_CALL_THISCALL);

    // XMLElement XMLElement::GetOrCreateChild(const String& name)
    engine->RegisterObjectMethod(className, "XMLElement GetOrCreateChild(const String&in)", AS_METHODPR(T, GetOrCreateChild, (const String&), XMLElement), AS_CALL_THISCALL);

    // XMLElement XMLElement::GetParent() const
    engine->RegisterObjectMethod(className, "XMLElement GetParent() const", AS_METHODPR(T, GetParent, () const, XMLElement), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLElement get_parent() const", AS_METHODPR(T, GetParent, () const, XMLElement), AS_CALL_THISCALL);

    // Quaternion XMLElement::GetQuaternion(const String& name) const
    engine->RegisterObjectMethod(className, "Quaternion GetQuaternion(const String&in) const", AS_METHODPR(T, GetQuaternion, (const String&) const, Quaternion), AS_CALL_THISCALL);

    // Rect XMLElement::GetRect(const String& name) const
    engine->RegisterObjectMethod(className, "Rect GetRect(const String&in) const", AS_METHODPR(T, GetRect, (const String&) const, Rect), AS_CALL_THISCALL);

    // ResourceRef XMLElement::GetResourceRef() const
    engine->RegisterObjectMethod(className, "ResourceRef GetResourceRef() const", AS_METHODPR(T, GetResourceRef, () const, ResourceRef), AS_CALL_THISCALL);

    // ResourceRefList XMLElement::GetResourceRefList() const
    engine->RegisterObjectMethod(className, "ResourceRefList GetResourceRefList() const", AS_METHODPR(T, GetResourceRefList, () const, ResourceRefList), AS_CALL_THISCALL);

    // StringVector XMLElement::GetStringVector() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetStringVector() const", AS_FUNCTION_OBJFIRST(XMLElement_StringVector_GetStringVector_void_template<XMLElement>), AS_CALL_CDECL_OBJFIRST);

    // unsigned XMLElement::GetUInt(const String& name) const
    engine->RegisterObjectMethod(className, "uint GetUInt(const String&in) const", AS_METHODPR(T, GetUInt, (const String&) const, unsigned), AS_CALL_THISCALL);

    // unsigned long long XMLElement::GetUInt64(const String& name) const
    engine->RegisterObjectMethod(className, "uint64 GetUInt64(const String&in) const", AS_METHODPR(T, GetUInt64, (const String&) const, unsigned long long), AS_CALL_THISCALL);

    // String XMLElement::GetValue() const
    engine->RegisterObjectMethod(className, "String GetValue() const", AS_METHODPR(T, GetValue, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_value() const", AS_METHODPR(T, GetValue, () const, String), AS_CALL_THISCALL);

    // Variant XMLElement::GetVariant() const
    engine->RegisterObjectMethod(className, "Variant GetVariant() const", AS_METHODPR(T, GetVariant, () const, Variant), AS_CALL_THISCALL);

    // VariantMap XMLElement::GetVariantMap() const
    engine->RegisterObjectMethod(className, "VariantMap GetVariantMap() const", AS_METHODPR(T, GetVariantMap, () const, VariantMap), AS_CALL_THISCALL);

    // Variant XMLElement::GetVariantValue(VariantType type) const
    engine->RegisterObjectMethod(className, "Variant GetVariantValue(VariantType) const", AS_METHODPR(T, GetVariantValue, (VariantType) const, Variant), AS_CALL_THISCALL);

    // Vector4 XMLElement::GetVector(const String& name) const
    engine->RegisterObjectMethod(className, "Vector4 GetVector(const String&in) const", AS_METHODPR(T, GetVector, (const String&) const, Vector4), AS_CALL_THISCALL);

    // Vector2 XMLElement::GetVector2(const String& name) const
    engine->RegisterObjectMethod(className, "Vector2 GetVector2(const String&in) const", AS_METHODPR(T, GetVector2, (const String&) const, Vector2), AS_CALL_THISCALL);

    // Vector3 XMLElement::GetVector3(const String& name) const
    engine->RegisterObjectMethod(className, "Vector3 GetVector3(const String&in) const", AS_METHODPR(T, GetVector3, (const String&) const, Vector3), AS_CALL_THISCALL);

    // Vector4 XMLElement::GetVector4(const String& name) const
    engine->RegisterObjectMethod(className, "Vector4 GetVector4(const String&in) const", AS_METHODPR(T, GetVector4, (const String&) const, Vector4), AS_CALL_THISCALL);

    // Variant XMLElement::GetVectorVariant(const String& name) const
    engine->RegisterObjectMethod(className, "Variant GetVectorVariant(const String&in) const", AS_METHODPR(T, GetVectorVariant, (const String&) const, Variant), AS_CALL_THISCALL);

    // unsigned XMLElement::GetXPathResultIndex() const
    engine->RegisterObjectMethod(className, "uint GetXPathResultIndex() const", AS_METHODPR(T, GetXPathResultIndex, () const, unsigned), AS_CALL_THISCALL);

    // bool XMLElement::HasAttribute(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasAttribute(const String&in) const", AS_METHODPR(T, HasAttribute, (const String&) const, bool), AS_CALL_THISCALL);

    // bool XMLElement::HasChild(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasChild(const String&in) const", AS_METHODPR(T, HasChild, (const String&) const, bool), AS_CALL_THISCALL);

    // bool XMLElement::IsNull() const
    engine->RegisterObjectMethod(className, "bool IsNull() const", AS_METHODPR(T, IsNull, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isNull() const", AS_METHODPR(T, IsNull, () const, bool), AS_CALL_THISCALL);

    // XMLElement XMLElement::NextResult() const
    engine->RegisterObjectMethod(className, "XMLElement NextResult() const", AS_METHODPR(T, NextResult, () const, XMLElement), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLElement get_nextResult() const", AS_METHODPR(T, NextResult, () const, XMLElement), AS_CALL_THISCALL);

    // bool XMLElement::NotNull() const
    engine->RegisterObjectMethod(className, "bool NotNull() const", AS_METHODPR(T, NotNull, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_notNull() const", AS_METHODPR(T, NotNull, () const, bool), AS_CALL_THISCALL);

    // explicit XMLElement::operator bool() const
    engine->RegisterObjectMethod(className, "bool opConv() const", AS_METHODPR(T, operator bool, () const, bool), AS_CALL_THISCALL);

    // XMLElement& XMLElement::operator =(const XMLElement& rhs)
    engine->RegisterObjectMethod(className, "XMLElement& opAssign(const XMLElement&in)", AS_METHODPR(T, operator=, (const XMLElement&), XMLElement&), AS_CALL_THISCALL);

    // bool XMLElement::Remove()
    engine->RegisterObjectMethod(className, "bool Remove()", AS_METHODPR(T, Remove, (), bool), AS_CALL_THISCALL);

    // bool XMLElement::RemoveAttribute(const String& name = String::EMPTY)
    engine->RegisterObjectMethod(className, "bool RemoveAttribute(const String&in = String::EMPTY)", AS_METHODPR(T, RemoveAttribute, (const String&), bool), AS_CALL_THISCALL);

    // bool XMLElement::RemoveChild(const XMLElement& element)
    engine->RegisterObjectMethod(className, "bool RemoveChild(const XMLElement&in)", AS_METHODPR(T, RemoveChild, (const XMLElement&), bool), AS_CALL_THISCALL);

    // bool XMLElement::RemoveChild(const String& name)
    engine->RegisterObjectMethod(className, "bool RemoveChild(const String&in)", AS_METHODPR(T, RemoveChild, (const String&), bool), AS_CALL_THISCALL);

    // bool XMLElement::RemoveChildren(const String& name = String::EMPTY)
    engine->RegisterObjectMethod(className, "bool RemoveChildren(const String&in = String::EMPTY)", AS_METHODPR(T, RemoveChildren, (const String&), bool), AS_CALL_THISCALL);

    // XPathResultSet XMLElement::SelectPrepared(const XPathQuery& query) const
    engine->RegisterObjectMethod(className, "XPathResultSet SelectPrepared(const XPathQuery&in) const", AS_METHODPR(T, SelectPrepared, (const XPathQuery&) const, XPathResultSet), AS_CALL_THISCALL);

    // XMLElement XMLElement::SelectSinglePrepared(const XPathQuery& query) const
    engine->RegisterObjectMethod(className, "XMLElement SelectSinglePrepared(const XPathQuery&in) const", AS_METHODPR(T, SelectSinglePrepared, (const XPathQuery&) const, XMLElement), AS_CALL_THISCALL);

    // bool XMLElement::SetAttribute(const String& name, const String& value)
    engine->RegisterObjectMethod(className, "bool SetAttribute(const String&in, const String&in)", AS_METHODPR(T, SetAttribute, (const String&, const String&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetAttribute(const String& value)
    engine->RegisterObjectMethod(className, "bool SetAttribute(const String&in)", AS_METHODPR(T, SetAttribute, (const String&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetBool(const String& name, bool value)
    engine->RegisterObjectMethod(className, "bool SetBool(const String&in, bool)", AS_METHODPR(T, SetBool, (const String&, bool), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetBoundingBox(const BoundingBox& value)
    engine->RegisterObjectMethod(className, "bool SetBoundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetColor(const String& name, const Color& value)
    engine->RegisterObjectMethod(className, "bool SetColor(const String&in, const Color&in)", AS_METHODPR(T, SetColor, (const String&, const Color&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetDouble(const String& name, double value)
    engine->RegisterObjectMethod(className, "bool SetDouble(const String&in, double)", AS_METHODPR(T, SetDouble, (const String&, double), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetFloat(const String& name, float value)
    engine->RegisterObjectMethod(className, "bool SetFloat(const String&in, float)", AS_METHODPR(T, SetFloat, (const String&, float), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetInt(const String& name, int value)
    engine->RegisterObjectMethod(className, "bool SetInt(const String&in, int)", AS_METHODPR(T, SetInt, (const String&, int), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetInt64(const String& name, long long value)
    engine->RegisterObjectMethod(className, "bool SetInt64(const String&in, int64)", AS_METHODPR(T, SetInt64, (const String&, long long), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetIntRect(const String& name, const IntRect& value)
    engine->RegisterObjectMethod(className, "bool SetIntRect(const String&in, const IntRect&in)", AS_METHODPR(T, SetIntRect, (const String&, const IntRect&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetIntVector2(const String& name, const IntVector2& value)
    engine->RegisterObjectMethod(className, "bool SetIntVector2(const String&in, const IntVector2&in)", AS_METHODPR(T, SetIntVector2, (const String&, const IntVector2&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetIntVector3(const String& name, const IntVector3& value)
    engine->RegisterObjectMethod(className, "bool SetIntVector3(const String&in, const IntVector3&in)", AS_METHODPR(T, SetIntVector3, (const String&, const IntVector3&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetMatrix3(const String& name, const Matrix3& value)
    engine->RegisterObjectMethod(className, "bool SetMatrix3(const String&in, const Matrix3&in)", AS_METHODPR(T, SetMatrix3, (const String&, const Matrix3&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetMatrix3x4(const String& name, const Matrix3x4& value)
    engine->RegisterObjectMethod(className, "bool SetMatrix3x4(const String&in, const Matrix3x4&in)", AS_METHODPR(T, SetMatrix3x4, (const String&, const Matrix3x4&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetMatrix4(const String& name, const Matrix4& value)
    engine->RegisterObjectMethod(className, "bool SetMatrix4(const String&in, const Matrix4&in)", AS_METHODPR(T, SetMatrix4, (const String&, const Matrix4&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetQuaternion(const String& name, const Quaternion& value)
    engine->RegisterObjectMethod(className, "bool SetQuaternion(const String&in, const Quaternion&in)", AS_METHODPR(T, SetQuaternion, (const String&, const Quaternion&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetRect(const String& name, const Rect& value)
    engine->RegisterObjectMethod(className, "bool SetRect(const String&in, const Rect&in)", AS_METHODPR(T, SetRect, (const String&, const Rect&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetResourceRef(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "bool SetResourceRef(const ResourceRef&in)", AS_METHODPR(T, SetResourceRef, (const ResourceRef&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetResourceRefList(const ResourceRefList& value)
    engine->RegisterObjectMethod(className, "bool SetResourceRefList(const ResourceRefList&in)", AS_METHODPR(T, SetResourceRefList, (const ResourceRefList&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetString(const String& name, const String& value)
    engine->RegisterObjectMethod(className, "bool SetString(const String&in, const String&in)", AS_METHODPR(T, SetString, (const String&, const String&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetStringVector(const StringVector& value)
    engine->RegisterObjectMethod(className, "bool SetStringVector(Array<String>@+)", AS_FUNCTION_OBJFIRST(XMLElement_bool_SetStringVector_constspStringVectoramp_template<XMLElement>), AS_CALL_CDECL_OBJFIRST);

    // bool XMLElement::SetUInt(const String& name, unsigned value)
    engine->RegisterObjectMethod(className, "bool SetUInt(const String&in, uint)", AS_METHODPR(T, SetUInt, (const String&, unsigned), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetUInt64(const String& name, unsigned long long value)
    engine->RegisterObjectMethod(className, "bool SetUInt64(const String&in, uint64)", AS_METHODPR(T, SetUInt64, (const String&, unsigned long long), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetValue(const String& value)
    engine->RegisterObjectMethod(className, "bool SetValue(const String&in)", AS_METHODPR(T, SetValue, (const String&), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_value(const String&in)", AS_METHODPR(T, SetValue, (const String&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVariant(const Variant& value)
    engine->RegisterObjectMethod(className, "bool SetVariant(const Variant&in)", AS_METHODPR(T, SetVariant, (const Variant&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVariantMap(const VariantMap& value)
    engine->RegisterObjectMethod(className, "bool SetVariantMap(const VariantMap&in)", AS_METHODPR(T, SetVariantMap, (const VariantMap&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVariantValue(const Variant& value)
    engine->RegisterObjectMethod(className, "bool SetVariantValue(const Variant&in)", AS_METHODPR(T, SetVariantValue, (const Variant&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVector2(const String& name, const Vector2& value)
    engine->RegisterObjectMethod(className, "bool SetVector2(const String&in, const Vector2&in)", AS_METHODPR(T, SetVector2, (const String&, const Vector2&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVector3(const String& name, const Vector3& value)
    engine->RegisterObjectMethod(className, "bool SetVector3(const String&in, const Vector3&in)", AS_METHODPR(T, SetVector3, (const String&, const Vector3&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVector4(const String& name, const Vector4& value)
    engine->RegisterObjectMethod(className, "bool SetVector4(const String&in, const Vector4&in)", AS_METHODPR(T, SetVector4, (const String&, const Vector4&), bool), AS_CALL_THISCALL);

    // bool XMLElement::SetVectorVariant(const String& name, const Variant& value)
    engine->RegisterObjectMethod(className, "bool SetVectorVariant(const String&in, const Variant&in)", AS_METHODPR(T, SetVectorVariant, (const String&, const Variant&), bool), AS_CALL_THISCALL);

    // static const XMLElement XMLElement::EMPTY
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const XMLElement EMPTY", (void*)&T::EMPTY);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_XMLElement
        REGISTER_MEMBERS_MANUAL_PART_XMLElement();
    #endif
}

// class XPathQuery | File: ../Resource/XMLElement.h
template <class T> void RegisterMembers_XPathQuery(asIScriptEngine* engine, const char* className)
{
    // pugi::xpath_query* XPathQuery::GetXPathQuery() const
    // Error: type "pugi::xpath_query*" can not automatically bind
    // pugi::xpath_variable_set* XPathQuery::GetXPathVariableSet() const
    // Error: type "pugi::xpath_variable_set*" can not automatically bind
    // bool XPathQuery::SetVariable(const char* name, const char* value)
    // Error: type "const char*" can not automatically bind

    // void XPathQuery::Bind()
    engine->RegisterObjectMethod(className, "void Bind()", AS_METHODPR(T, Bind, (), void), AS_CALL_THISCALL);

    // void XPathQuery::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // XPathResultSet XPathQuery::Evaluate(const XMLElement& element) const
    engine->RegisterObjectMethod(className, "XPathResultSet Evaluate(const XMLElement&in) const", AS_METHODPR(T, Evaluate, (const XMLElement&) const, XPathResultSet), AS_CALL_THISCALL);

    // bool XPathQuery::EvaluateToBool(const XMLElement& element) const
    engine->RegisterObjectMethod(className, "bool EvaluateToBool(const XMLElement&in) const", AS_METHODPR(T, EvaluateToBool, (const XMLElement&) const, bool), AS_CALL_THISCALL);

    // float XPathQuery::EvaluateToFloat(const XMLElement& element) const
    engine->RegisterObjectMethod(className, "float EvaluateToFloat(const XMLElement&in) const", AS_METHODPR(T, EvaluateToFloat, (const XMLElement&) const, float), AS_CALL_THISCALL);

    // String XPathQuery::EvaluateToString(const XMLElement& element) const
    engine->RegisterObjectMethod(className, "String EvaluateToString(const XMLElement&in) const", AS_METHODPR(T, EvaluateToString, (const XMLElement&) const, String), AS_CALL_THISCALL);

    // String XPathQuery::GetQuery() const
    engine->RegisterObjectMethod(className, "String GetQuery() const", AS_METHODPR(T, GetQuery, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_query() const", AS_METHODPR(T, GetQuery, () const, String), AS_CALL_THISCALL);

    // bool XPathQuery::SetQuery(const String& queryString, const String& variableString = String::EMPTY, bool bind = true)
    engine->RegisterObjectMethod(className, "bool SetQuery(const String&in, const String&in = String::EMPTY, bool = true)", AS_METHODPR(T, SetQuery, (const String&, const String&, bool), bool), AS_CALL_THISCALL);

    // bool XPathQuery::SetVariable(const String& name, bool value)
    engine->RegisterObjectMethod(className, "bool SetVariable(const String&in, bool)", AS_METHODPR(T, SetVariable, (const String&, bool), bool), AS_CALL_THISCALL);

    // bool XPathQuery::SetVariable(const String& name, float value)
    engine->RegisterObjectMethod(className, "bool SetVariable(const String&in, float)", AS_METHODPR(T, SetVariable, (const String&, float), bool), AS_CALL_THISCALL);

    // bool XPathQuery::SetVariable(const String& name, const String& value)
    engine->RegisterObjectMethod(className, "bool SetVariable(const String&in, const String&in)", AS_METHODPR(T, SetVariable, (const String&, const String&), bool), AS_CALL_THISCALL);

    // bool XPathQuery::SetVariable(const String& name, const XPathResultSet& value)
    engine->RegisterObjectMethod(className, "bool SetVariable(const String&in, const XPathResultSet&in)", AS_METHODPR(T, SetVariable, (const String&, const XPathResultSet&), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_XPathQuery
        REGISTER_MEMBERS_MANUAL_PART_XPathQuery();
    #endif
}

// class XPathResultSet | File: ../Resource/XMLElement.h
template <class T> void RegisterMembers_XPathResultSet(asIScriptEngine* engine, const char* className)
{
    // pugi::xpath_node_set* XPathResultSet::GetXPathNodeSet() const
    // Error: type "pugi::xpath_node_set*" can not automatically bind

    // bool XPathResultSet::Empty() const
    engine->RegisterObjectMethod(className, "bool Empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_empty() const", AS_METHODPR(T, Empty, () const, bool), AS_CALL_THISCALL);

    // XMLElement XPathResultSet::FirstResult()
    engine->RegisterObjectMethod(className, "XMLElement FirstResult()", AS_METHODPR(T, FirstResult, (), XMLElement), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLElement get_firstResult()", AS_METHODPR(T, FirstResult, (), XMLElement), AS_CALL_THISCALL);

    // XPathResultSet& XPathResultSet::operator =(const XPathResultSet& rhs)
    engine->RegisterObjectMethod(className, "XPathResultSet& opAssign(const XPathResultSet&in)", AS_METHODPR(T, operator=, (const XPathResultSet&), XPathResultSet&), AS_CALL_THISCALL);

    // XMLElement XPathResultSet::operator [](unsigned index) const
    engine->RegisterObjectMethod(className, "XMLElement opIndex(uint) const", AS_METHODPR(T, operator[], (unsigned) const, XMLElement), AS_CALL_THISCALL);

    // unsigned XPathResultSet::Size() const
    engine->RegisterObjectMethod(className, "uint Size() const", AS_METHODPR(T, Size, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_size() const", AS_METHODPR(T, Size, () const, unsigned), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_XPathResultSet
        REGISTER_MEMBERS_MANUAL_PART_XPathResultSet();
    #endif
}

#ifdef URHO3D_NAVIGATION

// struct CrowdObstacleAvoidanceParams | File: ../Navigation/CrowdManager.h
template <class T> void RegisterMembers_CrowdObstacleAvoidanceParams(asIScriptEngine* engine, const char* className)
{
    // float CrowdObstacleAvoidanceParams::velBias
    engine->RegisterObjectProperty(className, "float velBias", offsetof(T, velBias));

    // float CrowdObstacleAvoidanceParams::weightDesVel
    engine->RegisterObjectProperty(className, "float weightDesVel", offsetof(T, weightDesVel));

    // float CrowdObstacleAvoidanceParams::weightCurVel
    engine->RegisterObjectProperty(className, "float weightCurVel", offsetof(T, weightCurVel));

    // float CrowdObstacleAvoidanceParams::weightSide
    engine->RegisterObjectProperty(className, "float weightSide", offsetof(T, weightSide));

    // float CrowdObstacleAvoidanceParams::weightToi
    engine->RegisterObjectProperty(className, "float weightToi", offsetof(T, weightToi));

    // float CrowdObstacleAvoidanceParams::horizTime
    engine->RegisterObjectProperty(className, "float horizTime", offsetof(T, horizTime));

    // unsigned char CrowdObstacleAvoidanceParams::gridSize
    engine->RegisterObjectProperty(className, "uint8 gridSize", offsetof(T, gridSize));

    // unsigned char CrowdObstacleAvoidanceParams::adaptiveDivs
    engine->RegisterObjectProperty(className, "uint8 adaptiveDivs", offsetof(T, adaptiveDivs));

    // unsigned char CrowdObstacleAvoidanceParams::adaptiveRings
    engine->RegisterObjectProperty(className, "uint8 adaptiveRings", offsetof(T, adaptiveRings));

    // unsigned char CrowdObstacleAvoidanceParams::adaptiveDepth
    engine->RegisterObjectProperty(className, "uint8 adaptiveDepth", offsetof(T, adaptiveDepth));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CrowdObstacleAvoidanceParams
        REGISTER_MEMBERS_MANUAL_PART_CrowdObstacleAvoidanceParams();
    #endif
}

// struct NavAreaStub | File: ../Navigation/NavBuildData.h
template <class T> void RegisterMembers_NavAreaStub(asIScriptEngine* engine, const char* className)
{
    // BoundingBox NavAreaStub::bounds_
    engine->RegisterObjectProperty(className, "BoundingBox bounds", offsetof(T, bounds_));

    // unsigned char NavAreaStub::areaID_
    engine->RegisterObjectProperty(className, "uint8 areaID", offsetof(T, areaID_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NavAreaStub
        REGISTER_MEMBERS_MANUAL_PART_NavAreaStub();
    #endif
}

// struct NavBuildData | File: ../Navigation/NavBuildData.h
template <class T> void RegisterMembers_NavBuildData(asIScriptEngine* engine, const char* className)
{
    // PODVector<Vector3> NavBuildData::vertices_
    // Error: type "PODVector<Vector3>" can not automatically bind
    // PODVector<int> NavBuildData::indices_
    // Error: type "PODVector<int>" can not automatically bind
    // PODVector<Vector3> NavBuildData::offMeshVertices_
    // Error: type "PODVector<Vector3>" can not automatically bind
    // PODVector<float> NavBuildData::offMeshRadii_
    // Error: type "PODVector<float>" can not automatically bind
    // PODVector<unsigned short> NavBuildData::offMeshFlags_
    // Error: type "PODVector<unsigned short>" can not automatically bind
    // PODVector<unsigned char> NavBuildData::offMeshAreas_
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // PODVector<unsigned char> NavBuildData::offMeshDir_
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // rcContext* NavBuildData::ctx_
    // Not registered because pointer
    // rcHeightfield* NavBuildData::heightField_
    // Not registered because pointer
    // rcCompactHeightfield* NavBuildData::compactHeightField_
    // Not registered because pointer
    // PODVector<NavAreaStub> NavBuildData::navAreas_
    // Error: type "PODVector<NavAreaStub>" can not automatically bind

    // BoundingBox NavBuildData::worldBoundingBox_
    engine->RegisterObjectProperty(className, "BoundingBox worldBoundingBox", offsetof(T, worldBoundingBox_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NavBuildData
        REGISTER_MEMBERS_MANUAL_PART_NavBuildData();
    #endif
}

// struct NavigationGeometryInfo | File: ../Navigation/NavigationMesh.h
template <class T> void RegisterMembers_NavigationGeometryInfo(asIScriptEngine* engine, const char* className)
{
    // Component* NavigationGeometryInfo::component_
    // Not registered because pointer

    // unsigned NavigationGeometryInfo::lodLevel_
    engine->RegisterObjectProperty(className, "uint lodLevel", offsetof(T, lodLevel_));

    // Matrix3x4 NavigationGeometryInfo::transform_
    engine->RegisterObjectProperty(className, "Matrix3x4 transform", offsetof(T, transform_));

    // BoundingBox NavigationGeometryInfo::boundingBox_
    engine->RegisterObjectProperty(className, "BoundingBox boundingBox", offsetof(T, boundingBox_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NavigationGeometryInfo
        REGISTER_MEMBERS_MANUAL_PART_NavigationGeometryInfo();
    #endif
}

// struct NavigationPathPoint | File: ../Navigation/NavigationMesh.h
template <class T> void RegisterMembers_NavigationPathPoint(asIScriptEngine* engine, const char* className)
{
    // Vector3 NavigationPathPoint::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // NavigationPathPointFlag NavigationPathPoint::flag_
    engine->RegisterObjectProperty(className, "NavigationPathPointFlag flag", offsetof(T, flag_));

    // unsigned char NavigationPathPoint::areaID_
    engine->RegisterObjectProperty(className, "uint8 areaID", offsetof(T, areaID_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NavigationPathPoint
        REGISTER_MEMBERS_MANUAL_PART_NavigationPathPoint();
    #endif
}

#endif // def URHO3D_NAVIGATION

#ifdef URHO3D_NETWORK

// struct PackageDownload | File: ../Network/Connection.h
template <class T> void RegisterMembers_PackageDownload(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<File> PackageDownload::file_
    // Error: type "SharedPtr<File>" can not automatically bind
    // HashSet<unsigned> PackageDownload::receivedFragments_
    // Error: type "HashSet<unsigned>" can not automatically bind

    // String PackageDownload::name_
    engine->RegisterObjectProperty(className, "String name", offsetof(T, name_));

    // unsigned PackageDownload::totalFragments_
    engine->RegisterObjectProperty(className, "uint totalFragments", offsetof(T, totalFragments_));

    // unsigned PackageDownload::checksum_
    engine->RegisterObjectProperty(className, "uint checksum", offsetof(T, checksum_));

    // bool PackageDownload::initiated_
    engine->RegisterObjectProperty(className, "bool initiated", offsetof(T, initiated_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PackageDownload
        REGISTER_MEMBERS_MANUAL_PART_PackageDownload();
    #endif
}

// struct PackageUpload | File: ../Network/Connection.h
template <class T> void RegisterMembers_PackageUpload(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<File> PackageUpload::file_
    // Error: type "SharedPtr<File>" can not automatically bind

    // unsigned PackageUpload::fragment_
    engine->RegisterObjectProperty(className, "uint fragment", offsetof(T, fragment_));

    // unsigned PackageUpload::totalFragments_
    engine->RegisterObjectProperty(className, "uint totalFragments", offsetof(T, totalFragments_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PackageUpload
        REGISTER_MEMBERS_MANUAL_PART_PackageUpload();
    #endif
}

// struct RemoteEvent | File: ../Network/Connection.h
template <class T> void RegisterMembers_RemoteEvent(asIScriptEngine* engine, const char* className)
{
    // unsigned RemoteEvent::senderID_
    engine->RegisterObjectProperty(className, "uint senderID", offsetof(T, senderID_));

    // StringHash RemoteEvent::eventType_
    engine->RegisterObjectProperty(className, "StringHash eventType", offsetof(T, eventType_));

    // VariantMap RemoteEvent::eventData_
    engine->RegisterObjectProperty(className, "VariantMap eventData", offsetof(T, eventData_));

    // bool RemoteEvent::inOrder_
    engine->RegisterObjectProperty(className, "bool inOrder", offsetof(T, inOrder_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RemoteEvent
        REGISTER_MEMBERS_MANUAL_PART_RemoteEvent();
    #endif
}

#endif // def URHO3D_NETWORK

#ifdef URHO3D_PHYSICS

// struct DelayedWorldTransform | File: ../Physics/PhysicsWorld.h
template <class T> void RegisterMembers_DelayedWorldTransform(asIScriptEngine* engine, const char* className)
{
    // RigidBody* DelayedWorldTransform::rigidBody_
    // Not registered because pointer
    // RigidBody* DelayedWorldTransform::parentRigidBody_
    // Not registered because pointer

    // Vector3 DelayedWorldTransform::worldPosition_
    engine->RegisterObjectProperty(className, "Vector3 worldPosition", offsetof(T, worldPosition_));

    // Quaternion DelayedWorldTransform::worldRotation_
    engine->RegisterObjectProperty(className, "Quaternion worldRotation", offsetof(T, worldRotation_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DelayedWorldTransform
        REGISTER_MEMBERS_MANUAL_PART_DelayedWorldTransform();
    #endif
}

// struct ManifoldPair | File: ../Physics/PhysicsWorld.h
template <class T> void RegisterMembers_ManifoldPair(asIScriptEngine* engine, const char* className)
{
    // btPersistentManifold* ManifoldPair::manifold_
    // Not registered because pointer
    // btPersistentManifold* ManifoldPair::flippedManifold_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ManifoldPair
        REGISTER_MEMBERS_MANUAL_PART_ManifoldPair();
    #endif
}

// struct PhysicsRaycastResult | File: ../Physics/PhysicsWorld.h
template <class T> void RegisterMembers_PhysicsRaycastResult(asIScriptEngine* engine, const char* className)
{
    // bool PhysicsRaycastResult::operator !=(const PhysicsRaycastResult& rhs) const
    // Only operator == is needed

    // RigidBody* PhysicsRaycastResult::body_
    // Not registered because pointer

    // Vector3 PhysicsRaycastResult::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // Vector3 PhysicsRaycastResult::normal_
    engine->RegisterObjectProperty(className, "Vector3 normal", offsetof(T, normal_));

    // float PhysicsRaycastResult::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    // float PhysicsRaycastResult::hitFraction_
    engine->RegisterObjectProperty(className, "float hitFraction", offsetof(T, hitFraction_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PhysicsRaycastResult
        REGISTER_MEMBERS_MANUAL_PART_PhysicsRaycastResult();
    #endif
}

// struct PhysicsWorldConfig | File: ../Physics/PhysicsWorld.h
template <class T> void RegisterMembers_PhysicsWorldConfig(asIScriptEngine* engine, const char* className)
{
    // btCollisionConfiguration* PhysicsWorldConfig::collisionConfig_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PhysicsWorldConfig
        REGISTER_MEMBERS_MANUAL_PART_PhysicsWorldConfig();
    #endif
}

#endif // def URHO3D_PHYSICS

#ifdef URHO3D_URHO2D

// struct DelayedWorldTransform2D | File: ../Urho2D/PhysicsWorld2D.h
template <class T> void RegisterMembers_DelayedWorldTransform2D(asIScriptEngine* engine, const char* className)
{
    // RigidBody2D* DelayedWorldTransform2D::rigidBody_
    // Not registered because pointer
    // RigidBody2D* DelayedWorldTransform2D::parentRigidBody_
    // Not registered because pointer

    // Vector3 DelayedWorldTransform2D::worldPosition_
    engine->RegisterObjectProperty(className, "Vector3 worldPosition", offsetof(T, worldPosition_));

    // Quaternion DelayedWorldTransform2D::worldRotation_
    engine->RegisterObjectProperty(className, "Quaternion worldRotation", offsetof(T, worldRotation_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DelayedWorldTransform2D
        REGISTER_MEMBERS_MANUAL_PART_DelayedWorldTransform2D();
    #endif
}

// struct Particle2D | File: ../Urho2D/ParticleEmitter2D.h
template <class T> void RegisterMembers_Particle2D(asIScriptEngine* engine, const char* className)
{
    // float Particle2D::timeToLive_
    engine->RegisterObjectProperty(className, "float timeToLive", offsetof(T, timeToLive_));

    // Vector3 Particle2D::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // float Particle2D::size_
    engine->RegisterObjectProperty(className, "float size", offsetof(T, size_));

    // float Particle2D::sizeDelta_
    engine->RegisterObjectProperty(className, "float sizeDelta", offsetof(T, sizeDelta_));

    // float Particle2D::rotation_
    engine->RegisterObjectProperty(className, "float rotation", offsetof(T, rotation_));

    // float Particle2D::rotationDelta_
    engine->RegisterObjectProperty(className, "float rotationDelta", offsetof(T, rotationDelta_));

    // Color Particle2D::color_
    engine->RegisterObjectProperty(className, "Color color", offsetof(T, color_));

    // Color Particle2D::colorDelta_
    engine->RegisterObjectProperty(className, "Color colorDelta", offsetof(T, colorDelta_));

    // Vector2 Particle2D::startPos_
    engine->RegisterObjectProperty(className, "Vector2 startPos", offsetof(T, startPos_));

    // Vector2 Particle2D::velocity_
    engine->RegisterObjectProperty(className, "Vector2 velocity", offsetof(T, velocity_));

    // float Particle2D::radialAcceleration_
    engine->RegisterObjectProperty(className, "float radialAcceleration", offsetof(T, radialAcceleration_));

    // float Particle2D::tangentialAcceleration_
    engine->RegisterObjectProperty(className, "float tangentialAcceleration", offsetof(T, tangentialAcceleration_));

    // float Particle2D::emitRadius_
    engine->RegisterObjectProperty(className, "float emitRadius", offsetof(T, emitRadius_));

    // float Particle2D::emitRadiusDelta_
    engine->RegisterObjectProperty(className, "float emitRadiusDelta", offsetof(T, emitRadiusDelta_));

    // float Particle2D::emitRotation_
    engine->RegisterObjectProperty(className, "float emitRotation", offsetof(T, emitRotation_));

    // float Particle2D::emitRotationDelta_
    engine->RegisterObjectProperty(className, "float emitRotationDelta", offsetof(T, emitRotationDelta_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Particle2D
        REGISTER_MEMBERS_MANUAL_PART_Particle2D();
    #endif
}

// struct PhysicsRaycastResult2D | File: ../Urho2D/PhysicsWorld2D.h
template <class T> void RegisterMembers_PhysicsRaycastResult2D(asIScriptEngine* engine, const char* className)
{
    // bool PhysicsRaycastResult2D::operator !=(const PhysicsRaycastResult2D& rhs) const
    // Only operator == is needed

    // RigidBody2D* PhysicsRaycastResult2D::body_
    // Not registered because pointer

    // Vector2 PhysicsRaycastResult2D::position_
    engine->RegisterObjectProperty(className, "Vector2 position", offsetof(T, position_));

    // Vector2 PhysicsRaycastResult2D::normal_
    engine->RegisterObjectProperty(className, "Vector2 normal", offsetof(T, normal_));

    // float PhysicsRaycastResult2D::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PhysicsRaycastResult2D
        REGISTER_MEMBERS_MANUAL_PART_PhysicsRaycastResult2D();
    #endif
}

// struct SourceBatch2D | File: ../Urho2D/Drawable2D.h
template <class T> void RegisterMembers_SourceBatch2D(asIScriptEngine* engine, const char* className)
{
    // WeakPtr<Drawable2D> SourceBatch2D::owner_
    // Error: type "WeakPtr<Drawable2D>" can not automatically bind
    // SharedPtr<Material> SourceBatch2D::material_
    // Error: type "SharedPtr<Material>" can not automatically bind
    // Vector<Vertex2D> SourceBatch2D::vertices_
    // Error: type "Vector<Vertex2D>" can not automatically bind

    // float SourceBatch2D::distance_
    engine->RegisterObjectProperty(className, "float distance", offsetof(T, distance_));

    // int SourceBatch2D::drawOrder_
    engine->RegisterObjectProperty(className, "int drawOrder", offsetof(T, drawOrder_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SourceBatch2D
        REGISTER_MEMBERS_MANUAL_PART_SourceBatch2D();
    #endif
}

// struct TileMapInfo2D | File: ../Urho2D/TileMapDefs2D.h
template <class T> void RegisterMembers_TileMapInfo2D(asIScriptEngine* engine, const char* className)
{
    // Vector2 TileMapInfo2D::ConvertPosition(const Vector2& position) const
    engine->RegisterObjectMethod(className, "Vector2 ConvertPosition(const Vector2&in) const", AS_METHODPR(T, ConvertPosition, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // float TileMapInfo2D::GetMapHeight() const
    engine->RegisterObjectMethod(className, "float GetMapHeight() const", AS_METHODPR(T, GetMapHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mapHeight() const", AS_METHODPR(T, GetMapHeight, () const, float), AS_CALL_THISCALL);

    // float TileMapInfo2D::GetMapWidth() const
    engine->RegisterObjectMethod(className, "float GetMapWidth() const", AS_METHODPR(T, GetMapWidth, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mapWidth() const", AS_METHODPR(T, GetMapWidth, () const, float), AS_CALL_THISCALL);

    // bool TileMapInfo2D::PositionToTileIndex(int& x, int& y, const Vector2& position) const
    engine->RegisterObjectMethod(className, "bool PositionToTileIndex(int&, int&, const Vector2&in) const", AS_METHODPR(T, PositionToTileIndex, (int&, int&, const Vector2&) const, bool), AS_CALL_THISCALL);

    // Vector2 TileMapInfo2D::TileIndexToPosition(int x, int y) const
    engine->RegisterObjectMethod(className, "Vector2 TileIndexToPosition(int, int) const", AS_METHODPR(T, TileIndexToPosition, (int, int) const, Vector2), AS_CALL_THISCALL);

    // Orientation2D TileMapInfo2D::orientation_
    engine->RegisterObjectProperty(className, "Orientation2D orientation", offsetof(T, orientation_));

    // int TileMapInfo2D::width_
    engine->RegisterObjectProperty(className, "int width", offsetof(T, width_));

    // int TileMapInfo2D::height_
    engine->RegisterObjectProperty(className, "int height", offsetof(T, height_));

    // float TileMapInfo2D::tileWidth_
    engine->RegisterObjectProperty(className, "float tileWidth", offsetof(T, tileWidth_));

    // float TileMapInfo2D::tileHeight_
    engine->RegisterObjectProperty(className, "float tileHeight", offsetof(T, tileHeight_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TileMapInfo2D
        REGISTER_MEMBERS_MANUAL_PART_TileMapInfo2D();
    #endif
}

// struct Vertex2D | File: ../Urho2D/Drawable2D.h
template <class T> void RegisterMembers_Vertex2D(asIScriptEngine* engine, const char* className)
{
    // Vector3 Vertex2D::position_
    engine->RegisterObjectProperty(className, "Vector3 position", offsetof(T, position_));

    // unsigned Vertex2D::color_
    engine->RegisterObjectProperty(className, "uint color", offsetof(T, color_));

    // Vector2 Vertex2D::uv_
    engine->RegisterObjectProperty(className, "Vector2 uv", offsetof(T, uv_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Vertex2D
        REGISTER_MEMBERS_MANUAL_PART_Vertex2D();
    #endif
}

// struct ViewBatchInfo2D | File: ../Urho2D/Renderer2D.h
template <class T> void RegisterMembers_ViewBatchInfo2D(asIScriptEngine* engine, const char* className)
{
    // SharedPtr<VertexBuffer> ViewBatchInfo2D::vertexBuffer_
    // Error: type "SharedPtr<VertexBuffer>" can not automatically bind
    // PODVector<const SourceBatch2D*> ViewBatchInfo2D::sourceBatches_
    // Error: type "PODVector<const SourceBatch2D*>" can not automatically bind
    // PODVector<float> ViewBatchInfo2D::distances_
    // Error: type "PODVector<float>" can not automatically bind
    // Vector<SharedPtr<Material>> ViewBatchInfo2D::materials_
    // Error: type "Vector<SharedPtr<Material>>" can not automatically bind
    // Vector<SharedPtr<Geometry>> ViewBatchInfo2D::geometries_
    // Error: type "Vector<SharedPtr<Geometry>>" can not automatically bind

    // unsigned ViewBatchInfo2D::vertexBufferUpdateFrameNumber_
    engine->RegisterObjectProperty(className, "uint vertexBufferUpdateFrameNumber", offsetof(T, vertexBufferUpdateFrameNumber_));

    // unsigned ViewBatchInfo2D::indexCount_
    engine->RegisterObjectProperty(className, "uint indexCount", offsetof(T, indexCount_));

    // unsigned ViewBatchInfo2D::vertexCount_
    engine->RegisterObjectProperty(className, "uint vertexCount", offsetof(T, vertexCount_));

    // unsigned ViewBatchInfo2D::batchUpdatedFrameNumber_
    engine->RegisterObjectProperty(className, "uint batchUpdatedFrameNumber", offsetof(T, batchUpdatedFrameNumber_));

    // unsigned ViewBatchInfo2D::batchCount_
    engine->RegisterObjectProperty(className, "uint batchCount", offsetof(T, batchCount_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ViewBatchInfo2D
        REGISTER_MEMBERS_MANUAL_PART_ViewBatchInfo2D();
    #endif
}

#endif // def URHO3D_URHO2D

// class AbstractFile | File: ../IO/AbstractFile.h
template <class T> void RegisterMembers_AbstractFile(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Deserializer<T>(engine, className);
    RegisterMembers_Serializer<T>(engine, className);

    // virtual void AbstractFile::SetName(const String& name)
    engine->RegisterObjectMethod(className, "void SetName(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_name(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AbstractFile
        REGISTER_MEMBERS_MANUAL_PART_AbstractFile();
    #endif
}

// class AllContentOctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_AllContentOctreeQuery(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_OctreeQuery<T>(engine, className);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AllContentOctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_AllContentOctreeQuery();
    #endif
}

// class AnimationState | File: ../Graphics/AnimationState.h
template <class T> void RegisterMembers_AnimationState(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // void AnimationState::AddTime(float delta)
    engine->RegisterObjectMethod(className, "void AddTime(float)", AS_METHODPR(T, AddTime, (float), void), AS_CALL_THISCALL);

    // void AnimationState::AddWeight(float delta)
    engine->RegisterObjectMethod(className, "void AddWeight(float)", AS_METHODPR(T, AddWeight, (float), void), AS_CALL_THISCALL);

    // void AnimationState::Apply()
    engine->RegisterObjectMethod(className, "void Apply()", AS_METHODPR(T, Apply, (), void), AS_CALL_THISCALL);

    // Animation* AnimationState::GetAnimation() const
    engine->RegisterObjectMethod(className, "Animation@+ GetAnimation() const", AS_METHODPR(T, GetAnimation, () const, Animation*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Animation@+ get_animation() const", AS_METHODPR(T, GetAnimation, () const, Animation*), AS_CALL_THISCALL);

    // AnimationBlendMode AnimationState::GetBlendMode() const
    engine->RegisterObjectMethod(className, "AnimationBlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, AnimationBlendMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AnimationBlendMode get_blendMode() const", AS_METHODPR(T, GetBlendMode, () const, AnimationBlendMode), AS_CALL_THISCALL);

    // float AnimationState::GetBoneWeight(unsigned index) const
    engine->RegisterObjectMethod(className, "float GetBoneWeight(uint) const", AS_METHODPR(T, GetBoneWeight, (unsigned) const, float), AS_CALL_THISCALL);

    // float AnimationState::GetBoneWeight(const String& name) const
    engine->RegisterObjectMethod(className, "float GetBoneWeight(const String&in) const", AS_METHODPR(T, GetBoneWeight, (const String&) const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_boneWeights(const String&in) const", AS_METHODPR(T, GetBoneWeight, (const String&) const, float), AS_CALL_THISCALL);

    // float AnimationState::GetBoneWeight(StringHash nameHash) const
    engine->RegisterObjectMethod(className, "float GetBoneWeight(StringHash) const", AS_METHODPR(T, GetBoneWeight, (StringHash) const, float), AS_CALL_THISCALL);

    // unsigned char AnimationState::GetLayer() const
    engine->RegisterObjectMethod(className, "uint8 GetLayer() const", AS_METHODPR(T, GetLayer, () const, unsigned char), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint8 get_layer() const", AS_METHODPR(T, GetLayer, () const, unsigned char), AS_CALL_THISCALL);

    // float AnimationState::GetLength() const
    engine->RegisterObjectMethod(className, "float GetLength() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);

    // AnimatedModel* AnimationState::GetModel() const
    engine->RegisterObjectMethod(className, "AnimatedModel@+ GetModel() const", AS_METHODPR(T, GetModel, () const, AnimatedModel*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AnimatedModel@+ get_model() const", AS_METHODPR(T, GetModel, () const, AnimatedModel*), AS_CALL_THISCALL);

    // Node* AnimationState::GetNode() const
    engine->RegisterObjectMethod(className, "Node@+ GetNode() const", AS_METHODPR(T, GetNode, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_node() const", AS_METHODPR(T, GetNode, () const, Node*), AS_CALL_THISCALL);

    // Bone* AnimationState::GetStartBone() const
    engine->RegisterObjectMethod(className, "Bone@+ GetStartBone() const", AS_METHODPR(T, GetStartBone, () const, Bone*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Bone@+ get_startBone() const", AS_METHODPR(T, GetStartBone, () const, Bone*), AS_CALL_THISCALL);

    // float AnimationState::GetTime() const
    engine->RegisterObjectMethod(className, "float GetTime() const", AS_METHODPR(T, GetTime, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_time() const", AS_METHODPR(T, GetTime, () const, float), AS_CALL_THISCALL);

    // unsigned AnimationState::GetTrackIndex(Node* node) const
    engine->RegisterObjectMethod(className, "uint GetTrackIndex(Node@+) const", AS_METHODPR(T, GetTrackIndex, (Node*) const, unsigned), AS_CALL_THISCALL);

    // unsigned AnimationState::GetTrackIndex(const String& name) const
    engine->RegisterObjectMethod(className, "uint GetTrackIndex(const String&in) const", AS_METHODPR(T, GetTrackIndex, (const String&) const, unsigned), AS_CALL_THISCALL);

    // unsigned AnimationState::GetTrackIndex(StringHash nameHash) const
    engine->RegisterObjectMethod(className, "uint GetTrackIndex(StringHash) const", AS_METHODPR(T, GetTrackIndex, (StringHash) const, unsigned), AS_CALL_THISCALL);

    // float AnimationState::GetWeight() const
    engine->RegisterObjectMethod(className, "float GetWeight() const", AS_METHODPR(T, GetWeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_weight() const", AS_METHODPR(T, GetWeight, () const, float), AS_CALL_THISCALL);

    // bool AnimationState::IsEnabled() const
    engine->RegisterObjectMethod(className, "bool IsEnabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);

    // bool AnimationState::IsLooped() const
    engine->RegisterObjectMethod(className, "bool IsLooped() const", AS_METHODPR(T, IsLooped, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_looped() const", AS_METHODPR(T, IsLooped, () const, bool), AS_CALL_THISCALL);

    // void AnimationState::SetBlendMode(AnimationBlendMode mode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(AnimationBlendMode)", AS_METHODPR(T, SetBlendMode, (AnimationBlendMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(AnimationBlendMode)", AS_METHODPR(T, SetBlendMode, (AnimationBlendMode), void), AS_CALL_THISCALL);

    // void AnimationState::SetBoneWeight(unsigned index, float weight, bool recursive = false)
    engine->RegisterObjectMethod(className, "void SetBoneWeight(uint, float, bool = false)", AS_METHODPR(T, SetBoneWeight, (unsigned, float, bool), void), AS_CALL_THISCALL);

    // void AnimationState::SetBoneWeight(const String& name, float weight, bool recursive = false)
    engine->RegisterObjectMethod(className, "void SetBoneWeight(const String&in, float, bool = false)", AS_METHODPR(T, SetBoneWeight, (const String&, float, bool), void), AS_CALL_THISCALL);

    // void AnimationState::SetBoneWeight(StringHash nameHash, float weight, bool recursive = false)
    engine->RegisterObjectMethod(className, "void SetBoneWeight(StringHash, float, bool = false)", AS_METHODPR(T, SetBoneWeight, (StringHash, float, bool), void), AS_CALL_THISCALL);

    // void AnimationState::SetLayer(unsigned char layer)
    engine->RegisterObjectMethod(className, "void SetLayer(uint8)", AS_METHODPR(T, SetLayer, (unsigned char), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layer(uint8)", AS_METHODPR(T, SetLayer, (unsigned char), void), AS_CALL_THISCALL);

    // void AnimationState::SetLooped(bool looped)
    engine->RegisterObjectMethod(className, "void SetLooped(bool)", AS_METHODPR(T, SetLooped, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_looped(bool)", AS_METHODPR(T, SetLooped, (bool), void), AS_CALL_THISCALL);

    // void AnimationState::SetStartBone(Bone* startBone)
    engine->RegisterObjectMethod(className, "void SetStartBone(Bone@+)", AS_METHODPR(T, SetStartBone, (Bone*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_startBone(Bone@+)", AS_METHODPR(T, SetStartBone, (Bone*), void), AS_CALL_THISCALL);

    // void AnimationState::SetTime(float time)
    engine->RegisterObjectMethod(className, "void SetTime(float)", AS_METHODPR(T, SetTime, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_time(float)", AS_METHODPR(T, SetTime, (float), void), AS_CALL_THISCALL);

    // void AnimationState::SetWeight(float weight)
    engine->RegisterObjectMethod(className, "void SetWeight(float)", AS_METHODPR(T, SetWeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_weight(float)", AS_METHODPR(T, SetWeight, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationState
        REGISTER_MEMBERS_MANUAL_PART_AnimationState();
    #endif
}

// class AttributeAccessor | File: ../Core/Attribute.h
template <class T> void RegisterMembers_AttributeAccessor(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // virtual void AttributeAccessor::Get(const Serializable* ptr, Variant& dest) const = 0
    engine->RegisterObjectMethod(className, "void Get(Serializable@+, Variant&) const", AS_METHODPR(T, Get, (const Serializable*, Variant&) const, void), AS_CALL_THISCALL);

    // virtual void AttributeAccessor::Set(Serializable* ptr, const Variant& src) = 0
    engine->RegisterObjectMethod(className, "void Set(Serializable@+, const Variant&in)", AS_METHODPR(T, Set, (Serializable*, const Variant&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AttributeAccessor
        REGISTER_MEMBERS_MANUAL_PART_AttributeAccessor();
    #endif
}

// class BackgroundLoader | File: ../Resource/BackgroundLoader.h
template <class T> void RegisterMembers_BackgroundLoader(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);
    RegisterMembers_Thread<T>(engine, className);

    // void BackgroundLoader::FinishResources(int maxMs)
    engine->RegisterObjectMethod(className, "void FinishResources(int)", AS_METHODPR(T, FinishResources, (int), void), AS_CALL_THISCALL);

    // unsigned BackgroundLoader::GetNumQueuedResources() const
    engine->RegisterObjectMethod(className, "uint GetNumQueuedResources() const", AS_METHODPR(T, GetNumQueuedResources, () const, unsigned), AS_CALL_THISCALL);

    // bool BackgroundLoader::QueueResource(StringHash type, const String& name, bool sendEventOnFailure, Resource* caller)
    engine->RegisterObjectMethod(className, "bool QueueResource(StringHash, const String&in, bool, Resource@+)", AS_METHODPR(T, QueueResource, (StringHash, const String&, bool, Resource*), bool), AS_CALL_THISCALL);

    // void BackgroundLoader::WaitForResource(StringHash type, StringHash nameHash)
    engine->RegisterObjectMethod(className, "void WaitForResource(StringHash, StringHash)", AS_METHODPR(T, WaitForResource, (StringHash, StringHash), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BackgroundLoader
        REGISTER_MEMBERS_MANUAL_PART_BackgroundLoader();
    #endif
}

// struct BatchGroup | File: ../Graphics/Batch.h
template <class T> void RegisterMembers_BatchGroup(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Batch<T>(engine, className);

    // void BatchGroup::SetInstancingData(void* lockedData, unsigned stride, unsigned& freeIndex)
    // Error: type "void*" can not automatically bind

    // void BatchGroup::AddTransforms(const Batch& batch)
    engine->RegisterObjectMethod(className, "void AddTransforms(const Batch&in)", AS_METHODPR(T, AddTransforms, (const Batch&), void), AS_CALL_THISCALL);

    // PODVector<InstanceData> BatchGroup::instances_
    // Error: type "PODVector<InstanceData>" can not automatically bind

    // unsigned BatchGroup::startIndex_
    engine->RegisterObjectProperty(className, "uint startIndex", offsetof(T, startIndex_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BatchGroup
        REGISTER_MEMBERS_MANUAL_PART_BatchGroup();
    #endif
}

// class BoxOctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_BoxOctreeQuery(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_OctreeQuery<T>(engine, className);

    // BoundingBox BoxOctreeQuery::box_
    engine->RegisterObjectProperty(className, "BoundingBox box", offsetof(T, box_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BoxOctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_BoxOctreeQuery();
    #endif
}

// struct ComponentReplicationState | File: ../Scene/ReplicationState.h
template <class T> void RegisterMembers_ComponentReplicationState(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ReplicationState<T>(engine, className);

    // NodeReplicationState* ComponentReplicationState::nodeState_
    // Not registered because pointer
    // WeakPtr<Component> ComponentReplicationState::component_
    // Error: type "WeakPtr<Component>" can not automatically bind

    // DirtyBits ComponentReplicationState::dirtyAttributes_
    engine->RegisterObjectProperty(className, "DirtyBits dirtyAttributes", offsetof(T, dirtyAttributes_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ComponentReplicationState
        REGISTER_MEMBERS_MANUAL_PART_ComponentReplicationState();
    #endif
}

// SharedPtr<Object> Context::CreateObject(StringHash objectType)
template <class T> Object* Context_SharedPtrlesObjectgre_CreateObject_StringHash_template(T* _ptr, StringHash objectType)
{
    SharedPtr<Object> result = _ptr->CreateObject(objectType);
    return result.Detach();
}

// class Context | File: ../Core/Context.h
template <class T> void RegisterMembers_Context(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // const HashMap<StringHash, Vector<AttributeInfo>>& Context::GetAllAttributes() const
    // Error: type "const HashMap<StringHash, Vector<AttributeInfo>>&" can not automatically bind
    // AttributeInfo* Context::GetAttribute(StringHash objectType, const char* name)
    // Error: type "const char*" can not automatically bind
    // const Vector<AttributeInfo>* Context::GetAttributes(StringHash type) const
    // Error: type "const Vector<AttributeInfo>*" can not automatically bind
    // EventHandler* Context::GetEventHandler() const
    // Error: type "EventHandler" can not bind bacause abstract value
    // const Vector<AttributeInfo>* Context::GetNetworkAttributes(StringHash type) const
    // Error: type "const Vector<AttributeInfo>*" can not automatically bind
    // const HashMap<String, Vector<StringHash>>& Context::GetObjectCategories() const
    // Error: type "const HashMap<String, Vector<StringHash>>&" can not automatically bind
    // const HashMap<StringHash, SharedPtr<ObjectFactory>>& Context::GetObjectFactories() const
    // Error: type "const HashMap<StringHash, SharedPtr<ObjectFactory>>&" can not automatically bind
    // const HashMap<StringHash, SharedPtr<Object>>& Context::GetSubsystems() const
    // Error: type "const HashMap<StringHash, SharedPtr<Object>>&" can not automatically bind
    // AttributeHandle Context::RegisterAttribute(StringHash objectType, const AttributeInfo& attr)
    // Error: type "AttributeHandle" can not automatically bind bacause have @nobind mark
    // void Context::RegisterFactory(ObjectFactory* factory, const char* category)
    // Error: type "const char*" can not automatically bind
    // void Context::RemoveAttribute(StringHash objectType, const char* name)
    // Error: type "const char*" can not automatically bind
    // void Context::UpdateAttributeDefaultValue(StringHash objectType, const char* name, const Variant& defaultValue)
    // Error: type "const char*" can not automatically bind

    // void Context::CopyBaseAttributes(StringHash baseType, StringHash derivedType)
    engine->RegisterObjectMethod(className, "void CopyBaseAttributes(StringHash, StringHash)", AS_METHODPR(T, CopyBaseAttributes, (StringHash, StringHash), void), AS_CALL_THISCALL);

    // SharedPtr<Object> Context::CreateObject(StringHash objectType)
    engine->RegisterObjectMethod(className, "Object@+ CreateObject(StringHash)", AS_FUNCTION_OBJFIRST(Context_SharedPtrlesObjectgre_CreateObject_StringHash_template<Context>), AS_CALL_CDECL_OBJFIRST);

    // VariantMap& Context::GetEventDataMap()
    engine->RegisterObjectMethod(className, "VariantMap& GetEventDataMap()", AS_METHODPR(T, GetEventDataMap, (), VariantMap&), AS_CALL_THISCALL);

    // EventReceiverGroup* Context::GetEventReceivers(Object* sender, StringHash eventType)
    engine->RegisterObjectMethod(className, "EventReceiverGroup@+ GetEventReceivers(Object@+, StringHash)", AS_METHODPR(T, GetEventReceivers, (Object*, StringHash), EventReceiverGroup*), AS_CALL_THISCALL);

    // EventReceiverGroup* Context::GetEventReceivers(StringHash eventType)
    engine->RegisterObjectMethod(className, "EventReceiverGroup@+ GetEventReceivers(StringHash)", AS_METHODPR(T, GetEventReceivers, (StringHash), EventReceiverGroup*), AS_CALL_THISCALL);

    // Object* Context::GetEventSender() const
    engine->RegisterObjectMethod(className, "Object@+ GetEventSender() const", AS_METHODPR(T, GetEventSender, () const, Object*), AS_CALL_THISCALL);

    // const Variant& Context::GetGlobalVar(StringHash key) const
    engine->RegisterObjectMethod(className, "const Variant& GetGlobalVar(StringHash) const", AS_METHODPR(T, GetGlobalVar, (StringHash) const, const Variant&), AS_CALL_THISCALL);

    // const VariantMap& Context::GetGlobalVars() const
    engine->RegisterObjectMethod(className, "const VariantMap& GetGlobalVars() const", AS_METHODPR(T, GetGlobalVars, () const, const VariantMap&), AS_CALL_THISCALL);

    // Object* Context::GetSubsystem(StringHash type) const
    engine->RegisterObjectMethod(className, "Object@+ GetSubsystem(StringHash) const", AS_METHODPR(T, GetSubsystem, (StringHash) const, Object*), AS_CALL_THISCALL);

    // const String& Context::GetTypeName(StringHash objectType) const
    engine->RegisterObjectMethod(className, "const String& GetTypeName(StringHash) const", AS_METHODPR(T, GetTypeName, (StringHash) const, const String&), AS_CALL_THISCALL);

    // void Context::RegisterFactory(ObjectFactory* factory)
    engine->RegisterObjectMethod(className, "void RegisterFactory(ObjectFactory@+)", AS_METHODPR(T, RegisterFactory, (ObjectFactory*), void), AS_CALL_THISCALL);

    // void Context::RegisterSubsystem(Object* object)
    engine->RegisterObjectMethod(className, "void RegisterSubsystem(Object@+)", AS_METHODPR(T, RegisterSubsystem, (Object*), void), AS_CALL_THISCALL);

    // void Context::ReleaseSDL()
    engine->RegisterObjectMethod(className, "void ReleaseSDL()", AS_METHODPR(T, ReleaseSDL, (), void), AS_CALL_THISCALL);

    // void Context::RemoveAllAttributes(StringHash objectType)
    engine->RegisterObjectMethod(className, "void RemoveAllAttributes(StringHash)", AS_METHODPR(T, RemoveAllAttributes, (StringHash), void), AS_CALL_THISCALL);

    // void Context::RemoveSubsystem(StringHash objectType)
    engine->RegisterObjectMethod(className, "void RemoveSubsystem(StringHash)", AS_METHODPR(T, RemoveSubsystem, (StringHash), void), AS_CALL_THISCALL);

    // bool Context::RequireSDL(unsigned int sdlFlags)
    engine->RegisterObjectMethod(className, "bool RequireSDL(uint)", AS_METHODPR(T, RequireSDL, (unsigned int), bool), AS_CALL_THISCALL);

    // void Context::SetGlobalVar(StringHash key, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetGlobalVar(StringHash, const Variant&in)", AS_METHODPR(T, SetGlobalVar, (StringHash, const Variant&), void), AS_CALL_THISCALL);

    // template <class T, class U> void Context::CopyBaseAttributes()
    // Not registered because template
    // template <class T> SharedPtr<T> Context::CreateObject()
    // Not registered because template
    // template <class T> AttributeInfo* Context::GetAttribute(const char* name)
    // Not registered because template
    // template <class T> T* Context::GetSubsystem() const
    // Not registered because template
    // template <class T> AttributeHandle Context::RegisterAttribute(const AttributeInfo& attr)
    // Not registered because template
    // template <class T> void Context::RegisterFactory()
    // Not registered because template
    // template <class T> void Context::RegisterFactory(const char* category)
    // Not registered because template
    // template <class T> T* Context::RegisterSubsystem()
    // Not registered because template
    // template <class T> void Context::RemoveAllAttributes()
    // Not registered because template
    // template <class T> void Context::RemoveAttribute(const char* name)
    // Not registered because template
    // template <class T> void Context::RemoveSubsystem()
    // Not registered because template
    // template <class T> void Context::UpdateAttributeDefaultValue(const char* name, const Variant& defaultValue)
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Context
        REGISTER_MEMBERS_MANUAL_PART_Context();
    #endif
}

// class EventHandler | File: ../Core/Object.h
template <class T> void RegisterMembers_EventHandler(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_LinkedListNode<T>(engine, className);

    // virtual EventHandler* EventHandler::Clone() const = 0
    // Error: type "EventHandler" can not bind bacause abstract value
    // void* EventHandler::GetUserData() const
    // Error: type "void*" can not automatically bind

    // const StringHash& EventHandler::GetEventType() const
    engine->RegisterObjectMethod(className, "const StringHash& GetEventType() const", AS_METHODPR(T, GetEventType, () const, const StringHash&), AS_CALL_THISCALL);

    // Object* EventHandler::GetReceiver() const
    engine->RegisterObjectMethod(className, "Object@+ GetReceiver() const", AS_METHODPR(T, GetReceiver, () const, Object*), AS_CALL_THISCALL);

    // Object* EventHandler::GetSender() const
    engine->RegisterObjectMethod(className, "Object@+ GetSender() const", AS_METHODPR(T, GetSender, () const, Object*), AS_CALL_THISCALL);

    // virtual void EventHandler::Invoke(VariantMap& eventData) = 0
    engine->RegisterObjectMethod(className, "void Invoke(VariantMap&)", AS_METHODPR(T, Invoke, (VariantMap&), void), AS_CALL_THISCALL);

    // void EventHandler::SetSenderAndEventType(Object* sender, StringHash eventType)
    engine->RegisterObjectMethod(className, "void SetSenderAndEventType(Object@+, StringHash)", AS_METHODPR(T, SetSenderAndEventType, (Object*, StringHash), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_EventHandler
        REGISTER_MEMBERS_MANUAL_PART_EventHandler();
    #endif
}

// class EventProfilerBlock | File: ../Core/EventProfiler.h
template <class T> void RegisterMembers_EventProfilerBlock(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ProfilerBlock<T>(engine, className);

    // EventProfilerBlock* EventProfilerBlock::GetChild(StringHash eventID)
    // Error: type "EventProfilerBlock" can not automatically bind bacause have @nobind mark

    // StringHash EventProfilerBlock::eventID_
    engine->RegisterObjectProperty(className, "StringHash eventID", offsetof(T, eventID_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_EventProfilerBlock
        REGISTER_MEMBERS_MANUAL_PART_EventProfilerBlock();
    #endif
}

// class EventReceiverGroup | File: ../Core/Context.h
template <class T> void RegisterMembers_EventReceiverGroup(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // void EventReceiverGroup::Add(Object* object)
    engine->RegisterObjectMethod(className, "void Add(Object@+)", AS_METHODPR(T, Add, (Object*), void), AS_CALL_THISCALL);

    // void EventReceiverGroup::BeginSendEvent()
    engine->RegisterObjectMethod(className, "void BeginSendEvent()", AS_METHODPR(T, BeginSendEvent, (), void), AS_CALL_THISCALL);

    // void EventReceiverGroup::EndSendEvent()
    engine->RegisterObjectMethod(className, "void EndSendEvent()", AS_METHODPR(T, EndSendEvent, (), void), AS_CALL_THISCALL);

    // void EventReceiverGroup::Remove(Object* object)
    engine->RegisterObjectMethod(className, "void Remove(Object@+)", AS_METHODPR(T, Remove, (Object*), void), AS_CALL_THISCALL);

    // PODVector<Object*> EventReceiverGroup::receivers_
    // Error: type "PODVector<Object*>" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_EventReceiverGroup
        REGISTER_MEMBERS_MANUAL_PART_EventReceiverGroup();
    #endif
}

// const Vector<SharedPtr<Texture2D>>& FontFace::GetTextures() const
template <class T> CScriptArray* FontFace_constspVectorlesSharedPtrlesTexture2Dgregreamp_GetTextures_void_template(T* _ptr)
{
    const Vector<SharedPtr<Texture2D>>& result = _ptr->GetTextures();
    return VectorToHandleArray(result, "Array<Texture2D@>");
}

// class FontFace | File: ../UI/FontFace.h
template <class T> void RegisterMembers_FontFace(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // virtual const FontGlyph* FontFace::GetGlyph(unsigned c)
    // Error: type "const FontGlyph*" can not automatically bind
    // virtual bool FontFace::Load(const unsigned char* fontData, unsigned fontDataSize, float pointSize) = 0
    // Error: type "const unsigned char*" can not automatically bind

    // float FontFace::GetKerning(unsigned c, unsigned d) const
    engine->RegisterObjectMethod(className, "float GetKerning(uint, uint) const", AS_METHODPR(T, GetKerning, (unsigned, unsigned) const, float), AS_CALL_THISCALL);

    // float FontFace::GetPointSize() const
    engine->RegisterObjectMethod(className, "float GetPointSize() const", AS_METHODPR(T, GetPointSize, () const, float), AS_CALL_THISCALL);

    // float FontFace::GetRowHeight() const
    engine->RegisterObjectMethod(className, "float GetRowHeight() const", AS_METHODPR(T, GetRowHeight, () const, float), AS_CALL_THISCALL);

    // const Vector<SharedPtr<Texture2D>>& FontFace::GetTextures() const
    engine->RegisterObjectMethod(className, "Array<Texture2D@>@ GetTextures() const", AS_FUNCTION_OBJFIRST(FontFace_constspVectorlesSharedPtrlesTexture2Dgregreamp_GetTextures_void_template<FontFace>), AS_CALL_CDECL_OBJFIRST);

    // virtual bool FontFace::HasMutableGlyphs() const
    engine->RegisterObjectMethod(className, "bool HasMutableGlyphs() const", AS_METHODPR(T, HasMutableGlyphs, () const, bool), AS_CALL_THISCALL);

    // bool FontFace::IsDataLost() const
    engine->RegisterObjectMethod(className, "bool IsDataLost() const", AS_METHODPR(T, IsDataLost, () const, bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FontFace
        REGISTER_MEMBERS_MANUAL_PART_FontFace();
    #endif
}

// class FrustumOctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_FrustumOctreeQuery(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_OctreeQuery<T>(engine, className);

    // Frustum FrustumOctreeQuery::frustum_
    engine->RegisterObjectProperty(className, "Frustum frustum", offsetof(T, frustum_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FrustumOctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_FrustumOctreeQuery();
    #endif
}

// struct NodeReplicationState | File: ../Scene/ReplicationState.h
template <class T> void RegisterMembers_NodeReplicationState(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ReplicationState<T>(engine, className);

    // SceneReplicationState* NodeReplicationState::sceneState_
    // Not registered because pointer
    // WeakPtr<Node> NodeReplicationState::node_
    // Error: type "WeakPtr<Node>" can not automatically bind
    // HashSet<StringHash> NodeReplicationState::dirtyVars_
    // Error: type "HashSet<StringHash>" can not automatically bind
    // HashMap<unsigned, ComponentReplicationState> NodeReplicationState::componentStates_
    // Error: type "HashMap<unsigned, ComponentReplicationState>" can not automatically bind

    // DirtyBits NodeReplicationState::dirtyAttributes_
    engine->RegisterObjectProperty(className, "DirtyBits dirtyAttributes", offsetof(T, dirtyAttributes_));

    // float NodeReplicationState::priorityAcc_
    engine->RegisterObjectProperty(className, "float priorityAcc", offsetof(T, priorityAcc_));

    // bool NodeReplicationState::markedDirty_
    engine->RegisterObjectProperty(className, "bool markedDirty", offsetof(T, markedDirty_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NodeReplicationState
        REGISTER_MEMBERS_MANUAL_PART_NodeReplicationState();
    #endif
}

// void Object::UnsubscribeFromAllEventsExcept(const PODVector<StringHash>& exceptions, bool onlyUserData)
template <class T> void Object_void_UnsubscribeFromAllEventsExcept_constspPODVectorlesStringHashgreamp_bool_template(T* _ptr, CScriptArray* exceptions_conv, bool onlyUserData)
{
    PODVector<StringHash> exceptions = ArrayToPODVector<StringHash>(exceptions_conv);
    _ptr->UnsubscribeFromAllEventsExcept(exceptions, onlyUserData);
}

// class Object | File: ../Core/Object.h
template <class T> void RegisterMembers_Object(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // Context* Object::GetContext() const
    // Error: type "Context*" can used only as function parameter
    // EventHandler* Object::GetEventHandler() const
    // Error: type "EventHandler" can not bind bacause abstract value
    // virtual const TypeInfo* Object::GetTypeInfo() const = 0
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // bool Object::IsInstanceOf(const TypeInfo* typeInfo) const
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark
    // void Object::SubscribeToEvent(StringHash eventType, EventHandler* handler)
    // Error: type "EventHandler" can not bind bacause abstract value
    // void Object::SubscribeToEvent(Object* sender, StringHash eventType, EventHandler* handler)
    // Error: type "EventHandler" can not bind bacause abstract value
    // void Object::SubscribeToEvent(StringHash eventType, const std::function<void(StringHash, VariantMap&)>& function, void* userData = nullptr)
    // Error: type "const std::function<void(StringHash, VariantMap&)>&" can not automatically bind
    // void Object::SubscribeToEvent(Object* sender, StringHash eventType, const std::function<void(StringHash, VariantMap&)>& function, void* userData = nullptr)
    // Error: type "const std::function<void(StringHash, VariantMap&)>&" can not automatically bind

    // bool Object::GetBlockEvents() const
    engine->RegisterObjectMethod(className, "bool GetBlockEvents() const", AS_METHODPR(T, GetBlockEvents, () const, bool), AS_CALL_THISCALL);

    // const String& Object::GetCategory() const
    engine->RegisterObjectMethod(className, "const String& GetCategory() const", AS_METHODPR(T, GetCategory, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_category() const", AS_METHODPR(T, GetCategory, () const, const String&), AS_CALL_THISCALL);

    // VariantMap& Object::GetEventDataMap() const
    engine->RegisterObjectMethod(className, "VariantMap& GetEventDataMap() const", AS_METHODPR(T, GetEventDataMap, () const, VariantMap&), AS_CALL_THISCALL);

    // Object* Object::GetEventSender() const
    engine->RegisterObjectMethod(className, "Object@+ GetEventSender() const", AS_METHODPR(T, GetEventSender, () const, Object*), AS_CALL_THISCALL);

    // const Variant& Object::GetGlobalVar(StringHash key) const
    engine->RegisterObjectMethod(className, "const Variant& GetGlobalVar(StringHash) const", AS_METHODPR(T, GetGlobalVar, (StringHash) const, const Variant&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Variant& get_globalVar(StringHash) const", AS_METHODPR(T, GetGlobalVar, (StringHash) const, const Variant&), AS_CALL_THISCALL);

    // const VariantMap& Object::GetGlobalVars() const
    engine->RegisterObjectMethod(className, "const VariantMap& GetGlobalVars() const", AS_METHODPR(T, GetGlobalVars, () const, const VariantMap&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const VariantMap& get_globalVars() const", AS_METHODPR(T, GetGlobalVars, () const, const VariantMap&), AS_CALL_THISCALL);

    // Object* Object::GetSubsystem(StringHash type) const
    engine->RegisterObjectMethod(className, "Object@+ GetSubsystem(StringHash) const", AS_METHODPR(T, GetSubsystem, (StringHash) const, Object*), AS_CALL_THISCALL);

    // virtual StringHash Object::GetType() const = 0
    engine->RegisterObjectMethod(className, "StringHash GetType() const", AS_METHODPR(T, GetType, () const, StringHash), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "StringHash get_type() const", AS_METHODPR(T, GetType, () const, StringHash), AS_CALL_THISCALL);

    // virtual const String& Object::GetTypeName() const = 0
    engine->RegisterObjectMethod(className, "const String& GetTypeName() const", AS_METHODPR(T, GetTypeName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_typeName() const", AS_METHODPR(T, GetTypeName, () const, const String&), AS_CALL_THISCALL);

    // bool Object::HasEventHandlers() const
    engine->RegisterObjectMethod(className, "bool HasEventHandlers() const", AS_METHODPR(T, HasEventHandlers, () const, bool), AS_CALL_THISCALL);

    // bool Object::HasSubscribedToEvent(StringHash eventType) const
    engine->RegisterObjectMethod(className, "bool HasSubscribedToEvent(StringHash) const", AS_METHODPR(T, HasSubscribedToEvent, (StringHash) const, bool), AS_CALL_THISCALL);

    // bool Object::HasSubscribedToEvent(Object* sender, StringHash eventType) const
    engine->RegisterObjectMethod(className, "bool HasSubscribedToEvent(Object@+, StringHash) const", AS_METHODPR(T, HasSubscribedToEvent, (Object*, StringHash) const, bool), AS_CALL_THISCALL);

    // bool Object::IsInstanceOf(StringHash type) const
    engine->RegisterObjectMethod(className, "bool IsInstanceOf(StringHash) const", AS_METHODPR(T, IsInstanceOf, (StringHash) const, bool), AS_CALL_THISCALL);

    // virtual void Object::OnEvent(Object* sender, StringHash eventType, VariantMap& eventData)
    engine->RegisterObjectMethod(className, "void OnEvent(Object@+, StringHash, VariantMap&)", AS_METHODPR(T, OnEvent, (Object*, StringHash, VariantMap&), void), AS_CALL_THISCALL);

    // void Object::SendEvent(StringHash eventType)
    engine->RegisterObjectMethod(className, "void SendEvent(StringHash)", AS_METHODPR(T, SendEvent, (StringHash), void), AS_CALL_THISCALL);

    // void Object::SendEvent(StringHash eventType, VariantMap& eventData)
    engine->RegisterObjectMethod(className, "void SendEvent(StringHash, VariantMap&)", AS_METHODPR(T, SendEvent, (StringHash, VariantMap&), void), AS_CALL_THISCALL);

    // void Object::SetBlockEvents(bool block)
    engine->RegisterObjectMethod(className, "void SetBlockEvents(bool)", AS_METHODPR(T, SetBlockEvents, (bool), void), AS_CALL_THISCALL);

    // void Object::SetGlobalVar(StringHash key, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetGlobalVar(StringHash, const Variant&in)", AS_METHODPR(T, SetGlobalVar, (StringHash, const Variant&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_globalVar(StringHash, const Variant&in)", AS_METHODPR(T, SetGlobalVar, (StringHash, const Variant&), void), AS_CALL_THISCALL);

    // void Object::UnsubscribeFromAllEvents()
    engine->RegisterObjectMethod(className, "void UnsubscribeFromAllEvents()", AS_METHODPR(T, UnsubscribeFromAllEvents, (), void), AS_CALL_THISCALL);

    // void Object::UnsubscribeFromAllEventsExcept(const PODVector<StringHash>& exceptions, bool onlyUserData)
    engine->RegisterObjectMethod(className, "void UnsubscribeFromAllEventsExcept(Array<StringHash>@+, bool)", AS_FUNCTION_OBJFIRST(Object_void_UnsubscribeFromAllEventsExcept_constspPODVectorlesStringHashgreamp_bool_template<Object>), AS_CALL_CDECL_OBJFIRST);

    // void Object::UnsubscribeFromEvent(StringHash eventType)
    engine->RegisterObjectMethod(className, "void UnsubscribeFromEvent(StringHash)", AS_METHODPR(T, UnsubscribeFromEvent, (StringHash), void), AS_CALL_THISCALL);

    // void Object::UnsubscribeFromEvent(Object* sender, StringHash eventType)
    engine->RegisterObjectMethod(className, "void UnsubscribeFromEvent(Object@+, StringHash)", AS_METHODPR(T, UnsubscribeFromEvent, (Object*, StringHash), void), AS_CALL_THISCALL);

    // void Object::UnsubscribeFromEvents(Object* sender)
    engine->RegisterObjectMethod(className, "void UnsubscribeFromEvents(Object@+)", AS_METHODPR(T, UnsubscribeFromEvents, (Object*), void), AS_CALL_THISCALL);

    // template <typename T> T* Object::Cast()
    // Not registered because template
    // template <typename T> const T* Object::Cast() const
    // Not registered because template
    // template <class T> T* Object::GetSubsystem() const
    // Not registered because template
    // template <typename T> bool Object::IsInstanceOf() const
    // Not registered because template
    // template <typename... Args> void Object::SendEvent(StringHash eventType, Args... args)
    // Not registered because template
    // static const TypeInfo* Object::GetTypeInfoStatic()
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Object
        REGISTER_MEMBERS_MANUAL_PART_Object();
    #endif
}

// virtual SharedPtr<Object> ObjectFactory::CreateObject() = 0
template <class T> Object* ObjectFactory_SharedPtrlesObjectgre_CreateObject_void_template(T* _ptr)
{
    SharedPtr<Object> result = _ptr->CreateObject();
    return result.Detach();
}

// class ObjectFactory | File: ../Core/Object.h
template <class T> void RegisterMembers_ObjectFactory(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // Context* ObjectFactory::GetContext() const
    // Error: type "Context*" can used only as function parameter
    // const TypeInfo* ObjectFactory::GetTypeInfo() const
    // Error: type "TypeInfo" can not automatically bind bacause have @nobind mark

    // virtual SharedPtr<Object> ObjectFactory::CreateObject() = 0
    engine->RegisterObjectMethod(className, "Object@+ CreateObject()", AS_FUNCTION_OBJFIRST(ObjectFactory_SharedPtrlesObjectgre_CreateObject_void_template<ObjectFactory>), AS_CALL_CDECL_OBJFIRST);

    // StringHash ObjectFactory::GetType() const
    engine->RegisterObjectMethod(className, "StringHash GetType() const", AS_METHODPR(T, GetType, () const, StringHash), AS_CALL_THISCALL);

    // const String& ObjectFactory::GetTypeName() const
    engine->RegisterObjectMethod(className, "const String& GetTypeName() const", AS_METHODPR(T, GetTypeName, () const, const String&), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ObjectFactory
        REGISTER_MEMBERS_MANUAL_PART_ObjectFactory();
    #endif
}

// Vector<SharedPtr<ShaderVariation>>& Pass::GetPixelShaders()
template <class T> CScriptArray* Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetPixelShaders_void_template(T* _ptr)
{
    Vector<SharedPtr<ShaderVariation>>& result = _ptr->GetPixelShaders();
    return VectorToHandleArray(result, "Array<ShaderVariation@>");
}

// Vector<SharedPtr<ShaderVariation>>& Pass::GetPixelShaders(const StringHash& extraDefinesHash)
template <class T> CScriptArray* Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetPixelShaders_constspStringHashamp_template(T* _ptr, const StringHash& extraDefinesHash)
{
    Vector<SharedPtr<ShaderVariation>>& result = _ptr->GetPixelShaders(extraDefinesHash);
    return VectorToHandleArray(result, "Array<ShaderVariation@>");
}

// Vector<SharedPtr<ShaderVariation>>& Pass::GetVertexShaders()
template <class T> CScriptArray* Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetVertexShaders_void_template(T* _ptr)
{
    Vector<SharedPtr<ShaderVariation>>& result = _ptr->GetVertexShaders();
    return VectorToHandleArray(result, "Array<ShaderVariation@>");
}

// Vector<SharedPtr<ShaderVariation>>& Pass::GetVertexShaders(const StringHash& extraDefinesHash)
template <class T> CScriptArray* Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetVertexShaders_constspStringHashamp_template(T* _ptr, const StringHash& extraDefinesHash)
{
    Vector<SharedPtr<ShaderVariation>>& result = _ptr->GetVertexShaders(extraDefinesHash);
    return VectorToHandleArray(result, "Array<ShaderVariation@>");
}

// class Pass | File: ../Graphics/Technique.h
template <class T> void RegisterMembers_Pass(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // bool Pass::GetAlphaToCoverage() const
    engine->RegisterObjectMethod(className, "bool GetAlphaToCoverage() const", AS_METHODPR(T, GetAlphaToCoverage, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_alphaToCoverage() const", AS_METHODPR(T, GetAlphaToCoverage, () const, bool), AS_CALL_THISCALL);

    // BlendMode Pass::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BlendMode get_blendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // CullMode Pass::GetCullMode() const
    engine->RegisterObjectMethod(className, "CullMode GetCullMode() const", AS_METHODPR(T, GetCullMode, () const, CullMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CullMode get_cullMode() const", AS_METHODPR(T, GetCullMode, () const, CullMode), AS_CALL_THISCALL);

    // CompareMode Pass::GetDepthTestMode() const
    engine->RegisterObjectMethod(className, "CompareMode GetDepthTestMode() const", AS_METHODPR(T, GetDepthTestMode, () const, CompareMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CompareMode get_depthTestMode() const", AS_METHODPR(T, GetDepthTestMode, () const, CompareMode), AS_CALL_THISCALL);

    // bool Pass::GetDepthWrite() const
    engine->RegisterObjectMethod(className, "bool GetDepthWrite() const", AS_METHODPR(T, GetDepthWrite, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_depthWrite() const", AS_METHODPR(T, GetDepthWrite, () const, bool), AS_CALL_THISCALL);

    // String Pass::GetEffectivePixelShaderDefines() const
    engine->RegisterObjectMethod(className, "String GetEffectivePixelShaderDefines() const", AS_METHODPR(T, GetEffectivePixelShaderDefines, () const, String), AS_CALL_THISCALL);

    // String Pass::GetEffectiveVertexShaderDefines() const
    engine->RegisterObjectMethod(className, "String GetEffectiveVertexShaderDefines() const", AS_METHODPR(T, GetEffectiveVertexShaderDefines, () const, String), AS_CALL_THISCALL);

    // unsigned Pass::GetIndex() const
    engine->RegisterObjectMethod(className, "uint GetIndex() const", AS_METHODPR(T, GetIndex, () const, unsigned), AS_CALL_THISCALL);

    // PassLightingMode Pass::GetLightingMode() const
    engine->RegisterObjectMethod(className, "PassLightingMode GetLightingMode() const", AS_METHODPR(T, GetLightingMode, () const, PassLightingMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "PassLightingMode get_lightingMode() const", AS_METHODPR(T, GetLightingMode, () const, PassLightingMode), AS_CALL_THISCALL);

    // const String& Pass::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // const String& Pass::GetPixelShader() const
    engine->RegisterObjectMethod(className, "const String& GetPixelShader() const", AS_METHODPR(T, GetPixelShader, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_pixelShader() const", AS_METHODPR(T, GetPixelShader, () const, const String&), AS_CALL_THISCALL);

    // const String& Pass::GetPixelShaderDefineExcludes() const
    engine->RegisterObjectMethod(className, "const String& GetPixelShaderDefineExcludes() const", AS_METHODPR(T, GetPixelShaderDefineExcludes, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_pixelShaderDefineExcludes() const", AS_METHODPR(T, GetPixelShaderDefineExcludes, () const, const String&), AS_CALL_THISCALL);

    // const String& Pass::GetPixelShaderDefines() const
    engine->RegisterObjectMethod(className, "const String& GetPixelShaderDefines() const", AS_METHODPR(T, GetPixelShaderDefines, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_pixelShaderDefines() const", AS_METHODPR(T, GetPixelShaderDefines, () const, const String&), AS_CALL_THISCALL);

    // Vector<SharedPtr<ShaderVariation>>& Pass::GetPixelShaders()
    engine->RegisterObjectMethod(className, "Array<ShaderVariation@>@ GetPixelShaders()", AS_FUNCTION_OBJFIRST(Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetPixelShaders_void_template<Pass>), AS_CALL_CDECL_OBJFIRST);

    // Vector<SharedPtr<ShaderVariation>>& Pass::GetPixelShaders(const StringHash& extraDefinesHash)
    engine->RegisterObjectMethod(className, "Array<ShaderVariation@>@ GetPixelShaders(const StringHash&in)", AS_FUNCTION_OBJFIRST(Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetPixelShaders_constspStringHashamp_template<Pass>), AS_CALL_CDECL_OBJFIRST);

    // unsigned Pass::GetShadersLoadedFrameNumber() const
    engine->RegisterObjectMethod(className, "uint GetShadersLoadedFrameNumber() const", AS_METHODPR(T, GetShadersLoadedFrameNumber, () const, unsigned), AS_CALL_THISCALL);

    // const String& Pass::GetVertexShader() const
    engine->RegisterObjectMethod(className, "const String& GetVertexShader() const", AS_METHODPR(T, GetVertexShader, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_vertexShader() const", AS_METHODPR(T, GetVertexShader, () const, const String&), AS_CALL_THISCALL);

    // const String& Pass::GetVertexShaderDefineExcludes() const
    engine->RegisterObjectMethod(className, "const String& GetVertexShaderDefineExcludes() const", AS_METHODPR(T, GetVertexShaderDefineExcludes, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_vertexShaderDefineExcludes() const", AS_METHODPR(T, GetVertexShaderDefineExcludes, () const, const String&), AS_CALL_THISCALL);

    // const String& Pass::GetVertexShaderDefines() const
    engine->RegisterObjectMethod(className, "const String& GetVertexShaderDefines() const", AS_METHODPR(T, GetVertexShaderDefines, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_vertexShaderDefines() const", AS_METHODPR(T, GetVertexShaderDefines, () const, const String&), AS_CALL_THISCALL);

    // Vector<SharedPtr<ShaderVariation>>& Pass::GetVertexShaders()
    engine->RegisterObjectMethod(className, "Array<ShaderVariation@>@ GetVertexShaders()", AS_FUNCTION_OBJFIRST(Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetVertexShaders_void_template<Pass>), AS_CALL_CDECL_OBJFIRST);

    // Vector<SharedPtr<ShaderVariation>>& Pass::GetVertexShaders(const StringHash& extraDefinesHash)
    engine->RegisterObjectMethod(className, "Array<ShaderVariation@>@ GetVertexShaders(const StringHash&in)", AS_FUNCTION_OBJFIRST(Pass_VectorlesSharedPtrlesShaderVariationgregreamp_GetVertexShaders_constspStringHashamp_template<Pass>), AS_CALL_CDECL_OBJFIRST);

    // bool Pass::IsDesktop() const
    engine->RegisterObjectMethod(className, "bool IsDesktop() const", AS_METHODPR(T, IsDesktop, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_desktop() const", AS_METHODPR(T, IsDesktop, () const, bool), AS_CALL_THISCALL);

    // void Pass::MarkShadersLoaded(unsigned frameNumber)
    engine->RegisterObjectMethod(className, "void MarkShadersLoaded(uint)", AS_METHODPR(T, MarkShadersLoaded, (unsigned), void), AS_CALL_THISCALL);

    // void Pass::ReleaseShaders()
    engine->RegisterObjectMethod(className, "void ReleaseShaders()", AS_METHODPR(T, ReleaseShaders, (), void), AS_CALL_THISCALL);

    // void Pass::SetAlphaToCoverage(bool enable)
    engine->RegisterObjectMethod(className, "void SetAlphaToCoverage(bool)", AS_METHODPR(T, SetAlphaToCoverage, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_alphaToCoverage(bool)", AS_METHODPR(T, SetAlphaToCoverage, (bool), void), AS_CALL_THISCALL);

    // void Pass::SetBlendMode(BlendMode mode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);

    // void Pass::SetCullMode(CullMode mode)
    engine->RegisterObjectMethod(className, "void SetCullMode(CullMode)", AS_METHODPR(T, SetCullMode, (CullMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cullMode(CullMode)", AS_METHODPR(T, SetCullMode, (CullMode), void), AS_CALL_THISCALL);

    // void Pass::SetDepthTestMode(CompareMode mode)
    engine->RegisterObjectMethod(className, "void SetDepthTestMode(CompareMode)", AS_METHODPR(T, SetDepthTestMode, (CompareMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_depthTestMode(CompareMode)", AS_METHODPR(T, SetDepthTestMode, (CompareMode), void), AS_CALL_THISCALL);

    // void Pass::SetDepthWrite(bool enable)
    engine->RegisterObjectMethod(className, "void SetDepthWrite(bool)", AS_METHODPR(T, SetDepthWrite, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_depthWrite(bool)", AS_METHODPR(T, SetDepthWrite, (bool), void), AS_CALL_THISCALL);

    // void Pass::SetIsDesktop(bool enable)
    engine->RegisterObjectMethod(className, "void SetIsDesktop(bool)", AS_METHODPR(T, SetIsDesktop, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_desktop(bool)", AS_METHODPR(T, SetIsDesktop, (bool), void), AS_CALL_THISCALL);

    // void Pass::SetLightingMode(PassLightingMode mode)
    engine->RegisterObjectMethod(className, "void SetLightingMode(PassLightingMode)", AS_METHODPR(T, SetLightingMode, (PassLightingMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lightingMode(PassLightingMode)", AS_METHODPR(T, SetLightingMode, (PassLightingMode), void), AS_CALL_THISCALL);

    // void Pass::SetPixelShader(const String& name)
    engine->RegisterObjectMethod(className, "void SetPixelShader(const String&in)", AS_METHODPR(T, SetPixelShader, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pixelShader(const String&in)", AS_METHODPR(T, SetPixelShader, (const String&), void), AS_CALL_THISCALL);

    // void Pass::SetPixelShaderDefineExcludes(const String& excludes)
    engine->RegisterObjectMethod(className, "void SetPixelShaderDefineExcludes(const String&in)", AS_METHODPR(T, SetPixelShaderDefineExcludes, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pixelShaderDefineExcludes(const String&in)", AS_METHODPR(T, SetPixelShaderDefineExcludes, (const String&), void), AS_CALL_THISCALL);

    // void Pass::SetPixelShaderDefines(const String& defines)
    engine->RegisterObjectMethod(className, "void SetPixelShaderDefines(const String&in)", AS_METHODPR(T, SetPixelShaderDefines, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pixelShaderDefines(const String&in)", AS_METHODPR(T, SetPixelShaderDefines, (const String&), void), AS_CALL_THISCALL);

    // void Pass::SetVertexShader(const String& name)
    engine->RegisterObjectMethod(className, "void SetVertexShader(const String&in)", AS_METHODPR(T, SetVertexShader, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexShader(const String&in)", AS_METHODPR(T, SetVertexShader, (const String&), void), AS_CALL_THISCALL);

    // void Pass::SetVertexShaderDefineExcludes(const String& excludes)
    engine->RegisterObjectMethod(className, "void SetVertexShaderDefineExcludes(const String&in)", AS_METHODPR(T, SetVertexShaderDefineExcludes, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexShaderDefineExcludes(const String&in)", AS_METHODPR(T, SetVertexShaderDefineExcludes, (const String&), void), AS_CALL_THISCALL);

    // void Pass::SetVertexShaderDefines(const String& defines)
    engine->RegisterObjectMethod(className, "void SetVertexShaderDefines(const String&in)", AS_METHODPR(T, SetVertexShaderDefines, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexShaderDefines(const String&in)", AS_METHODPR(T, SetVertexShaderDefines, (const String&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Pass
        REGISTER_MEMBERS_MANUAL_PART_Pass();
    #endif
}

// class PointOctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_PointOctreeQuery(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_OctreeQuery<T>(engine, className);

    // Vector3 PointOctreeQuery::point_
    engine->RegisterObjectProperty(className, "Vector3 point", offsetof(T, point_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PointOctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_PointOctreeQuery();
    #endif
}

// SharedPtr<RenderPath> RenderPath::Clone()
template <class T> RenderPath* RenderPath_SharedPtrlesRenderPathgre_Clone_void_template(T* _ptr)
{
    SharedPtr<RenderPath> result = _ptr->Clone();
    return result.Detach();
}

// class RenderPath | File: ../Graphics/RenderPath.h
template <class T> void RegisterMembers_RenderPath(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // RenderPathCommand* RenderPath::GetCommand(unsigned index)
    // Error: type "RenderPathCommand*" can not automatically bind

    // void RenderPath::AddCommand(const RenderPathCommand& command)
    engine->RegisterObjectMethod(className, "void AddCommand(const RenderPathCommand&in)", AS_METHODPR(T, AddCommand, (const RenderPathCommand&), void), AS_CALL_THISCALL);

    // void RenderPath::AddRenderTarget(const RenderTargetInfo& info)
    engine->RegisterObjectMethod(className, "void AddRenderTarget(const RenderTargetInfo&in)", AS_METHODPR(T, AddRenderTarget, (const RenderTargetInfo&), void), AS_CALL_THISCALL);

    // bool RenderPath::Append(XMLFile* file)
    engine->RegisterObjectMethod(className, "bool Append(XMLFile@+)", AS_METHODPR(T, Append, (XMLFile*), bool), AS_CALL_THISCALL);

    // SharedPtr<RenderPath> RenderPath::Clone()
    engine->RegisterObjectMethod(className, "RenderPath@+ Clone()", AS_FUNCTION_OBJFIRST(RenderPath_SharedPtrlesRenderPathgre_Clone_void_template<RenderPath>), AS_CALL_CDECL_OBJFIRST);

    // unsigned RenderPath::GetNumCommands() const
    engine->RegisterObjectMethod(className, "uint GetNumCommands() const", AS_METHODPR(T, GetNumCommands, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numCommands() const", AS_METHODPR(T, GetNumCommands, () const, unsigned), AS_CALL_THISCALL);

    // unsigned RenderPath::GetNumRenderTargets() const
    engine->RegisterObjectMethod(className, "uint GetNumRenderTargets() const", AS_METHODPR(T, GetNumRenderTargets, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numRenderTargets() const", AS_METHODPR(T, GetNumRenderTargets, () const, unsigned), AS_CALL_THISCALL);

    // const Variant& RenderPath::GetShaderParameter(const String& name) const
    engine->RegisterObjectMethod(className, "const Variant& GetShaderParameter(const String&in) const", AS_METHODPR(T, GetShaderParameter, (const String&) const, const Variant&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Variant& get_shaderParameters(const String&in) const", AS_METHODPR(T, GetShaderParameter, (const String&) const, const Variant&), AS_CALL_THISCALL);

    // void RenderPath::InsertCommand(unsigned index, const RenderPathCommand& command)
    engine->RegisterObjectMethod(className, "void InsertCommand(uint, const RenderPathCommand&in)", AS_METHODPR(T, InsertCommand, (unsigned, const RenderPathCommand&), void), AS_CALL_THISCALL);

    // bool RenderPath::IsAdded(const String& tag) const
    engine->RegisterObjectMethod(className, "bool IsAdded(const String&in) const", AS_METHODPR(T, IsAdded, (const String&) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_added(const String&in) const", AS_METHODPR(T, IsAdded, (const String&) const, bool), AS_CALL_THISCALL);

    // bool RenderPath::IsEnabled(const String& tag) const
    engine->RegisterObjectMethod(className, "bool IsEnabled(const String&in) const", AS_METHODPR(T, IsEnabled, (const String&) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled(const String&in) const", AS_METHODPR(T, IsEnabled, (const String&) const, bool), AS_CALL_THISCALL);

    // bool RenderPath::Load(XMLFile* file)
    engine->RegisterObjectMethod(className, "bool Load(XMLFile@+)", AS_METHODPR(T, Load, (XMLFile*), bool), AS_CALL_THISCALL);

    // void RenderPath::RemoveCommand(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveCommand(uint)", AS_METHODPR(T, RemoveCommand, (unsigned), void), AS_CALL_THISCALL);

    // void RenderPath::RemoveCommands(const String& tag)
    engine->RegisterObjectMethod(className, "void RemoveCommands(const String&in)", AS_METHODPR(T, RemoveCommands, (const String&), void), AS_CALL_THISCALL);

    // void RenderPath::RemoveRenderTarget(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveRenderTarget(uint)", AS_METHODPR(T, RemoveRenderTarget, (unsigned), void), AS_CALL_THISCALL);

    // void RenderPath::RemoveRenderTarget(const String& name)
    engine->RegisterObjectMethod(className, "void RemoveRenderTarget(const String&in)", AS_METHODPR(T, RemoveRenderTarget, (const String&), void), AS_CALL_THISCALL);

    // void RenderPath::RemoveRenderTargets(const String& tag)
    engine->RegisterObjectMethod(className, "void RemoveRenderTargets(const String&in)", AS_METHODPR(T, RemoveRenderTargets, (const String&), void), AS_CALL_THISCALL);

    // void RenderPath::SetCommand(unsigned index, const RenderPathCommand& command)
    engine->RegisterObjectMethod(className, "void SetCommand(uint, const RenderPathCommand&in)", AS_METHODPR(T, SetCommand, (unsigned, const RenderPathCommand&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_commands(uint, const RenderPathCommand&in)", AS_METHODPR(T, SetCommand, (unsigned, const RenderPathCommand&), void), AS_CALL_THISCALL);

    // void RenderPath::SetEnabled(const String& tag, bool active)
    engine->RegisterObjectMethod(className, "void SetEnabled(const String&in, bool)", AS_METHODPR(T, SetEnabled, (const String&, bool), void), AS_CALL_THISCALL);

    // void RenderPath::SetRenderTarget(unsigned index, const RenderTargetInfo& info)
    engine->RegisterObjectMethod(className, "void SetRenderTarget(uint, const RenderTargetInfo&in)", AS_METHODPR(T, SetRenderTarget, (unsigned, const RenderTargetInfo&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_renderTargets(uint, const RenderTargetInfo&in)", AS_METHODPR(T, SetRenderTarget, (unsigned, const RenderTargetInfo&), void), AS_CALL_THISCALL);

    // void RenderPath::SetShaderParameter(const String& name, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(const String&in, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (const String&, const Variant&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shaderParameters(const String&in, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (const String&, const Variant&), void), AS_CALL_THISCALL);

    // void RenderPath::ToggleEnabled(const String& tag)
    engine->RegisterObjectMethod(className, "void ToggleEnabled(const String&in)", AS_METHODPR(T, ToggleEnabled, (const String&), void), AS_CALL_THISCALL);

    // Vector<RenderTargetInfo> RenderPath::renderTargets_
    // Error: type "Vector<RenderTargetInfo>" can not automatically bind
    // Vector<RenderPathCommand> RenderPath::commands_
    // Error: type "Vector<RenderPathCommand>" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RenderPath
        REGISTER_MEMBERS_MANUAL_PART_RenderPath();
    #endif
}

// class RenderSurface | File: ../Graphics/RenderSurface.h
template <class T> void RegisterMembers_RenderSurface(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // void* RenderSurface::GetReadOnlyView() const
    // Error: type "void*" can not automatically bind
    // void* RenderSurface::GetRenderTargetView() const
    // Error: type "void*" can not automatically bind
    // void* RenderSurface::GetSurface() const
    // Error: type "void*" can not automatically bind

    // bool RenderSurface::CreateRenderBuffer(unsigned width, unsigned height, unsigned format, int multiSample)
    engine->RegisterObjectMethod(className, "bool CreateRenderBuffer(uint, uint, uint, int)", AS_METHODPR(T, CreateRenderBuffer, (unsigned, unsigned, unsigned, int), bool), AS_CALL_THISCALL);

    // bool RenderSurface::GetAutoResolve() const
    engine->RegisterObjectMethod(className, "bool GetAutoResolve() const", AS_METHODPR(T, GetAutoResolve, () const, bool), AS_CALL_THISCALL);

    // int RenderSurface::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // RenderSurface* RenderSurface::GetLinkedDepthStencil() const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetLinkedDepthStencil() const", AS_METHODPR(T, GetLinkedDepthStencil, () const, RenderSurface*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderSurface@+ get_linkedDepthStencil() const", AS_METHODPR(T, GetLinkedDepthStencil, () const, RenderSurface*), AS_CALL_THISCALL);

    // RenderSurface* RenderSurface::GetLinkedRenderTarget() const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetLinkedRenderTarget() const", AS_METHODPR(T, GetLinkedRenderTarget, () const, RenderSurface*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderSurface@+ get_linkedRenderTarget() const", AS_METHODPR(T, GetLinkedRenderTarget, () const, RenderSurface*), AS_CALL_THISCALL);

    // int RenderSurface::GetMultiSample() const
    engine->RegisterObjectMethod(className, "int GetMultiSample() const", AS_METHODPR(T, GetMultiSample, () const, int), AS_CALL_THISCALL);

    // unsigned RenderSurface::GetNumViewports() const
    engine->RegisterObjectMethod(className, "uint GetNumViewports() const", AS_METHODPR(T, GetNumViewports, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numViewports() const", AS_METHODPR(T, GetNumViewports, () const, unsigned), AS_CALL_THISCALL);

    // Texture* RenderSurface::GetParentTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetParentTexture() const", AS_METHODPR(T, GetParentTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_parentTexture() const", AS_METHODPR(T, GetParentTexture, () const, Texture*), AS_CALL_THISCALL);

    // unsigned RenderSurface::GetRenderBuffer() const
    engine->RegisterObjectMethod(className, "uint GetRenderBuffer() const", AS_METHODPR(T, GetRenderBuffer, () const, unsigned), AS_CALL_THISCALL);

    // unsigned RenderSurface::GetTarget() const
    engine->RegisterObjectMethod(className, "uint GetTarget() const", AS_METHODPR(T, GetTarget, () const, unsigned), AS_CALL_THISCALL);

    // RenderSurfaceUpdateMode RenderSurface::GetUpdateMode() const
    engine->RegisterObjectMethod(className, "RenderSurfaceUpdateMode GetUpdateMode() const", AS_METHODPR(T, GetUpdateMode, () const, RenderSurfaceUpdateMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderSurfaceUpdateMode get_updateMode() const", AS_METHODPR(T, GetUpdateMode, () const, RenderSurfaceUpdateMode), AS_CALL_THISCALL);

    // TextureUsage RenderSurface::GetUsage() const
    engine->RegisterObjectMethod(className, "TextureUsage GetUsage() const", AS_METHODPR(T, GetUsage, () const, TextureUsage), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureUsage get_usage() const", AS_METHODPR(T, GetUsage, () const, TextureUsage), AS_CALL_THISCALL);

    // Viewport* RenderSurface::GetViewport(unsigned index) const
    engine->RegisterObjectMethod(className, "Viewport@+ GetViewport(uint) const", AS_METHODPR(T, GetViewport, (unsigned) const, Viewport*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Viewport@+ get_viewports(uint) const", AS_METHODPR(T, GetViewport, (unsigned) const, Viewport*), AS_CALL_THISCALL);

    // int RenderSurface::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool RenderSurface::IsResolveDirty() const
    engine->RegisterObjectMethod(className, "bool IsResolveDirty() const", AS_METHODPR(T, IsResolveDirty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resolveDirty() const", AS_METHODPR(T, IsResolveDirty, () const, bool), AS_CALL_THISCALL);

    // bool RenderSurface::IsUpdateQueued() const
    engine->RegisterObjectMethod(className, "bool IsUpdateQueued() const", AS_METHODPR(T, IsUpdateQueued, () const, bool), AS_CALL_THISCALL);

    // void RenderSurface::OnDeviceLost()
    engine->RegisterObjectMethod(className, "void OnDeviceLost()", AS_METHODPR(T, OnDeviceLost, (), void), AS_CALL_THISCALL);

    // void RenderSurface::QueueUpdate()
    engine->RegisterObjectMethod(className, "void QueueUpdate()", AS_METHODPR(T, QueueUpdate, (), void), AS_CALL_THISCALL);

    // void RenderSurface::Release()
    engine->RegisterObjectMethod(className, "void Release()", AS_METHODPR(T, Release, (), void), AS_CALL_THISCALL);

    // void RenderSurface::ResetUpdateQueued()
    engine->RegisterObjectMethod(className, "void ResetUpdateQueued()", AS_METHODPR(T, ResetUpdateQueued, (), void), AS_CALL_THISCALL);

    // void RenderSurface::SetLinkedDepthStencil(RenderSurface* depthStencil)
    engine->RegisterObjectMethod(className, "void SetLinkedDepthStencil(RenderSurface@+)", AS_METHODPR(T, SetLinkedDepthStencil, (RenderSurface*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linkedDepthStencil(RenderSurface@+)", AS_METHODPR(T, SetLinkedDepthStencil, (RenderSurface*), void), AS_CALL_THISCALL);

    // void RenderSurface::SetLinkedRenderTarget(RenderSurface* renderTarget)
    engine->RegisterObjectMethod(className, "void SetLinkedRenderTarget(RenderSurface@+)", AS_METHODPR(T, SetLinkedRenderTarget, (RenderSurface*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linkedRenderTarget(RenderSurface@+)", AS_METHODPR(T, SetLinkedRenderTarget, (RenderSurface*), void), AS_CALL_THISCALL);

    // void RenderSurface::SetNumViewports(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumViewports(uint)", AS_METHODPR(T, SetNumViewports, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numViewports(uint)", AS_METHODPR(T, SetNumViewports, (unsigned), void), AS_CALL_THISCALL);

    // void RenderSurface::SetResolveDirty(bool enable)
    engine->RegisterObjectMethod(className, "void SetResolveDirty(bool)", AS_METHODPR(T, SetResolveDirty, (bool), void), AS_CALL_THISCALL);

    // void RenderSurface::SetUpdateMode(RenderSurfaceUpdateMode mode)
    engine->RegisterObjectMethod(className, "void SetUpdateMode(RenderSurfaceUpdateMode)", AS_METHODPR(T, SetUpdateMode, (RenderSurfaceUpdateMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateMode(RenderSurfaceUpdateMode)", AS_METHODPR(T, SetUpdateMode, (RenderSurfaceUpdateMode), void), AS_CALL_THISCALL);

    // void RenderSurface::SetViewport(unsigned index, Viewport* viewport)
    engine->RegisterObjectMethod(className, "void SetViewport(uint, Viewport@+)", AS_METHODPR(T, SetViewport, (unsigned, Viewport*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewports(uint, Viewport@+)", AS_METHODPR(T, SetViewport, (unsigned, Viewport*), void), AS_CALL_THISCALL);

    // void* RenderSurface::surface_
    // Not registered because have @nobind mark
    // void* RenderSurface::renderTargetView_
    // Not registered because have @nobind mark
    // unsigned RenderSurface::renderBuffer_
    // Not registered because have @nobind mark
    // void* RenderSurface::readOnlyView_
    // Not registered because have @nobind mark
    // unsigned RenderSurface::target_
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RenderSurface
        REGISTER_MEMBERS_MANUAL_PART_RenderSurface();
    #endif
}

// struct SceneReplicationState | File: ../Scene/ReplicationState.h
template <class T> void RegisterMembers_SceneReplicationState(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ReplicationState<T>(engine, className);

    // void SceneReplicationState::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // HashMap<unsigned, NodeReplicationState> SceneReplicationState::nodeStates_
    // Error: type "HashMap<unsigned, NodeReplicationState>" can not automatically bind
    // HashSet<unsigned> SceneReplicationState::dirtyNodes_
    // Error: type "HashSet<unsigned>" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SceneReplicationState
        REGISTER_MEMBERS_MANUAL_PART_SceneReplicationState();
    #endif
}

// class ShaderVariation | File: ../Graphics/ShaderVariation.h
template <class T> void RegisterMembers_ShaderVariation(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);
    RegisterMembers_GPUObject<T>(engine, className);

    // const PODVector<unsigned char>& ShaderVariation::GetByteCode() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // const unsigned* ShaderVariation::GetConstantBufferSizes() const
    // Error: type "const unsigned*" can not automatically bind
    // const HashMap<StringHash, ShaderParameter>& ShaderVariation::GetParameters() const
    // Error: type "const HashMap<StringHash, ShaderParameter>&" can not automatically bind

    // bool ShaderVariation::Create()
    engine->RegisterObjectMethod(className, "bool Create()", AS_METHODPR(T, Create, (), bool), AS_CALL_THISCALL);

    // const String& ShaderVariation::GetCompilerOutput() const
    engine->RegisterObjectMethod(className, "const String& GetCompilerOutput() const", AS_METHODPR(T, GetCompilerOutput, () const, const String&), AS_CALL_THISCALL);

    // const String& ShaderVariation::GetDefines() const
    engine->RegisterObjectMethod(className, "const String& GetDefines() const", AS_METHODPR(T, GetDefines, () const, const String&), AS_CALL_THISCALL);

    // const String& ShaderVariation::GetDefinesClipPlane()
    engine->RegisterObjectMethod(className, "const String& GetDefinesClipPlane()", AS_METHODPR(T, GetDefinesClipPlane, (), const String&), AS_CALL_THISCALL);

    // unsigned long long ShaderVariation::GetElementHash() const
    engine->RegisterObjectMethod(className, "uint64 GetElementHash() const", AS_METHODPR(T, GetElementHash, () const, unsigned long long), AS_CALL_THISCALL);

    // String ShaderVariation::GetFullName() const
    engine->RegisterObjectMethod(className, "String GetFullName() const", AS_METHODPR(T, GetFullName, () const, String), AS_CALL_THISCALL);

    // const String& ShaderVariation::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // Shader* ShaderVariation::GetOwner() const
    engine->RegisterObjectMethod(className, "Shader@+ GetOwner() const", AS_METHODPR(T, GetOwner, () const, Shader*), AS_CALL_THISCALL);

    // ShaderType ShaderVariation::GetShaderType() const
    engine->RegisterObjectMethod(className, "ShaderType GetShaderType() const", AS_METHODPR(T, GetShaderType, () const, ShaderType), AS_CALL_THISCALL);

    // bool ShaderVariation::HasParameter(StringHash param) const
    engine->RegisterObjectMethod(className, "bool HasParameter(StringHash) const", AS_METHODPR(T, HasParameter, (StringHash) const, bool), AS_CALL_THISCALL);

    // bool ShaderVariation::HasTextureUnit(TextureUnit unit) const
    engine->RegisterObjectMethod(className, "bool HasTextureUnit(TextureUnit) const", AS_METHODPR(T, HasTextureUnit, (TextureUnit) const, bool), AS_CALL_THISCALL);

    // void ShaderVariation::SetDefines(const String& defines)
    engine->RegisterObjectMethod(className, "void SetDefines(const String&in)", AS_METHODPR(T, SetDefines, (const String&), void), AS_CALL_THISCALL);

    // void ShaderVariation::SetName(const String& name)
    engine->RegisterObjectMethod(className, "void SetName(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);

    // static const char* ShaderVariation::elementSemanticNames[]
    // Error: type "const char*" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ShaderVariation
        REGISTER_MEMBERS_MANUAL_PART_ShaderVariation();
    #endif
}

// class SoundStream | File: ../Audio/SoundStream.h
template <class T> void RegisterMembers_SoundStream(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // virtual unsigned SoundStream::GetData(signed char* dest, unsigned numBytes) = 0
    // Error: type "signed char*" can not automatically bind

    // float SoundStream::GetFrequency() const
    engine->RegisterObjectMethod(className, "float GetFrequency() const", AS_METHODPR(T, GetFrequency, () const, float), AS_CALL_THISCALL);

    // unsigned SoundStream::GetIntFrequency() const
    engine->RegisterObjectMethod(className, "uint GetIntFrequency() const", AS_METHODPR(T, GetIntFrequency, () const, unsigned), AS_CALL_THISCALL);

    // unsigned SoundStream::GetSampleSize() const
    engine->RegisterObjectMethod(className, "uint GetSampleSize() const", AS_METHODPR(T, GetSampleSize, () const, unsigned), AS_CALL_THISCALL);

    // bool SoundStream::GetStopAtEnd() const
    engine->RegisterObjectMethod(className, "bool GetStopAtEnd() const", AS_METHODPR(T, GetStopAtEnd, () const, bool), AS_CALL_THISCALL);

    // bool SoundStream::IsSixteenBit() const
    engine->RegisterObjectMethod(className, "bool IsSixteenBit() const", AS_METHODPR(T, IsSixteenBit, () const, bool), AS_CALL_THISCALL);

    // bool SoundStream::IsStereo() const
    engine->RegisterObjectMethod(className, "bool IsStereo() const", AS_METHODPR(T, IsStereo, () const, bool), AS_CALL_THISCALL);

    // virtual bool SoundStream::Seek(unsigned sample_number)
    engine->RegisterObjectMethod(className, "bool Seek(uint)", AS_METHODPR(T, Seek, (unsigned), bool), AS_CALL_THISCALL);

    // void SoundStream::SetFormat(unsigned frequency, bool sixteenBit, bool stereo)
    engine->RegisterObjectMethod(className, "void SetFormat(uint, bool, bool)", AS_METHODPR(T, SetFormat, (unsigned, bool, bool), void), AS_CALL_THISCALL);

    // void SoundStream::SetStopAtEnd(bool enable)
    engine->RegisterObjectMethod(className, "void SetStopAtEnd(bool)", AS_METHODPR(T, SetStopAtEnd, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SoundStream
        REGISTER_MEMBERS_MANUAL_PART_SoundStream();
    #endif
}

// class SphereOctreeQuery | File: ../Graphics/OctreeQuery.h
template <class T> void RegisterMembers_SphereOctreeQuery(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_OctreeQuery<T>(engine, className);

    // Sphere SphereOctreeQuery::sphere_
    engine->RegisterObjectProperty(className, "Sphere sphere", offsetof(T, sphere_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SphereOctreeQuery
        REGISTER_MEMBERS_MANUAL_PART_SphereOctreeQuery();
    #endif
}

// class ValueAnimationInfo | File: ../Scene/ValueAnimationInfo.h
template <class T> void RegisterMembers_ValueAnimationInfo(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // ValueAnimation* ValueAnimationInfo::GetAnimation() const
    engine->RegisterObjectMethod(className, "ValueAnimation@+ GetAnimation() const", AS_METHODPR(T, GetAnimation, () const, ValueAnimation*), AS_CALL_THISCALL);

    // float ValueAnimationInfo::GetSpeed() const
    engine->RegisterObjectMethod(className, "float GetSpeed() const", AS_METHODPR(T, GetSpeed, () const, float), AS_CALL_THISCALL);

    // Object* ValueAnimationInfo::GetTarget() const
    engine->RegisterObjectMethod(className, "Object@+ GetTarget() const", AS_METHODPR(T, GetTarget, () const, Object*), AS_CALL_THISCALL);

    // float ValueAnimationInfo::GetTime() const
    engine->RegisterObjectMethod(className, "float GetTime() const", AS_METHODPR(T, GetTime, () const, float), AS_CALL_THISCALL);

    // WrapMode ValueAnimationInfo::GetWrapMode() const
    engine->RegisterObjectMethod(className, "WrapMode GetWrapMode() const", AS_METHODPR(T, GetWrapMode, () const, WrapMode), AS_CALL_THISCALL);

    // void ValueAnimationInfo::SetSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetSpeed(float)", AS_METHODPR(T, SetSpeed, (float), void), AS_CALL_THISCALL);

    // bool ValueAnimationInfo::SetTime(float time)
    engine->RegisterObjectMethod(className, "bool SetTime(float)", AS_METHODPR(T, SetTime, (float), bool), AS_CALL_THISCALL);

    // void ValueAnimationInfo::SetWrapMode(WrapMode wrapMode)
    engine->RegisterObjectMethod(className, "void SetWrapMode(WrapMode)", AS_METHODPR(T, SetWrapMode, (WrapMode), void), AS_CALL_THISCALL);

    // bool ValueAnimationInfo::Update(float timeStep)
    engine->RegisterObjectMethod(className, "bool Update(float)", AS_METHODPR(T, Update, (float), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ValueAnimationInfo
        REGISTER_MEMBERS_MANUAL_PART_ValueAnimationInfo();
    #endif
}

// struct WorkItem | File: ../Core/WorkQueue.h
template <class T> void RegisterMembers_WorkItem(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // void(* WorkItem::workFunction_) (const WorkItem* , unsigned)
    // Not registered because pointer
    // void* WorkItem::start_
    // Not registered because pointer
    // void* WorkItem::end_
    // Not registered because pointer
    // void* WorkItem::aux_
    // Not registered because pointer
    // std::atomic<bool> WorkItem::completed_
    // Error: type "std::atomic<bool>" can not automatically bind

    // unsigned WorkItem::priority_
    engine->RegisterObjectProperty(className, "uint priority", offsetof(T, priority_));

    // bool WorkItem::sendEvent_
    engine->RegisterObjectProperty(className, "bool sendEvent", offsetof(T, sendEvent_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_WorkItem
        REGISTER_MEMBERS_MANUAL_PART_WorkItem();
    #endif
}

#ifdef URHO3D_NAVIGATION

// struct DynamicNavBuildData | File: ../Navigation/NavBuildData.h
template <class T> void RegisterMembers_DynamicNavBuildData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_NavBuildData<T>(engine, className);

    // dtTileCacheContourSet* DynamicNavBuildData::contourSet_
    // Not registered because pointer
    // dtTileCachePolyMesh* DynamicNavBuildData::polyMesh_
    // Not registered because pointer
    // rcHeightfieldLayerSet* DynamicNavBuildData::heightFieldLayers_
    // Not registered because pointer
    // dtTileCacheAlloc* DynamicNavBuildData::alloc_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DynamicNavBuildData
        REGISTER_MEMBERS_MANUAL_PART_DynamicNavBuildData();
    #endif
}

// struct SimpleNavBuildData | File: ../Navigation/NavBuildData.h
template <class T> void RegisterMembers_SimpleNavBuildData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_NavBuildData<T>(engine, className);

    // rcContourSet* SimpleNavBuildData::contourSet_
    // Not registered because pointer
    // rcPolyMesh* SimpleNavBuildData::polyMesh_
    // Not registered because pointer
    // rcPolyMeshDetail* SimpleNavBuildData::polyMeshDetail_
    // Not registered because pointer

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SimpleNavBuildData
        REGISTER_MEMBERS_MANUAL_PART_SimpleNavBuildData();
    #endif
}

#endif // def URHO3D_NAVIGATION

#ifdef URHO3D_NETWORK

// class HttpRequest | File: ../Network/HttpRequest.h
template <class T> void RegisterMembers_HttpRequest(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);
    RegisterMembers_Deserializer<T>(engine, className);
    RegisterMembers_Thread<T>(engine, className);

    // unsigned HttpRequest::GetAvailableSize() const
    engine->RegisterObjectMethod(className, "uint GetAvailableSize() const", AS_METHODPR(T, GetAvailableSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_availableSize() const", AS_METHODPR(T, GetAvailableSize, () const, unsigned), AS_CALL_THISCALL);

    // String HttpRequest::GetError() const
    engine->RegisterObjectMethod(className, "String GetError() const", AS_METHODPR(T, GetError, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_error() const", AS_METHODPR(T, GetError, () const, String), AS_CALL_THISCALL);

    // HttpRequestState HttpRequest::GetState() const
    engine->RegisterObjectMethod(className, "HttpRequestState GetState() const", AS_METHODPR(T, GetState, () const, HttpRequestState), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "HttpRequestState get_state() const", AS_METHODPR(T, GetState, () const, HttpRequestState), AS_CALL_THISCALL);

    // const String& HttpRequest::GetURL() const
    engine->RegisterObjectMethod(className, "const String& GetURL() const", AS_METHODPR(T, GetURL, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_url() const", AS_METHODPR(T, GetURL, () const, const String&), AS_CALL_THISCALL);

    // const String& HttpRequest::GetVerb() const
    engine->RegisterObjectMethod(className, "const String& GetVerb() const", AS_METHODPR(T, GetVerb, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_verb() const", AS_METHODPR(T, GetVerb, () const, const String&), AS_CALL_THISCALL);

    // bool HttpRequest::IsOpen() const
    engine->RegisterObjectMethod(className, "bool IsOpen() const", AS_METHODPR(T, IsOpen, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_open() const", AS_METHODPR(T, IsOpen, () const, bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_HttpRequest
        REGISTER_MEMBERS_MANUAL_PART_HttpRequest();
    #endif
}

#endif // def URHO3D_NETWORK

#ifdef URHO3D_PHYSICS

// struct CollisionGeometryData | File: ../Physics/CollisionShape.h
template <class T> void RegisterMembers_CollisionGeometryData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionGeometryData
        REGISTER_MEMBERS_MANUAL_PART_CollisionGeometryData();
    #endif
}

#endif // def URHO3D_PHYSICS

#ifdef URHO3D_URHO2D

// class PropertySet2D | File: ../Urho2D/TileMapDefs2D.h
template <class T> void RegisterMembers_PropertySet2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // const String& PropertySet2D::GetProperty(const String& name) const
    engine->RegisterObjectMethod(className, "const String& GetProperty(const String&in) const", AS_METHODPR(T, GetProperty, (const String&) const, const String&), AS_CALL_THISCALL);

    // bool PropertySet2D::HasProperty(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasProperty(const String&in) const", AS_METHODPR(T, HasProperty, (const String&) const, bool), AS_CALL_THISCALL);

    // void PropertySet2D::Load(const XMLElement& element)
    engine->RegisterObjectMethod(className, "void Load(const XMLElement&in)", AS_METHODPR(T, Load, (const XMLElement&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PropertySet2D
        REGISTER_MEMBERS_MANUAL_PART_PropertySet2D();
    #endif
}

// class Tile2D | File: ../Urho2D/TileMapDefs2D.h
template <class T> void RegisterMembers_Tile2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // bool Tile2D::GetFlipX() const
    engine->RegisterObjectMethod(className, "bool GetFlipX() const", AS_METHODPR(T, GetFlipX, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_flipX() const", AS_METHODPR(T, GetFlipX, () const, bool), AS_CALL_THISCALL);

    // bool Tile2D::GetFlipY() const
    engine->RegisterObjectMethod(className, "bool GetFlipY() const", AS_METHODPR(T, GetFlipY, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_flipY() const", AS_METHODPR(T, GetFlipY, () const, bool), AS_CALL_THISCALL);

    // unsigned Tile2D::GetGid() const
    engine->RegisterObjectMethod(className, "uint GetGid() const", AS_METHODPR(T, GetGid, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_gid() const", AS_METHODPR(T, GetGid, () const, unsigned), AS_CALL_THISCALL);

    // const String& Tile2D::GetProperty(const String& name) const
    engine->RegisterObjectMethod(className, "const String& GetProperty(const String&in) const", AS_METHODPR(T, GetProperty, (const String&) const, const String&), AS_CALL_THISCALL);

    // Sprite2D* Tile2D::GetSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Sprite2D@+ get_sprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // bool Tile2D::GetSwapXY() const
    engine->RegisterObjectMethod(className, "bool GetSwapXY() const", AS_METHODPR(T, GetSwapXY, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_swapXY() const", AS_METHODPR(T, GetSwapXY, () const, bool), AS_CALL_THISCALL);

    // bool Tile2D::HasProperty(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasProperty(const String&in) const", AS_METHODPR(T, HasProperty, (const String&) const, bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Tile2D
        REGISTER_MEMBERS_MANUAL_PART_Tile2D();
    #endif
}

// class TileMapObject2D | File: ../Urho2D/TileMapDefs2D.h
template <class T> void RegisterMembers_TileMapObject2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // const String& TileMapObject2D::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // unsigned TileMapObject2D::GetNumPoints() const
    engine->RegisterObjectMethod(className, "uint GetNumPoints() const", AS_METHODPR(T, GetNumPoints, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numPoints() const", AS_METHODPR(T, GetNumPoints, () const, unsigned), AS_CALL_THISCALL);

    // TileMapObjectType2D TileMapObject2D::GetObjectType() const
    engine->RegisterObjectMethod(className, "TileMapObjectType2D GetObjectType() const", AS_METHODPR(T, GetObjectType, () const, TileMapObjectType2D), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TileMapObjectType2D get_objectType() const", AS_METHODPR(T, GetObjectType, () const, TileMapObjectType2D), AS_CALL_THISCALL);

    // const Vector2& TileMapObject2D::GetPoint(unsigned index) const
    engine->RegisterObjectMethod(className, "const Vector2& GetPoint(uint) const", AS_METHODPR(T, GetPoint, (unsigned) const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& TileMapObject2D::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_position() const", AS_METHODPR(T, GetPosition, () const, const Vector2&), AS_CALL_THISCALL);

    // const String& TileMapObject2D::GetProperty(const String& name) const
    engine->RegisterObjectMethod(className, "const String& GetProperty(const String&in) const", AS_METHODPR(T, GetProperty, (const String&) const, const String&), AS_CALL_THISCALL);

    // const Vector2& TileMapObject2D::GetSize() const
    engine->RegisterObjectMethod(className, "const Vector2& GetSize() const", AS_METHODPR(T, GetSize, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_size() const", AS_METHODPR(T, GetSize, () const, const Vector2&), AS_CALL_THISCALL);

    // bool TileMapObject2D::GetTileFlipX() const
    engine->RegisterObjectMethod(className, "bool GetTileFlipX() const", AS_METHODPR(T, GetTileFlipX, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_tileFlipX() const", AS_METHODPR(T, GetTileFlipX, () const, bool), AS_CALL_THISCALL);

    // bool TileMapObject2D::GetTileFlipY() const
    engine->RegisterObjectMethod(className, "bool GetTileFlipY() const", AS_METHODPR(T, GetTileFlipY, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_tileFlipY() const", AS_METHODPR(T, GetTileFlipY, () const, bool), AS_CALL_THISCALL);

    // unsigned TileMapObject2D::GetTileGid() const
    engine->RegisterObjectMethod(className, "uint GetTileGid() const", AS_METHODPR(T, GetTileGid, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_tileGid() const", AS_METHODPR(T, GetTileGid, () const, unsigned), AS_CALL_THISCALL);

    // Sprite2D* TileMapObject2D::GetTileSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetTileSprite() const", AS_METHODPR(T, GetTileSprite, () const, Sprite2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Sprite2D@+ get_tileSprite() const", AS_METHODPR(T, GetTileSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // bool TileMapObject2D::GetTileSwapXY() const
    engine->RegisterObjectMethod(className, "bool GetTileSwapXY() const", AS_METHODPR(T, GetTileSwapXY, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_tileSwapXY() const", AS_METHODPR(T, GetTileSwapXY, () const, bool), AS_CALL_THISCALL);

    // const String& TileMapObject2D::GetType() const
    engine->RegisterObjectMethod(className, "const String& GetType() const", AS_METHODPR(T, GetType, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_type() const", AS_METHODPR(T, GetType, () const, const String&), AS_CALL_THISCALL);

    // bool TileMapObject2D::HasProperty(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasProperty(const String&in) const", AS_METHODPR(T, HasProperty, (const String&) const, bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TileMapObject2D
        REGISTER_MEMBERS_MANUAL_PART_TileMapObject2D();
    #endif
}

// class TmxLayer2D | File: ../Urho2D/TmxFile2D.h
template <class T> void RegisterMembers_TmxLayer2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_RefCounted<T>(engine, className);

    // int TmxLayer2D::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // const String& TmxLayer2D::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // const String& TmxLayer2D::GetProperty(const String& name) const
    engine->RegisterObjectMethod(className, "const String& GetProperty(const String&in) const", AS_METHODPR(T, GetProperty, (const String&) const, const String&), AS_CALL_THISCALL);

    // TmxFile2D* TmxLayer2D::GetTmxFile() const
    engine->RegisterObjectMethod(className, "TmxFile2D@+ GetTmxFile() const", AS_METHODPR(T, GetTmxFile, () const, TmxFile2D*), AS_CALL_THISCALL);

    // TileMapLayerType2D TmxLayer2D::GetType() const
    engine->RegisterObjectMethod(className, "TileMapLayerType2D GetType() const", AS_METHODPR(T, GetType, () const, TileMapLayerType2D), AS_CALL_THISCALL);

    // int TmxLayer2D::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool TmxLayer2D::HasProperty(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasProperty(const String&in) const", AS_METHODPR(T, HasProperty, (const String&) const, bool), AS_CALL_THISCALL);

    // bool TmxLayer2D::IsVisible() const
    engine->RegisterObjectMethod(className, "bool IsVisible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TmxLayer2D
        REGISTER_MEMBERS_MANUAL_PART_TmxLayer2D();
    #endif
}

#endif // def URHO3D_URHO2D

// class AttributeAnimationInfo | File: ../Scene/Animatable.h
template <class T> void RegisterMembers_AttributeAnimationInfo(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ValueAnimationInfo<T>(engine, className);

    // const AttributeInfo& AttributeAnimationInfo::GetAttributeInfo() const
    engine->RegisterObjectMethod(className, "const AttributeInfo& GetAttributeInfo() const", AS_METHODPR(T, GetAttributeInfo, () const, const AttributeInfo&), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AttributeAnimationInfo
        REGISTER_MEMBERS_MANUAL_PART_AttributeAnimationInfo();
    #endif
}

// const PODVector<SoundSource*>& Audio::GetSoundSources() const
template <class T> CScriptArray* Audio_constspPODVectorlesSoundSourcestargreamp_GetSoundSources_void_template(T* _ptr)
{
    const PODVector<SoundSource*>& result = _ptr->GetSoundSources();
    return VectorToHandleArray(result, "Array<SoundSource@>");
}

// class Audio | File: ../Audio/Audio.h
template <class T> void RegisterMembers_Audio(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Audio::MixOutput(void* dest, unsigned samples)
    // Error: type "void*" can not automatically bind

    // void Audio::AddSoundSource(SoundSource* soundSource)
    engine->RegisterObjectMethod(className, "void AddSoundSource(SoundSource@+)", AS_METHODPR(T, AddSoundSource, (SoundSource*), void), AS_CALL_THISCALL);

    // bool Audio::GetInterpolation() const
    engine->RegisterObjectMethod(className, "bool GetInterpolation() const", AS_METHODPR(T, GetInterpolation, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_interpolation() const", AS_METHODPR(T, GetInterpolation, () const, bool), AS_CALL_THISCALL);

    // SoundListener* Audio::GetListener() const
    engine->RegisterObjectMethod(className, "SoundListener@+ GetListener() const", AS_METHODPR(T, GetListener, () const, SoundListener*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "SoundListener@+ get_listener() const", AS_METHODPR(T, GetListener, () const, SoundListener*), AS_CALL_THISCALL);

    // float Audio::GetMasterGain(const String& type) const
    engine->RegisterObjectMethod(className, "float GetMasterGain(const String&in) const", AS_METHODPR(T, GetMasterGain, (const String&) const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_masterGain(const String&in) const", AS_METHODPR(T, GetMasterGain, (const String&) const, float), AS_CALL_THISCALL);

    // int Audio::GetMixRate() const
    engine->RegisterObjectMethod(className, "int GetMixRate() const", AS_METHODPR(T, GetMixRate, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_mixRate() const", AS_METHODPR(T, GetMixRate, () const, int), AS_CALL_THISCALL);

    // Mutex& Audio::GetMutex()
    engine->RegisterObjectMethod(className, "Mutex& GetMutex()", AS_METHODPR(T, GetMutex, (), Mutex&), AS_CALL_THISCALL);

    // unsigned Audio::GetSampleSize() const
    engine->RegisterObjectMethod(className, "uint GetSampleSize() const", AS_METHODPR(T, GetSampleSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_sampleSize() const", AS_METHODPR(T, GetSampleSize, () const, unsigned), AS_CALL_THISCALL);

    // float Audio::GetSoundSourceMasterGain(StringHash typeHash) const
    engine->RegisterObjectMethod(className, "float GetSoundSourceMasterGain(StringHash) const", AS_METHODPR(T, GetSoundSourceMasterGain, (StringHash) const, float), AS_CALL_THISCALL);

    // const PODVector<SoundSource*>& Audio::GetSoundSources() const
    engine->RegisterObjectMethod(className, "Array<SoundSource@>@ GetSoundSources() const", AS_FUNCTION_OBJFIRST(Audio_constspPODVectorlesSoundSourcestargreamp_GetSoundSources_void_template<Audio>), AS_CALL_CDECL_OBJFIRST);

    // bool Audio::HasMasterGain(const String& type) const
    engine->RegisterObjectMethod(className, "bool HasMasterGain(const String&in) const", AS_METHODPR(T, HasMasterGain, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Audio::IsInitialized() const
    engine->RegisterObjectMethod(className, "bool IsInitialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_initialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);

    // bool Audio::IsPlaying() const
    engine->RegisterObjectMethod(className, "bool IsPlaying() const", AS_METHODPR(T, IsPlaying, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_playing() const", AS_METHODPR(T, IsPlaying, () const, bool), AS_CALL_THISCALL);

    // bool Audio::IsSoundTypePaused(const String& type) const
    engine->RegisterObjectMethod(className, "bool IsSoundTypePaused(const String&in) const", AS_METHODPR(T, IsSoundTypePaused, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Audio::IsStereo() const
    engine->RegisterObjectMethod(className, "bool IsStereo() const", AS_METHODPR(T, IsStereo, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_stereo() const", AS_METHODPR(T, IsStereo, () const, bool), AS_CALL_THISCALL);

    // void Audio::PauseSoundType(const String& type)
    engine->RegisterObjectMethod(className, "void PauseSoundType(const String&in)", AS_METHODPR(T, PauseSoundType, (const String&), void), AS_CALL_THISCALL);

    // bool Audio::Play()
    engine->RegisterObjectMethod(className, "bool Play()", AS_METHODPR(T, Play, (), bool), AS_CALL_THISCALL);

    // void Audio::RemoveSoundSource(SoundSource* soundSource)
    engine->RegisterObjectMethod(className, "void RemoveSoundSource(SoundSource@+)", AS_METHODPR(T, RemoveSoundSource, (SoundSource*), void), AS_CALL_THISCALL);

    // void Audio::ResumeAll()
    engine->RegisterObjectMethod(className, "void ResumeAll()", AS_METHODPR(T, ResumeAll, (), void), AS_CALL_THISCALL);

    // void Audio::ResumeSoundType(const String& type)
    engine->RegisterObjectMethod(className, "void ResumeSoundType(const String&in)", AS_METHODPR(T, ResumeSoundType, (const String&), void), AS_CALL_THISCALL);

    // void Audio::SetListener(SoundListener* listener)
    engine->RegisterObjectMethod(className, "void SetListener(SoundListener@+)", AS_METHODPR(T, SetListener, (SoundListener*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_listener(SoundListener@+)", AS_METHODPR(T, SetListener, (SoundListener*), void), AS_CALL_THISCALL);

    // void Audio::SetMasterGain(const String& type, float gain)
    engine->RegisterObjectMethod(className, "void SetMasterGain(const String&in, float)", AS_METHODPR(T, SetMasterGain, (const String&, float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_masterGain(const String&in, float)", AS_METHODPR(T, SetMasterGain, (const String&, float), void), AS_CALL_THISCALL);

    // bool Audio::SetMode(int bufferLengthMSec, int mixRate, bool stereo, bool interpolation = true)
    engine->RegisterObjectMethod(className, "bool SetMode(int, int, bool, bool = true)", AS_METHODPR(T, SetMode, (int, int, bool, bool), bool), AS_CALL_THISCALL);

    // void Audio::Stop()
    engine->RegisterObjectMethod(className, "void Stop()", AS_METHODPR(T, Stop, (), void), AS_CALL_THISCALL);

    // void Audio::StopSound(Sound* sound)
    engine->RegisterObjectMethod(className, "void StopSound(Sound@+)", AS_METHODPR(T, StopSound, (Sound*), void), AS_CALL_THISCALL);

    // void Audio::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Audio
        REGISTER_MEMBERS_MANUAL_PART_Audio();
    #endif
}

// class BufferedSoundStream | File: ../Audio/BufferedSoundStream.h
template <class T> void RegisterMembers_BufferedSoundStream(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_SoundStream<T>(engine, className);

    // void BufferedSoundStream::AddData(void* data, unsigned numBytes)
    // Error: type "void*" can not automatically bind
    // void BufferedSoundStream::AddData(const SharedArrayPtr<signed char>& data, unsigned numBytes)
    // Error: type "const SharedArrayPtr<signed char>&" can not automatically bind
    // void BufferedSoundStream::AddData(const SharedArrayPtr<signed short>& data, unsigned numBytes)
    // Error: type "const SharedArrayPtr<signed short>&" can not automatically bind

    // void BufferedSoundStream::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // float BufferedSoundStream::GetBufferLength() const
    engine->RegisterObjectMethod(className, "float GetBufferLength() const", AS_METHODPR(T, GetBufferLength, () const, float), AS_CALL_THISCALL);

    // unsigned BufferedSoundStream::GetBufferNumBytes() const
    engine->RegisterObjectMethod(className, "uint GetBufferNumBytes() const", AS_METHODPR(T, GetBufferNumBytes, () const, unsigned), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BufferedSoundStream
        REGISTER_MEMBERS_MANUAL_PART_BufferedSoundStream();
    #endif
}

// class Console | File: ../Engine/Console.h
template <class T> void RegisterMembers_Console(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Console::AddAutoComplete(const String& option)
    engine->RegisterObjectMethod(className, "void AddAutoComplete(const String&in)", AS_METHODPR(T, AddAutoComplete, (const String&), void), AS_CALL_THISCALL);

    // void Console::CopySelectedRows() const
    engine->RegisterObjectMethod(className, "void CopySelectedRows() const", AS_METHODPR(T, CopySelectedRows, () const, void), AS_CALL_THISCALL);

    // BorderImage* Console::GetBackground() const
    engine->RegisterObjectMethod(className, "BorderImage@+ GetBackground() const", AS_METHODPR(T, GetBackground, () const, BorderImage*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BorderImage@+ get_background() const", AS_METHODPR(T, GetBackground, () const, BorderImage*), AS_CALL_THISCALL);

    // Button* Console::GetCloseButton() const
    engine->RegisterObjectMethod(className, "Button@+ GetCloseButton() const", AS_METHODPR(T, GetCloseButton, () const, Button*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Button@+ get_closeButton() const", AS_METHODPR(T, GetCloseButton, () const, Button*), AS_CALL_THISCALL);

    // const String& Console::GetCommandInterpreter() const
    engine->RegisterObjectMethod(className, "const String& GetCommandInterpreter() const", AS_METHODPR(T, GetCommandInterpreter, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_commandInterpreter() const", AS_METHODPR(T, GetCommandInterpreter, () const, const String&), AS_CALL_THISCALL);

    // XMLFile* Console::GetDefaultStyle() const
    engine->RegisterObjectMethod(className, "XMLFile@+ GetDefaultStyle() const", AS_METHODPR(T, GetDefaultStyle, () const, XMLFile*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLFile@+ get_defaultStyle() const", AS_METHODPR(T, GetDefaultStyle, () const, XMLFile*), AS_CALL_THISCALL);

    // bool Console::GetFocusOnShow() const
    engine->RegisterObjectMethod(className, "bool GetFocusOnShow() const", AS_METHODPR(T, GetFocusOnShow, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_focusOnShow() const", AS_METHODPR(T, GetFocusOnShow, () const, bool), AS_CALL_THISCALL);

    // unsigned Console::GetHistoryPosition() const
    engine->RegisterObjectMethod(className, "uint GetHistoryPosition() const", AS_METHODPR(T, GetHistoryPosition, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_historyPosition() const", AS_METHODPR(T, GetHistoryPosition, () const, unsigned), AS_CALL_THISCALL);

    // const String& Console::GetHistoryRow(unsigned index) const
    engine->RegisterObjectMethod(className, "const String& GetHistoryRow(uint) const", AS_METHODPR(T, GetHistoryRow, (unsigned) const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_historyRow(uint) const", AS_METHODPR(T, GetHistoryRow, (unsigned) const, const String&), AS_CALL_THISCALL);

    // LineEdit* Console::GetLineEdit() const
    engine->RegisterObjectMethod(className, "LineEdit@+ GetLineEdit() const", AS_METHODPR(T, GetLineEdit, () const, LineEdit*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LineEdit@+ get_lineEdit() const", AS_METHODPR(T, GetLineEdit, () const, LineEdit*), AS_CALL_THISCALL);

    // unsigned Console::GetNumBufferedRows() const
    engine->RegisterObjectMethod(className, "uint GetNumBufferedRows() const", AS_METHODPR(T, GetNumBufferedRows, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numBufferedRows() const", AS_METHODPR(T, GetNumBufferedRows, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Console::GetNumHistoryRows() const
    engine->RegisterObjectMethod(className, "uint GetNumHistoryRows() const", AS_METHODPR(T, GetNumHistoryRows, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numHistoryRows() const", AS_METHODPR(T, GetNumHistoryRows, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Console::GetNumRows() const
    engine->RegisterObjectMethod(className, "uint GetNumRows() const", AS_METHODPR(T, GetNumRows, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numRows() const", AS_METHODPR(T, GetNumRows, () const, unsigned), AS_CALL_THISCALL);

    // bool Console::IsAutoVisibleOnError() const
    engine->RegisterObjectMethod(className, "bool IsAutoVisibleOnError() const", AS_METHODPR(T, IsAutoVisibleOnError, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoVisibleOnError() const", AS_METHODPR(T, IsAutoVisibleOnError, () const, bool), AS_CALL_THISCALL);

    // bool Console::IsVisible() const
    engine->RegisterObjectMethod(className, "bool IsVisible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_visible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);

    // void Console::RemoveAutoComplete(const String& option)
    engine->RegisterObjectMethod(className, "void RemoveAutoComplete(const String&in)", AS_METHODPR(T, RemoveAutoComplete, (const String&), void), AS_CALL_THISCALL);

    // void Console::SetAutoVisibleOnError(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoVisibleOnError(bool)", AS_METHODPR(T, SetAutoVisibleOnError, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoVisibleOnError(bool)", AS_METHODPR(T, SetAutoVisibleOnError, (bool), void), AS_CALL_THISCALL);

    // void Console::SetCommandInterpreter(const String& interpreter)
    engine->RegisterObjectMethod(className, "void SetCommandInterpreter(const String&in)", AS_METHODPR(T, SetCommandInterpreter, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_commandInterpreter(const String&in)", AS_METHODPR(T, SetCommandInterpreter, (const String&), void), AS_CALL_THISCALL);

    // void Console::SetDefaultStyle(XMLFile* style)
    engine->RegisterObjectMethod(className, "void SetDefaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);

    // void Console::SetFocusOnShow(bool enable)
    engine->RegisterObjectMethod(className, "void SetFocusOnShow(bool)", AS_METHODPR(T, SetFocusOnShow, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_focusOnShow(bool)", AS_METHODPR(T, SetFocusOnShow, (bool), void), AS_CALL_THISCALL);

    // void Console::SetNumBufferedRows(unsigned rows)
    engine->RegisterObjectMethod(className, "void SetNumBufferedRows(uint)", AS_METHODPR(T, SetNumBufferedRows, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numBufferedRows(uint)", AS_METHODPR(T, SetNumBufferedRows, (unsigned), void), AS_CALL_THISCALL);

    // void Console::SetNumHistoryRows(unsigned rows)
    engine->RegisterObjectMethod(className, "void SetNumHistoryRows(uint)", AS_METHODPR(T, SetNumHistoryRows, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numHistoryRows(uint)", AS_METHODPR(T, SetNumHistoryRows, (unsigned), void), AS_CALL_THISCALL);

    // void Console::SetNumRows(unsigned rows)
    engine->RegisterObjectMethod(className, "void SetNumRows(uint)", AS_METHODPR(T, SetNumRows, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numRows(uint)", AS_METHODPR(T, SetNumRows, (unsigned), void), AS_CALL_THISCALL);

    // void Console::SetVisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetVisible(bool)", AS_METHODPR(T, SetVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_visible(bool)", AS_METHODPR(T, SetVisible, (bool), void), AS_CALL_THISCALL);

    // void Console::Toggle()
    engine->RegisterObjectMethod(className, "void Toggle()", AS_METHODPR(T, Toggle, (), void), AS_CALL_THISCALL);

    // void Console::UpdateElements()
    engine->RegisterObjectMethod(className, "void UpdateElements()", AS_METHODPR(T, UpdateElements, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Console
        REGISTER_MEMBERS_MANUAL_PART_Console();
    #endif
}

// class ConstantBuffer | File: ../Graphics/ConstantBuffer.h
template <class T> void RegisterMembers_ConstantBuffer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);
    RegisterMembers_GPUObject<T>(engine, className);

    // void ConstantBuffer::SetParameter(unsigned offset, unsigned size, const void* data)
    // Error: type "const void*" can not automatically bind
    // void ConstantBuffer::SetVector3ArrayParameter(unsigned offset, unsigned rows, const void* data)
    // Error: type "const void*" can not automatically bind

    // void ConstantBuffer::Apply()
    engine->RegisterObjectMethod(className, "void Apply()", AS_METHODPR(T, Apply, (), void), AS_CALL_THISCALL);

    // unsigned ConstantBuffer::GetSize() const
    engine->RegisterObjectMethod(className, "uint GetSize() const", AS_METHODPR(T, GetSize, () const, unsigned), AS_CALL_THISCALL);

    // bool ConstantBuffer::IsDirty() const
    engine->RegisterObjectMethod(className, "bool IsDirty() const", AS_METHODPR(T, IsDirty, () const, bool), AS_CALL_THISCALL);

    // bool ConstantBuffer::SetSize(unsigned size)
    engine->RegisterObjectMethod(className, "bool SetSize(uint)", AS_METHODPR(T, SetSize, (unsigned), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstantBuffer
        REGISTER_MEMBERS_MANUAL_PART_ConstantBuffer();
    #endif
}

// class DebugHud | File: ../Engine/DebugHud.h
template <class T> void RegisterMembers_DebugHud(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void DebugHud::ClearAppStats()
    engine->RegisterObjectMethod(className, "void ClearAppStats()", AS_METHODPR(T, ClearAppStats, (), void), AS_CALL_THISCALL);

    // XMLFile* DebugHud::GetDefaultStyle() const
    engine->RegisterObjectMethod(className, "XMLFile@+ GetDefaultStyle() const", AS_METHODPR(T, GetDefaultStyle, () const, XMLFile*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLFile@+ get_defaultStyle() const", AS_METHODPR(T, GetDefaultStyle, () const, XMLFile*), AS_CALL_THISCALL);

    // Text* DebugHud::GetMemoryText() const
    engine->RegisterObjectMethod(className, "Text@+ GetMemoryText() const", AS_METHODPR(T, GetMemoryText, () const, Text*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Text@+ get_memoryText() const", AS_METHODPR(T, GetMemoryText, () const, Text*), AS_CALL_THISCALL);

    // unsigned DebugHud::GetMode() const
    engine->RegisterObjectMethod(className, "uint GetMode() const", AS_METHODPR(T, GetMode, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_mode() const", AS_METHODPR(T, GetMode, () const, unsigned), AS_CALL_THISCALL);

    // Text* DebugHud::GetModeText() const
    engine->RegisterObjectMethod(className, "Text@+ GetModeText() const", AS_METHODPR(T, GetModeText, () const, Text*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Text@+ get_modeText() const", AS_METHODPR(T, GetModeText, () const, Text*), AS_CALL_THISCALL);

    // float DebugHud::GetProfilerInterval() const
    engine->RegisterObjectMethod(className, "float GetProfilerInterval() const", AS_METHODPR(T, GetProfilerInterval, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_profilerInterval() const", AS_METHODPR(T, GetProfilerInterval, () const, float), AS_CALL_THISCALL);

    // unsigned DebugHud::GetProfilerMaxDepth() const
    engine->RegisterObjectMethod(className, "uint GetProfilerMaxDepth() const", AS_METHODPR(T, GetProfilerMaxDepth, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_profilerMaxDepth() const", AS_METHODPR(T, GetProfilerMaxDepth, () const, unsigned), AS_CALL_THISCALL);

    // Text* DebugHud::GetProfilerText() const
    engine->RegisterObjectMethod(className, "Text@+ GetProfilerText() const", AS_METHODPR(T, GetProfilerText, () const, Text*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Text@+ get_profilerText() const", AS_METHODPR(T, GetProfilerText, () const, Text*), AS_CALL_THISCALL);

    // Text* DebugHud::GetStatsText() const
    engine->RegisterObjectMethod(className, "Text@+ GetStatsText() const", AS_METHODPR(T, GetStatsText, () const, Text*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Text@+ get_statsText() const", AS_METHODPR(T, GetStatsText, () const, Text*), AS_CALL_THISCALL);

    // bool DebugHud::GetUseRendererStats() const
    engine->RegisterObjectMethod(className, "bool GetUseRendererStats() const", AS_METHODPR(T, GetUseRendererStats, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useRendererStats() const", AS_METHODPR(T, GetUseRendererStats, () const, bool), AS_CALL_THISCALL);

    // bool DebugHud::ResetAppStats(const String& label)
    engine->RegisterObjectMethod(className, "bool ResetAppStats(const String&in)", AS_METHODPR(T, ResetAppStats, (const String&), bool), AS_CALL_THISCALL);

    // void DebugHud::SetAppStats(const String& label, const Variant& stats)
    engine->RegisterObjectMethod(className, "void SetAppStats(const String&in, const Variant&in)", AS_METHODPR(T, SetAppStats, (const String&, const Variant&), void), AS_CALL_THISCALL);

    // void DebugHud::SetAppStats(const String& label, const String& stats)
    engine->RegisterObjectMethod(className, "void SetAppStats(const String&in, const String&in)", AS_METHODPR(T, SetAppStats, (const String&, const String&), void), AS_CALL_THISCALL);

    // void DebugHud::SetDefaultStyle(XMLFile* style)
    engine->RegisterObjectMethod(className, "void SetDefaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);

    // void DebugHud::SetMode(unsigned mode)
    engine->RegisterObjectMethod(className, "void SetMode(uint)", AS_METHODPR(T, SetMode, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mode(uint)", AS_METHODPR(T, SetMode, (unsigned), void), AS_CALL_THISCALL);

    // void DebugHud::SetProfilerInterval(float interval)
    engine->RegisterObjectMethod(className, "void SetProfilerInterval(float)", AS_METHODPR(T, SetProfilerInterval, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_profilerInterval(float)", AS_METHODPR(T, SetProfilerInterval, (float), void), AS_CALL_THISCALL);

    // void DebugHud::SetProfilerMaxDepth(unsigned depth)
    engine->RegisterObjectMethod(className, "void SetProfilerMaxDepth(uint)", AS_METHODPR(T, SetProfilerMaxDepth, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_profilerMaxDepth(uint)", AS_METHODPR(T, SetProfilerMaxDepth, (unsigned), void), AS_CALL_THISCALL);

    // void DebugHud::SetUseRendererStats(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseRendererStats(bool)", AS_METHODPR(T, SetUseRendererStats, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useRendererStats(bool)", AS_METHODPR(T, SetUseRendererStats, (bool), void), AS_CALL_THISCALL);

    // void DebugHud::Toggle(unsigned mode)
    engine->RegisterObjectMethod(className, "void Toggle(uint)", AS_METHODPR(T, Toggle, (unsigned), void), AS_CALL_THISCALL);

    // void DebugHud::ToggleAll()
    engine->RegisterObjectMethod(className, "void ToggleAll()", AS_METHODPR(T, ToggleAll, (), void), AS_CALL_THISCALL);

    // void DebugHud::Update()
    engine->RegisterObjectMethod(className, "void Update()", AS_METHODPR(T, Update, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DebugHud
        REGISTER_MEMBERS_MANUAL_PART_DebugHud();
    #endif
}

// static VariantMap Engine::ParseParameters(const Vector<String>& arguments)
template <class T> VariantMap Engine_VariantMap_ParseParameters_constspVectorlesStringgreamp(CScriptArray* arguments_conv)
{
    Vector<String> arguments = ArrayToVector<String>(arguments_conv);
    VariantMap result = T::ParseParameters(arguments);
    return result;
}

// class Engine | File: ../Engine/Engine.h
template <class T> void RegisterMembers_Engine(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Engine::ApplyFrameLimit()
    engine->RegisterObjectMethod(className, "void ApplyFrameLimit()", AS_METHODPR(T, ApplyFrameLimit, (), void), AS_CALL_THISCALL);

    // Console* Engine::CreateConsole()
    engine->RegisterObjectMethod(className, "Console@+ CreateConsole()", AS_METHODPR(T, CreateConsole, (), Console*), AS_CALL_THISCALL);

    // DebugHud* Engine::CreateDebugHud()
    engine->RegisterObjectMethod(className, "DebugHud@+ CreateDebugHud()", AS_METHODPR(T, CreateDebugHud, (), DebugHud*), AS_CALL_THISCALL);

    // void Engine::DumpMemory()
    engine->RegisterObjectMethod(className, "void DumpMemory()", AS_METHODPR(T, DumpMemory, (), void), AS_CALL_THISCALL);

    // void Engine::DumpProfiler()
    engine->RegisterObjectMethod(className, "void DumpProfiler()", AS_METHODPR(T, DumpProfiler, (), void), AS_CALL_THISCALL);

    // void Engine::DumpResources(bool dumpFileName = false)
    engine->RegisterObjectMethod(className, "void DumpResources(bool = false)", AS_METHODPR(T, DumpResources, (bool), void), AS_CALL_THISCALL);

    // void Engine::Exit()
    engine->RegisterObjectMethod(className, "void Exit()", AS_METHODPR(T, Exit, (), void), AS_CALL_THISCALL);

    // bool Engine::GetAutoExit() const
    engine->RegisterObjectMethod(className, "bool GetAutoExit() const", AS_METHODPR(T, GetAutoExit, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoExit() const", AS_METHODPR(T, GetAutoExit, () const, bool), AS_CALL_THISCALL);

    // int Engine::GetMaxFps() const
    engine->RegisterObjectMethod(className, "int GetMaxFps() const", AS_METHODPR(T, GetMaxFps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxFps() const", AS_METHODPR(T, GetMaxFps, () const, int), AS_CALL_THISCALL);

    // int Engine::GetMaxInactiveFps() const
    engine->RegisterObjectMethod(className, "int GetMaxInactiveFps() const", AS_METHODPR(T, GetMaxInactiveFps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxInactiveFps() const", AS_METHODPR(T, GetMaxInactiveFps, () const, int), AS_CALL_THISCALL);

    // int Engine::GetMinFps() const
    engine->RegisterObjectMethod(className, "int GetMinFps() const", AS_METHODPR(T, GetMinFps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_minFps() const", AS_METHODPR(T, GetMinFps, () const, int), AS_CALL_THISCALL);

    // float Engine::GetNextTimeStep() const
    engine->RegisterObjectMethod(className, "float GetNextTimeStep() const", AS_METHODPR(T, GetNextTimeStep, () const, float), AS_CALL_THISCALL);

    // bool Engine::GetPauseMinimized() const
    engine->RegisterObjectMethod(className, "bool GetPauseMinimized() const", AS_METHODPR(T, GetPauseMinimized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_pauseMinimized() const", AS_METHODPR(T, GetPauseMinimized, () const, bool), AS_CALL_THISCALL);

    // int Engine::GetTimeStepSmoothing() const
    engine->RegisterObjectMethod(className, "int GetTimeStepSmoothing() const", AS_METHODPR(T, GetTimeStepSmoothing, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_timeStepSmoothing() const", AS_METHODPR(T, GetTimeStepSmoothing, () const, int), AS_CALL_THISCALL);

    // bool Engine::Initialize(const VariantMap& parameters)
    engine->RegisterObjectMethod(className, "bool Initialize(const VariantMap&in)", AS_METHODPR(T, Initialize, (const VariantMap&), bool), AS_CALL_THISCALL);

    // bool Engine::InitializeResourceCache(const VariantMap& parameters, bool removeOld = true)
    engine->RegisterObjectMethod(className, "bool InitializeResourceCache(const VariantMap&in, bool = true)", AS_METHODPR(T, InitializeResourceCache, (const VariantMap&, bool), bool), AS_CALL_THISCALL);

    // bool Engine::IsExiting() const
    engine->RegisterObjectMethod(className, "bool IsExiting() const", AS_METHODPR(T, IsExiting, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_exiting() const", AS_METHODPR(T, IsExiting, () const, bool), AS_CALL_THISCALL);

    // bool Engine::IsHeadless() const
    engine->RegisterObjectMethod(className, "bool IsHeadless() const", AS_METHODPR(T, IsHeadless, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_headless() const", AS_METHODPR(T, IsHeadless, () const, bool), AS_CALL_THISCALL);

    // bool Engine::IsInitialized() const
    engine->RegisterObjectMethod(className, "bool IsInitialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_initialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);

    // void Engine::Render()
    engine->RegisterObjectMethod(className, "void Render()", AS_METHODPR(T, Render, (), void), AS_CALL_THISCALL);

    // void Engine::RunFrame()
    engine->RegisterObjectMethod(className, "void RunFrame()", AS_METHODPR(T, RunFrame, (), void), AS_CALL_THISCALL);

    // void Engine::SetAutoExit(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoExit(bool)", AS_METHODPR(T, SetAutoExit, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoExit(bool)", AS_METHODPR(T, SetAutoExit, (bool), void), AS_CALL_THISCALL);

    // void Engine::SetMaxFps(int fps)
    engine->RegisterObjectMethod(className, "void SetMaxFps(int)", AS_METHODPR(T, SetMaxFps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxFps(int)", AS_METHODPR(T, SetMaxFps, (int), void), AS_CALL_THISCALL);

    // void Engine::SetMaxInactiveFps(int fps)
    engine->RegisterObjectMethod(className, "void SetMaxInactiveFps(int)", AS_METHODPR(T, SetMaxInactiveFps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxInactiveFps(int)", AS_METHODPR(T, SetMaxInactiveFps, (int), void), AS_CALL_THISCALL);

    // void Engine::SetMinFps(int fps)
    engine->RegisterObjectMethod(className, "void SetMinFps(int)", AS_METHODPR(T, SetMinFps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minFps(int)", AS_METHODPR(T, SetMinFps, (int), void), AS_CALL_THISCALL);

    // void Engine::SetNextTimeStep(float seconds)
    engine->RegisterObjectMethod(className, "void SetNextTimeStep(float)", AS_METHODPR(T, SetNextTimeStep, (float), void), AS_CALL_THISCALL);

    // void Engine::SetPauseMinimized(bool enable)
    engine->RegisterObjectMethod(className, "void SetPauseMinimized(bool)", AS_METHODPR(T, SetPauseMinimized, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pauseMinimized(bool)", AS_METHODPR(T, SetPauseMinimized, (bool), void), AS_CALL_THISCALL);

    // void Engine::SetTimeStepSmoothing(int frames)
    engine->RegisterObjectMethod(className, "void SetTimeStepSmoothing(int)", AS_METHODPR(T, SetTimeStepSmoothing, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_timeStepSmoothing(int)", AS_METHODPR(T, SetTimeStepSmoothing, (int), void), AS_CALL_THISCALL);

    // void Engine::Update()
    engine->RegisterObjectMethod(className, "void Update()", AS_METHODPR(T, Update, (), void), AS_CALL_THISCALL);

    // static VariantMap Engine::ParseParameters(const Vector<String>& arguments)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("VariantMap ParseParameters(Array<String>@+)", AS_FUNCTION(Engine_VariantMap_ParseParameters_constspVectorlesStringgreamp<Engine>), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static bool Engine::HasParameter(const VariantMap& parameters, const String& parameter)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool HasParameter(const VariantMap&in, const String&in)", AS_FUNCTIONPR(T::HasParameter, (const VariantMap&, const String&), bool), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static const Variant& Engine::GetParameter(const VariantMap& parameters, const String& parameter, const Variant& defaultValue = Variant::EMPTY)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("const Variant& GetParameter(const VariantMap&in, const String&in, const Variant&in = Variant::EMPTY)", AS_FUNCTIONPR(T::GetParameter, (const VariantMap&, const String&, const Variant&), const Variant&), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Engine
        REGISTER_MEMBERS_MANUAL_PART_Engine();
    #endif
}

// class EventHandler11Impl | File: ../Core/Object.h
template <class T> void RegisterMembers_EventHandler11Impl(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_EventHandler<T>(engine, className);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_EventHandler11Impl
        REGISTER_MEMBERS_MANUAL_PART_EventHandler11Impl();
    #endif
}

// class File | File: ../IO/File.h
template <class T> void RegisterMembers_File(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);
    RegisterMembers_AbstractFile<T>(engine, className);

    // void* File::GetHandle() const
    // Error: type "void*" can not automatically bind

    // void File::Close()
    engine->RegisterObjectMethod(className, "void Close()", AS_METHODPR(T, Close, (), void), AS_CALL_THISCALL);

    // void File::Flush()
    engine->RegisterObjectMethod(className, "void Flush()", AS_METHODPR(T, Flush, (), void), AS_CALL_THISCALL);

    // FileMode File::GetMode() const
    engine->RegisterObjectMethod(className, "FileMode GetMode() const", AS_METHODPR(T, GetMode, () const, FileMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FileMode get_mode() const", AS_METHODPR(T, GetMode, () const, FileMode), AS_CALL_THISCALL);

    // bool File::IsOpen() const
    engine->RegisterObjectMethod(className, "bool IsOpen() const", AS_METHODPR(T, IsOpen, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_open() const", AS_METHODPR(T, IsOpen, () const, bool), AS_CALL_THISCALL);

    // bool File::IsPackaged() const
    engine->RegisterObjectMethod(className, "bool IsPackaged() const", AS_METHODPR(T, IsPackaged, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_packaged() const", AS_METHODPR(T, IsPackaged, () const, bool), AS_CALL_THISCALL);

    // bool File::Open(const String& fileName, FileMode mode = FILE_READ)
    engine->RegisterObjectMethod(className, "bool Open(const String&in, FileMode = FILE_READ)", AS_METHODPR(T, Open, (const String&, FileMode), bool), AS_CALL_THISCALL);

    // bool File::Open(PackageFile* package, const String& fileName)
    engine->RegisterObjectMethod(className, "bool Open(PackageFile@+, const String&in)", AS_METHODPR(T, Open, (PackageFile*, const String&), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_File
        REGISTER_MEMBERS_MANUAL_PART_File();
    #endif
}

// void FileSelector::SetFilters(const Vector<String>& filters, unsigned defaultIndex)
template <class T> void FileSelector_void_SetFilters_constspVectorlesStringgreamp_unsigned_template(T* _ptr, CScriptArray* filters_conv, unsigned defaultIndex)
{
    Vector<String> filters = ArrayToVector<String>(filters_conv);
    _ptr->SetFilters(filters, defaultIndex);
}

// class FileSelector | File: ../UI/FileSelector.h
template <class T> void RegisterMembers_FileSelector(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // Button* FileSelector::GetCancelButton() const
    engine->RegisterObjectMethod(className, "Button@+ GetCancelButton() const", AS_METHODPR(T, GetCancelButton, () const, Button*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Button@+ get_cancelButton() const", AS_METHODPR(T, GetCancelButton, () const, Button*), AS_CALL_THISCALL);

    // Button* FileSelector::GetCloseButton() const
    engine->RegisterObjectMethod(className, "Button@+ GetCloseButton() const", AS_METHODPR(T, GetCloseButton, () const, Button*), AS_CALL_THISCALL);

    // XMLFile* FileSelector::GetDefaultStyle() const
    engine->RegisterObjectMethod(className, "XMLFile@+ GetDefaultStyle() const", AS_METHODPR(T, GetDefaultStyle, () const, XMLFile*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "XMLFile@+ get_defaultStyle() const", AS_METHODPR(T, GetDefaultStyle, () const, XMLFile*), AS_CALL_THISCALL);

    // bool FileSelector::GetDirectoryMode() const
    engine->RegisterObjectMethod(className, "bool GetDirectoryMode() const", AS_METHODPR(T, GetDirectoryMode, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_directoryMode() const", AS_METHODPR(T, GetDirectoryMode, () const, bool), AS_CALL_THISCALL);

    // ListView* FileSelector::GetFileList() const
    engine->RegisterObjectMethod(className, "ListView@+ GetFileList() const", AS_METHODPR(T, GetFileList, () const, ListView*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ListView@+ get_fileList() const", AS_METHODPR(T, GetFileList, () const, ListView*), AS_CALL_THISCALL);

    // const String& FileSelector::GetFileName() const
    engine->RegisterObjectMethod(className, "const String& GetFileName() const", AS_METHODPR(T, GetFileName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_fileName() const", AS_METHODPR(T, GetFileName, () const, const String&), AS_CALL_THISCALL);

    // LineEdit* FileSelector::GetFileNameEdit() const
    engine->RegisterObjectMethod(className, "LineEdit@+ GetFileNameEdit() const", AS_METHODPR(T, GetFileNameEdit, () const, LineEdit*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LineEdit@+ get_fileNameEdit() const", AS_METHODPR(T, GetFileNameEdit, () const, LineEdit*), AS_CALL_THISCALL);

    // const String& FileSelector::GetFilter() const
    engine->RegisterObjectMethod(className, "const String& GetFilter() const", AS_METHODPR(T, GetFilter, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_filter() const", AS_METHODPR(T, GetFilter, () const, const String&), AS_CALL_THISCALL);

    // unsigned FileSelector::GetFilterIndex() const
    engine->RegisterObjectMethod(className, "uint GetFilterIndex() const", AS_METHODPR(T, GetFilterIndex, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_filterIndex() const", AS_METHODPR(T, GetFilterIndex, () const, unsigned), AS_CALL_THISCALL);

    // DropDownList* FileSelector::GetFilterList() const
    engine->RegisterObjectMethod(className, "DropDownList@+ GetFilterList() const", AS_METHODPR(T, GetFilterList, () const, DropDownList*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "DropDownList@+ get_filterList() const", AS_METHODPR(T, GetFilterList, () const, DropDownList*), AS_CALL_THISCALL);

    // Button* FileSelector::GetOKButton() const
    engine->RegisterObjectMethod(className, "Button@+ GetOKButton() const", AS_METHODPR(T, GetOKButton, () const, Button*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Button@+ get_okButton() const", AS_METHODPR(T, GetOKButton, () const, Button*), AS_CALL_THISCALL);

    // const String& FileSelector::GetPath() const
    engine->RegisterObjectMethod(className, "const String& GetPath() const", AS_METHODPR(T, GetPath, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_path() const", AS_METHODPR(T, GetPath, () const, const String&), AS_CALL_THISCALL);

    // LineEdit* FileSelector::GetPathEdit() const
    engine->RegisterObjectMethod(className, "LineEdit@+ GetPathEdit() const", AS_METHODPR(T, GetPathEdit, () const, LineEdit*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LineEdit@+ get_pathEdit() const", AS_METHODPR(T, GetPathEdit, () const, LineEdit*), AS_CALL_THISCALL);

    // const String& FileSelector::GetTitle() const
    engine->RegisterObjectMethod(className, "const String& GetTitle() const", AS_METHODPR(T, GetTitle, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_title() const", AS_METHODPR(T, GetTitle, () const, const String&), AS_CALL_THISCALL);

    // Text* FileSelector::GetTitleText() const
    engine->RegisterObjectMethod(className, "Text@+ GetTitleText() const", AS_METHODPR(T, GetTitleText, () const, Text*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Text@+ get_titleText() const", AS_METHODPR(T, GetTitleText, () const, Text*), AS_CALL_THISCALL);

    // Window* FileSelector::GetWindow() const
    engine->RegisterObjectMethod(className, "Window@+ GetWindow() const", AS_METHODPR(T, GetWindow, () const, Window*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Window@+ get_window() const", AS_METHODPR(T, GetWindow, () const, Window*), AS_CALL_THISCALL);

    // void FileSelector::SetButtonTexts(const String& okText, const String& cancelText)
    engine->RegisterObjectMethod(className, "void SetButtonTexts(const String&in, const String&in)", AS_METHODPR(T, SetButtonTexts, (const String&, const String&), void), AS_CALL_THISCALL);

    // void FileSelector::SetDefaultStyle(XMLFile* style)
    engine->RegisterObjectMethod(className, "void SetDefaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);

    // void FileSelector::SetDirectoryMode(bool enable)
    engine->RegisterObjectMethod(className, "void SetDirectoryMode(bool)", AS_METHODPR(T, SetDirectoryMode, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_directoryMode(bool)", AS_METHODPR(T, SetDirectoryMode, (bool), void), AS_CALL_THISCALL);

    // void FileSelector::SetFileName(const String& fileName)
    engine->RegisterObjectMethod(className, "void SetFileName(const String&in)", AS_METHODPR(T, SetFileName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fileName(const String&in)", AS_METHODPR(T, SetFileName, (const String&), void), AS_CALL_THISCALL);

    // void FileSelector::SetFilters(const Vector<String>& filters, unsigned defaultIndex)
    engine->RegisterObjectMethod(className, "void SetFilters(Array<String>@+, uint)", AS_FUNCTION_OBJFIRST(FileSelector_void_SetFilters_constspVectorlesStringgreamp_unsigned_template<FileSelector>), AS_CALL_CDECL_OBJFIRST);

    // void FileSelector::SetPath(const String& path)
    engine->RegisterObjectMethod(className, "void SetPath(const String&in)", AS_METHODPR(T, SetPath, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_path(const String&in)", AS_METHODPR(T, SetPath, (const String&), void), AS_CALL_THISCALL);

    // void FileSelector::SetTitle(const String& text)
    engine->RegisterObjectMethod(className, "void SetTitle(const String&in)", AS_METHODPR(T, SetTitle, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_title(const String&in)", AS_METHODPR(T, SetTitle, (const String&), void), AS_CALL_THISCALL);

    // void FileSelector::UpdateElements()
    engine->RegisterObjectMethod(className, "void UpdateElements()", AS_METHODPR(T, UpdateElements, (), void), AS_CALL_THISCALL);

    // static void FileSelector::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FileSelector
        REGISTER_MEMBERS_MANUAL_PART_FileSelector();
    #endif
}

// int FileSystem::SystemRun(const String& fileName, const Vector<String>& arguments)
template <class T> int FileSystem_int_SystemRun_constspStringamp_constspVectorlesStringgreamp_template(T* _ptr, const String& fileName, CScriptArray* arguments_conv)
{
    Vector<String> arguments = ArrayToVector<String>(arguments_conv);
    int result = _ptr->SystemRun(fileName, arguments);
    return result;
}

// unsigned FileSystem::SystemRunAsync(const String& fileName, const Vector<String>& arguments)
template <class T> unsigned FileSystem_unsigned_SystemRunAsync_constspStringamp_constspVectorlesStringgreamp_template(T* _ptr, const String& fileName, CScriptArray* arguments_conv)
{
    Vector<String> arguments = ArrayToVector<String>(arguments_conv);
    unsigned result = _ptr->SystemRunAsync(fileName, arguments);
    return result;
}

// class FileSystem | File: ../IO/FileSystem.h
template <class T> void RegisterMembers_FileSystem(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void FileSystem::ScanDir(Vector<String>& result, const String& pathName, const String& filter, unsigned flags, bool recursive) const
    // Error: type "Vector<String>&" can not automatically bind

    // bool FileSystem::CheckAccess(const String& pathName) const
    engine->RegisterObjectMethod(className, "bool CheckAccess(const String&in) const", AS_METHODPR(T, CheckAccess, (const String&) const, bool), AS_CALL_THISCALL);

    // bool FileSystem::Copy(const String& srcFileName, const String& destFileName)
    engine->RegisterObjectMethod(className, "bool Copy(const String&in, const String&in)", AS_METHODPR(T, Copy, (const String&, const String&), bool), AS_CALL_THISCALL);

    // bool FileSystem::CreateDir(const String& pathName)
    engine->RegisterObjectMethod(className, "bool CreateDir(const String&in)", AS_METHODPR(T, CreateDir, (const String&), bool), AS_CALL_THISCALL);

    // bool FileSystem::Delete(const String& fileName)
    engine->RegisterObjectMethod(className, "bool Delete(const String&in)", AS_METHODPR(T, Delete, (const String&), bool), AS_CALL_THISCALL);

    // bool FileSystem::DirExists(const String& pathName) const
    engine->RegisterObjectMethod(className, "bool DirExists(const String&in) const", AS_METHODPR(T, DirExists, (const String&) const, bool), AS_CALL_THISCALL);

    // bool FileSystem::FileExists(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool FileExists(const String&in) const", AS_METHODPR(T, FileExists, (const String&) const, bool), AS_CALL_THISCALL);

    // String FileSystem::GetAppPreferencesDir(const String& org, const String& app) const
    engine->RegisterObjectMethod(className, "String GetAppPreferencesDir(const String&in, const String&in) const", AS_METHODPR(T, GetAppPreferencesDir, (const String&, const String&) const, String), AS_CALL_THISCALL);

    // String FileSystem::GetCurrentDir() const
    engine->RegisterObjectMethod(className, "String GetCurrentDir() const", AS_METHODPR(T, GetCurrentDir, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_currentDir() const", AS_METHODPR(T, GetCurrentDir, () const, String), AS_CALL_THISCALL);

    // bool FileSystem::GetExecuteConsoleCommands() const
    engine->RegisterObjectMethod(className, "bool GetExecuteConsoleCommands() const", AS_METHODPR(T, GetExecuteConsoleCommands, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_executeConsoleCommands() const", AS_METHODPR(T, GetExecuteConsoleCommands, () const, bool), AS_CALL_THISCALL);

    // unsigned FileSystem::GetLastModifiedTime(const String& fileName) const
    engine->RegisterObjectMethod(className, "uint GetLastModifiedTime(const String&in) const", AS_METHODPR(T, GetLastModifiedTime, (const String&) const, unsigned), AS_CALL_THISCALL);

    // String FileSystem::GetProgramDir() const
    engine->RegisterObjectMethod(className, "String GetProgramDir() const", AS_METHODPR(T, GetProgramDir, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_programDir() const", AS_METHODPR(T, GetProgramDir, () const, String), AS_CALL_THISCALL);

    // String FileSystem::GetTemporaryDir() const
    engine->RegisterObjectMethod(className, "String GetTemporaryDir() const", AS_METHODPR(T, GetTemporaryDir, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_temporaryDir() const", AS_METHODPR(T, GetTemporaryDir, () const, String), AS_CALL_THISCALL);

    // String FileSystem::GetUserDocumentsDir() const
    engine->RegisterObjectMethod(className, "String GetUserDocumentsDir() const", AS_METHODPR(T, GetUserDocumentsDir, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_userDocumentsDir() const", AS_METHODPR(T, GetUserDocumentsDir, () const, String), AS_CALL_THISCALL);

    // bool FileSystem::HasRegisteredPaths() const
    engine->RegisterObjectMethod(className, "bool HasRegisteredPaths() const", AS_METHODPR(T, HasRegisteredPaths, () const, bool), AS_CALL_THISCALL);

    // void FileSystem::RegisterPath(const String& pathName)
    engine->RegisterObjectMethod(className, "void RegisterPath(const String&in)", AS_METHODPR(T, RegisterPath, (const String&), void), AS_CALL_THISCALL);

    // bool FileSystem::Rename(const String& srcFileName, const String& destFileName)
    engine->RegisterObjectMethod(className, "bool Rename(const String&in, const String&in)", AS_METHODPR(T, Rename, (const String&, const String&), bool), AS_CALL_THISCALL);

    // bool FileSystem::SetCurrentDir(const String& pathName)
    engine->RegisterObjectMethod(className, "bool SetCurrentDir(const String&in)", AS_METHODPR(T, SetCurrentDir, (const String&), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_currentDir(const String&in)", AS_METHODPR(T, SetCurrentDir, (const String&), bool), AS_CALL_THISCALL);

    // void FileSystem::SetExecuteConsoleCommands(bool enable)
    engine->RegisterObjectMethod(className, "void SetExecuteConsoleCommands(bool)", AS_METHODPR(T, SetExecuteConsoleCommands, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_executeConsoleCommands(bool)", AS_METHODPR(T, SetExecuteConsoleCommands, (bool), void), AS_CALL_THISCALL);

    // bool FileSystem::SetLastModifiedTime(const String& fileName, unsigned newTime)
    engine->RegisterObjectMethod(className, "bool SetLastModifiedTime(const String&in, uint)", AS_METHODPR(T, SetLastModifiedTime, (const String&, unsigned), bool), AS_CALL_THISCALL);

    // int FileSystem::SystemCommand(const String& commandLine, bool redirectStdOutToLog = false)
    engine->RegisterObjectMethod(className, "int SystemCommand(const String&in, bool = false)", AS_METHODPR(T, SystemCommand, (const String&, bool), int), AS_CALL_THISCALL);

    // unsigned FileSystem::SystemCommandAsync(const String& commandLine)
    engine->RegisterObjectMethod(className, "uint SystemCommandAsync(const String&in)", AS_METHODPR(T, SystemCommandAsync, (const String&), unsigned), AS_CALL_THISCALL);

    // bool FileSystem::SystemOpen(const String& fileName, const String& mode = String::EMPTY)
    engine->RegisterObjectMethod(className, "bool SystemOpen(const String&in, const String&in = String::EMPTY)", AS_METHODPR(T, SystemOpen, (const String&, const String&), bool), AS_CALL_THISCALL);

    // int FileSystem::SystemRun(const String& fileName, const Vector<String>& arguments)
    engine->RegisterObjectMethod(className, "int SystemRun(const String&in, Array<String>@+)", AS_FUNCTION_OBJFIRST(FileSystem_int_SystemRun_constspStringamp_constspVectorlesStringgreamp_template<FileSystem>), AS_CALL_CDECL_OBJFIRST);

    // unsigned FileSystem::SystemRunAsync(const String& fileName, const Vector<String>& arguments)
    engine->RegisterObjectMethod(className, "uint SystemRunAsync(const String&in, Array<String>@+)", AS_FUNCTION_OBJFIRST(FileSystem_unsigned_SystemRunAsync_constspStringamp_constspVectorlesStringgreamp_template<FileSystem>), AS_CALL_CDECL_OBJFIRST);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FileSystem
        REGISTER_MEMBERS_MANUAL_PART_FileSystem();
    #endif
}

// class FileWatcher | File: ../IO/FileWatcher.h
template <class T> void RegisterMembers_FileWatcher(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);
    RegisterMembers_Thread<T>(engine, className);

    // void FileWatcher::AddChange(const String& fileName)
    engine->RegisterObjectMethod(className, "void AddChange(const String&in)", AS_METHODPR(T, AddChange, (const String&), void), AS_CALL_THISCALL);

    // float FileWatcher::GetDelay() const
    engine->RegisterObjectMethod(className, "float GetDelay() const", AS_METHODPR(T, GetDelay, () const, float), AS_CALL_THISCALL);

    // bool FileWatcher::GetNextChange(String& dest)
    engine->RegisterObjectMethod(className, "bool GetNextChange(String&)", AS_METHODPR(T, GetNextChange, (String&), bool), AS_CALL_THISCALL);

    // const String& FileWatcher::GetPath() const
    engine->RegisterObjectMethod(className, "const String& GetPath() const", AS_METHODPR(T, GetPath, () const, const String&), AS_CALL_THISCALL);

    // void FileWatcher::SetDelay(float interval)
    engine->RegisterObjectMethod(className, "void SetDelay(float)", AS_METHODPR(T, SetDelay, (float), void), AS_CALL_THISCALL);

    // bool FileWatcher::StartWatching(const String& pathName, bool watchSubDirs)
    engine->RegisterObjectMethod(className, "bool StartWatching(const String&in, bool)", AS_METHODPR(T, StartWatching, (const String&, bool), bool), AS_CALL_THISCALL);

    // void FileWatcher::StopWatching()
    engine->RegisterObjectMethod(className, "void StopWatching()", AS_METHODPR(T, StopWatching, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FileWatcher
        REGISTER_MEMBERS_MANUAL_PART_FileWatcher();
    #endif
}

// class FontFaceBitmap | File: ../UI/FontFaceBitmap.h
template <class T> void RegisterMembers_FontFaceBitmap(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_FontFace<T>(engine, className);

    // bool FontFaceBitmap::Load(FontFace* fontFace, bool usedGlyphs)
    engine->RegisterObjectMethod(className, "bool Load(FontFace@+, bool)", AS_METHODPR(T, Load, (FontFace*, bool), bool), AS_CALL_THISCALL);

    // bool FontFaceBitmap::Save(Serializer& dest, int pointSize, const String& indentation = "\t")
    engine->RegisterObjectMethod(className, "bool Save(Serializer&, int, const String&in = \"\t\")", AS_METHODPR(T, Save, (Serializer&, int, const String&), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FontFaceBitmap
        REGISTER_MEMBERS_MANUAL_PART_FontFaceBitmap();
    #endif
}

// class FontFaceFreeType | File: ../UI/FontFaceFreeType.h
template <class T> void RegisterMembers_FontFaceFreeType(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_FontFace<T>(engine, className);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_FontFaceFreeType
        REGISTER_MEMBERS_MANUAL_PART_FontFaceFreeType();
    #endif
}

// const Vector<SharedPtr<VertexBuffer>>& Geometry::GetVertexBuffers() const
template <class T> CScriptArray* Geometry_constspVectorlesSharedPtrlesVertexBuffergregreamp_GetVertexBuffers_void_template(T* _ptr)
{
    const Vector<SharedPtr<VertexBuffer>>& result = _ptr->GetVertexBuffers();
    return VectorToHandleArray(result, "Array<VertexBuffer@>");
}

// class Geometry | File: ../Graphics/Geometry.h
template <class T> void RegisterMembers_Geometry(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // float Geometry::GetHitDistance(const Ray& ray, Vector3* outNormal = nullptr, Vector2* outUV = nullptr) const
    // Error: type "Vector3*" can not automatically bind
    // void Geometry::GetRawData(const unsigned char*& vertexData, unsigned& vertexSize, const unsigned char*& indexData, unsigned& indexSize, const PODVector<VertexElement>*& elements) const
    // Error: type "const unsigned char*&" can not automatically bind
    // void Geometry::GetRawDataShared(SharedArrayPtr<unsigned char>& vertexData, unsigned& vertexSize, SharedArrayPtr<unsigned char>& indexData, unsigned& indexSize, const PODVector<VertexElement>*& elements) const
    // Error: type "SharedArrayPtr<unsigned char>&" can not automatically bind
    // void Geometry::SetRawIndexData(const SharedArrayPtr<unsigned char>& data, unsigned indexSize)
    // Error: type "const SharedArrayPtr<unsigned char>&" can not automatically bind
    // void Geometry::SetRawVertexData(const SharedArrayPtr<unsigned char>& data, const PODVector<VertexElement>& elements)
    // Error: type "const SharedArrayPtr<unsigned char>&" can not automatically bind
    // void Geometry::SetRawVertexData(const SharedArrayPtr<unsigned char>& data, unsigned elementMask)
    // Error: type "const SharedArrayPtr<unsigned char>&" can not automatically bind

    // void Geometry::Draw(Graphics* graphics)
    engine->RegisterObjectMethod(className, "void Draw(Graphics@+)", AS_METHODPR(T, Draw, (Graphics*), void), AS_CALL_THISCALL);

    // unsigned short Geometry::GetBufferHash() const
    engine->RegisterObjectMethod(className, "uint16 GetBufferHash() const", AS_METHODPR(T, GetBufferHash, () const, unsigned short), AS_CALL_THISCALL);

    // IndexBuffer* Geometry::GetIndexBuffer() const
    engine->RegisterObjectMethod(className, "IndexBuffer@+ GetIndexBuffer() const", AS_METHODPR(T, GetIndexBuffer, () const, IndexBuffer*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IndexBuffer@+ get_indexBuffer() const", AS_METHODPR(T, GetIndexBuffer, () const, IndexBuffer*), AS_CALL_THISCALL);

    // unsigned Geometry::GetIndexCount() const
    engine->RegisterObjectMethod(className, "uint GetIndexCount() const", AS_METHODPR(T, GetIndexCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_indexCount() const", AS_METHODPR(T, GetIndexCount, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Geometry::GetIndexStart() const
    engine->RegisterObjectMethod(className, "uint GetIndexStart() const", AS_METHODPR(T, GetIndexStart, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_indexStart() const", AS_METHODPR(T, GetIndexStart, () const, unsigned), AS_CALL_THISCALL);

    // float Geometry::GetLodDistance() const
    engine->RegisterObjectMethod(className, "float GetLodDistance() const", AS_METHODPR(T, GetLodDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lodDistance() const", AS_METHODPR(T, GetLodDistance, () const, float), AS_CALL_THISCALL);

    // unsigned Geometry::GetNumVertexBuffers() const
    engine->RegisterObjectMethod(className, "uint GetNumVertexBuffers() const", AS_METHODPR(T, GetNumVertexBuffers, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numVertexBuffers() const", AS_METHODPR(T, GetNumVertexBuffers, () const, unsigned), AS_CALL_THISCALL);

    // PrimitiveType Geometry::GetPrimitiveType() const
    engine->RegisterObjectMethod(className, "PrimitiveType GetPrimitiveType() const", AS_METHODPR(T, GetPrimitiveType, () const, PrimitiveType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "PrimitiveType get_primitiveType() const", AS_METHODPR(T, GetPrimitiveType, () const, PrimitiveType), AS_CALL_THISCALL);

    // VertexBuffer* Geometry::GetVertexBuffer(unsigned index) const
    engine->RegisterObjectMethod(className, "VertexBuffer@+ GetVertexBuffer(uint) const", AS_METHODPR(T, GetVertexBuffer, (unsigned) const, VertexBuffer*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "VertexBuffer@+ get_vertexBuffers(uint) const", AS_METHODPR(T, GetVertexBuffer, (unsigned) const, VertexBuffer*), AS_CALL_THISCALL);

    // const Vector<SharedPtr<VertexBuffer>>& Geometry::GetVertexBuffers() const
    engine->RegisterObjectMethod(className, "Array<VertexBuffer@>@ GetVertexBuffers() const", AS_FUNCTION_OBJFIRST(Geometry_constspVectorlesSharedPtrlesVertexBuffergregreamp_GetVertexBuffers_void_template<Geometry>), AS_CALL_CDECL_OBJFIRST);

    // unsigned Geometry::GetVertexCount() const
    engine->RegisterObjectMethod(className, "uint GetVertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_vertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Geometry::GetVertexStart() const
    engine->RegisterObjectMethod(className, "uint GetVertexStart() const", AS_METHODPR(T, GetVertexStart, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_vertexStart() const", AS_METHODPR(T, GetVertexStart, () const, unsigned), AS_CALL_THISCALL);

    // bool Geometry::IsEmpty() const
    engine->RegisterObjectMethod(className, "bool IsEmpty() const", AS_METHODPR(T, IsEmpty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_empty() const", AS_METHODPR(T, IsEmpty, () const, bool), AS_CALL_THISCALL);

    // bool Geometry::IsInside(const Ray& ray) const
    engine->RegisterObjectMethod(className, "bool IsInside(const Ray&in) const", AS_METHODPR(T, IsInside, (const Ray&) const, bool), AS_CALL_THISCALL);

    // bool Geometry::SetDrawRange(PrimitiveType type, unsigned indexStart, unsigned indexCount, bool getUsedVertexRange = true)
    engine->RegisterObjectMethod(className, "bool SetDrawRange(PrimitiveType, uint, uint, bool = true)", AS_METHODPR(T, SetDrawRange, (PrimitiveType, unsigned, unsigned, bool), bool), AS_CALL_THISCALL);

    // bool Geometry::SetDrawRange(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned vertexStart, unsigned vertexCount, bool checkIllegal = true)
    engine->RegisterObjectMethod(className, "bool SetDrawRange(PrimitiveType, uint, uint, uint, uint, bool = true)", AS_METHODPR(T, SetDrawRange, (PrimitiveType, unsigned, unsigned, unsigned, unsigned, bool), bool), AS_CALL_THISCALL);

    // void Geometry::SetIndexBuffer(IndexBuffer* buffer)
    engine->RegisterObjectMethod(className, "void SetIndexBuffer(IndexBuffer@+)", AS_METHODPR(T, SetIndexBuffer, (IndexBuffer*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_indexBuffer(IndexBuffer@+)", AS_METHODPR(T, SetIndexBuffer, (IndexBuffer*), void), AS_CALL_THISCALL);

    // void Geometry::SetLodDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetLodDistance(float)", AS_METHODPR(T, SetLodDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lodDistance(float)", AS_METHODPR(T, SetLodDistance, (float), void), AS_CALL_THISCALL);

    // bool Geometry::SetNumVertexBuffers(unsigned num)
    engine->RegisterObjectMethod(className, "bool SetNumVertexBuffers(uint)", AS_METHODPR(T, SetNumVertexBuffers, (unsigned), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_numVertexBuffers(uint)", AS_METHODPR(T, SetNumVertexBuffers, (unsigned), bool), AS_CALL_THISCALL);

    // bool Geometry::SetVertexBuffer(unsigned index, VertexBuffer* buffer)
    engine->RegisterObjectMethod(className, "bool SetVertexBuffer(uint, VertexBuffer@+)", AS_METHODPR(T, SetVertexBuffer, (unsigned, VertexBuffer*), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Geometry
        REGISTER_MEMBERS_MANUAL_PART_Geometry();
    #endif
}

// PODVector<int> Graphics::GetMultiSampleLevels() const
template <class T> CScriptArray* Graphics_PODVectorlesintgre_GetMultiSampleLevels_void_template(T* _ptr)
{
    PODVector<int> result = _ptr->GetMultiSampleLevels();
    return VectorToArray(result, "Array<int>");
}

// PODVector<IntVector3> Graphics::GetResolutions(int monitor) const
template <class T> CScriptArray* Graphics_PODVectorlesIntVector3gre_GetResolutions_int_template(T* _ptr, int monitor)
{
    PODVector<IntVector3> result = _ptr->GetResolutions(monitor);
    return VectorToArray(result, "Array<IntVector3>");
}

// bool Graphics::SetVertexBuffers(const Vector<SharedPtr<VertexBuffer>>& buffers, unsigned instanceOffset = 0)
template <class T> bool Graphics_bool_SetVertexBuffers_constspVectorlesSharedPtrlesVertexBuffergregreamp_unsigned_template(T* _ptr, CScriptArray* buffers_conv, unsigned instanceOffset)
{
    Vector<SharedPtr<VertexBuffer>> buffers = HandleArrayToVector<VertexBuffer>(buffers_conv);
    bool result = _ptr->SetVertexBuffers(buffers, instanceOffset);
    return result;
}

// class Graphics | File: ../Graphics/Graphics.h
template <class T> void RegisterMembers_Graphics(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Graphics::AddGPUObject(GPUObject* object)
    // Error: type "GPUObject*" can not automatically bind
    // void Graphics::CleanupRenderSurface(RenderSurface* surface)
    // Not registered because have @nobind mark
    // void Graphics::FreeScratchBuffer(void* buffer)
    // Error: type "void*" can not automatically bind
    // void* Graphics::GetExternalWindow() const
    // Error: type "void*" can not automatically bind
    // GraphicsImpl* Graphics::GetImpl() const
    // Error: type "GraphicsImpl*" can not automatically bind
    // ConstantBuffer* Graphics::GetOrCreateConstantBuffer(ShaderType type, unsigned index, unsigned size)
    // Not registered because have @nobind mark
    // ShaderVariation* Graphics::GetShader(ShaderType type, const char* name, const char* defines) const
    // Error: type "const char*" can not automatically bind
    // ShaderProgram* Graphics::GetShaderProgram() const
    // Not registered because have @nobind mark
    // SDL_Window* Graphics::GetWindow() const
    // Error: type "SDL_Window*" can not automatically bind
    // void Graphics::MarkFBODirty()
    // Not registered because have @nobind mark
    // bool Graphics::NeedParameterUpdate(ShaderParameterGroup group, const void* source)
    // Error: type "const void*" can not automatically bind
    // void Graphics::RemoveGPUObject(GPUObject* object)
    // Error: type "GPUObject*" can not automatically bind
    // void* Graphics::ReserveScratchBuffer(unsigned size)
    // Error: type "void*" can not automatically bind
    // void Graphics::Restore()
    // Not registered because have @nobind mark
    // void Graphics::SetExternalWindow(void* window)
    // Error: type "void*" can not automatically bind
    // void Graphics::SetShaderParameter(StringHash param, const float* data, unsigned count)
    // Error: type "const float*" can not automatically bind
    // void Graphics::SetTextureForUpdate(Texture* texture)
    // Not registered because have @nobind mark
    // void Graphics::SetTextureParametersDirty()
    // Not registered because have @nobind mark
    // void Graphics::SetUBO(unsigned object)
    // Not registered because have @nobind mark
    // void Graphics::SetVBO(unsigned object)
    // Not registered because have @nobind mark
    // bool Graphics::SetVertexBuffers(const PODVector<VertexBuffer*>& buffers, unsigned instanceOffset = 0)
    // Not registered because have @nobind mark

    // void Graphics::BeginDumpShaders(const String& fileName)
    engine->RegisterObjectMethod(className, "void BeginDumpShaders(const String&in)", AS_METHODPR(T, BeginDumpShaders, (const String&), void), AS_CALL_THISCALL);

    // bool Graphics::BeginFrame()
    engine->RegisterObjectMethod(className, "bool BeginFrame()", AS_METHODPR(T, BeginFrame, (), bool), AS_CALL_THISCALL);

    // void Graphics::CleanupScratchBuffers()
    engine->RegisterObjectMethod(className, "void CleanupScratchBuffers()", AS_METHODPR(T, CleanupScratchBuffers, (), void), AS_CALL_THISCALL);

    // void Graphics::CleanupShaderPrograms(ShaderVariation* variation)
    engine->RegisterObjectMethod(className, "void CleanupShaderPrograms(ShaderVariation@+)", AS_METHODPR(T, CleanupShaderPrograms, (ShaderVariation*), void), AS_CALL_THISCALL);

    // void Graphics::Clear(ClearTargetFlags flags, const Color& color = Color(0.0f, 0.0f, 0.0f, 0.0f), float depth = 1.0f, unsigned stencil = 0)
    engine->RegisterObjectMethod(className, "void Clear(ClearTargetFlags, const Color&in = Color(0.0f, 0.0f, 0.0f, 0.0f), float = 1.0f, uint = 0)", AS_METHODPR(T, Clear, (ClearTargetFlags, const Color&, float, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::ClearParameterSource(ShaderParameterGroup group)
    engine->RegisterObjectMethod(className, "void ClearParameterSource(ShaderParameterGroup)", AS_METHODPR(T, ClearParameterSource, (ShaderParameterGroup), void), AS_CALL_THISCALL);

    // void Graphics::ClearParameterSources()
    engine->RegisterObjectMethod(className, "void ClearParameterSources()", AS_METHODPR(T, ClearParameterSources, (), void), AS_CALL_THISCALL);

    // void Graphics::ClearTransformSources()
    engine->RegisterObjectMethod(className, "void ClearTransformSources()", AS_METHODPR(T, ClearTransformSources, (), void), AS_CALL_THISCALL);

    // void Graphics::Close()
    engine->RegisterObjectMethod(className, "void Close()", AS_METHODPR(T, Close, (), void), AS_CALL_THISCALL);

    // void Graphics::Draw(PrimitiveType type, unsigned vertexStart, unsigned vertexCount)
    engine->RegisterObjectMethod(className, "void Draw(PrimitiveType, uint, uint)", AS_METHODPR(T, Draw, (PrimitiveType, unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::Draw(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned minVertex, unsigned vertexCount)
    engine->RegisterObjectMethod(className, "void Draw(PrimitiveType, uint, uint, uint, uint)", AS_METHODPR(T, Draw, (PrimitiveType, unsigned, unsigned, unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::Draw(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned baseVertexIndex, unsigned minVertex, unsigned vertexCount)
    engine->RegisterObjectMethod(className, "void Draw(PrimitiveType, uint, uint, uint, uint, uint)", AS_METHODPR(T, Draw, (PrimitiveType, unsigned, unsigned, unsigned, unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::DrawInstanced(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned minVertex, unsigned vertexCount, unsigned instanceCount)
    engine->RegisterObjectMethod(className, "void DrawInstanced(PrimitiveType, uint, uint, uint, uint, uint)", AS_METHODPR(T, DrawInstanced, (PrimitiveType, unsigned, unsigned, unsigned, unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::DrawInstanced(PrimitiveType type, unsigned indexStart, unsigned indexCount, unsigned baseVertexIndex, unsigned minVertex, unsigned vertexCount, unsigned instanceCount)
    engine->RegisterObjectMethod(className, "void DrawInstanced(PrimitiveType, uint, uint, uint, uint, uint, uint)", AS_METHODPR(T, DrawInstanced, (PrimitiveType, unsigned, unsigned, unsigned, unsigned, unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::EndDumpShaders()
    engine->RegisterObjectMethod(className, "void EndDumpShaders()", AS_METHODPR(T, EndDumpShaders, (), void), AS_CALL_THISCALL);

    // void Graphics::EndFrame()
    engine->RegisterObjectMethod(className, "void EndFrame()", AS_METHODPR(T, EndFrame, (), void), AS_CALL_THISCALL);

    // unsigned Graphics::FindBestResolutionIndex(int monitor, int width, int height, int refreshRate) const
    engine->RegisterObjectMethod(className, "uint FindBestResolutionIndex(int, int, int, int) const", AS_METHODPR(T, FindBestResolutionIndex, (int, int, int, int) const, unsigned), AS_CALL_THISCALL);

    // bool Graphics::GetAlphaToCoverage() const
    engine->RegisterObjectMethod(className, "bool GetAlphaToCoverage() const", AS_METHODPR(T, GetAlphaToCoverage, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetAnisotropySupport() const
    engine->RegisterObjectMethod(className, "bool GetAnisotropySupport() const", AS_METHODPR(T, GetAnisotropySupport, () const, bool), AS_CALL_THISCALL);

    // const String& Graphics::GetApiName() const
    engine->RegisterObjectMethod(className, "const String& GetApiName() const", AS_METHODPR(T, GetApiName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_apiName() const", AS_METHODPR(T, GetApiName, () const, const String&), AS_CALL_THISCALL);

    // BlendMode Graphics::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // bool Graphics::GetBorderless() const
    engine->RegisterObjectMethod(className, "bool GetBorderless() const", AS_METHODPR(T, GetBorderless, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_borderless() const", AS_METHODPR(T, GetBorderless, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetColorWrite() const
    engine->RegisterObjectMethod(className, "bool GetColorWrite() const", AS_METHODPR(T, GetColorWrite, () const, bool), AS_CALL_THISCALL);

    // CullMode Graphics::GetCullMode() const
    engine->RegisterObjectMethod(className, "CullMode GetCullMode() const", AS_METHODPR(T, GetCullMode, () const, CullMode), AS_CALL_THISCALL);

    // int Graphics::GetCurrentMonitor() const
    engine->RegisterObjectMethod(className, "int GetCurrentMonitor() const", AS_METHODPR(T, GetCurrentMonitor, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_currentMonitor() const", AS_METHODPR(T, GetCurrentMonitor, () const, int), AS_CALL_THISCALL);

    // unsigned Graphics::GetDefaultTextureAnisotropy() const
    engine->RegisterObjectMethod(className, "uint GetDefaultTextureAnisotropy() const", AS_METHODPR(T, GetDefaultTextureAnisotropy, () const, unsigned), AS_CALL_THISCALL);

    // TextureFilterMode Graphics::GetDefaultTextureFilterMode() const
    engine->RegisterObjectMethod(className, "TextureFilterMode GetDefaultTextureFilterMode() const", AS_METHODPR(T, GetDefaultTextureFilterMode, () const, TextureFilterMode), AS_CALL_THISCALL);

    // bool Graphics::GetDeferredSupport() const
    engine->RegisterObjectMethod(className, "bool GetDeferredSupport() const", AS_METHODPR(T, GetDeferredSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_deferredSupport() const", AS_METHODPR(T, GetDeferredSupport, () const, bool), AS_CALL_THISCALL);

    // float Graphics::GetDepthConstantBias() const
    engine->RegisterObjectMethod(className, "float GetDepthConstantBias() const", AS_METHODPR(T, GetDepthConstantBias, () const, float), AS_CALL_THISCALL);

    // float Graphics::GetDepthSlopeScaledBias() const
    engine->RegisterObjectMethod(className, "float GetDepthSlopeScaledBias() const", AS_METHODPR(T, GetDepthSlopeScaledBias, () const, float), AS_CALL_THISCALL);

    // RenderSurface* Graphics::GetDepthStencil() const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetDepthStencil() const", AS_METHODPR(T, GetDepthStencil, () const, RenderSurface*), AS_CALL_THISCALL);

    // CompareMode Graphics::GetDepthTest() const
    engine->RegisterObjectMethod(className, "CompareMode GetDepthTest() const", AS_METHODPR(T, GetDepthTest, () const, CompareMode), AS_CALL_THISCALL);

    // bool Graphics::GetDepthWrite() const
    engine->RegisterObjectMethod(className, "bool GetDepthWrite() const", AS_METHODPR(T, GetDepthWrite, () const, bool), AS_CALL_THISCALL);

    // IntVector2 Graphics::GetDesktopResolution(int monitor) const
    engine->RegisterObjectMethod(className, "IntVector2 GetDesktopResolution(int) const", AS_METHODPR(T, GetDesktopResolution, (int) const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_desktopResolution(int) const", AS_METHODPR(T, GetDesktopResolution, (int) const, IntVector2), AS_CALL_THISCALL);

    // Vector3 Graphics::GetDisplayDPI(int monitor = 0) const
    engine->RegisterObjectMethod(className, "Vector3 GetDisplayDPI(int = 0) const", AS_METHODPR(T, GetDisplayDPI, (int) const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_displayDPI(int = 0) const", AS_METHODPR(T, GetDisplayDPI, (int) const, Vector3), AS_CALL_THISCALL);

    // bool Graphics::GetDither() const
    engine->RegisterObjectMethod(className, "bool GetDither() const", AS_METHODPR(T, GetDither, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dither() const", AS_METHODPR(T, GetDither, () const, bool), AS_CALL_THISCALL);

    // unsigned Graphics::GetDummyColorFormat() const
    engine->RegisterObjectMethod(className, "uint GetDummyColorFormat() const", AS_METHODPR(T, GetDummyColorFormat, () const, unsigned), AS_CALL_THISCALL);

    // FillMode Graphics::GetFillMode() const
    engine->RegisterObjectMethod(className, "FillMode GetFillMode() const", AS_METHODPR(T, GetFillMode, () const, FillMode), AS_CALL_THISCALL);

    // bool Graphics::GetFlushGPU() const
    engine->RegisterObjectMethod(className, "bool GetFlushGPU() const", AS_METHODPR(T, GetFlushGPU, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_flushGPU() const", AS_METHODPR(T, GetFlushGPU, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetForceGL2() const
    engine->RegisterObjectMethod(className, "bool GetForceGL2() const", AS_METHODPR(T, GetForceGL2, () const, bool), AS_CALL_THISCALL);

    // unsigned Graphics::GetFormat(CompressedFormat format) const
    engine->RegisterObjectMethod(className, "uint GetFormat(CompressedFormat) const", AS_METHODPR(T, GetFormat, (CompressedFormat) const, unsigned), AS_CALL_THISCALL);

    // bool Graphics::GetFullscreen() const
    engine->RegisterObjectMethod(className, "bool GetFullscreen() const", AS_METHODPR(T, GetFullscreen, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fullscreen() const", AS_METHODPR(T, GetFullscreen, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetHardwareShadowSupport() const
    engine->RegisterObjectMethod(className, "bool GetHardwareShadowSupport() const", AS_METHODPR(T, GetHardwareShadowSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hardwareShadowSupport() const", AS_METHODPR(T, GetHardwareShadowSupport, () const, bool), AS_CALL_THISCALL);

    // int Graphics::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // bool Graphics::GetHighDPI() const
    engine->RegisterObjectMethod(className, "bool GetHighDPI() const", AS_METHODPR(T, GetHighDPI, () const, bool), AS_CALL_THISCALL);

    // unsigned Graphics::GetHiresShadowMapFormat() const
    engine->RegisterObjectMethod(className, "uint GetHiresShadowMapFormat() const", AS_METHODPR(T, GetHiresShadowMapFormat, () const, unsigned), AS_CALL_THISCALL);

    // IndexBuffer* Graphics::GetIndexBuffer() const
    engine->RegisterObjectMethod(className, "IndexBuffer@+ GetIndexBuffer() const", AS_METHODPR(T, GetIndexBuffer, () const, IndexBuffer*), AS_CALL_THISCALL);

    // bool Graphics::GetInstancingSupport() const
    engine->RegisterObjectMethod(className, "bool GetInstancingSupport() const", AS_METHODPR(T, GetInstancingSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_instancingSupport() const", AS_METHODPR(T, GetInstancingSupport, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetLightPrepassSupport() const
    engine->RegisterObjectMethod(className, "bool GetLightPrepassSupport() const", AS_METHODPR(T, GetLightPrepassSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_lightPrepassSupport() const", AS_METHODPR(T, GetLightPrepassSupport, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetLineAntiAlias() const
    engine->RegisterObjectMethod(className, "bool GetLineAntiAlias() const", AS_METHODPR(T, GetLineAntiAlias, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetMaximized() const
    engine->RegisterObjectMethod(className, "bool GetMaximized() const", AS_METHODPR(T, GetMaximized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_maximized() const", AS_METHODPR(T, GetMaximized, () const, bool), AS_CALL_THISCALL);

    // int Graphics::GetMonitor() const
    engine->RegisterObjectMethod(className, "int GetMonitor() const", AS_METHODPR(T, GetMonitor, () const, int), AS_CALL_THISCALL);

    // int Graphics::GetMonitorCount() const
    engine->RegisterObjectMethod(className, "int GetMonitorCount() const", AS_METHODPR(T, GetMonitorCount, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_monitorCount() const", AS_METHODPR(T, GetMonitorCount, () const, int), AS_CALL_THISCALL);

    // int Graphics::GetMultiSample() const
    engine->RegisterObjectMethod(className, "int GetMultiSample() const", AS_METHODPR(T, GetMultiSample, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_multiSample() const", AS_METHODPR(T, GetMultiSample, () const, int), AS_CALL_THISCALL);

    // PODVector<int> Graphics::GetMultiSampleLevels() const
    engine->RegisterObjectMethod(className, "Array<int>@ GetMultiSampleLevels() const", AS_FUNCTION_OBJFIRST(Graphics_PODVectorlesintgre_GetMultiSampleLevels_void_template<Graphics>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<int>@ get_multiSampleLevels() const", AS_FUNCTION_OBJFIRST(Graphics_PODVectorlesintgre_GetMultiSampleLevels_void_template<Graphics>), AS_CALL_CDECL_OBJFIRST);

    // unsigned Graphics::GetNumBatches() const
    engine->RegisterObjectMethod(className, "uint GetNumBatches() const", AS_METHODPR(T, GetNumBatches, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numBatches() const", AS_METHODPR(T, GetNumBatches, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Graphics::GetNumPrimitives() const
    engine->RegisterObjectMethod(className, "uint GetNumPrimitives() const", AS_METHODPR(T, GetNumPrimitives, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numPrimitives() const", AS_METHODPR(T, GetNumPrimitives, () const, unsigned), AS_CALL_THISCALL);

    // const String& Graphics::GetOrientations() const
    engine->RegisterObjectMethod(className, "const String& GetOrientations() const", AS_METHODPR(T, GetOrientations, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_orientations() const", AS_METHODPR(T, GetOrientations, () const, const String&), AS_CALL_THISCALL);

    // ShaderVariation* Graphics::GetPixelShader() const
    engine->RegisterObjectMethod(className, "ShaderVariation@+ GetPixelShader() const", AS_METHODPR(T, GetPixelShader, () const, ShaderVariation*), AS_CALL_THISCALL);

    // bool Graphics::GetReadableDepthSupport() const
    engine->RegisterObjectMethod(className, "bool GetReadableDepthSupport() const", AS_METHODPR(T, GetReadableDepthSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_readableDepthSupport() const", AS_METHODPR(T, GetReadableDepthSupport, () const, bool), AS_CALL_THISCALL);

    // int Graphics::GetRefreshRate() const
    engine->RegisterObjectMethod(className, "int GetRefreshRate() const", AS_METHODPR(T, GetRefreshRate, () const, int), AS_CALL_THISCALL);

    // RenderSurface* Graphics::GetRenderTarget(unsigned index) const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetRenderTarget(uint) const", AS_METHODPR(T, GetRenderTarget, (unsigned) const, RenderSurface*), AS_CALL_THISCALL);

    // IntVector2 Graphics::GetRenderTargetDimensions() const
    engine->RegisterObjectMethod(className, "IntVector2 GetRenderTargetDimensions() const", AS_METHODPR(T, GetRenderTargetDimensions, () const, IntVector2), AS_CALL_THISCALL);

    // bool Graphics::GetResizable() const
    engine->RegisterObjectMethod(className, "bool GetResizable() const", AS_METHODPR(T, GetResizable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resizable() const", AS_METHODPR(T, GetResizable, () const, bool), AS_CALL_THISCALL);

    // PODVector<IntVector3> Graphics::GetResolutions(int monitor) const
    engine->RegisterObjectMethod(className, "Array<IntVector3>@ GetResolutions(int) const", AS_FUNCTION_OBJFIRST(Graphics_PODVectorlesIntVector3gre_GetResolutions_int_template<Graphics>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<IntVector3>@ get_resolutions(int) const", AS_FUNCTION_OBJFIRST(Graphics_PODVectorlesIntVector3gre_GetResolutions_int_template<Graphics>), AS_CALL_CDECL_OBJFIRST);

    // const IntRect& Graphics::GetScissorRect() const
    engine->RegisterObjectMethod(className, "const IntRect& GetScissorRect() const", AS_METHODPR(T, GetScissorRect, () const, const IntRect&), AS_CALL_THISCALL);

    // bool Graphics::GetScissorTest() const
    engine->RegisterObjectMethod(className, "bool GetScissorTest() const", AS_METHODPR(T, GetScissorTest, () const, bool), AS_CALL_THISCALL);

    // const ScreenModeParams& Graphics::GetScreenModeParams() const
    engine->RegisterObjectMethod(className, "const ScreenModeParams& GetScreenModeParams() const", AS_METHODPR(T, GetScreenModeParams, () const, const ScreenModeParams&), AS_CALL_THISCALL);

    // ShaderVariation* Graphics::GetShader(ShaderType type, const String& name, const String& defines = String::EMPTY) const
    engine->RegisterObjectMethod(className, "ShaderVariation@+ GetShader(ShaderType, const String&in, const String&in = String::EMPTY) const", AS_METHODPR(T, GetShader, (ShaderType, const String&, const String&) const, ShaderVariation*), AS_CALL_THISCALL);

    // const String& Graphics::GetShaderCacheDir() const
    engine->RegisterObjectMethod(className, "const String& GetShaderCacheDir() const", AS_METHODPR(T, GetShaderCacheDir, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_shaderCacheDir() const", AS_METHODPR(T, GetShaderCacheDir, () const, const String&), AS_CALL_THISCALL);

    // unsigned Graphics::GetShadowMapFormat() const
    engine->RegisterObjectMethod(className, "uint GetShadowMapFormat() const", AS_METHODPR(T, GetShadowMapFormat, () const, unsigned), AS_CALL_THISCALL);

    // IntVector2 Graphics::GetSize() const
    engine->RegisterObjectMethod(className, "IntVector2 GetSize() const", AS_METHODPR(T, GetSize, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_size() const", AS_METHODPR(T, GetSize, () const, IntVector2), AS_CALL_THISCALL);

    // bool Graphics::GetSRGB() const
    engine->RegisterObjectMethod(className, "bool GetSRGB() const", AS_METHODPR(T, GetSRGB, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sRGB() const", AS_METHODPR(T, GetSRGB, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetSRGBSupport() const
    engine->RegisterObjectMethod(className, "bool GetSRGBSupport() const", AS_METHODPR(T, GetSRGBSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sRGBSupport() const", AS_METHODPR(T, GetSRGBSupport, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetSRGBWriteSupport() const
    engine->RegisterObjectMethod(className, "bool GetSRGBWriteSupport() const", AS_METHODPR(T, GetSRGBWriteSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sRGBWriteSupport() const", AS_METHODPR(T, GetSRGBWriteSupport, () const, bool), AS_CALL_THISCALL);

    // unsigned Graphics::GetStencilCompareMask() const
    engine->RegisterObjectMethod(className, "uint GetStencilCompareMask() const", AS_METHODPR(T, GetStencilCompareMask, () const, unsigned), AS_CALL_THISCALL);

    // StencilOp Graphics::GetStencilFail() const
    engine->RegisterObjectMethod(className, "StencilOp GetStencilFail() const", AS_METHODPR(T, GetStencilFail, () const, StencilOp), AS_CALL_THISCALL);

    // StencilOp Graphics::GetStencilPass() const
    engine->RegisterObjectMethod(className, "StencilOp GetStencilPass() const", AS_METHODPR(T, GetStencilPass, () const, StencilOp), AS_CALL_THISCALL);

    // unsigned Graphics::GetStencilRef() const
    engine->RegisterObjectMethod(className, "uint GetStencilRef() const", AS_METHODPR(T, GetStencilRef, () const, unsigned), AS_CALL_THISCALL);

    // bool Graphics::GetStencilTest() const
    engine->RegisterObjectMethod(className, "bool GetStencilTest() const", AS_METHODPR(T, GetStencilTest, () const, bool), AS_CALL_THISCALL);

    // CompareMode Graphics::GetStencilTestMode() const
    engine->RegisterObjectMethod(className, "CompareMode GetStencilTestMode() const", AS_METHODPR(T, GetStencilTestMode, () const, CompareMode), AS_CALL_THISCALL);

    // unsigned Graphics::GetStencilWriteMask() const
    engine->RegisterObjectMethod(className, "uint GetStencilWriteMask() const", AS_METHODPR(T, GetStencilWriteMask, () const, unsigned), AS_CALL_THISCALL);

    // StencilOp Graphics::GetStencilZFail() const
    engine->RegisterObjectMethod(className, "StencilOp GetStencilZFail() const", AS_METHODPR(T, GetStencilZFail, () const, StencilOp), AS_CALL_THISCALL);

    // Texture* Graphics::GetTexture(unsigned index) const
    engine->RegisterObjectMethod(className, "Texture@+ GetTexture(uint) const", AS_METHODPR(T, GetTexture, (unsigned) const, Texture*), AS_CALL_THISCALL);

    // TextureUnit Graphics::GetTextureUnit(const String& name)
    engine->RegisterObjectMethod(className, "TextureUnit GetTextureUnit(const String&in)", AS_METHODPR(T, GetTextureUnit, (const String&), TextureUnit), AS_CALL_THISCALL);

    // const String& Graphics::GetTextureUnitName(TextureUnit unit)
    engine->RegisterObjectMethod(className, "const String& GetTextureUnitName(TextureUnit)", AS_METHODPR(T, GetTextureUnitName, (TextureUnit), const String&), AS_CALL_THISCALL);

    // bool Graphics::GetTripleBuffer() const
    engine->RegisterObjectMethod(className, "bool GetTripleBuffer() const", AS_METHODPR(T, GetTripleBuffer, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_tripleBuffer() const", AS_METHODPR(T, GetTripleBuffer, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::GetUseClipPlane() const
    engine->RegisterObjectMethod(className, "bool GetUseClipPlane() const", AS_METHODPR(T, GetUseClipPlane, () const, bool), AS_CALL_THISCALL);

    // VertexBuffer* Graphics::GetVertexBuffer(unsigned index) const
    engine->RegisterObjectMethod(className, "VertexBuffer@+ GetVertexBuffer(uint) const", AS_METHODPR(T, GetVertexBuffer, (unsigned) const, VertexBuffer*), AS_CALL_THISCALL);

    // ShaderVariation* Graphics::GetVertexShader() const
    engine->RegisterObjectMethod(className, "ShaderVariation@+ GetVertexShader() const", AS_METHODPR(T, GetVertexShader, () const, ShaderVariation*), AS_CALL_THISCALL);

    // IntRect Graphics::GetViewport() const
    engine->RegisterObjectMethod(className, "IntRect GetViewport() const", AS_METHODPR(T, GetViewport, () const, IntRect), AS_CALL_THISCALL);

    // bool Graphics::GetVSync() const
    engine->RegisterObjectMethod(className, "bool GetVSync() const", AS_METHODPR(T, GetVSync, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_vSync() const", AS_METHODPR(T, GetVSync, () const, bool), AS_CALL_THISCALL);

    // int Graphics::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // IntVector2 Graphics::GetWindowPosition() const
    engine->RegisterObjectMethod(className, "IntVector2 GetWindowPosition() const", AS_METHODPR(T, GetWindowPosition, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_windowPosition() const", AS_METHODPR(T, GetWindowPosition, () const, IntVector2), AS_CALL_THISCALL);

    // const String& Graphics::GetWindowTitle() const
    engine->RegisterObjectMethod(className, "const String& GetWindowTitle() const", AS_METHODPR(T, GetWindowTitle, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_windowTitle() const", AS_METHODPR(T, GetWindowTitle, () const, const String&), AS_CALL_THISCALL);

    // bool Graphics::HasShaderParameter(StringHash param)
    engine->RegisterObjectMethod(className, "bool HasShaderParameter(StringHash)", AS_METHODPR(T, HasShaderParameter, (StringHash), bool), AS_CALL_THISCALL);

    // bool Graphics::HasTextureUnit(TextureUnit unit)
    engine->RegisterObjectMethod(className, "bool HasTextureUnit(TextureUnit)", AS_METHODPR(T, HasTextureUnit, (TextureUnit), bool), AS_CALL_THISCALL);

    // bool Graphics::IsDeviceLost() const
    engine->RegisterObjectMethod(className, "bool IsDeviceLost() const", AS_METHODPR(T, IsDeviceLost, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_deviceLost() const", AS_METHODPR(T, IsDeviceLost, () const, bool), AS_CALL_THISCALL);

    // bool Graphics::IsInitialized() const
    engine->RegisterObjectMethod(className, "bool IsInitialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_initialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);

    // void Graphics::Maximize()
    engine->RegisterObjectMethod(className, "void Maximize()", AS_METHODPR(T, Maximize, (), void), AS_CALL_THISCALL);

    // void Graphics::Minimize()
    engine->RegisterObjectMethod(className, "void Minimize()", AS_METHODPR(T, Minimize, (), void), AS_CALL_THISCALL);

    // void Graphics::OnWindowMoved()
    engine->RegisterObjectMethod(className, "void OnWindowMoved()", AS_METHODPR(T, OnWindowMoved, (), void), AS_CALL_THISCALL);

    // void Graphics::OnWindowResized()
    engine->RegisterObjectMethod(className, "void OnWindowResized()", AS_METHODPR(T, OnWindowResized, (), void), AS_CALL_THISCALL);

    // void Graphics::PrecacheShaders(Deserializer& source)
    engine->RegisterObjectMethod(className, "void PrecacheShaders(Deserializer&)", AS_METHODPR(T, PrecacheShaders, (Deserializer&), void), AS_CALL_THISCALL);

    // void Graphics::Raise() const
    engine->RegisterObjectMethod(className, "void Raise() const", AS_METHODPR(T, Raise, () const, void), AS_CALL_THISCALL);

    // void Graphics::ResetDepthStencil()
    engine->RegisterObjectMethod(className, "void ResetDepthStencil()", AS_METHODPR(T, ResetDepthStencil, (), void), AS_CALL_THISCALL);

    // void Graphics::ResetRenderTarget(unsigned index)
    engine->RegisterObjectMethod(className, "void ResetRenderTarget(uint)", AS_METHODPR(T, ResetRenderTarget, (unsigned), void), AS_CALL_THISCALL);

    // void Graphics::ResetRenderTargets()
    engine->RegisterObjectMethod(className, "void ResetRenderTargets()", AS_METHODPR(T, ResetRenderTargets, (), void), AS_CALL_THISCALL);

    // bool Graphics::ResolveToTexture(Texture2D* destination, const IntRect& viewport)
    engine->RegisterObjectMethod(className, "bool ResolveToTexture(Texture2D@+, const IntRect&in)", AS_METHODPR(T, ResolveToTexture, (Texture2D*, const IntRect&), bool), AS_CALL_THISCALL);

    // bool Graphics::ResolveToTexture(Texture2D* texture)
    engine->RegisterObjectMethod(className, "bool ResolveToTexture(Texture2D@+)", AS_METHODPR(T, ResolveToTexture, (Texture2D*), bool), AS_CALL_THISCALL);

    // bool Graphics::ResolveToTexture(TextureCube* texture)
    engine->RegisterObjectMethod(className, "bool ResolveToTexture(TextureCube@+)", AS_METHODPR(T, ResolveToTexture, (TextureCube*), bool), AS_CALL_THISCALL);

    // void Graphics::SetBlendMode(BlendMode mode, bool alphaToCoverage = false)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode, bool = false)", AS_METHODPR(T, SetBlendMode, (BlendMode, bool), void), AS_CALL_THISCALL);

    // void Graphics::SetClipPlane(bool enable, const Plane& clipPlane = Plane::UP, const Matrix3x4& view = Matrix3x4::IDENTITY, const Matrix4& projection = Matrix4::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetClipPlane(bool, const Plane&in = Plane::UP, const Matrix3x4&in = Matrix3x4::IDENTITY, const Matrix4&in = Matrix4::IDENTITY)", AS_METHODPR(T, SetClipPlane, (bool, const Plane&, const Matrix3x4&, const Matrix4&), void), AS_CALL_THISCALL);

    // void Graphics::SetColorWrite(bool enable)
    engine->RegisterObjectMethod(className, "void SetColorWrite(bool)", AS_METHODPR(T, SetColorWrite, (bool), void), AS_CALL_THISCALL);

    // void Graphics::SetCullMode(CullMode mode)
    engine->RegisterObjectMethod(className, "void SetCullMode(CullMode)", AS_METHODPR(T, SetCullMode, (CullMode), void), AS_CALL_THISCALL);

    // void Graphics::SetDefaultTextureAnisotropy(unsigned level)
    engine->RegisterObjectMethod(className, "void SetDefaultTextureAnisotropy(uint)", AS_METHODPR(T, SetDefaultTextureAnisotropy, (unsigned), void), AS_CALL_THISCALL);

    // void Graphics::SetDefaultTextureFilterMode(TextureFilterMode mode)
    engine->RegisterObjectMethod(className, "void SetDefaultTextureFilterMode(TextureFilterMode)", AS_METHODPR(T, SetDefaultTextureFilterMode, (TextureFilterMode), void), AS_CALL_THISCALL);

    // bool Graphics::SetDefaultWindowModes(int width, int height, const ScreenModeParams& params)
    engine->RegisterObjectMethod(className, "bool SetDefaultWindowModes(int, int, const ScreenModeParams&in)", AS_METHODPR(T, SetDefaultWindowModes, (int, int, const ScreenModeParams&), bool), AS_CALL_THISCALL);

    // void Graphics::SetDepthBias(float constantBias, float slopeScaledBias)
    engine->RegisterObjectMethod(className, "void SetDepthBias(float, float)", AS_METHODPR(T, SetDepthBias, (float, float), void), AS_CALL_THISCALL);

    // void Graphics::SetDepthStencil(RenderSurface* depthStencil)
    engine->RegisterObjectMethod(className, "void SetDepthStencil(RenderSurface@+)", AS_METHODPR(T, SetDepthStencil, (RenderSurface*), void), AS_CALL_THISCALL);

    // void Graphics::SetDepthStencil(Texture2D* texture)
    engine->RegisterObjectMethod(className, "void SetDepthStencil(Texture2D@+)", AS_METHODPR(T, SetDepthStencil, (Texture2D*), void), AS_CALL_THISCALL);

    // void Graphics::SetDepthTest(CompareMode mode)
    engine->RegisterObjectMethod(className, "void SetDepthTest(CompareMode)", AS_METHODPR(T, SetDepthTest, (CompareMode), void), AS_CALL_THISCALL);

    // void Graphics::SetDepthWrite(bool enable)
    engine->RegisterObjectMethod(className, "void SetDepthWrite(bool)", AS_METHODPR(T, SetDepthWrite, (bool), void), AS_CALL_THISCALL);

    // void Graphics::SetDither(bool enable)
    engine->RegisterObjectMethod(className, "void SetDither(bool)", AS_METHODPR(T, SetDither, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dither(bool)", AS_METHODPR(T, SetDither, (bool), void), AS_CALL_THISCALL);

    // void Graphics::SetFillMode(FillMode mode)
    engine->RegisterObjectMethod(className, "void SetFillMode(FillMode)", AS_METHODPR(T, SetFillMode, (FillMode), void), AS_CALL_THISCALL);

    // void Graphics::SetFlushGPU(bool enable)
    engine->RegisterObjectMethod(className, "void SetFlushGPU(bool)", AS_METHODPR(T, SetFlushGPU, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_flushGPU(bool)", AS_METHODPR(T, SetFlushGPU, (bool), void), AS_CALL_THISCALL);

    // void Graphics::SetForceGL2(bool enable)
    engine->RegisterObjectMethod(className, "void SetForceGL2(bool)", AS_METHODPR(T, SetForceGL2, (bool), void), AS_CALL_THISCALL);

    // void Graphics::SetIndexBuffer(IndexBuffer* buffer)
    engine->RegisterObjectMethod(className, "void SetIndexBuffer(IndexBuffer@+)", AS_METHODPR(T, SetIndexBuffer, (IndexBuffer*), void), AS_CALL_THISCALL);

    // void Graphics::SetLineAntiAlias(bool enable)
    engine->RegisterObjectMethod(className, "void SetLineAntiAlias(bool)", AS_METHODPR(T, SetLineAntiAlias, (bool), void), AS_CALL_THISCALL);

    // bool Graphics::SetMode(int width, int height, bool fullscreen, bool borderless, bool resizable, bool highDPI, bool vsync, bool tripleBuffer, int multiSample, int monitor, int refreshRate)
    engine->RegisterObjectMethod(className, "bool SetMode(int, int, bool, bool, bool, bool, bool, bool, int, int, int)", AS_METHODPR(T, SetMode, (int, int, bool, bool, bool, bool, bool, bool, int, int, int), bool), AS_CALL_THISCALL);

    // bool Graphics::SetMode(int width, int height)
    engine->RegisterObjectMethod(className, "bool SetMode(int, int)", AS_METHODPR(T, SetMode, (int, int), bool), AS_CALL_THISCALL);

    // void Graphics::SetOrientations(const String& orientations)
    engine->RegisterObjectMethod(className, "void SetOrientations(const String&in)", AS_METHODPR(T, SetOrientations, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orientations(const String&in)", AS_METHODPR(T, SetOrientations, (const String&), void), AS_CALL_THISCALL);

    // void Graphics::SetRenderTarget(unsigned index, RenderSurface* renderTarget)
    engine->RegisterObjectMethod(className, "void SetRenderTarget(uint, RenderSurface@+)", AS_METHODPR(T, SetRenderTarget, (unsigned, RenderSurface*), void), AS_CALL_THISCALL);

    // void Graphics::SetRenderTarget(unsigned index, Texture2D* texture)
    engine->RegisterObjectMethod(className, "void SetRenderTarget(uint, Texture2D@+)", AS_METHODPR(T, SetRenderTarget, (unsigned, Texture2D*), void), AS_CALL_THISCALL);

    // void Graphics::SetScissorTest(bool enable, const Rect& rect = Rect::FULL, bool borderInclusive = true)
    engine->RegisterObjectMethod(className, "void SetScissorTest(bool, const Rect&in = Rect::FULL, bool = true)", AS_METHODPR(T, SetScissorTest, (bool, const Rect&, bool), void), AS_CALL_THISCALL);

    // void Graphics::SetScissorTest(bool enable, const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetScissorTest(bool, const IntRect&in)", AS_METHODPR(T, SetScissorTest, (bool, const IntRect&), void), AS_CALL_THISCALL);

    // bool Graphics::SetScreenMode(int width, int height, const ScreenModeParams& params, bool maximize = false)
    engine->RegisterObjectMethod(className, "bool SetScreenMode(int, int, const ScreenModeParams&in, bool = false)", AS_METHODPR(T, SetScreenMode, (int, int, const ScreenModeParams&, bool), bool), AS_CALL_THISCALL);

    // bool Graphics::SetScreenMode(int width, int height)
    engine->RegisterObjectMethod(className, "bool SetScreenMode(int, int)", AS_METHODPR(T, SetScreenMode, (int, int), bool), AS_CALL_THISCALL);

    // void Graphics::SetShaderCacheDir(const String& path)
    engine->RegisterObjectMethod(className, "void SetShaderCacheDir(const String&in)", AS_METHODPR(T, SetShaderCacheDir, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shaderCacheDir(const String&in)", AS_METHODPR(T, SetShaderCacheDir, (const String&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, float value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, float)", AS_METHODPR(T, SetShaderParameter, (StringHash, float), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, int value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, int)", AS_METHODPR(T, SetShaderParameter, (StringHash, int), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, bool value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, bool)", AS_METHODPR(T, SetShaderParameter, (StringHash, bool), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Color& color)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Color&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Color&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Vector2& vector)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Vector2&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Vector2&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Matrix3& matrix)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Matrix3&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Matrix3&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Vector3& vector)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Vector3&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Vector3&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Matrix4& matrix)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Matrix4&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Matrix4&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Vector4& vector)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Vector4&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Vector4&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Matrix3x4& matrix)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Matrix3x4&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaderParameter(StringHash param, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(StringHash, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (StringHash, const Variant&), void), AS_CALL_THISCALL);

    // void Graphics::SetShaders(ShaderVariation* vs, ShaderVariation* ps)
    engine->RegisterObjectMethod(className, "void SetShaders(ShaderVariation@+, ShaderVariation@+)", AS_METHODPR(T, SetShaders, (ShaderVariation*, ShaderVariation*), void), AS_CALL_THISCALL);

    // void Graphics::SetSRGB(bool enable)
    engine->RegisterObjectMethod(className, "void SetSRGB(bool)", AS_METHODPR(T, SetSRGB, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sRGB(bool)", AS_METHODPR(T, SetSRGB, (bool), void), AS_CALL_THISCALL);

    // void Graphics::SetStencilTest(bool enable, CompareMode mode = CMP_ALWAYS, StencilOp pass = OP_KEEP, StencilOp fail = OP_KEEP, StencilOp zFail = OP_KEEP, unsigned stencilRef = 0, unsigned compareMask = M_MAX_UNSIGNED, unsigned writeMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void SetStencilTest(bool, CompareMode = CMP_ALWAYS, StencilOp = OP_KEEP, StencilOp = OP_KEEP, StencilOp = OP_KEEP, uint = 0, uint = M_MAX_UNSIGNED, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, SetStencilTest, (bool, CompareMode, StencilOp, StencilOp, StencilOp, unsigned, unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Graphics::SetTexture(unsigned index, Texture* texture)
    engine->RegisterObjectMethod(className, "void SetTexture(uint, Texture@+)", AS_METHODPR(T, SetTexture, (unsigned, Texture*), void), AS_CALL_THISCALL);

    // void Graphics::SetVertexBuffer(VertexBuffer* buffer)
    engine->RegisterObjectMethod(className, "void SetVertexBuffer(VertexBuffer@+)", AS_METHODPR(T, SetVertexBuffer, (VertexBuffer*), void), AS_CALL_THISCALL);

    // bool Graphics::SetVertexBuffers(const Vector<SharedPtr<VertexBuffer>>& buffers, unsigned instanceOffset = 0)
    engine->RegisterObjectMethod(className, "bool SetVertexBuffers(Array<VertexBuffer@>@+, uint = 0)", AS_FUNCTION_OBJFIRST(Graphics_bool_SetVertexBuffers_constspVectorlesSharedPtrlesVertexBuffergregreamp_unsigned_template<Graphics>), AS_CALL_CDECL_OBJFIRST);

    // void Graphics::SetViewport(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetViewport(const IntRect&in)", AS_METHODPR(T, SetViewport, (const IntRect&), void), AS_CALL_THISCALL);

    // void Graphics::SetWindowIcon(Image* windowIcon)
    engine->RegisterObjectMethod(className, "void SetWindowIcon(Image@+)", AS_METHODPR(T, SetWindowIcon, (Image*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_windowIcon(Image@+)", AS_METHODPR(T, SetWindowIcon, (Image*), void), AS_CALL_THISCALL);

    // bool Graphics::SetWindowModes(const WindowModeParams& windowMode, const WindowModeParams& secondaryWindowMode, bool maximize = false)
    engine->RegisterObjectMethod(className, "bool SetWindowModes(const WindowModeParams&in, const WindowModeParams&in, bool = false)", AS_METHODPR(T, SetWindowModes, (const WindowModeParams&, const WindowModeParams&, bool), bool), AS_CALL_THISCALL);

    // void Graphics::SetWindowPosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetWindowPosition(const IntVector2&in)", AS_METHODPR(T, SetWindowPosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_windowPosition(const IntVector2&in)", AS_METHODPR(T, SetWindowPosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Graphics::SetWindowPosition(int x, int y)
    engine->RegisterObjectMethod(className, "void SetWindowPosition(int, int)", AS_METHODPR(T, SetWindowPosition, (int, int), void), AS_CALL_THISCALL);

    // void Graphics::SetWindowTitle(const String& windowTitle)
    engine->RegisterObjectMethod(className, "void SetWindowTitle(const String&in)", AS_METHODPR(T, SetWindowTitle, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_windowTitle(const String&in)", AS_METHODPR(T, SetWindowTitle, (const String&), void), AS_CALL_THISCALL);

    // bool Graphics::TakeScreenShot(Image& destImage)
    engine->RegisterObjectMethod(className, "bool TakeScreenShot(Image&)", AS_METHODPR(T, TakeScreenShot, (Image&), bool), AS_CALL_THISCALL);

    // bool Graphics::ToggleFullscreen()
    engine->RegisterObjectMethod(className, "bool ToggleFullscreen()", AS_METHODPR(T, ToggleFullscreen, (), bool), AS_CALL_THISCALL);

    // static unsigned Graphics::GetAlphaFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetAlphaFormat()", AS_FUNCTIONPR(T::GetAlphaFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetLuminanceFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetLuminanceFormat()", AS_FUNCTIONPR(T::GetLuminanceFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetLuminanceAlphaFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetLuminanceAlphaFormat()", AS_FUNCTIONPR(T::GetLuminanceAlphaFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGBFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGBFormat()", AS_FUNCTIONPR(T::GetRGBFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGBAFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGBAFormat()", AS_FUNCTIONPR(T::GetRGBAFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGBA16Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGBA16Format()", AS_FUNCTIONPR(T::GetRGBA16Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGBAFloat16Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGBAFloat16Format()", AS_FUNCTIONPR(T::GetRGBAFloat16Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGBAFloat32Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGBAFloat32Format()", AS_FUNCTIONPR(T::GetRGBAFloat32Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRG16Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRG16Format()", AS_FUNCTIONPR(T::GetRG16Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGFloat16Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGFloat16Format()", AS_FUNCTIONPR(T::GetRGFloat16Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetRGFloat32Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetRGFloat32Format()", AS_FUNCTIONPR(T::GetRGFloat32Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetFloat16Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetFloat16Format()", AS_FUNCTIONPR(T::GetFloat16Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetFloat32Format()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetFloat32Format()", AS_FUNCTIONPR(T::GetFloat32Format, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetLinearDepthFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetLinearDepthFormat()", AS_FUNCTIONPR(T::GetLinearDepthFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetDepthStencilFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetDepthStencilFormat()", AS_FUNCTIONPR(T::GetDepthStencilFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetReadableDepthFormat()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetReadableDepthFormat()", AS_FUNCTIONPR(T::GetReadableDepthFormat, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetFormat(const String& formatName)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetFormat(const String&in)", AS_FUNCTIONPR(T::GetFormat, (const String&), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static const Vector2& Graphics::GetPixelUVOffset()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("const Vector2& GetPixelUVOffset()", AS_FUNCTIONPR(T::GetPixelUVOffset, (), const Vector2&), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Graphics::GetMaxBones()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetMaxBones()", AS_FUNCTIONPR(T::GetMaxBones, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static bool Graphics::GetGL3Support()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool GetGL3Support()", AS_FUNCTIONPR(T::GetGL3Support, (), bool), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Graphics
        REGISTER_MEMBERS_MANUAL_PART_Graphics();
    #endif
}

// class IndexBuffer | File: ../Graphics/IndexBuffer.h
template <class T> void RegisterMembers_IndexBuffer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);
    RegisterMembers_GPUObject<T>(engine, className);

    // unsigned char* IndexBuffer::GetShadowData() const
    // Error: type "unsigned char*" can not automatically bind
    // SharedArrayPtr<unsigned char> IndexBuffer::GetShadowDataShared() const
    // Error: type "SharedArrayPtr<unsigned char>" can not automatically bind
    // void* IndexBuffer::Lock(unsigned start, unsigned count, bool discard = false)
    // Error: type "void*" can not automatically bind
    // bool IndexBuffer::SetData(const void* data)
    // Error: type "const void*" can not automatically bind
    // bool IndexBuffer::SetDataRange(const void* data, unsigned start, unsigned count, bool discard = false)
    // Error: type "const void*" can not automatically bind

    // unsigned IndexBuffer::GetIndexCount() const
    engine->RegisterObjectMethod(className, "uint GetIndexCount() const", AS_METHODPR(T, GetIndexCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_indexCount() const", AS_METHODPR(T, GetIndexCount, () const, unsigned), AS_CALL_THISCALL);

    // unsigned IndexBuffer::GetIndexSize() const
    engine->RegisterObjectMethod(className, "uint GetIndexSize() const", AS_METHODPR(T, GetIndexSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_indexSize() const", AS_METHODPR(T, GetIndexSize, () const, unsigned), AS_CALL_THISCALL);

    // bool IndexBuffer::GetUsedVertexRange(unsigned start, unsigned count, unsigned& minVertex, unsigned& vertexCount)
    engine->RegisterObjectMethod(className, "bool GetUsedVertexRange(uint, uint, uint&, uint&)", AS_METHODPR(T, GetUsedVertexRange, (unsigned, unsigned, unsigned&, unsigned&), bool), AS_CALL_THISCALL);

    // bool IndexBuffer::IsDynamic() const
    engine->RegisterObjectMethod(className, "bool IsDynamic() const", AS_METHODPR(T, IsDynamic, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dynamic() const", AS_METHODPR(T, IsDynamic, () const, bool), AS_CALL_THISCALL);

    // bool IndexBuffer::IsLocked() const
    engine->RegisterObjectMethod(className, "bool IsLocked() const", AS_METHODPR(T, IsLocked, () const, bool), AS_CALL_THISCALL);

    // bool IndexBuffer::IsShadowed() const
    engine->RegisterObjectMethod(className, "bool IsShadowed() const", AS_METHODPR(T, IsShadowed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_shadowed() const", AS_METHODPR(T, IsShadowed, () const, bool), AS_CALL_THISCALL);

    // void IndexBuffer::SetShadowed(bool enable)
    engine->RegisterObjectMethod(className, "void SetShadowed(bool)", AS_METHODPR(T, SetShadowed, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowed(bool)", AS_METHODPR(T, SetShadowed, (bool), void), AS_CALL_THISCALL);

    // bool IndexBuffer::SetSize(unsigned indexCount, bool largeIndices, bool dynamic = false)
    engine->RegisterObjectMethod(className, "bool SetSize(uint, bool, bool = false)", AS_METHODPR(T, SetSize, (unsigned, bool, bool), bool), AS_CALL_THISCALL);

    // void IndexBuffer::Unlock()
    engine->RegisterObjectMethod(className, "void Unlock()", AS_METHODPR(T, Unlock, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IndexBuffer
        REGISTER_MEMBERS_MANUAL_PART_IndexBuffer();
    #endif
}

// class Input | File: ../Input/Input.h
template <class T> void RegisterMembers_Input(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // SDL_JoystickID Input::AddScreenJoystick(XMLFile* layoutFile = nullptr, XMLFile* styleFile = nullptr)
    engine->RegisterObjectMethod(className, "SDL_JoystickID AddScreenJoystick(XMLFile@+ = null, XMLFile@+ = null)", AS_METHODPR(T, AddScreenJoystick, (XMLFile*, XMLFile*), SDL_JoystickID), AS_CALL_THISCALL);

    // void Input::CenterMousePosition()
    engine->RegisterObjectMethod(className, "void CenterMousePosition()", AS_METHODPR(T, CenterMousePosition, (), void), AS_CALL_THISCALL);

    // Vector2 Input::GetInputScale() const
    engine->RegisterObjectMethod(className, "Vector2 GetInputScale() const", AS_METHODPR(T, GetInputScale, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_inputScale() const", AS_METHODPR(T, GetInputScale, () const, Vector2), AS_CALL_THISCALL);

    // JoystickState* Input::GetJoystick(SDL_JoystickID id)
    engine->RegisterObjectMethod(className, "JoystickState@+ GetJoystick(SDL_JoystickID)", AS_METHODPR(T, GetJoystick, (SDL_JoystickID), JoystickState*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "JoystickState@+ get_joysticks(SDL_JoystickID)", AS_METHODPR(T, GetJoystick, (SDL_JoystickID), JoystickState*), AS_CALL_THISCALL);

    // JoystickState* Input::GetJoystickByIndex(unsigned index)
    engine->RegisterObjectMethod(className, "JoystickState@+ GetJoystickByIndex(uint)", AS_METHODPR(T, GetJoystickByIndex, (unsigned), JoystickState*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "JoystickState@+ get_joysticksByIndex(uint)", AS_METHODPR(T, GetJoystickByIndex, (unsigned), JoystickState*), AS_CALL_THISCALL);

    // JoystickState* Input::GetJoystickByName(const String& name)
    engine->RegisterObjectMethod(className, "JoystickState@+ GetJoystickByName(const String&in)", AS_METHODPR(T, GetJoystickByName, (const String&), JoystickState*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "JoystickState@+ get_joysticksByName(const String&in)", AS_METHODPR(T, GetJoystickByName, (const String&), JoystickState*), AS_CALL_THISCALL);

    // bool Input::GetKeyDown(Key key) const
    engine->RegisterObjectMethod(className, "bool GetKeyDown(Key) const", AS_METHODPR(T, GetKeyDown, (Key) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_keyDown(Key) const", AS_METHODPR(T, GetKeyDown, (Key) const, bool), AS_CALL_THISCALL);

    // Key Input::GetKeyFromName(const String& name) const
    engine->RegisterObjectMethod(className, "Key GetKeyFromName(const String&in) const", AS_METHODPR(T, GetKeyFromName, (const String&) const, Key), AS_CALL_THISCALL);

    // Key Input::GetKeyFromScancode(Scancode scancode) const
    engine->RegisterObjectMethod(className, "Key GetKeyFromScancode(Scancode) const", AS_METHODPR(T, GetKeyFromScancode, (Scancode) const, Key), AS_CALL_THISCALL);

    // String Input::GetKeyName(Key key) const
    engine->RegisterObjectMethod(className, "String GetKeyName(Key) const", AS_METHODPR(T, GetKeyName, (Key) const, String), AS_CALL_THISCALL);

    // bool Input::GetKeyPress(Key key) const
    engine->RegisterObjectMethod(className, "bool GetKeyPress(Key) const", AS_METHODPR(T, GetKeyPress, (Key) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_keyPress(Key) const", AS_METHODPR(T, GetKeyPress, (Key) const, bool), AS_CALL_THISCALL);

    // bool Input::GetMouseButtonDown(MouseButtonFlags button) const
    engine->RegisterObjectMethod(className, "bool GetMouseButtonDown(MouseButtonFlags) const", AS_METHODPR(T, GetMouseButtonDown, (MouseButtonFlags) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_mouseButtonDown(MouseButtonFlags) const", AS_METHODPR(T, GetMouseButtonDown, (MouseButtonFlags) const, bool), AS_CALL_THISCALL);

    // bool Input::GetMouseButtonPress(MouseButtonFlags button) const
    engine->RegisterObjectMethod(className, "bool GetMouseButtonPress(MouseButtonFlags) const", AS_METHODPR(T, GetMouseButtonPress, (MouseButtonFlags) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_mouseButtonPress(MouseButtonFlags) const", AS_METHODPR(T, GetMouseButtonPress, (MouseButtonFlags) const, bool), AS_CALL_THISCALL);

    // MouseMode Input::GetMouseMode() const
    engine->RegisterObjectMethod(className, "MouseMode GetMouseMode() const", AS_METHODPR(T, GetMouseMode, () const, MouseMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "MouseMode get_mouseMode() const", AS_METHODPR(T, GetMouseMode, () const, MouseMode), AS_CALL_THISCALL);

    // IntVector2 Input::GetMouseMove() const
    engine->RegisterObjectMethod(className, "IntVector2 GetMouseMove() const", AS_METHODPR(T, GetMouseMove, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_mouseMove() const", AS_METHODPR(T, GetMouseMove, () const, IntVector2), AS_CALL_THISCALL);

    // int Input::GetMouseMoveWheel() const
    engine->RegisterObjectMethod(className, "int GetMouseMoveWheel() const", AS_METHODPR(T, GetMouseMoveWheel, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_mouseMoveWheel() const", AS_METHODPR(T, GetMouseMoveWheel, () const, int), AS_CALL_THISCALL);

    // int Input::GetMouseMoveX() const
    engine->RegisterObjectMethod(className, "int GetMouseMoveX() const", AS_METHODPR(T, GetMouseMoveX, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_mouseMoveX() const", AS_METHODPR(T, GetMouseMoveX, () const, int), AS_CALL_THISCALL);

    // int Input::GetMouseMoveY() const
    engine->RegisterObjectMethod(className, "int GetMouseMoveY() const", AS_METHODPR(T, GetMouseMoveY, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_mouseMoveY() const", AS_METHODPR(T, GetMouseMoveY, () const, int), AS_CALL_THISCALL);

    // IntVector2 Input::GetMousePosition() const
    engine->RegisterObjectMethod(className, "IntVector2 GetMousePosition() const", AS_METHODPR(T, GetMousePosition, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_mousePosition() const", AS_METHODPR(T, GetMousePosition, () const, IntVector2), AS_CALL_THISCALL);

    // unsigned Input::GetNumJoysticks() const
    engine->RegisterObjectMethod(className, "uint GetNumJoysticks() const", AS_METHODPR(T, GetNumJoysticks, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numJoysticks() const", AS_METHODPR(T, GetNumJoysticks, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Input::GetNumTouches() const
    engine->RegisterObjectMethod(className, "uint GetNumTouches() const", AS_METHODPR(T, GetNumTouches, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numTouches() const", AS_METHODPR(T, GetNumTouches, () const, unsigned), AS_CALL_THISCALL);

    // bool Input::GetQualifierDown(Qualifier qualifier) const
    engine->RegisterObjectMethod(className, "bool GetQualifierDown(Qualifier) const", AS_METHODPR(T, GetQualifierDown, (Qualifier) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_qualifierDown(Qualifier) const", AS_METHODPR(T, GetQualifierDown, (Qualifier) const, bool), AS_CALL_THISCALL);

    // bool Input::GetQualifierPress(Qualifier qualifier) const
    engine->RegisterObjectMethod(className, "bool GetQualifierPress(Qualifier) const", AS_METHODPR(T, GetQualifierPress, (Qualifier) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_qualifierPress(Qualifier) const", AS_METHODPR(T, GetQualifierPress, (Qualifier) const, bool), AS_CALL_THISCALL);

    // QualifierFlags Input::GetQualifiers() const
    engine->RegisterObjectMethod(className, "QualifierFlags GetQualifiers() const", AS_METHODPR(T, GetQualifiers, () const, QualifierFlags), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "QualifierFlags get_qualifiers() const", AS_METHODPR(T, GetQualifiers, () const, QualifierFlags), AS_CALL_THISCALL);

    // bool Input::GetScancodeDown(Scancode scancode) const
    engine->RegisterObjectMethod(className, "bool GetScancodeDown(Scancode) const", AS_METHODPR(T, GetScancodeDown, (Scancode) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_scancodeDown(Scancode) const", AS_METHODPR(T, GetScancodeDown, (Scancode) const, bool), AS_CALL_THISCALL);

    // Scancode Input::GetScancodeFromKey(Key key) const
    engine->RegisterObjectMethod(className, "Scancode GetScancodeFromKey(Key) const", AS_METHODPR(T, GetScancodeFromKey, (Key) const, Scancode), AS_CALL_THISCALL);

    // Scancode Input::GetScancodeFromName(const String& name) const
    engine->RegisterObjectMethod(className, "Scancode GetScancodeFromName(const String&in) const", AS_METHODPR(T, GetScancodeFromName, (const String&) const, Scancode), AS_CALL_THISCALL);

    // String Input::GetScancodeName(Scancode scancode) const
    engine->RegisterObjectMethod(className, "String GetScancodeName(Scancode) const", AS_METHODPR(T, GetScancodeName, (Scancode) const, String), AS_CALL_THISCALL);

    // bool Input::GetScancodePress(Scancode scancode) const
    engine->RegisterObjectMethod(className, "bool GetScancodePress(Scancode) const", AS_METHODPR(T, GetScancodePress, (Scancode) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_scancodePress(Scancode) const", AS_METHODPR(T, GetScancodePress, (Scancode) const, bool), AS_CALL_THISCALL);

    // bool Input::GetScreenKeyboardSupport() const
    engine->RegisterObjectMethod(className, "bool GetScreenKeyboardSupport() const", AS_METHODPR(T, GetScreenKeyboardSupport, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_screenKeyboardSupport() const", AS_METHODPR(T, GetScreenKeyboardSupport, () const, bool), AS_CALL_THISCALL);

    // bool Input::GetToggleFullscreen() const
    engine->RegisterObjectMethod(className, "bool GetToggleFullscreen() const", AS_METHODPR(T, GetToggleFullscreen, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_toggleFullscreen() const", AS_METHODPR(T, GetToggleFullscreen, () const, bool), AS_CALL_THISCALL);

    // TouchState* Input::GetTouch(unsigned index) const
    engine->RegisterObjectMethod(className, "TouchState@+ GetTouch(uint) const", AS_METHODPR(T, GetTouch, (unsigned) const, TouchState*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TouchState@+ get_touches(uint) const", AS_METHODPR(T, GetTouch, (unsigned) const, TouchState*), AS_CALL_THISCALL);

    // bool Input::GetTouchEmulation() const
    engine->RegisterObjectMethod(className, "bool GetTouchEmulation() const", AS_METHODPR(T, GetTouchEmulation, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_touchEmulation() const", AS_METHODPR(T, GetTouchEmulation, () const, bool), AS_CALL_THISCALL);

    // bool Input::HasFocus()
    engine->RegisterObjectMethod(className, "bool HasFocus()", AS_METHODPR(T, HasFocus, (), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_focus()", AS_METHODPR(T, HasFocus, (), bool), AS_CALL_THISCALL);

    // bool Input::IsMinimized() const
    engine->RegisterObjectMethod(className, "bool IsMinimized() const", AS_METHODPR(T, IsMinimized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_minimized() const", AS_METHODPR(T, IsMinimized, () const, bool), AS_CALL_THISCALL);

    // bool Input::IsMouseGrabbed() const
    engine->RegisterObjectMethod(className, "bool IsMouseGrabbed() const", AS_METHODPR(T, IsMouseGrabbed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_mouseGrabbed() const", AS_METHODPR(T, IsMouseGrabbed, () const, bool), AS_CALL_THISCALL);

    // bool Input::IsMouseLocked() const
    engine->RegisterObjectMethod(className, "bool IsMouseLocked() const", AS_METHODPR(T, IsMouseLocked, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_mouseLocked() const", AS_METHODPR(T, IsMouseLocked, () const, bool), AS_CALL_THISCALL);

    // bool Input::IsMouseVisible() const
    engine->RegisterObjectMethod(className, "bool IsMouseVisible() const", AS_METHODPR(T, IsMouseVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_mouseVisible() const", AS_METHODPR(T, IsMouseVisible, () const, bool), AS_CALL_THISCALL);

    // bool Input::IsScreenJoystickVisible(SDL_JoystickID id) const
    engine->RegisterObjectMethod(className, "bool IsScreenJoystickVisible(SDL_JoystickID) const", AS_METHODPR(T, IsScreenJoystickVisible, (SDL_JoystickID) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_screenJoystickVisible(SDL_JoystickID) const", AS_METHODPR(T, IsScreenJoystickVisible, (SDL_JoystickID) const, bool), AS_CALL_THISCALL);

    // bool Input::IsScreenKeyboardVisible() const
    engine->RegisterObjectMethod(className, "bool IsScreenKeyboardVisible() const", AS_METHODPR(T, IsScreenKeyboardVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_screenKeyboardVisible() const", AS_METHODPR(T, IsScreenKeyboardVisible, () const, bool), AS_CALL_THISCALL);

    // unsigned Input::LoadGestures(Deserializer& source)
    engine->RegisterObjectMethod(className, "uint LoadGestures(Deserializer&)", AS_METHODPR(T, LoadGestures, (Deserializer&), unsigned), AS_CALL_THISCALL);

    // bool Input::RecordGesture()
    engine->RegisterObjectMethod(className, "bool RecordGesture()", AS_METHODPR(T, RecordGesture, (), bool), AS_CALL_THISCALL);

    // void Input::RemoveAllGestures()
    engine->RegisterObjectMethod(className, "void RemoveAllGestures()", AS_METHODPR(T, RemoveAllGestures, (), void), AS_CALL_THISCALL);

    // bool Input::RemoveGesture(unsigned gestureID)
    engine->RegisterObjectMethod(className, "bool RemoveGesture(uint)", AS_METHODPR(T, RemoveGesture, (unsigned), bool), AS_CALL_THISCALL);

    // bool Input::RemoveScreenJoystick(SDL_JoystickID id)
    engine->RegisterObjectMethod(className, "bool RemoveScreenJoystick(SDL_JoystickID)", AS_METHODPR(T, RemoveScreenJoystick, (SDL_JoystickID), bool), AS_CALL_THISCALL);

    // void Input::ResetMouseGrabbed()
    engine->RegisterObjectMethod(className, "void ResetMouseGrabbed()", AS_METHODPR(T, ResetMouseGrabbed, (), void), AS_CALL_THISCALL);

    // void Input::ResetMouseMode()
    engine->RegisterObjectMethod(className, "void ResetMouseMode()", AS_METHODPR(T, ResetMouseMode, (), void), AS_CALL_THISCALL);

    // void Input::ResetMouseVisible()
    engine->RegisterObjectMethod(className, "void ResetMouseVisible()", AS_METHODPR(T, ResetMouseVisible, (), void), AS_CALL_THISCALL);

    // bool Input::SaveGesture(Serializer& dest, unsigned gestureID)
    engine->RegisterObjectMethod(className, "bool SaveGesture(Serializer&, uint)", AS_METHODPR(T, SaveGesture, (Serializer&, unsigned), bool), AS_CALL_THISCALL);

    // bool Input::SaveGestures(Serializer& dest)
    engine->RegisterObjectMethod(className, "bool SaveGestures(Serializer&)", AS_METHODPR(T, SaveGestures, (Serializer&), bool), AS_CALL_THISCALL);

    // void Input::SetMouseGrabbed(bool grab, bool suppressEvent = false)
    engine->RegisterObjectMethod(className, "void SetMouseGrabbed(bool, bool = false)", AS_METHODPR(T, SetMouseGrabbed, (bool, bool), void), AS_CALL_THISCALL);

    // void Input::SetMouseMode(MouseMode mode, bool suppressEvent = false)
    engine->RegisterObjectMethod(className, "void SetMouseMode(MouseMode, bool = false)", AS_METHODPR(T, SetMouseMode, (MouseMode, bool), void), AS_CALL_THISCALL);

    // void Input::SetMousePosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetMousePosition(const IntVector2&in)", AS_METHODPR(T, SetMousePosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mousePosition(const IntVector2&in)", AS_METHODPR(T, SetMousePosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Input::SetMouseVisible(bool enable, bool suppressEvent = false)
    engine->RegisterObjectMethod(className, "void SetMouseVisible(bool, bool = false)", AS_METHODPR(T, SetMouseVisible, (bool, bool), void), AS_CALL_THISCALL);

    // void Input::SetScreenJoystickVisible(SDL_JoystickID id, bool enable)
    engine->RegisterObjectMethod(className, "void SetScreenJoystickVisible(SDL_JoystickID, bool)", AS_METHODPR(T, SetScreenJoystickVisible, (SDL_JoystickID, bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_screenJoystickVisible(SDL_JoystickID, bool)", AS_METHODPR(T, SetScreenJoystickVisible, (SDL_JoystickID, bool), void), AS_CALL_THISCALL);

    // void Input::SetScreenKeyboardVisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetScreenKeyboardVisible(bool)", AS_METHODPR(T, SetScreenKeyboardVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_screenKeyboardVisible(bool)", AS_METHODPR(T, SetScreenKeyboardVisible, (bool), void), AS_CALL_THISCALL);

    // void Input::SetToggleFullscreen(bool enable)
    engine->RegisterObjectMethod(className, "void SetToggleFullscreen(bool)", AS_METHODPR(T, SetToggleFullscreen, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_toggleFullscreen(bool)", AS_METHODPR(T, SetToggleFullscreen, (bool), void), AS_CALL_THISCALL);

    // void Input::SetTouchEmulation(bool enable)
    engine->RegisterObjectMethod(className, "void SetTouchEmulation(bool)", AS_METHODPR(T, SetTouchEmulation, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_touchEmulation(bool)", AS_METHODPR(T, SetTouchEmulation, (bool), void), AS_CALL_THISCALL);

    // void Input::Update()
    engine->RegisterObjectMethod(className, "void Update()", AS_METHODPR(T, Update, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Input
        REGISTER_MEMBERS_MANUAL_PART_Input();
    #endif
}

// class Localization | File: ../Resource/Localization.h
template <class T> void RegisterMembers_Localization(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // String Localization::Get(const String& id)
    engine->RegisterObjectMethod(className, "String Get(const String&in)", AS_METHODPR(T, Get, (const String&), String), AS_CALL_THISCALL);

    // String Localization::GetLanguage()
    engine->RegisterObjectMethod(className, "String GetLanguage()", AS_METHODPR(T, GetLanguage, (), String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_language()", AS_METHODPR(T, GetLanguage, (), String), AS_CALL_THISCALL);

    // String Localization::GetLanguage(int index)
    engine->RegisterObjectMethod(className, "String GetLanguage(int)", AS_METHODPR(T, GetLanguage, (int), String), AS_CALL_THISCALL);

    // int Localization::GetLanguageIndex() const
    engine->RegisterObjectMethod(className, "int GetLanguageIndex() const", AS_METHODPR(T, GetLanguageIndex, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_languageIndex() const", AS_METHODPR(T, GetLanguageIndex, () const, int), AS_CALL_THISCALL);

    // int Localization::GetLanguageIndex(const String& language)
    engine->RegisterObjectMethod(className, "int GetLanguageIndex(const String&in)", AS_METHODPR(T, GetLanguageIndex, (const String&), int), AS_CALL_THISCALL);

    // int Localization::GetNumLanguages() const
    engine->RegisterObjectMethod(className, "int GetNumLanguages() const", AS_METHODPR(T, GetNumLanguages, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_numLanguages() const", AS_METHODPR(T, GetNumLanguages, () const, int), AS_CALL_THISCALL);

    // void Localization::LoadJSONFile(const String& name, const String& language = String::EMPTY)
    engine->RegisterObjectMethod(className, "void LoadJSONFile(const String&in, const String&in = String::EMPTY)", AS_METHODPR(T, LoadJSONFile, (const String&, const String&), void), AS_CALL_THISCALL);

    // void Localization::LoadMultipleLanguageJSON(const JSONValue& source)
    engine->RegisterObjectMethod(className, "void LoadMultipleLanguageJSON(const JSONValue&in)", AS_METHODPR(T, LoadMultipleLanguageJSON, (const JSONValue&), void), AS_CALL_THISCALL);

    // void Localization::LoadSingleLanguageJSON(const JSONValue& source, const String& language = String::EMPTY)
    engine->RegisterObjectMethod(className, "void LoadSingleLanguageJSON(const JSONValue&in, const String&in = String::EMPTY)", AS_METHODPR(T, LoadSingleLanguageJSON, (const JSONValue&, const String&), void), AS_CALL_THISCALL);

    // void Localization::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void Localization::SetLanguage(int index)
    engine->RegisterObjectMethod(className, "void SetLanguage(int)", AS_METHODPR(T, SetLanguage, (int), void), AS_CALL_THISCALL);

    // void Localization::SetLanguage(const String& language)
    engine->RegisterObjectMethod(className, "void SetLanguage(const String&in)", AS_METHODPR(T, SetLanguage, (const String&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Localization
        REGISTER_MEMBERS_MANUAL_PART_Localization();
    #endif
}

// class Log | File: ../IO/Log.h
template <class T> void RegisterMembers_Log(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Log::Close()
    engine->RegisterObjectMethod(className, "void Close()", AS_METHODPR(T, Close, (), void), AS_CALL_THISCALL);

    // String Log::GetLastMessage() const
    engine->RegisterObjectMethod(className, "String GetLastMessage() const", AS_METHODPR(T, GetLastMessage, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_lastMessage() const", AS_METHODPR(T, GetLastMessage, () const, String), AS_CALL_THISCALL);

    // int Log::GetLevel() const
    engine->RegisterObjectMethod(className, "int GetLevel() const", AS_METHODPR(T, GetLevel, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_level() const", AS_METHODPR(T, GetLevel, () const, int), AS_CALL_THISCALL);

    // bool Log::GetTimeStamp() const
    engine->RegisterObjectMethod(className, "bool GetTimeStamp() const", AS_METHODPR(T, GetTimeStamp, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_timeStamp() const", AS_METHODPR(T, GetTimeStamp, () const, bool), AS_CALL_THISCALL);

    // bool Log::IsQuiet() const
    engine->RegisterObjectMethod(className, "bool IsQuiet() const", AS_METHODPR(T, IsQuiet, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_quiet() const", AS_METHODPR(T, IsQuiet, () const, bool), AS_CALL_THISCALL);

    // void Log::Open(const String& fileName)
    engine->RegisterObjectMethod(className, "void Open(const String&in)", AS_METHODPR(T, Open, (const String&), void), AS_CALL_THISCALL);

    // void Log::SetLevel(int level)
    engine->RegisterObjectMethod(className, "void SetLevel(int)", AS_METHODPR(T, SetLevel, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_level(int)", AS_METHODPR(T, SetLevel, (int), void), AS_CALL_THISCALL);

    // void Log::SetQuiet(bool quiet)
    engine->RegisterObjectMethod(className, "void SetQuiet(bool)", AS_METHODPR(T, SetQuiet, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_quiet(bool)", AS_METHODPR(T, SetQuiet, (bool), void), AS_CALL_THISCALL);

    // void Log::SetTimeStamp(bool enable)
    engine->RegisterObjectMethod(className, "void SetTimeStamp(bool)", AS_METHODPR(T, SetTimeStamp, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_timeStamp(bool)", AS_METHODPR(T, SetTimeStamp, (bool), void), AS_CALL_THISCALL);

    // static void Log::Write(int level, const String& message)
    // Not registered because have @nobind mark
    // static void Log::WriteFormat(int level, const char* format,...)
    // Error: type "const char*" can not automatically bind

    // static void Log::WriteRaw(const String& message, bool error = false)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("void WriteRaw(const String&in, bool = false)", AS_FUNCTIONPR(T::WriteRaw, (const String&, bool), void), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Log
        REGISTER_MEMBERS_MANUAL_PART_Log();
    #endif
}

// class MemoryBuffer | File: ../IO/MemoryBuffer.h
template <class T> void RegisterMembers_MemoryBuffer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_AbstractFile<T>(engine, className);

    // unsigned char* MemoryBuffer::GetData()
    // Error: type "unsigned char*" can not automatically bind

    // bool MemoryBuffer::IsReadOnly()
    engine->RegisterObjectMethod(className, "bool IsReadOnly()", AS_METHODPR(T, IsReadOnly, (), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_MemoryBuffer
        REGISTER_MEMBERS_MANUAL_PART_MemoryBuffer();
    #endif
}

// class MessageBox | File: ../UI/MessageBox.h
template <class T> void RegisterMembers_MessageBox(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // const String& MessageBox::GetMessage() const
    engine->RegisterObjectMethod(className, "const String& GetMessage() const", AS_METHODPR(T, GetMessage, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_message() const", AS_METHODPR(T, GetMessage, () const, const String&), AS_CALL_THISCALL);

    // const String& MessageBox::GetTitle() const
    engine->RegisterObjectMethod(className, "const String& GetTitle() const", AS_METHODPR(T, GetTitle, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_title() const", AS_METHODPR(T, GetTitle, () const, const String&), AS_CALL_THISCALL);

    // UIElement* MessageBox::GetWindow() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetWindow() const", AS_METHODPR(T, GetWindow, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_window() const", AS_METHODPR(T, GetWindow, () const, UIElement*), AS_CALL_THISCALL);

    // void MessageBox::SetMessage(const String& text)
    engine->RegisterObjectMethod(className, "void SetMessage(const String&in)", AS_METHODPR(T, SetMessage, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_message(const String&in)", AS_METHODPR(T, SetMessage, (const String&), void), AS_CALL_THISCALL);

    // void MessageBox::SetTitle(const String& text)
    engine->RegisterObjectMethod(className, "void SetTitle(const String&in)", AS_METHODPR(T, SetTitle, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_title(const String&in)", AS_METHODPR(T, SetTitle, (const String&), void), AS_CALL_THISCALL);

    // static void MessageBox::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_MessageBox
        REGISTER_MEMBERS_MANUAL_PART_MessageBox();
    #endif
}

// class NamedPipe | File: ../IO/NamedPipe.h
template <class T> void RegisterMembers_NamedPipe(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);
    RegisterMembers_AbstractFile<T>(engine, className);

    // void NamedPipe::Close()
    engine->RegisterObjectMethod(className, "void Close()", AS_METHODPR(T, Close, (), void), AS_CALL_THISCALL);

    // bool NamedPipe::IsOpen() const
    engine->RegisterObjectMethod(className, "bool IsOpen() const", AS_METHODPR(T, IsOpen, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_open() const", AS_METHODPR(T, IsOpen, () const, bool), AS_CALL_THISCALL);

    // bool NamedPipe::IsServer() const
    engine->RegisterObjectMethod(className, "bool IsServer() const", AS_METHODPR(T, IsServer, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_server() const", AS_METHODPR(T, IsServer, () const, bool), AS_CALL_THISCALL);

    // bool NamedPipe::Open(const String& name, bool isServer)
    engine->RegisterObjectMethod(className, "bool Open(const String&in, bool)", AS_METHODPR(T, Open, (const String&, bool), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NamedPipe
        REGISTER_MEMBERS_MANUAL_PART_NamedPipe();
    #endif
}

// class OcclusionBuffer | File: ../Graphics/OcclusionBuffer.h
template <class T> void RegisterMembers_OcclusionBuffer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // bool OcclusionBuffer::AddTriangles(const Matrix3x4& model, const void* vertexData, unsigned vertexSize, unsigned vertexStart, unsigned vertexCount)
    // Error: type "const void*" can not automatically bind
    // bool OcclusionBuffer::AddTriangles(const Matrix3x4& model, const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount)
    // Error: type "const void*" can not automatically bind
    // int* OcclusionBuffer::GetBuffer() const
    // Error: type "int*" can not automatically bind

    // void OcclusionBuffer::BuildDepthHierarchy()
    engine->RegisterObjectMethod(className, "void BuildDepthHierarchy()", AS_METHODPR(T, BuildDepthHierarchy, (), void), AS_CALL_THISCALL);

    // void OcclusionBuffer::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void OcclusionBuffer::DrawBatch(const OcclusionBatch& batch, unsigned threadIndex)
    engine->RegisterObjectMethod(className, "void DrawBatch(const OcclusionBatch&in, uint)", AS_METHODPR(T, DrawBatch, (const OcclusionBatch&, unsigned), void), AS_CALL_THISCALL);

    // void OcclusionBuffer::DrawTriangles()
    engine->RegisterObjectMethod(className, "void DrawTriangles()", AS_METHODPR(T, DrawTriangles, (), void), AS_CALL_THISCALL);

    // CullMode OcclusionBuffer::GetCullMode() const
    engine->RegisterObjectMethod(className, "CullMode GetCullMode() const", AS_METHODPR(T, GetCullMode, () const, CullMode), AS_CALL_THISCALL);

    // int OcclusionBuffer::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // unsigned OcclusionBuffer::GetMaxTriangles() const
    engine->RegisterObjectMethod(className, "uint GetMaxTriangles() const", AS_METHODPR(T, GetMaxTriangles, () const, unsigned), AS_CALL_THISCALL);

    // unsigned OcclusionBuffer::GetNumTriangles() const
    engine->RegisterObjectMethod(className, "uint GetNumTriangles() const", AS_METHODPR(T, GetNumTriangles, () const, unsigned), AS_CALL_THISCALL);

    // const Matrix4& OcclusionBuffer::GetProjection() const
    engine->RegisterObjectMethod(className, "const Matrix4& GetProjection() const", AS_METHODPR(T, GetProjection, () const, const Matrix4&), AS_CALL_THISCALL);

    // unsigned OcclusionBuffer::GetUseTimer()
    engine->RegisterObjectMethod(className, "uint GetUseTimer()", AS_METHODPR(T, GetUseTimer, (), unsigned), AS_CALL_THISCALL);

    // const Matrix3x4& OcclusionBuffer::GetView() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetView() const", AS_METHODPR(T, GetView, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // int OcclusionBuffer::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool OcclusionBuffer::IsThreaded() const
    engine->RegisterObjectMethod(className, "bool IsThreaded() const", AS_METHODPR(T, IsThreaded, () const, bool), AS_CALL_THISCALL);

    // bool OcclusionBuffer::IsVisible(const BoundingBox& worldSpaceBox) const
    engine->RegisterObjectMethod(className, "bool IsVisible(const BoundingBox&in) const", AS_METHODPR(T, IsVisible, (const BoundingBox&) const, bool), AS_CALL_THISCALL);

    // void OcclusionBuffer::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void OcclusionBuffer::ResetUseTimer()
    engine->RegisterObjectMethod(className, "void ResetUseTimer()", AS_METHODPR(T, ResetUseTimer, (), void), AS_CALL_THISCALL);

    // void OcclusionBuffer::SetCullMode(CullMode mode)
    engine->RegisterObjectMethod(className, "void SetCullMode(CullMode)", AS_METHODPR(T, SetCullMode, (CullMode), void), AS_CALL_THISCALL);

    // void OcclusionBuffer::SetMaxTriangles(unsigned triangles)
    engine->RegisterObjectMethod(className, "void SetMaxTriangles(uint)", AS_METHODPR(T, SetMaxTriangles, (unsigned), void), AS_CALL_THISCALL);

    // bool OcclusionBuffer::SetSize(int width, int height, bool threaded)
    engine->RegisterObjectMethod(className, "bool SetSize(int, int, bool)", AS_METHODPR(T, SetSize, (int, int, bool), bool), AS_CALL_THISCALL);

    // void OcclusionBuffer::SetView(Camera* camera)
    engine->RegisterObjectMethod(className, "void SetView(Camera@+)", AS_METHODPR(T, SetView, (Camera*), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OcclusionBuffer
        REGISTER_MEMBERS_MANUAL_PART_OcclusionBuffer();
    #endif
}

// class OggVorbisSoundStream | File: ../Audio/OggVorbisSoundStream.h
template <class T> void RegisterMembers_OggVorbisSoundStream(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_SoundStream<T>(engine, className);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OggVorbisSoundStream
        REGISTER_MEMBERS_MANUAL_PART_OggVorbisSoundStream();
    #endif
}

// const Vector<String> PackageFile::GetEntryNames() const
template <class T> CScriptArray* PackageFile_constspVectorlesStringgre_GetEntryNames_void_template(T* _ptr)
{
    const Vector<String> result = _ptr->GetEntryNames();
    return VectorToArray<String>(result, "Array<String>");
}

// class PackageFile | File: ../IO/PackageFile.h
template <class T> void RegisterMembers_PackageFile(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // const HashMap<String, PackageEntry>& PackageFile::GetEntries() const
    // Error: type "const HashMap<String, PackageEntry>&" can not automatically bind
    // const PackageEntry* PackageFile::GetEntry(const String& fileName) const
    // Error: type "const PackageEntry*" can not automatically bind

    // bool PackageFile::Exists(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool Exists(const String&in) const", AS_METHODPR(T, Exists, (const String&) const, bool), AS_CALL_THISCALL);

    // unsigned PackageFile::GetChecksum() const
    engine->RegisterObjectMethod(className, "uint GetChecksum() const", AS_METHODPR(T, GetChecksum, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_checksum() const", AS_METHODPR(T, GetChecksum, () const, unsigned), AS_CALL_THISCALL);

    // const Vector<String> PackageFile::GetEntryNames() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetEntryNames() const", AS_FUNCTION_OBJFIRST(PackageFile_constspVectorlesStringgre_GetEntryNames_void_template<PackageFile>), AS_CALL_CDECL_OBJFIRST);

    // const String& PackageFile::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // StringHash PackageFile::GetNameHash() const
    engine->RegisterObjectMethod(className, "StringHash GetNameHash() const", AS_METHODPR(T, GetNameHash, () const, StringHash), AS_CALL_THISCALL);

    // unsigned PackageFile::GetNumFiles() const
    engine->RegisterObjectMethod(className, "uint GetNumFiles() const", AS_METHODPR(T, GetNumFiles, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numFiles() const", AS_METHODPR(T, GetNumFiles, () const, unsigned), AS_CALL_THISCALL);

    // unsigned PackageFile::GetTotalDataSize() const
    engine->RegisterObjectMethod(className, "uint GetTotalDataSize() const", AS_METHODPR(T, GetTotalDataSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_totalDataSize() const", AS_METHODPR(T, GetTotalDataSize, () const, unsigned), AS_CALL_THISCALL);

    // unsigned PackageFile::GetTotalSize() const
    engine->RegisterObjectMethod(className, "uint GetTotalSize() const", AS_METHODPR(T, GetTotalSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_totalSize() const", AS_METHODPR(T, GetTotalSize, () const, unsigned), AS_CALL_THISCALL);

    // bool PackageFile::IsCompressed() const
    engine->RegisterObjectMethod(className, "bool IsCompressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_compressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);

    // bool PackageFile::Open(const String& fileName, unsigned startOffset = 0)
    engine->RegisterObjectMethod(className, "bool Open(const String&in, uint = 0)", AS_METHODPR(T, Open, (const String&, unsigned), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PackageFile
        REGISTER_MEMBERS_MANUAL_PART_PackageFile();
    #endif
}

// class Profiler | File: ../Core/Profiler.h
template <class T> void RegisterMembers_Profiler(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Profiler::BeginBlock(const char* name)
    // Can not be registered here bacause hidden in derived classes: EventProfiler
    // const ProfilerBlock* Profiler::GetCurrentBlock()
    // Error: type "ProfilerBlock" can not automatically bind bacause have @nobind mark
    // const ProfilerBlock* Profiler::GetRootBlock()
    // Error: type "ProfilerBlock" can not automatically bind bacause have @nobind mark

    // void Profiler::BeginFrame()
    engine->RegisterObjectMethod(className, "void BeginFrame()", AS_METHODPR(T, BeginFrame, (), void), AS_CALL_THISCALL);

    // void Profiler::BeginInterval()
    engine->RegisterObjectMethod(className, "void BeginInterval()", AS_METHODPR(T, BeginInterval, (), void), AS_CALL_THISCALL);

    // void Profiler::EndBlock()
    engine->RegisterObjectMethod(className, "void EndBlock()", AS_METHODPR(T, EndBlock, (), void), AS_CALL_THISCALL);

    // void Profiler::EndFrame()
    engine->RegisterObjectMethod(className, "void EndFrame()", AS_METHODPR(T, EndFrame, (), void), AS_CALL_THISCALL);

    // const String& Profiler::PrintData(bool showUnused = false, bool showTotal = false, unsigned maxDepth = M_MAX_UNSIGNED) const
    engine->RegisterObjectMethod(className, "const String& PrintData(bool = false, bool = false, uint = M_MAX_UNSIGNED) const", AS_METHODPR(T, PrintData, (bool, bool, unsigned) const, const String&), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Profiler
        REGISTER_MEMBERS_MANUAL_PART_Profiler();
    #endif
}

// class Renderer | File: ../Graphics/Renderer.h
template <class T> void RegisterMembers_Renderer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Renderer::SetShadowMapFilter(Object* instance, ShadowMapFilter functionPtr)
    // Not registered because have @nobind mark

    // void Renderer::ApplyShadowMapFilter(View* view, Texture2D* shadowMap, float blurScale)
    engine->RegisterObjectMethod(className, "void ApplyShadowMapFilter(View@+, Texture2D@+, float)", AS_METHODPR(T, ApplyShadowMapFilter, (View*, Texture2D*, float), void), AS_CALL_THISCALL);

    // void Renderer::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // Texture2D* Renderer::GetDefaultLightRamp() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetDefaultLightRamp() const", AS_METHODPR(T, GetDefaultLightRamp, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_defaultLightRamp() const", AS_METHODPR(T, GetDefaultLightRamp, () const, Texture2D*), AS_CALL_THISCALL);

    // Texture2D* Renderer::GetDefaultLightSpot() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetDefaultLightSpot() const", AS_METHODPR(T, GetDefaultLightSpot, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_defaultLightSpot() const", AS_METHODPR(T, GetDefaultLightSpot, () const, Texture2D*), AS_CALL_THISCALL);

    // Material* Renderer::GetDefaultMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetDefaultMaterial() const", AS_METHODPR(T, GetDefaultMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_defaultMaterial() const", AS_METHODPR(T, GetDefaultMaterial, () const, Material*), AS_CALL_THISCALL);

    // RenderPath* Renderer::GetDefaultRenderPath() const
    engine->RegisterObjectMethod(className, "RenderPath@+ GetDefaultRenderPath() const", AS_METHODPR(T, GetDefaultRenderPath, () const, RenderPath*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderPath@+ get_defaultRenderPath() const", AS_METHODPR(T, GetDefaultRenderPath, () const, RenderPath*), AS_CALL_THISCALL);

    // Technique* Renderer::GetDefaultTechnique() const
    engine->RegisterObjectMethod(className, "Technique@+ GetDefaultTechnique() const", AS_METHODPR(T, GetDefaultTechnique, () const, Technique*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Technique@+ get_defaultTechnique() const", AS_METHODPR(T, GetDefaultTechnique, () const, Technique*), AS_CALL_THISCALL);

    // Zone* Renderer::GetDefaultZone() const
    engine->RegisterObjectMethod(className, "Zone@+ GetDefaultZone() const", AS_METHODPR(T, GetDefaultZone, () const, Zone*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Zone@+ get_defaultZone() const", AS_METHODPR(T, GetDefaultZone, () const, Zone*), AS_CALL_THISCALL);

    // RenderSurface* Renderer::GetDepthStencil(int width, int height, int multiSample, bool autoResolve)
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetDepthStencil(int, int, int, bool)", AS_METHODPR(T, GetDepthStencil, (int, int, int, bool), RenderSurface*), AS_CALL_THISCALL);

    // bool Renderer::GetDrawShadows() const
    engine->RegisterObjectMethod(className, "bool GetDrawShadows() const", AS_METHODPR(T, GetDrawShadows, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawShadows() const", AS_METHODPR(T, GetDrawShadows, () const, bool), AS_CALL_THISCALL);

    // bool Renderer::GetDynamicInstancing() const
    engine->RegisterObjectMethod(className, "bool GetDynamicInstancing() const", AS_METHODPR(T, GetDynamicInstancing, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dynamicInstancing() const", AS_METHODPR(T, GetDynamicInstancing, () const, bool), AS_CALL_THISCALL);

    // TextureCube* Renderer::GetFaceSelectCubeMap() const
    engine->RegisterObjectMethod(className, "TextureCube@+ GetFaceSelectCubeMap() const", AS_METHODPR(T, GetFaceSelectCubeMap, () const, TextureCube*), AS_CALL_THISCALL);

    // const FrameInfo& Renderer::GetFrameInfo() const
    engine->RegisterObjectMethod(className, "const FrameInfo& GetFrameInfo() const", AS_METHODPR(T, GetFrameInfo, () const, const FrameInfo&), AS_CALL_THISCALL);

    // bool Renderer::GetHDRRendering() const
    engine->RegisterObjectMethod(className, "bool GetHDRRendering() const", AS_METHODPR(T, GetHDRRendering, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hdrRendering() const", AS_METHODPR(T, GetHDRRendering, () const, bool), AS_CALL_THISCALL);

    // TextureCube* Renderer::GetIndirectionCubeMap() const
    engine->RegisterObjectMethod(className, "TextureCube@+ GetIndirectionCubeMap() const", AS_METHODPR(T, GetIndirectionCubeMap, () const, TextureCube*), AS_CALL_THISCALL);

    // VertexBuffer* Renderer::GetInstancingBuffer() const
    engine->RegisterObjectMethod(className, "VertexBuffer@+ GetInstancingBuffer() const", AS_METHODPR(T, GetInstancingBuffer, () const, VertexBuffer*), AS_CALL_THISCALL);

    // Geometry* Renderer::GetLightGeometry(Light* light)
    engine->RegisterObjectMethod(className, "Geometry@+ GetLightGeometry(Light@+)", AS_METHODPR(T, GetLightGeometry, (Light*), Geometry*), AS_CALL_THISCALL);

    // const Rect& Renderer::GetLightScissor(Light* light, Camera* camera)
    engine->RegisterObjectMethod(className, "const Rect& GetLightScissor(Light@+, Camera@+)", AS_METHODPR(T, GetLightScissor, (Light*, Camera*), const Rect&), AS_CALL_THISCALL);

    // MaterialQuality Renderer::GetMaterialQuality() const
    engine->RegisterObjectMethod(className, "MaterialQuality GetMaterialQuality() const", AS_METHODPR(T, GetMaterialQuality, () const, MaterialQuality), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "MaterialQuality get_materialQuality() const", AS_METHODPR(T, GetMaterialQuality, () const, MaterialQuality), AS_CALL_THISCALL);

    // int Renderer::GetMaxOccluderTriangles() const
    engine->RegisterObjectMethod(className, "int GetMaxOccluderTriangles() const", AS_METHODPR(T, GetMaxOccluderTriangles, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxOccluderTriangles() const", AS_METHODPR(T, GetMaxOccluderTriangles, () const, int), AS_CALL_THISCALL);

    // int Renderer::GetMaxShadowMaps() const
    engine->RegisterObjectMethod(className, "int GetMaxShadowMaps() const", AS_METHODPR(T, GetMaxShadowMaps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxShadowMaps() const", AS_METHODPR(T, GetMaxShadowMaps, () const, int), AS_CALL_THISCALL);

    // int Renderer::GetMaxSortedInstances() const
    engine->RegisterObjectMethod(className, "int GetMaxSortedInstances() const", AS_METHODPR(T, GetMaxSortedInstances, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxSortedInstances() const", AS_METHODPR(T, GetMaxSortedInstances, () const, int), AS_CALL_THISCALL);

    // int Renderer::GetMinInstances() const
    engine->RegisterObjectMethod(className, "int GetMinInstances() const", AS_METHODPR(T, GetMinInstances, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_minInstances() const", AS_METHODPR(T, GetMinInstances, () const, int), AS_CALL_THISCALL);

    // float Renderer::GetMobileNormalOffsetMul() const
    engine->RegisterObjectMethod(className, "float GetMobileNormalOffsetMul() const", AS_METHODPR(T, GetMobileNormalOffsetMul, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mobileNormalOffsetMul() const", AS_METHODPR(T, GetMobileNormalOffsetMul, () const, float), AS_CALL_THISCALL);

    // float Renderer::GetMobileShadowBiasAdd() const
    engine->RegisterObjectMethod(className, "float GetMobileShadowBiasAdd() const", AS_METHODPR(T, GetMobileShadowBiasAdd, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mobileShadowBiasAdd() const", AS_METHODPR(T, GetMobileShadowBiasAdd, () const, float), AS_CALL_THISCALL);

    // float Renderer::GetMobileShadowBiasMul() const
    engine->RegisterObjectMethod(className, "float GetMobileShadowBiasMul() const", AS_METHODPR(T, GetMobileShadowBiasMul, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mobileShadowBiasMul() const", AS_METHODPR(T, GetMobileShadowBiasMul, () const, float), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumBatches() const
    engine->RegisterObjectMethod(className, "uint GetNumBatches() const", AS_METHODPR(T, GetNumBatches, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numBatches() const", AS_METHODPR(T, GetNumBatches, () const, unsigned), AS_CALL_THISCALL);

    // int Renderer::GetNumExtraInstancingBufferElements() const
    engine->RegisterObjectMethod(className, "int GetNumExtraInstancingBufferElements() const", AS_METHODPR(T, GetNumExtraInstancingBufferElements, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_numExtraInstancingBufferElements() const", AS_METHODPR(T, GetNumExtraInstancingBufferElements, () const, int), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumGeometries(bool allViews = false) const
    engine->RegisterObjectMethod(className, "uint GetNumGeometries(bool = false) const", AS_METHODPR(T, GetNumGeometries, (bool) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numGeometries(bool = false) const", AS_METHODPR(T, GetNumGeometries, (bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumLights(bool allViews = false) const
    engine->RegisterObjectMethod(className, "uint GetNumLights(bool = false) const", AS_METHODPR(T, GetNumLights, (bool) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numLights(bool = false) const", AS_METHODPR(T, GetNumLights, (bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumOccluders(bool allViews = false) const
    engine->RegisterObjectMethod(className, "uint GetNumOccluders(bool = false) const", AS_METHODPR(T, GetNumOccluders, (bool) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numOccluders(bool = false) const", AS_METHODPR(T, GetNumOccluders, (bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumPrimitives() const
    engine->RegisterObjectMethod(className, "uint GetNumPrimitives() const", AS_METHODPR(T, GetNumPrimitives, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numPrimitives() const", AS_METHODPR(T, GetNumPrimitives, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumShadowMaps(bool allViews = false) const
    engine->RegisterObjectMethod(className, "uint GetNumShadowMaps(bool = false) const", AS_METHODPR(T, GetNumShadowMaps, (bool) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numShadowMaps(bool = false) const", AS_METHODPR(T, GetNumShadowMaps, (bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumViewports() const
    engine->RegisterObjectMethod(className, "uint GetNumViewports() const", AS_METHODPR(T, GetNumViewports, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numViewports() const", AS_METHODPR(T, GetNumViewports, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Renderer::GetNumViews() const
    engine->RegisterObjectMethod(className, "uint GetNumViews() const", AS_METHODPR(T, GetNumViews, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numViews() const", AS_METHODPR(T, GetNumViews, () const, unsigned), AS_CALL_THISCALL);

    // float Renderer::GetOccluderSizeThreshold() const
    engine->RegisterObjectMethod(className, "float GetOccluderSizeThreshold() const", AS_METHODPR(T, GetOccluderSizeThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_occluderSizeThreshold() const", AS_METHODPR(T, GetOccluderSizeThreshold, () const, float), AS_CALL_THISCALL);

    // OcclusionBuffer* Renderer::GetOcclusionBuffer(Camera* camera)
    engine->RegisterObjectMethod(className, "OcclusionBuffer@+ GetOcclusionBuffer(Camera@+)", AS_METHODPR(T, GetOcclusionBuffer, (Camera*), OcclusionBuffer*), AS_CALL_THISCALL);

    // int Renderer::GetOcclusionBufferSize() const
    engine->RegisterObjectMethod(className, "int GetOcclusionBufferSize() const", AS_METHODPR(T, GetOcclusionBufferSize, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_occlusionBufferSize() const", AS_METHODPR(T, GetOcclusionBufferSize, () const, int), AS_CALL_THISCALL);

    // View* Renderer::GetPreparedView(Camera* camera)
    engine->RegisterObjectMethod(className, "View@+ GetPreparedView(Camera@+)", AS_METHODPR(T, GetPreparedView, (Camera*), View*), AS_CALL_THISCALL);

    // Geometry* Renderer::GetQuadGeometry()
    engine->RegisterObjectMethod(className, "Geometry@+ GetQuadGeometry()", AS_METHODPR(T, GetQuadGeometry, (), Geometry*), AS_CALL_THISCALL);

    // bool Renderer::GetReuseShadowMaps() const
    engine->RegisterObjectMethod(className, "bool GetReuseShadowMaps() const", AS_METHODPR(T, GetReuseShadowMaps, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_reuseShadowMaps() const", AS_METHODPR(T, GetReuseShadowMaps, () const, bool), AS_CALL_THISCALL);

    // Texture* Renderer::GetScreenBuffer(int width, int height, unsigned format, int multiSample, bool autoResolve, bool cubemap, bool filtered, bool srgb, unsigned persistentKey = 0)
    engine->RegisterObjectMethod(className, "Texture@+ GetScreenBuffer(int, int, uint, int, bool, bool, bool, bool, uint = 0)", AS_METHODPR(T, GetScreenBuffer, (int, int, unsigned, int, bool, bool, bool, bool, unsigned), Texture*), AS_CALL_THISCALL);

    // Camera* Renderer::GetShadowCamera()
    engine->RegisterObjectMethod(className, "Camera@+ GetShadowCamera()", AS_METHODPR(T, GetShadowCamera, (), Camera*), AS_CALL_THISCALL);

    // Texture2D* Renderer::GetShadowMap(Light* light, Camera* camera, unsigned viewWidth, unsigned viewHeight)
    engine->RegisterObjectMethod(className, "Texture2D@+ GetShadowMap(Light@+, Camera@+, uint, uint)", AS_METHODPR(T, GetShadowMap, (Light*, Camera*, unsigned, unsigned), Texture2D*), AS_CALL_THISCALL);

    // int Renderer::GetShadowMapSize() const
    engine->RegisterObjectMethod(className, "int GetShadowMapSize() const", AS_METHODPR(T, GetShadowMapSize, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_shadowMapSize() const", AS_METHODPR(T, GetShadowMapSize, () const, int), AS_CALL_THISCALL);

    // ShadowQuality Renderer::GetShadowQuality() const
    engine->RegisterObjectMethod(className, "ShadowQuality GetShadowQuality() const", AS_METHODPR(T, GetShadowQuality, () const, ShadowQuality), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ShadowQuality get_shadowQuality() const", AS_METHODPR(T, GetShadowQuality, () const, ShadowQuality), AS_CALL_THISCALL);

    // float Renderer::GetShadowSoftness() const
    engine->RegisterObjectMethod(className, "float GetShadowSoftness() const", AS_METHODPR(T, GetShadowSoftness, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowSoftness() const", AS_METHODPR(T, GetShadowSoftness, () const, float), AS_CALL_THISCALL);

    // bool Renderer::GetSpecularLighting() const
    engine->RegisterObjectMethod(className, "bool GetSpecularLighting() const", AS_METHODPR(T, GetSpecularLighting, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_specularLighting() const", AS_METHODPR(T, GetSpecularLighting, () const, bool), AS_CALL_THISCALL);

    // int Renderer::GetTextureAnisotropy() const
    engine->RegisterObjectMethod(className, "int GetTextureAnisotropy() const", AS_METHODPR(T, GetTextureAnisotropy, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_textureAnisotropy() const", AS_METHODPR(T, GetTextureAnisotropy, () const, int), AS_CALL_THISCALL);

    // TextureFilterMode Renderer::GetTextureFilterMode() const
    engine->RegisterObjectMethod(className, "TextureFilterMode GetTextureFilterMode() const", AS_METHODPR(T, GetTextureFilterMode, () const, TextureFilterMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureFilterMode get_textureFilterMode() const", AS_METHODPR(T, GetTextureFilterMode, () const, TextureFilterMode), AS_CALL_THISCALL);

    // MaterialQuality Renderer::GetTextureQuality() const
    engine->RegisterObjectMethod(className, "MaterialQuality GetTextureQuality() const", AS_METHODPR(T, GetTextureQuality, () const, MaterialQuality), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "MaterialQuality get_textureQuality() const", AS_METHODPR(T, GetTextureQuality, () const, MaterialQuality), AS_CALL_THISCALL);

    // bool Renderer::GetThreadedOcclusion() const
    engine->RegisterObjectMethod(className, "bool GetThreadedOcclusion() const", AS_METHODPR(T, GetThreadedOcclusion, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_threadedOcclusion() const", AS_METHODPR(T, GetThreadedOcclusion, () const, bool), AS_CALL_THISCALL);

    // Viewport* Renderer::GetViewport(unsigned index) const
    engine->RegisterObjectMethod(className, "Viewport@+ GetViewport(uint) const", AS_METHODPR(T, GetViewport, (unsigned) const, Viewport*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Viewport@+ get_viewports(uint) const", AS_METHODPR(T, GetViewport, (unsigned) const, Viewport*), AS_CALL_THISCALL);

    // Viewport* Renderer::GetViewportForScene(Scene* scene, unsigned index) const
    engine->RegisterObjectMethod(className, "Viewport@+ GetViewportForScene(Scene@+, uint) const", AS_METHODPR(T, GetViewportForScene, (Scene*, unsigned) const, Viewport*), AS_CALL_THISCALL);

    // int Renderer::GetVSMMultiSample() const
    engine->RegisterObjectMethod(className, "int GetVSMMultiSample() const", AS_METHODPR(T, GetVSMMultiSample, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_vsmMultiSample() const", AS_METHODPR(T, GetVSMMultiSample, () const, int), AS_CALL_THISCALL);

    // Vector2 Renderer::GetVSMShadowParameters() const
    engine->RegisterObjectMethod(className, "Vector2 GetVSMShadowParameters() const", AS_METHODPR(T, GetVSMShadowParameters, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_vsmShadowParameters() const", AS_METHODPR(T, GetVSMShadowParameters, () const, Vector2), AS_CALL_THISCALL);

    // void Renderer::OptimizeLightByScissor(Light* light, Camera* camera)
    engine->RegisterObjectMethod(className, "void OptimizeLightByScissor(Light@+, Camera@+)", AS_METHODPR(T, OptimizeLightByScissor, (Light*, Camera*), void), AS_CALL_THISCALL);

    // void Renderer::OptimizeLightByStencil(Light* light, Camera* camera)
    engine->RegisterObjectMethod(className, "void OptimizeLightByStencil(Light@+, Camera@+)", AS_METHODPR(T, OptimizeLightByStencil, (Light*, Camera*), void), AS_CALL_THISCALL);

    // void Renderer::QueueRenderSurface(RenderSurface* renderTarget)
    engine->RegisterObjectMethod(className, "void QueueRenderSurface(RenderSurface@+)", AS_METHODPR(T, QueueRenderSurface, (RenderSurface*), void), AS_CALL_THISCALL);

    // void Renderer::QueueViewport(RenderSurface* renderTarget, Viewport* viewport)
    engine->RegisterObjectMethod(className, "void QueueViewport(RenderSurface@+, Viewport@+)", AS_METHODPR(T, QueueViewport, (RenderSurface*, Viewport*), void), AS_CALL_THISCALL);

    // void Renderer::ReloadShaders()
    engine->RegisterObjectMethod(className, "void ReloadShaders()", AS_METHODPR(T, ReloadShaders, (), void), AS_CALL_THISCALL);

    // void Renderer::Render()
    engine->RegisterObjectMethod(className, "void Render()", AS_METHODPR(T, Render, (), void), AS_CALL_THISCALL);

    // bool Renderer::ResizeInstancingBuffer(unsigned numInstances)
    engine->RegisterObjectMethod(className, "bool ResizeInstancingBuffer(uint)", AS_METHODPR(T, ResizeInstancingBuffer, (unsigned), bool), AS_CALL_THISCALL);

    // void Renderer::SetBatchShaders(Batch& batch, Technique* tech, bool allowShadows, const BatchQueue& queue)
    engine->RegisterObjectMethod(className, "void SetBatchShaders(Batch&, Technique@+, bool, const BatchQueue&in)", AS_METHODPR(T, SetBatchShaders, (Batch&, Technique*, bool, const BatchQueue&), void), AS_CALL_THISCALL);

    // void Renderer::SetCullMode(CullMode mode, Camera* camera)
    engine->RegisterObjectMethod(className, "void SetCullMode(CullMode, Camera@+)", AS_METHODPR(T, SetCullMode, (CullMode, Camera*), void), AS_CALL_THISCALL);

    // void Renderer::SetDefaultRenderPath(RenderPath* renderPath)
    engine->RegisterObjectMethod(className, "void SetDefaultRenderPath(RenderPath@+)", AS_METHODPR(T, SetDefaultRenderPath, (RenderPath*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultRenderPath(RenderPath@+)", AS_METHODPR(T, SetDefaultRenderPath, (RenderPath*), void), AS_CALL_THISCALL);

    // void Renderer::SetDefaultRenderPath(XMLFile* xmlFile)
    engine->RegisterObjectMethod(className, "void SetDefaultRenderPath(XMLFile@+)", AS_METHODPR(T, SetDefaultRenderPath, (XMLFile*), void), AS_CALL_THISCALL);

    // void Renderer::SetDefaultTechnique(Technique* technique)
    engine->RegisterObjectMethod(className, "void SetDefaultTechnique(Technique@+)", AS_METHODPR(T, SetDefaultTechnique, (Technique*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultTechnique(Technique@+)", AS_METHODPR(T, SetDefaultTechnique, (Technique*), void), AS_CALL_THISCALL);

    // void Renderer::SetDrawShadows(bool enable)
    engine->RegisterObjectMethod(className, "void SetDrawShadows(bool)", AS_METHODPR(T, SetDrawShadows, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawShadows(bool)", AS_METHODPR(T, SetDrawShadows, (bool), void), AS_CALL_THISCALL);

    // void Renderer::SetDynamicInstancing(bool enable)
    engine->RegisterObjectMethod(className, "void SetDynamicInstancing(bool)", AS_METHODPR(T, SetDynamicInstancing, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dynamicInstancing(bool)", AS_METHODPR(T, SetDynamicInstancing, (bool), void), AS_CALL_THISCALL);

    // void Renderer::SetHDRRendering(bool enable)
    engine->RegisterObjectMethod(className, "void SetHDRRendering(bool)", AS_METHODPR(T, SetHDRRendering, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hdrRendering(bool)", AS_METHODPR(T, SetHDRRendering, (bool), void), AS_CALL_THISCALL);

    // void Renderer::SetLightVolumeBatchShaders(Batch& batch, Camera* camera, const String& vsName, const String& psName, const String& vsDefines, const String& psDefines)
    engine->RegisterObjectMethod(className, "void SetLightVolumeBatchShaders(Batch&, Camera@+, const String&in, const String&in, const String&in, const String&in)", AS_METHODPR(T, SetLightVolumeBatchShaders, (Batch&, Camera*, const String&, const String&, const String&, const String&), void), AS_CALL_THISCALL);

    // void Renderer::SetMaterialQuality(MaterialQuality quality)
    engine->RegisterObjectMethod(className, "void SetMaterialQuality(MaterialQuality)", AS_METHODPR(T, SetMaterialQuality, (MaterialQuality), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_materialQuality(MaterialQuality)", AS_METHODPR(T, SetMaterialQuality, (MaterialQuality), void), AS_CALL_THISCALL);

    // void Renderer::SetMaxOccluderTriangles(int triangles)
    engine->RegisterObjectMethod(className, "void SetMaxOccluderTriangles(int)", AS_METHODPR(T, SetMaxOccluderTriangles, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxOccluderTriangles(int)", AS_METHODPR(T, SetMaxOccluderTriangles, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetMaxShadowMaps(int shadowMaps)
    engine->RegisterObjectMethod(className, "void SetMaxShadowMaps(int)", AS_METHODPR(T, SetMaxShadowMaps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxShadowMaps(int)", AS_METHODPR(T, SetMaxShadowMaps, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetMaxSortedInstances(int instances)
    engine->RegisterObjectMethod(className, "void SetMaxSortedInstances(int)", AS_METHODPR(T, SetMaxSortedInstances, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxSortedInstances(int)", AS_METHODPR(T, SetMaxSortedInstances, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetMinInstances(int instances)
    engine->RegisterObjectMethod(className, "void SetMinInstances(int)", AS_METHODPR(T, SetMinInstances, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minInstances(int)", AS_METHODPR(T, SetMinInstances, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetMobileNormalOffsetMul(float mul)
    engine->RegisterObjectMethod(className, "void SetMobileNormalOffsetMul(float)", AS_METHODPR(T, SetMobileNormalOffsetMul, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mobileNormalOffsetMul(float)", AS_METHODPR(T, SetMobileNormalOffsetMul, (float), void), AS_CALL_THISCALL);

    // void Renderer::SetMobileShadowBiasAdd(float add)
    engine->RegisterObjectMethod(className, "void SetMobileShadowBiasAdd(float)", AS_METHODPR(T, SetMobileShadowBiasAdd, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mobileShadowBiasAdd(float)", AS_METHODPR(T, SetMobileShadowBiasAdd, (float), void), AS_CALL_THISCALL);

    // void Renderer::SetMobileShadowBiasMul(float mul)
    engine->RegisterObjectMethod(className, "void SetMobileShadowBiasMul(float)", AS_METHODPR(T, SetMobileShadowBiasMul, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mobileShadowBiasMul(float)", AS_METHODPR(T, SetMobileShadowBiasMul, (float), void), AS_CALL_THISCALL);

    // void Renderer::SetNumExtraInstancingBufferElements(int elements)
    engine->RegisterObjectMethod(className, "void SetNumExtraInstancingBufferElements(int)", AS_METHODPR(T, SetNumExtraInstancingBufferElements, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numExtraInstancingBufferElements(int)", AS_METHODPR(T, SetNumExtraInstancingBufferElements, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetNumViewports(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumViewports(uint)", AS_METHODPR(T, SetNumViewports, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numViewports(uint)", AS_METHODPR(T, SetNumViewports, (unsigned), void), AS_CALL_THISCALL);

    // void Renderer::SetOccluderSizeThreshold(float screenSize)
    engine->RegisterObjectMethod(className, "void SetOccluderSizeThreshold(float)", AS_METHODPR(T, SetOccluderSizeThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occluderSizeThreshold(float)", AS_METHODPR(T, SetOccluderSizeThreshold, (float), void), AS_CALL_THISCALL);

    // void Renderer::SetOcclusionBufferSize(int size)
    engine->RegisterObjectMethod(className, "void SetOcclusionBufferSize(int)", AS_METHODPR(T, SetOcclusionBufferSize, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occlusionBufferSize(int)", AS_METHODPR(T, SetOcclusionBufferSize, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetReuseShadowMaps(bool enable)
    engine->RegisterObjectMethod(className, "void SetReuseShadowMaps(bool)", AS_METHODPR(T, SetReuseShadowMaps, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_reuseShadowMaps(bool)", AS_METHODPR(T, SetReuseShadowMaps, (bool), void), AS_CALL_THISCALL);

    // void Renderer::SetShadowMapSize(int size)
    engine->RegisterObjectMethod(className, "void SetShadowMapSize(int)", AS_METHODPR(T, SetShadowMapSize, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowMapSize(int)", AS_METHODPR(T, SetShadowMapSize, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetShadowQuality(ShadowQuality quality)
    engine->RegisterObjectMethod(className, "void SetShadowQuality(ShadowQuality)", AS_METHODPR(T, SetShadowQuality, (ShadowQuality), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowQuality(ShadowQuality)", AS_METHODPR(T, SetShadowQuality, (ShadowQuality), void), AS_CALL_THISCALL);

    // void Renderer::SetShadowSoftness(float shadowSoftness)
    engine->RegisterObjectMethod(className, "void SetShadowSoftness(float)", AS_METHODPR(T, SetShadowSoftness, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowSoftness(float)", AS_METHODPR(T, SetShadowSoftness, (float), void), AS_CALL_THISCALL);

    // void Renderer::SetSpecularLighting(bool enable)
    engine->RegisterObjectMethod(className, "void SetSpecularLighting(bool)", AS_METHODPR(T, SetSpecularLighting, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_specularLighting(bool)", AS_METHODPR(T, SetSpecularLighting, (bool), void), AS_CALL_THISCALL);

    // void Renderer::SetTextureAnisotropy(int level)
    engine->RegisterObjectMethod(className, "void SetTextureAnisotropy(int)", AS_METHODPR(T, SetTextureAnisotropy, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textureAnisotropy(int)", AS_METHODPR(T, SetTextureAnisotropy, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetTextureFilterMode(TextureFilterMode mode)
    engine->RegisterObjectMethod(className, "void SetTextureFilterMode(TextureFilterMode)", AS_METHODPR(T, SetTextureFilterMode, (TextureFilterMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textureFilterMode(TextureFilterMode)", AS_METHODPR(T, SetTextureFilterMode, (TextureFilterMode), void), AS_CALL_THISCALL);

    // void Renderer::SetTextureQuality(MaterialQuality quality)
    engine->RegisterObjectMethod(className, "void SetTextureQuality(MaterialQuality)", AS_METHODPR(T, SetTextureQuality, (MaterialQuality), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textureQuality(MaterialQuality)", AS_METHODPR(T, SetTextureQuality, (MaterialQuality), void), AS_CALL_THISCALL);

    // void Renderer::SetThreadedOcclusion(bool enable)
    engine->RegisterObjectMethod(className, "void SetThreadedOcclusion(bool)", AS_METHODPR(T, SetThreadedOcclusion, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_threadedOcclusion(bool)", AS_METHODPR(T, SetThreadedOcclusion, (bool), void), AS_CALL_THISCALL);

    // void Renderer::SetViewport(unsigned index, Viewport* viewport)
    engine->RegisterObjectMethod(className, "void SetViewport(uint, Viewport@+)", AS_METHODPR(T, SetViewport, (unsigned, Viewport*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewports(uint, Viewport@+)", AS_METHODPR(T, SetViewport, (unsigned, Viewport*), void), AS_CALL_THISCALL);

    // void Renderer::SetVSMMultiSample(int multiSample)
    engine->RegisterObjectMethod(className, "void SetVSMMultiSample(int)", AS_METHODPR(T, SetVSMMultiSample, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vsmMultiSample(int)", AS_METHODPR(T, SetVSMMultiSample, (int), void), AS_CALL_THISCALL);

    // void Renderer::SetVSMShadowParameters(float minVariance, float lightBleedingReduction)
    engine->RegisterObjectMethod(className, "void SetVSMShadowParameters(float, float)", AS_METHODPR(T, SetVSMShadowParameters, (float, float), void), AS_CALL_THISCALL);

    // void Renderer::StorePreparedView(View* view, Camera* camera)
    engine->RegisterObjectMethod(className, "void StorePreparedView(View@+, Camera@+)", AS_METHODPR(T, StorePreparedView, (View*, Camera*), void), AS_CALL_THISCALL);

    // void Renderer::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    // static View* Renderer::GetActualView(View* view)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("View@+ GetActualView(View@+)", AS_FUNCTIONPR(T::GetActualView, (View*), View*), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Renderer
        REGISTER_MEMBERS_MANUAL_PART_Renderer();
    #endif
}

// class Resource | File: ../Resource/Resource.h
template <class T> void RegisterMembers_Resource(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // virtual bool Resource::BeginLoad(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool BeginLoad(Deserializer&)", AS_METHODPR(T, BeginLoad, (Deserializer&), bool), AS_CALL_THISCALL);

    // virtual bool Resource::EndLoad()
    engine->RegisterObjectMethod(className, "bool EndLoad()", AS_METHODPR(T, EndLoad, (), bool), AS_CALL_THISCALL);

    // AsyncLoadState Resource::GetAsyncLoadState() const
    engine->RegisterObjectMethod(className, "AsyncLoadState GetAsyncLoadState() const", AS_METHODPR(T, GetAsyncLoadState, () const, AsyncLoadState), AS_CALL_THISCALL);

    // unsigned Resource::GetMemoryUse() const
    engine->RegisterObjectMethod(className, "uint GetMemoryUse() const", AS_METHODPR(T, GetMemoryUse, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_memoryUse() const", AS_METHODPR(T, GetMemoryUse, () const, unsigned), AS_CALL_THISCALL);

    // const String& Resource::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // StringHash Resource::GetNameHash() const
    engine->RegisterObjectMethod(className, "StringHash GetNameHash() const", AS_METHODPR(T, GetNameHash, () const, StringHash), AS_CALL_THISCALL);

    // unsigned Resource::GetUseTimer()
    engine->RegisterObjectMethod(className, "uint GetUseTimer()", AS_METHODPR(T, GetUseTimer, (), unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_useTimer()", AS_METHODPR(T, GetUseTimer, (), unsigned), AS_CALL_THISCALL);

    // bool Resource::Load(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool Load(Deserializer&)", AS_METHODPR(T, Load, (Deserializer&), bool), AS_CALL_THISCALL);

    // bool Resource::LoadFile(const String& fileName)
    engine->RegisterObjectMethod(className, "bool LoadFile(const String&in)", AS_METHODPR(T, LoadFile, (const String&), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool Load(const String&in)", AS_METHODPR(T, LoadFile, (const String&), bool), AS_CALL_THISCALL);

    // void Resource::ResetUseTimer()
    engine->RegisterObjectMethod(className, "void ResetUseTimer()", AS_METHODPR(T, ResetUseTimer, (), void), AS_CALL_THISCALL);

    // virtual bool Resource::Save(Serializer& dest) const
    engine->RegisterObjectMethod(className, "bool Save(Serializer&) const", AS_METHODPR(T, Save, (Serializer&) const, bool), AS_CALL_THISCALL);

    // virtual bool Resource::SaveFile(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool SaveFile(const String&in) const", AS_METHODPR(T, SaveFile, (const String&) const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool Save(const String&in) const", AS_METHODPR(T, SaveFile, (const String&) const, bool), AS_CALL_THISCALL);

    // void Resource::SetAsyncLoadState(AsyncLoadState newState)
    engine->RegisterObjectMethod(className, "void SetAsyncLoadState(AsyncLoadState)", AS_METHODPR(T, SetAsyncLoadState, (AsyncLoadState), void), AS_CALL_THISCALL);

    // void Resource::SetMemoryUse(unsigned size)
    engine->RegisterObjectMethod(className, "void SetMemoryUse(uint)", AS_METHODPR(T, SetMemoryUse, (unsigned), void), AS_CALL_THISCALL);

    // void Resource::SetName(const String& name)
    engine->RegisterObjectMethod(className, "void SetName(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_name(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Resource
        REGISTER_MEMBERS_MANUAL_PART_Resource();
    #endif
}

// SharedPtr<File> ResourceCache::GetFile(const String& name, bool sendEventOnFailure = true)
template <class T> File* ResourceCache_SharedPtrlesFilegre_GetFile_constspStringamp_bool_template(T* _ptr, const String& name, bool sendEventOnFailure)
{
    SharedPtr<File> result = _ptr->GetFile(name, sendEventOnFailure);
    return result.Detach();
}

// const Vector<SharedPtr<PackageFile>>& ResourceCache::GetPackageFiles() const
template <class T> CScriptArray* ResourceCache_constspVectorlesSharedPtrlesPackageFilegregreamp_GetPackageFiles_void_template(T* _ptr)
{
    const Vector<SharedPtr<PackageFile>>& result = _ptr->GetPackageFiles();
    return VectorToHandleArray(result, "Array<PackageFile@>");
}

// const Vector<String>& ResourceCache::GetResourceDirs() const
template <class T> CScriptArray* ResourceCache_constspVectorlesStringgreamp_GetResourceDirs_void_template(T* _ptr)
{
    const Vector<String>& result = _ptr->GetResourceDirs();
    return VectorToArray<String>(result, "Array<String>");
}

// SharedPtr<Resource> ResourceCache::GetTempResource(StringHash type, const String& name, bool sendEventOnFailure = true)
template <class T> Resource* ResourceCache_SharedPtrlesResourcegre_GetTempResource_StringHash_constspStringamp_bool_template(T* _ptr, StringHash type, const String& name, bool sendEventOnFailure)
{
    SharedPtr<Resource> result = _ptr->GetTempResource(type, name, sendEventOnFailure);
    return result.Detach();
}

// class ResourceCache | File: ../Resource/ResourceCache.h
template <class T> void RegisterMembers_ResourceCache(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void ResourceCache::AddResourceRouter(ResourceRouter* router, bool addAsFirst = false)
    // Error: type "ResourceRouter" can not automatically bind bacause have @nobind mark
    // const HashMap<StringHash, ResourceGroup>& ResourceCache::GetAllResources() const
    // Error: type "const HashMap<StringHash, ResourceGroup>&" can not automatically bind
    // ResourceRouter* ResourceCache::GetResourceRouter(unsigned index) const
    // Error: type "ResourceRouter" can not automatically bind bacause have @nobind mark
    // void ResourceCache::GetResources(PODVector<Resource*>& result, StringHash type) const
    // Error: type "PODVector<Resource*>&" can not automatically bind
    // void ResourceCache::RemoveResourceRouter(ResourceRouter* router)
    // Error: type "ResourceRouter" can not automatically bind bacause have @nobind mark

    // bool ResourceCache::AddManualResource(Resource* resource)
    engine->RegisterObjectMethod(className, "bool AddManualResource(Resource@+)", AS_METHODPR(T, AddManualResource, (Resource*), bool), AS_CALL_THISCALL);

    // bool ResourceCache::AddPackageFile(PackageFile* package, unsigned priority = PRIORITY_LAST)
    engine->RegisterObjectMethod(className, "bool AddPackageFile(PackageFile@+, uint = PRIORITY_LAST)", AS_METHODPR(T, AddPackageFile, (PackageFile*, unsigned), bool), AS_CALL_THISCALL);

    // bool ResourceCache::AddPackageFile(const String& fileName, unsigned priority = PRIORITY_LAST)
    engine->RegisterObjectMethod(className, "bool AddPackageFile(const String&in, uint = PRIORITY_LAST)", AS_METHODPR(T, AddPackageFile, (const String&, unsigned), bool), AS_CALL_THISCALL);

    // bool ResourceCache::AddResourceDir(const String& pathName, unsigned priority = PRIORITY_LAST)
    engine->RegisterObjectMethod(className, "bool AddResourceDir(const String&in, uint = PRIORITY_LAST)", AS_METHODPR(T, AddResourceDir, (const String&, unsigned), bool), AS_CALL_THISCALL);

    // bool ResourceCache::BackgroundLoadResource(StringHash type, const String& name, bool sendEventOnFailure = true, Resource* caller = nullptr)
    engine->RegisterObjectMethod(className, "bool BackgroundLoadResource(StringHash, const String&in, bool = true, Resource@+ = null)", AS_METHODPR(T, BackgroundLoadResource, (StringHash, const String&, bool, Resource*), bool), AS_CALL_THISCALL);

    // bool ResourceCache::Exists(const String& name) const
    engine->RegisterObjectMethod(className, "bool Exists(const String&in) const", AS_METHODPR(T, Exists, (const String&) const, bool), AS_CALL_THISCALL);

    // bool ResourceCache::GetAutoReloadResources() const
    engine->RegisterObjectMethod(className, "bool GetAutoReloadResources() const", AS_METHODPR(T, GetAutoReloadResources, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoReloadResources() const", AS_METHODPR(T, GetAutoReloadResources, () const, bool), AS_CALL_THISCALL);

    // Resource* ResourceCache::GetExistingResource(StringHash type, const String& name)
    engine->RegisterObjectMethod(className, "Resource@+ GetExistingResource(StringHash, const String&in)", AS_METHODPR(T, GetExistingResource, (StringHash, const String&), Resource*), AS_CALL_THISCALL);

    // SharedPtr<File> ResourceCache::GetFile(const String& name, bool sendEventOnFailure = true)
    engine->RegisterObjectMethod(className, "File@+ GetFile(const String&in, bool = true)", AS_FUNCTION_OBJFIRST(ResourceCache_SharedPtrlesFilegre_GetFile_constspStringamp_bool_template<ResourceCache>), AS_CALL_CDECL_OBJFIRST);

    // int ResourceCache::GetFinishBackgroundResourcesMs() const
    engine->RegisterObjectMethod(className, "int GetFinishBackgroundResourcesMs() const", AS_METHODPR(T, GetFinishBackgroundResourcesMs, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_finishBackgroundResourcesMs() const", AS_METHODPR(T, GetFinishBackgroundResourcesMs, () const, int), AS_CALL_THISCALL);

    // unsigned long long ResourceCache::GetMemoryBudget(StringHash type) const
    engine->RegisterObjectMethod(className, "uint64 GetMemoryBudget(StringHash) const", AS_METHODPR(T, GetMemoryBudget, (StringHash) const, unsigned long long), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint64 get_memoryBudget(StringHash) const", AS_METHODPR(T, GetMemoryBudget, (StringHash) const, unsigned long long), AS_CALL_THISCALL);

    // unsigned long long ResourceCache::GetMemoryUse(StringHash type) const
    engine->RegisterObjectMethod(className, "uint64 GetMemoryUse(StringHash) const", AS_METHODPR(T, GetMemoryUse, (StringHash) const, unsigned long long), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint64 get_memoryUse(StringHash) const", AS_METHODPR(T, GetMemoryUse, (StringHash) const, unsigned long long), AS_CALL_THISCALL);

    // unsigned ResourceCache::GetNumBackgroundLoadResources() const
    engine->RegisterObjectMethod(className, "uint GetNumBackgroundLoadResources() const", AS_METHODPR(T, GetNumBackgroundLoadResources, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numBackgroundLoadResources() const", AS_METHODPR(T, GetNumBackgroundLoadResources, () const, unsigned), AS_CALL_THISCALL);

    // const Vector<SharedPtr<PackageFile>>& ResourceCache::GetPackageFiles() const
    engine->RegisterObjectMethod(className, "Array<PackageFile@>@ GetPackageFiles() const", AS_FUNCTION_OBJFIRST(ResourceCache_constspVectorlesSharedPtrlesPackageFilegregreamp_GetPackageFiles_void_template<ResourceCache>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<PackageFile@>@ get_packageFiles() const", AS_FUNCTION_OBJFIRST(ResourceCache_constspVectorlesSharedPtrlesPackageFilegregreamp_GetPackageFiles_void_template<ResourceCache>), AS_CALL_CDECL_OBJFIRST);

    // String ResourceCache::GetPreferredResourceDir(const String& path) const
    engine->RegisterObjectMethod(className, "String GetPreferredResourceDir(const String&in) const", AS_METHODPR(T, GetPreferredResourceDir, (const String&) const, String), AS_CALL_THISCALL);

    // Resource* ResourceCache::GetResource(StringHash type, const String& name, bool sendEventOnFailure = true)
    engine->RegisterObjectMethod(className, "Resource@+ GetResource(StringHash, const String&in, bool = true)", AS_METHODPR(T, GetResource, (StringHash, const String&, bool), Resource*), AS_CALL_THISCALL);

    // const Vector<String>& ResourceCache::GetResourceDirs() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetResourceDirs() const", AS_FUNCTION_OBJFIRST(ResourceCache_constspVectorlesStringgreamp_GetResourceDirs_void_template<ResourceCache>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<String>@ get_resourceDirs() const", AS_FUNCTION_OBJFIRST(ResourceCache_constspVectorlesStringgreamp_GetResourceDirs_void_template<ResourceCache>), AS_CALL_CDECL_OBJFIRST);

    // String ResourceCache::GetResourceFileName(const String& name) const
    engine->RegisterObjectMethod(className, "String GetResourceFileName(const String&in) const", AS_METHODPR(T, GetResourceFileName, (const String&) const, String), AS_CALL_THISCALL);

    // bool ResourceCache::GetReturnFailedResources() const
    engine->RegisterObjectMethod(className, "bool GetReturnFailedResources() const", AS_METHODPR(T, GetReturnFailedResources, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_returnFailedResources() const", AS_METHODPR(T, GetReturnFailedResources, () const, bool), AS_CALL_THISCALL);

    // bool ResourceCache::GetSearchPackagesFirst() const
    engine->RegisterObjectMethod(className, "bool GetSearchPackagesFirst() const", AS_METHODPR(T, GetSearchPackagesFirst, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_searchPackagesFirst() const", AS_METHODPR(T, GetSearchPackagesFirst, () const, bool), AS_CALL_THISCALL);

    // SharedPtr<Resource> ResourceCache::GetTempResource(StringHash type, const String& name, bool sendEventOnFailure = true)
    engine->RegisterObjectMethod(className, "Resource@+ GetTempResource(StringHash, const String&in, bool = true)", AS_FUNCTION_OBJFIRST(ResourceCache_SharedPtrlesResourcegre_GetTempResource_StringHash_constspStringamp_bool_template<ResourceCache>), AS_CALL_CDECL_OBJFIRST);

    // unsigned long long ResourceCache::GetTotalMemoryUse() const
    engine->RegisterObjectMethod(className, "uint64 GetTotalMemoryUse() const", AS_METHODPR(T, GetTotalMemoryUse, () const, unsigned long long), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint64 get_totalMemoryUse() const", AS_METHODPR(T, GetTotalMemoryUse, () const, unsigned long long), AS_CALL_THISCALL);

    // String ResourceCache::PrintMemoryUsage() const
    engine->RegisterObjectMethod(className, "String PrintMemoryUsage() const", AS_METHODPR(T, PrintMemoryUsage, () const, String), AS_CALL_THISCALL);

    // void ResourceCache::ReleaseAllResources(bool force = false)
    engine->RegisterObjectMethod(className, "void ReleaseAllResources(bool = false)", AS_METHODPR(T, ReleaseAllResources, (bool), void), AS_CALL_THISCALL);

    // void ResourceCache::ReleaseResource(StringHash type, const String& name, bool force = false)
    engine->RegisterObjectMethod(className, "void ReleaseResource(StringHash, const String&in, bool = false)", AS_METHODPR(T, ReleaseResource, (StringHash, const String&, bool), void), AS_CALL_THISCALL);

    // void ResourceCache::ReleaseResources(StringHash type, bool force = false)
    engine->RegisterObjectMethod(className, "void ReleaseResources(StringHash, bool = false)", AS_METHODPR(T, ReleaseResources, (StringHash, bool), void), AS_CALL_THISCALL);

    // void ResourceCache::ReleaseResources(StringHash type, const String& partialName, bool force = false)
    engine->RegisterObjectMethod(className, "void ReleaseResources(StringHash, const String&in, bool = false)", AS_METHODPR(T, ReleaseResources, (StringHash, const String&, bool), void), AS_CALL_THISCALL);

    // void ResourceCache::ReleaseResources(const String& partialName, bool force = false)
    engine->RegisterObjectMethod(className, "void ReleaseResources(const String&in, bool = false)", AS_METHODPR(T, ReleaseResources, (const String&, bool), void), AS_CALL_THISCALL);

    // bool ResourceCache::ReloadResource(Resource* resource)
    engine->RegisterObjectMethod(className, "bool ReloadResource(Resource@+)", AS_METHODPR(T, ReloadResource, (Resource*), bool), AS_CALL_THISCALL);

    // void ResourceCache::ReloadResourceWithDependencies(const String& fileName)
    engine->RegisterObjectMethod(className, "void ReloadResourceWithDependencies(const String&in)", AS_METHODPR(T, ReloadResourceWithDependencies, (const String&), void), AS_CALL_THISCALL);

    // void ResourceCache::RemovePackageFile(PackageFile* package, bool releaseResources = true, bool forceRelease = false)
    engine->RegisterObjectMethod(className, "void RemovePackageFile(PackageFile@+, bool = true, bool = false)", AS_METHODPR(T, RemovePackageFile, (PackageFile*, bool, bool), void), AS_CALL_THISCALL);

    // void ResourceCache::RemovePackageFile(const String& fileName, bool releaseResources = true, bool forceRelease = false)
    engine->RegisterObjectMethod(className, "void RemovePackageFile(const String&in, bool = true, bool = false)", AS_METHODPR(T, RemovePackageFile, (const String&, bool, bool), void), AS_CALL_THISCALL);

    // void ResourceCache::RemoveResourceDir(const String& pathName)
    engine->RegisterObjectMethod(className, "void RemoveResourceDir(const String&in)", AS_METHODPR(T, RemoveResourceDir, (const String&), void), AS_CALL_THISCALL);

    // void ResourceCache::ResetDependencies(Resource* resource)
    engine->RegisterObjectMethod(className, "void ResetDependencies(Resource@+)", AS_METHODPR(T, ResetDependencies, (Resource*), void), AS_CALL_THISCALL);

    // String ResourceCache::SanitateResourceDirName(const String& name) const
    engine->RegisterObjectMethod(className, "String SanitateResourceDirName(const String&in) const", AS_METHODPR(T, SanitateResourceDirName, (const String&) const, String), AS_CALL_THISCALL);

    // String ResourceCache::SanitateResourceName(const String& name) const
    engine->RegisterObjectMethod(className, "String SanitateResourceName(const String&in) const", AS_METHODPR(T, SanitateResourceName, (const String&) const, String), AS_CALL_THISCALL);

    // void ResourceCache::SetAutoReloadResources(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoReloadResources(bool)", AS_METHODPR(T, SetAutoReloadResources, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoReloadResources(bool)", AS_METHODPR(T, SetAutoReloadResources, (bool), void), AS_CALL_THISCALL);

    // void ResourceCache::SetFinishBackgroundResourcesMs(int ms)
    engine->RegisterObjectMethod(className, "void SetFinishBackgroundResourcesMs(int)", AS_METHODPR(T, SetFinishBackgroundResourcesMs, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_finishBackgroundResourcesMs(int)", AS_METHODPR(T, SetFinishBackgroundResourcesMs, (int), void), AS_CALL_THISCALL);

    // void ResourceCache::SetMemoryBudget(StringHash type, unsigned long long budget)
    engine->RegisterObjectMethod(className, "void SetMemoryBudget(StringHash, uint64)", AS_METHODPR(T, SetMemoryBudget, (StringHash, unsigned long long), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_memoryBudget(StringHash, uint64)", AS_METHODPR(T, SetMemoryBudget, (StringHash, unsigned long long), void), AS_CALL_THISCALL);

    // void ResourceCache::SetReturnFailedResources(bool enable)
    engine->RegisterObjectMethod(className, "void SetReturnFailedResources(bool)", AS_METHODPR(T, SetReturnFailedResources, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_returnFailedResources(bool)", AS_METHODPR(T, SetReturnFailedResources, (bool), void), AS_CALL_THISCALL);

    // void ResourceCache::SetSearchPackagesFirst(bool value)
    engine->RegisterObjectMethod(className, "void SetSearchPackagesFirst(bool)", AS_METHODPR(T, SetSearchPackagesFirst, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_searchPackagesFirst(bool)", AS_METHODPR(T, SetSearchPackagesFirst, (bool), void), AS_CALL_THISCALL);

    // void ResourceCache::StoreResourceDependency(Resource* resource, const String& dependency)
    engine->RegisterObjectMethod(className, "void StoreResourceDependency(Resource@+, const String&in)", AS_METHODPR(T, StoreResourceDependency, (Resource*, const String&), void), AS_CALL_THISCALL);

    // template <class T> bool ResourceCache::BackgroundLoadResource(const String& name, bool sendEventOnFailure = true, Resource* caller = nullptr)
    // Not registered because template
    // template <class T> T* ResourceCache::GetExistingResource(const String& name)
    // Not registered because template
    // template <class T> T* ResourceCache::GetResource(const String& name, bool sendEventOnFailure = true)
    // Not registered because template
    // template <class T> void ResourceCache::GetResources(PODVector<T*>& result) const
    // Not registered because template
    // template <class T> SharedPtr<T> ResourceCache::GetTempResource(const String& name, bool sendEventOnFailure = true)
    // Not registered because template
    // template <class T> void ResourceCache::ReleaseResource(const String& name, bool force = false)
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ResourceCache
        REGISTER_MEMBERS_MANUAL_PART_ResourceCache();
    #endif
}

// class ResourceRouter | File: ../Resource/ResourceCache.h
template <class T> void RegisterMembers_ResourceRouter(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // virtual void ResourceRouter::Route(String& name, ResourceRequest requestType) = 0
    engine->RegisterObjectMethod(className, "void Route(String&, ResourceRequest)", AS_METHODPR(T, Route, (String&, ResourceRequest), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ResourceRouter
        REGISTER_MEMBERS_MANUAL_PART_ResourceRouter();
    #endif
}

// class Serializable | File: ../Scene/Serializable.h
template <class T> void RegisterMembers_Serializable(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // virtual const Vector<AttributeInfo>* Serializable::GetAttributes() const
    // Error: type "const Vector<AttributeInfo>*" can not automatically bind
    // virtual const Vector<AttributeInfo>* Serializable::GetNetworkAttributes() const
    // Error: type "const Vector<AttributeInfo>*" can not automatically bind
    // NetworkState* Serializable::GetNetworkState() const
    // Error: type "NetworkState*" can not automatically bind

    // void Serializable::AllocateNetworkState()
    engine->RegisterObjectMethod(className, "void AllocateNetworkState()", AS_METHODPR(T, AllocateNetworkState, (), void), AS_CALL_THISCALL);

    // virtual void Serializable::ApplyAttributes()
    engine->RegisterObjectMethod(className, "void ApplyAttributes()", AS_METHODPR(T, ApplyAttributes, (), void), AS_CALL_THISCALL);

    // Variant Serializable::GetAttribute(unsigned index) const
    engine->RegisterObjectMethod(className, "Variant GetAttribute(uint) const", AS_METHODPR(T, GetAttribute, (unsigned) const, Variant), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant get_attributes(uint) const", AS_METHODPR(T, GetAttribute, (unsigned) const, Variant), AS_CALL_THISCALL);

    // Variant Serializable::GetAttribute(const String& name) const
    engine->RegisterObjectMethod(className, "Variant GetAttribute(const String&in) const", AS_METHODPR(T, GetAttribute, (const String&) const, Variant), AS_CALL_THISCALL);

    // Variant Serializable::GetAttributeDefault(unsigned index) const
    engine->RegisterObjectMethod(className, "Variant GetAttributeDefault(uint) const", AS_METHODPR(T, GetAttributeDefault, (unsigned) const, Variant), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Variant get_attributeDefaults(uint) const", AS_METHODPR(T, GetAttributeDefault, (unsigned) const, Variant), AS_CALL_THISCALL);

    // Variant Serializable::GetAttributeDefault(const String& name) const
    engine->RegisterObjectMethod(className, "Variant GetAttributeDefault(const String&in) const", AS_METHODPR(T, GetAttributeDefault, (const String&) const, Variant), AS_CALL_THISCALL);

    // bool Serializable::GetInterceptNetworkUpdate(const String& attributeName) const
    engine->RegisterObjectMethod(className, "bool GetInterceptNetworkUpdate(const String&in) const", AS_METHODPR(T, GetInterceptNetworkUpdate, (const String&) const, bool), AS_CALL_THISCALL);

    // unsigned Serializable::GetNumAttributes() const
    engine->RegisterObjectMethod(className, "uint GetNumAttributes() const", AS_METHODPR(T, GetNumAttributes, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAttributes() const", AS_METHODPR(T, GetNumAttributes, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Serializable::GetNumNetworkAttributes() const
    engine->RegisterObjectMethod(className, "uint GetNumNetworkAttributes() const", AS_METHODPR(T, GetNumNetworkAttributes, () const, unsigned), AS_CALL_THISCALL);

    // bool Serializable::IsTemporary() const
    engine->RegisterObjectMethod(className, "bool IsTemporary() const", AS_METHODPR(T, IsTemporary, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_temporary() const", AS_METHODPR(T, IsTemporary, () const, bool), AS_CALL_THISCALL);

    // virtual bool Serializable::Load(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool Load(Deserializer&)", AS_METHODPR(T, Load, (Deserializer&), bool), AS_CALL_THISCALL);

    // virtual bool Serializable::LoadJSON(const JSONValue& source)
    engine->RegisterObjectMethod(className, "bool LoadJSON(const JSONValue&in)", AS_METHODPR(T, LoadJSON, (const JSONValue&), bool), AS_CALL_THISCALL);

    // virtual bool Serializable::LoadXML(const XMLElement& source)
    engine->RegisterObjectMethod(className, "bool LoadXML(const XMLElement&in)", AS_METHODPR(T, LoadXML, (const XMLElement&), bool), AS_CALL_THISCALL);

    // virtual void Serializable::MarkNetworkUpdate()
    engine->RegisterObjectMethod(className, "void MarkNetworkUpdate()", AS_METHODPR(T, MarkNetworkUpdate, (), void), AS_CALL_THISCALL);

    // virtual void Serializable::OnGetAttribute(const AttributeInfo& attr, Variant& dest) const
    engine->RegisterObjectMethod(className, "void OnGetAttribute(const AttributeInfo&in, Variant&) const", AS_METHODPR(T, OnGetAttribute, (const AttributeInfo&, Variant&) const, void), AS_CALL_THISCALL);

    // virtual void Serializable::OnSetAttribute(const AttributeInfo& attr, const Variant& src)
    engine->RegisterObjectMethod(className, "void OnSetAttribute(const AttributeInfo&in, const Variant&in)", AS_METHODPR(T, OnSetAttribute, (const AttributeInfo&, const Variant&), void), AS_CALL_THISCALL);

    // bool Serializable::ReadDeltaUpdate(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool ReadDeltaUpdate(Deserializer&)", AS_METHODPR(T, ReadDeltaUpdate, (Deserializer&), bool), AS_CALL_THISCALL);

    // bool Serializable::ReadLatestDataUpdate(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool ReadLatestDataUpdate(Deserializer&)", AS_METHODPR(T, ReadLatestDataUpdate, (Deserializer&), bool), AS_CALL_THISCALL);

    // void Serializable::RemoveInstanceDefault()
    engine->RegisterObjectMethod(className, "void RemoveInstanceDefault()", AS_METHODPR(T, RemoveInstanceDefault, (), void), AS_CALL_THISCALL);

    // void Serializable::ResetToDefault()
    engine->RegisterObjectMethod(className, "void ResetToDefault()", AS_METHODPR(T, ResetToDefault, (), void), AS_CALL_THISCALL);

    // virtual bool Serializable::Save(Serializer& dest) const
    engine->RegisterObjectMethod(className, "bool Save(Serializer&) const", AS_METHODPR(T, Save, (Serializer&) const, bool), AS_CALL_THISCALL);

    // virtual bool Serializable::SaveDefaultAttributes() const
    engine->RegisterObjectMethod(className, "bool SaveDefaultAttributes() const", AS_METHODPR(T, SaveDefaultAttributes, () const, bool), AS_CALL_THISCALL);

    // virtual bool Serializable::SaveJSON(JSONValue& dest) const
    engine->RegisterObjectMethod(className, "bool SaveJSON(JSONValue&) const", AS_METHODPR(T, SaveJSON, (JSONValue&) const, bool), AS_CALL_THISCALL);

    // virtual bool Serializable::SaveXML(XMLElement& dest) const
    engine->RegisterObjectMethod(className, "bool SaveXML(XMLElement&) const", AS_METHODPR(T, SaveXML, (XMLElement&) const, bool), AS_CALL_THISCALL);

    // bool Serializable::SetAttribute(unsigned index, const Variant& value)
    engine->RegisterObjectMethod(className, "bool SetAttribute(uint, const Variant&in)", AS_METHODPR(T, SetAttribute, (unsigned, const Variant&), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_attributes(uint, const Variant&in)", AS_METHODPR(T, SetAttribute, (unsigned, const Variant&), bool), AS_CALL_THISCALL);

    // bool Serializable::SetAttribute(const String& name, const Variant& value)
    engine->RegisterObjectMethod(className, "bool SetAttribute(const String&in, const Variant&in)", AS_METHODPR(T, SetAttribute, (const String&, const Variant&), bool), AS_CALL_THISCALL);

    // void Serializable::SetInstanceDefault(bool enable)
    engine->RegisterObjectMethod(className, "void SetInstanceDefault(bool)", AS_METHODPR(T, SetInstanceDefault, (bool), void), AS_CALL_THISCALL);

    // void Serializable::SetInterceptNetworkUpdate(const String& attributeName, bool enable)
    engine->RegisterObjectMethod(className, "void SetInterceptNetworkUpdate(const String&in, bool)", AS_METHODPR(T, SetInterceptNetworkUpdate, (const String&, bool), void), AS_CALL_THISCALL);

    // void Serializable::SetTemporary(bool enable)
    engine->RegisterObjectMethod(className, "void SetTemporary(bool)", AS_METHODPR(T, SetTemporary, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_temporary(bool)", AS_METHODPR(T, SetTemporary, (bool), void), AS_CALL_THISCALL);

    // void Serializable::WriteDeltaUpdate(Serializer& dest, const DirtyBits& attributeBits, unsigned char timeStamp)
    engine->RegisterObjectMethod(className, "void WriteDeltaUpdate(Serializer&, const DirtyBits&in, uint8)", AS_METHODPR(T, WriteDeltaUpdate, (Serializer&, const DirtyBits&, unsigned char), void), AS_CALL_THISCALL);

    // void Serializable::WriteInitialDeltaUpdate(Serializer& dest, unsigned char timeStamp)
    engine->RegisterObjectMethod(className, "void WriteInitialDeltaUpdate(Serializer&, uint8)", AS_METHODPR(T, WriteInitialDeltaUpdate, (Serializer&, unsigned char), void), AS_CALL_THISCALL);

    // void Serializable::WriteLatestDataUpdate(Serializer& dest, unsigned char timeStamp)
    engine->RegisterObjectMethod(className, "void WriteLatestDataUpdate(Serializer&, uint8)", AS_METHODPR(T, WriteLatestDataUpdate, (Serializer&, unsigned char), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Serializable
        REGISTER_MEMBERS_MANUAL_PART_Serializable();
    #endif
}

// class ShaderParameterAnimationInfo | File: ../Graphics/Material.h
template <class T> void RegisterMembers_ShaderParameterAnimationInfo(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ValueAnimationInfo<T>(engine, className);

    // const String& ShaderParameterAnimationInfo::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ShaderParameterAnimationInfo
        REGISTER_MEMBERS_MANUAL_PART_ShaderParameterAnimationInfo();
    #endif
}

// class ShaderPrecache | File: ../Graphics/ShaderPrecache.h
template <class T> void RegisterMembers_ShaderPrecache(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void ShaderPrecache::StoreShaders(ShaderVariation* vs, ShaderVariation* ps)
    engine->RegisterObjectMethod(className, "void StoreShaders(ShaderVariation@+, ShaderVariation@+)", AS_METHODPR(T, StoreShaders, (ShaderVariation*, ShaderVariation*), void), AS_CALL_THISCALL);

    // static void ShaderPrecache::LoadShaders(Graphics* graphics, Deserializer& source)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("void LoadShaders(Graphics@+, Deserializer&)", AS_FUNCTIONPR(T::LoadShaders, (Graphics*, Deserializer&), void), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ShaderPrecache
        REGISTER_MEMBERS_MANUAL_PART_ShaderPrecache();
    #endif
}

// class Time | File: ../Core/Timer.h
template <class T> void RegisterMembers_Time(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Time::BeginFrame(float timeStep)
    engine->RegisterObjectMethod(className, "void BeginFrame(float)", AS_METHODPR(T, BeginFrame, (float), void), AS_CALL_THISCALL);

    // void Time::EndFrame()
    engine->RegisterObjectMethod(className, "void EndFrame()", AS_METHODPR(T, EndFrame, (), void), AS_CALL_THISCALL);

    // float Time::GetElapsedTime()
    engine->RegisterObjectMethod(className, "float GetElapsedTime()", AS_METHODPR(T, GetElapsedTime, (), float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_elapsedTime()", AS_METHODPR(T, GetElapsedTime, (), float), AS_CALL_THISCALL);

    // unsigned Time::GetFrameNumber() const
    engine->RegisterObjectMethod(className, "uint GetFrameNumber() const", AS_METHODPR(T, GetFrameNumber, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_frameNumber() const", AS_METHODPR(T, GetFrameNumber, () const, unsigned), AS_CALL_THISCALL);

    // float Time::GetFramesPerSecond() const
    engine->RegisterObjectMethod(className, "float GetFramesPerSecond() const", AS_METHODPR(T, GetFramesPerSecond, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_framesPerSecond() const", AS_METHODPR(T, GetFramesPerSecond, () const, float), AS_CALL_THISCALL);

    // unsigned Time::GetTimerPeriod() const
    engine->RegisterObjectMethod(className, "uint GetTimerPeriod() const", AS_METHODPR(T, GetTimerPeriod, () const, unsigned), AS_CALL_THISCALL);

    // float Time::GetTimeStep() const
    engine->RegisterObjectMethod(className, "float GetTimeStep() const", AS_METHODPR(T, GetTimeStep, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_timeStep() const", AS_METHODPR(T, GetTimeStep, () const, float), AS_CALL_THISCALL);

    // void Time::SetTimerPeriod(unsigned mSec)
    engine->RegisterObjectMethod(className, "void SetTimerPeriod(uint)", AS_METHODPR(T, SetTimerPeriod, (unsigned), void), AS_CALL_THISCALL);

    // static unsigned Time::GetSystemTime()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetSystemTime()", AS_FUNCTIONPR(T::GetSystemTime, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Time::GetTimeSinceEpoch()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetTimeSinceEpoch()", AS_FUNCTIONPR(T::GetTimeSinceEpoch, (), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static String Time::GetTimeStamp()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("String GetTimeStamp()", AS_FUNCTIONPR(T::GetTimeStamp, (), String), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static void Time::Sleep(unsigned mSec)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("void Sleep(uint)", AS_FUNCTIONPR(T::Sleep, (unsigned), void), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Time
        REGISTER_MEMBERS_MANUAL_PART_Time();
    #endif
}

// SharedPtr<UIElement> UI::LoadLayout(Deserializer& source, XMLFile* styleFile = nullptr)
template <class T> UIElement* UI_SharedPtrlesUIElementgre_LoadLayout_Deserializeramp_XMLFilestar_template(T* _ptr, Deserializer& source, XMLFile* styleFile)
{
    SharedPtr<UIElement> result = _ptr->LoadLayout(source, styleFile);
    return result.Detach();
}

// SharedPtr<UIElement> UI::LoadLayout(XMLFile* file, XMLFile* styleFile = nullptr)
template <class T> UIElement* UI_SharedPtrlesUIElementgre_LoadLayout_XMLFilestar_XMLFilestar_template(T* _ptr, XMLFile* file, XMLFile* styleFile)
{
    SharedPtr<UIElement> result = _ptr->LoadLayout(file, styleFile);
    return result.Detach();
}

// class UI | File: ../UI/UI.h
template <class T> void RegisterMembers_UI(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // const Vector<UIElement*> UI::GetDragElements()
    // Error: type "const Vector<UIElement*>" can not automatically bind

    // void UI::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // IntVector2 UI::ConvertSystemToUI(const IntVector2& systemPos) const
    engine->RegisterObjectMethod(className, "IntVector2 ConvertSystemToUI(const IntVector2&in) const", AS_METHODPR(T, ConvertSystemToUI, (const IntVector2&) const, IntVector2), AS_CALL_THISCALL);

    // IntVector2 UI::ConvertUIToSystem(const IntVector2& uiPos) const
    engine->RegisterObjectMethod(className, "IntVector2 ConvertUIToSystem(const IntVector2&in) const", AS_METHODPR(T, ConvertUIToSystem, (const IntVector2&) const, IntVector2), AS_CALL_THISCALL);

    // void UI::DebugDraw(UIElement* element)
    engine->RegisterObjectMethod(className, "void DebugDraw(UIElement@+)", AS_METHODPR(T, DebugDraw, (UIElement*), void), AS_CALL_THISCALL);

    // const String& UI::GetClipboardText() const
    engine->RegisterObjectMethod(className, "const String& GetClipboardText() const", AS_METHODPR(T, GetClipboardText, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_clipboardText() const", AS_METHODPR(T, GetClipboardText, () const, const String&), AS_CALL_THISCALL);

    // Cursor* UI::GetCursor() const
    engine->RegisterObjectMethod(className, "Cursor@+ GetCursor() const", AS_METHODPR(T, GetCursor, () const, Cursor*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Cursor@+ get_cursor() const", AS_METHODPR(T, GetCursor, () const, Cursor*), AS_CALL_THISCALL);

    // IntVector2 UI::GetCursorPosition() const
    engine->RegisterObjectMethod(className, "IntVector2 GetCursorPosition() const", AS_METHODPR(T, GetCursorPosition, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_cursorPosition() const", AS_METHODPR(T, GetCursorPosition, () const, IntVector2), AS_CALL_THISCALL);

    // const IntVector2& UI::GetCustomSize() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetCustomSize() const", AS_METHODPR(T, GetCustomSize, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_customSize() const", AS_METHODPR(T, GetCustomSize, () const, const IntVector2&), AS_CALL_THISCALL);

    // float UI::GetDefaultToolTipDelay() const
    engine->RegisterObjectMethod(className, "float GetDefaultToolTipDelay() const", AS_METHODPR(T, GetDefaultToolTipDelay, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_defaultToolTipDelay() const", AS_METHODPR(T, GetDefaultToolTipDelay, () const, float), AS_CALL_THISCALL);

    // float UI::GetDoubleClickInterval() const
    engine->RegisterObjectMethod(className, "float GetDoubleClickInterval() const", AS_METHODPR(T, GetDoubleClickInterval, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_doubleClickInterval() const", AS_METHODPR(T, GetDoubleClickInterval, () const, float), AS_CALL_THISCALL);

    // int UI::GetDragBeginDistance() const
    engine->RegisterObjectMethod(className, "int GetDragBeginDistance() const", AS_METHODPR(T, GetDragBeginDistance, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_dragBeginDistance() const", AS_METHODPR(T, GetDragBeginDistance, () const, int), AS_CALL_THISCALL);

    // float UI::GetDragBeginInterval() const
    engine->RegisterObjectMethod(className, "float GetDragBeginInterval() const", AS_METHODPR(T, GetDragBeginInterval, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_dragBeginInterval() const", AS_METHODPR(T, GetDragBeginInterval, () const, float), AS_CALL_THISCALL);

    // UIElement* UI::GetDragElement(unsigned index)
    engine->RegisterObjectMethod(className, "UIElement@+ GetDragElement(uint)", AS_METHODPR(T, GetDragElement, (unsigned), UIElement*), AS_CALL_THISCALL);

    // UIElement* UI::GetElementAt(const IntVector2& position, bool enabledOnly = true)
    engine->RegisterObjectMethod(className, "UIElement@+ GetElementAt(const IntVector2&in, bool = true)", AS_METHODPR(T, GetElementAt, (const IntVector2&, bool), UIElement*), AS_CALL_THISCALL);

    // UIElement* UI::GetElementAt(int x, int y, bool enabledOnly = true)
    engine->RegisterObjectMethod(className, "UIElement@+ GetElementAt(int, int, bool = true)", AS_METHODPR(T, GetElementAt, (int, int, bool), UIElement*), AS_CALL_THISCALL);

    // UIElement* UI::GetElementAt(UIElement* root, const IntVector2& position, bool enabledOnly = true)
    engine->RegisterObjectMethod(className, "UIElement@+ GetElementAt(UIElement@+, const IntVector2&in, bool = true)", AS_METHODPR(T, GetElementAt, (UIElement*, const IntVector2&, bool), UIElement*), AS_CALL_THISCALL);

    // UIElement* UI::GetFocusElement() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetFocusElement() const", AS_METHODPR(T, GetFocusElement, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_focusElement() const", AS_METHODPR(T, GetFocusElement, () const, UIElement*), AS_CALL_THISCALL);

    // FontHintLevel UI::GetFontHintLevel() const
    engine->RegisterObjectMethod(className, "FontHintLevel GetFontHintLevel() const", AS_METHODPR(T, GetFontHintLevel, () const, FontHintLevel), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FontHintLevel get_fontHintLevel() const", AS_METHODPR(T, GetFontHintLevel, () const, FontHintLevel), AS_CALL_THISCALL);

    // int UI::GetFontOversampling() const
    engine->RegisterObjectMethod(className, "int GetFontOversampling() const", AS_METHODPR(T, GetFontOversampling, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_fontOversampling() const", AS_METHODPR(T, GetFontOversampling, () const, int), AS_CALL_THISCALL);

    // float UI::GetFontSubpixelThreshold() const
    engine->RegisterObjectMethod(className, "float GetFontSubpixelThreshold() const", AS_METHODPR(T, GetFontSubpixelThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fontSubpixelThreshold() const", AS_METHODPR(T, GetFontSubpixelThreshold, () const, float), AS_CALL_THISCALL);

    // bool UI::GetForceAutoHint() const
    engine->RegisterObjectMethod(className, "bool GetForceAutoHint() const", AS_METHODPR(T, GetForceAutoHint, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_forceAutoHint() const", AS_METHODPR(T, GetForceAutoHint, () const, bool), AS_CALL_THISCALL);

    // UIElement* UI::GetFrontElement() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetFrontElement() const", AS_METHODPR(T, GetFrontElement, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_frontElement() const", AS_METHODPR(T, GetFrontElement, () const, UIElement*), AS_CALL_THISCALL);

    // float UI::GetMaxDoubleClickDistance() const
    engine->RegisterObjectMethod(className, "float GetMaxDoubleClickDistance() const", AS_METHODPR(T, GetMaxDoubleClickDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxDoubleClickDistance() const", AS_METHODPR(T, GetMaxDoubleClickDistance, () const, float), AS_CALL_THISCALL);

    // int UI::GetMaxFontTextureSize() const
    engine->RegisterObjectMethod(className, "int GetMaxFontTextureSize() const", AS_METHODPR(T, GetMaxFontTextureSize, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxFontTextureSize() const", AS_METHODPR(T, GetMaxFontTextureSize, () const, int), AS_CALL_THISCALL);

    // unsigned UI::GetNumDragElements() const
    engine->RegisterObjectMethod(className, "uint GetNumDragElements() const", AS_METHODPR(T, GetNumDragElements, () const, unsigned), AS_CALL_THISCALL);

    // UIElement* UI::GetRoot() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetRoot() const", AS_METHODPR(T, GetRoot, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_root() const", AS_METHODPR(T, GetRoot, () const, UIElement*), AS_CALL_THISCALL);

    // UIElement* UI::GetRootModalElement() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetRootModalElement() const", AS_METHODPR(T, GetRootModalElement, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_modalRoot() const", AS_METHODPR(T, GetRootModalElement, () const, UIElement*), AS_CALL_THISCALL);

    // float UI::GetScale() const
    engine->RegisterObjectMethod(className, "float GetScale() const", AS_METHODPR(T, GetScale, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_scale() const", AS_METHODPR(T, GetScale, () const, float), AS_CALL_THISCALL);

    // bool UI::GetUseMutableGlyphs() const
    engine->RegisterObjectMethod(className, "bool GetUseMutableGlyphs() const", AS_METHODPR(T, GetUseMutableGlyphs, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useMutableGlyphs() const", AS_METHODPR(T, GetUseMutableGlyphs, () const, bool), AS_CALL_THISCALL);

    // bool UI::GetUseScreenKeyboard() const
    engine->RegisterObjectMethod(className, "bool GetUseScreenKeyboard() const", AS_METHODPR(T, GetUseScreenKeyboard, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useScreenKeyboard() const", AS_METHODPR(T, GetUseScreenKeyboard, () const, bool), AS_CALL_THISCALL);

    // bool UI::GetUseSystemClipboard() const
    engine->RegisterObjectMethod(className, "bool GetUseSystemClipboard() const", AS_METHODPR(T, GetUseSystemClipboard, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useSystemClipboard() const", AS_METHODPR(T, GetUseSystemClipboard, () const, bool), AS_CALL_THISCALL);

    // bool UI::HasModalElement() const
    engine->RegisterObjectMethod(className, "bool HasModalElement() const", AS_METHODPR(T, HasModalElement, () const, bool), AS_CALL_THISCALL);

    // bool UI::IsDragging() const
    engine->RegisterObjectMethod(className, "bool IsDragging() const", AS_METHODPR(T, IsDragging, () const, bool), AS_CALL_THISCALL);

    // bool UI::IsNonFocusedMouseWheel() const
    engine->RegisterObjectMethod(className, "bool IsNonFocusedMouseWheel() const", AS_METHODPR(T, IsNonFocusedMouseWheel, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_nonFocusedMouseWheel() const", AS_METHODPR(T, IsNonFocusedMouseWheel, () const, bool), AS_CALL_THISCALL);

    // SharedPtr<UIElement> UI::LoadLayout(Deserializer& source, XMLFile* styleFile = nullptr)
    engine->RegisterObjectMethod(className, "UIElement@+ LoadLayout(Deserializer&, XMLFile@+ = null)", AS_FUNCTION_OBJFIRST(UI_SharedPtrlesUIElementgre_LoadLayout_Deserializeramp_XMLFilestar_template<UI>), AS_CALL_CDECL_OBJFIRST);

    // SharedPtr<UIElement> UI::LoadLayout(XMLFile* file, XMLFile* styleFile = nullptr)
    engine->RegisterObjectMethod(className, "UIElement@+ LoadLayout(XMLFile@+, XMLFile@+ = null)", AS_FUNCTION_OBJFIRST(UI_SharedPtrlesUIElementgre_LoadLayout_XMLFilestar_XMLFilestar_template<UI>), AS_CALL_CDECL_OBJFIRST);

    // void UI::Render(bool renderUICommand = false)
    engine->RegisterObjectMethod(className, "void Render(bool = false)", AS_METHODPR(T, Render, (bool), void), AS_CALL_THISCALL);

    // void UI::RenderUpdate()
    engine->RegisterObjectMethod(className, "void RenderUpdate()", AS_METHODPR(T, RenderUpdate, (), void), AS_CALL_THISCALL);

    // bool UI::SaveLayout(Serializer& dest, UIElement* element)
    engine->RegisterObjectMethod(className, "bool SaveLayout(Serializer&, UIElement@+)", AS_METHODPR(T, SaveLayout, (Serializer&, UIElement*), bool), AS_CALL_THISCALL);

    // void UI::SetClipboardText(const String& text)
    engine->RegisterObjectMethod(className, "void SetClipboardText(const String&in)", AS_METHODPR(T, SetClipboardText, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clipboardText(const String&in)", AS_METHODPR(T, SetClipboardText, (const String&), void), AS_CALL_THISCALL);

    // void UI::SetCursor(Cursor* cursor)
    engine->RegisterObjectMethod(className, "void SetCursor(Cursor@+)", AS_METHODPR(T, SetCursor, (Cursor*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cursor(Cursor@+)", AS_METHODPR(T, SetCursor, (Cursor*), void), AS_CALL_THISCALL);

    // void UI::SetCustomSize(const IntVector2& size)
    engine->RegisterObjectMethod(className, "void SetCustomSize(const IntVector2&in)", AS_METHODPR(T, SetCustomSize, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_customSize(const IntVector2&in)", AS_METHODPR(T, SetCustomSize, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UI::SetCustomSize(int width, int height)
    engine->RegisterObjectMethod(className, "void SetCustomSize(int, int)", AS_METHODPR(T, SetCustomSize, (int, int), void), AS_CALL_THISCALL);

    // void UI::SetDefaultToolTipDelay(float delay)
    engine->RegisterObjectMethod(className, "void SetDefaultToolTipDelay(float)", AS_METHODPR(T, SetDefaultToolTipDelay, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultToolTipDelay(float)", AS_METHODPR(T, SetDefaultToolTipDelay, (float), void), AS_CALL_THISCALL);

    // void UI::SetDoubleClickInterval(float interval)
    engine->RegisterObjectMethod(className, "void SetDoubleClickInterval(float)", AS_METHODPR(T, SetDoubleClickInterval, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_doubleClickInterval(float)", AS_METHODPR(T, SetDoubleClickInterval, (float), void), AS_CALL_THISCALL);

    // void UI::SetDragBeginDistance(int pixels)
    engine->RegisterObjectMethod(className, "void SetDragBeginDistance(int)", AS_METHODPR(T, SetDragBeginDistance, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dragBeginDistance(int)", AS_METHODPR(T, SetDragBeginDistance, (int), void), AS_CALL_THISCALL);

    // void UI::SetDragBeginInterval(float interval)
    engine->RegisterObjectMethod(className, "void SetDragBeginInterval(float)", AS_METHODPR(T, SetDragBeginInterval, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dragBeginInterval(float)", AS_METHODPR(T, SetDragBeginInterval, (float), void), AS_CALL_THISCALL);

    // void UI::SetElementRenderTexture(UIElement* element, Texture2D* texture)
    engine->RegisterObjectMethod(className, "void SetElementRenderTexture(UIElement@+, Texture2D@+)", AS_METHODPR(T, SetElementRenderTexture, (UIElement*, Texture2D*), void), AS_CALL_THISCALL);

    // void UI::SetFocusElement(UIElement* element, bool byKey = false)
    engine->RegisterObjectMethod(className, "void SetFocusElement(UIElement@+, bool = false)", AS_METHODPR(T, SetFocusElement, (UIElement*, bool), void), AS_CALL_THISCALL);

    // void UI::SetFontHintLevel(FontHintLevel level)
    engine->RegisterObjectMethod(className, "void SetFontHintLevel(FontHintLevel)", AS_METHODPR(T, SetFontHintLevel, (FontHintLevel), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fontHintLevel(FontHintLevel)", AS_METHODPR(T, SetFontHintLevel, (FontHintLevel), void), AS_CALL_THISCALL);

    // void UI::SetFontOversampling(int oversampling)
    engine->RegisterObjectMethod(className, "void SetFontOversampling(int)", AS_METHODPR(T, SetFontOversampling, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fontOversampling(int)", AS_METHODPR(T, SetFontOversampling, (int), void), AS_CALL_THISCALL);

    // void UI::SetFontSubpixelThreshold(float threshold)
    engine->RegisterObjectMethod(className, "void SetFontSubpixelThreshold(float)", AS_METHODPR(T, SetFontSubpixelThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fontSubpixelThreshold(float)", AS_METHODPR(T, SetFontSubpixelThreshold, (float), void), AS_CALL_THISCALL);

    // void UI::SetForceAutoHint(bool enable)
    engine->RegisterObjectMethod(className, "void SetForceAutoHint(bool)", AS_METHODPR(T, SetForceAutoHint, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_forceAutoHint(bool)", AS_METHODPR(T, SetForceAutoHint, (bool), void), AS_CALL_THISCALL);

    // void UI::SetHeight(float height)
    engine->RegisterObjectMethod(className, "void SetHeight(float)", AS_METHODPR(T, SetHeight, (float), void), AS_CALL_THISCALL);

    // void UI::SetMaxDoubleClickDistance(float distPixels)
    engine->RegisterObjectMethod(className, "void SetMaxDoubleClickDistance(float)", AS_METHODPR(T, SetMaxDoubleClickDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxDoubleClickDistance(float)", AS_METHODPR(T, SetMaxDoubleClickDistance, (float), void), AS_CALL_THISCALL);

    // void UI::SetMaxFontTextureSize(int size)
    engine->RegisterObjectMethod(className, "void SetMaxFontTextureSize(int)", AS_METHODPR(T, SetMaxFontTextureSize, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxFontTextureSize(int)", AS_METHODPR(T, SetMaxFontTextureSize, (int), void), AS_CALL_THISCALL);

    // bool UI::SetModalElement(UIElement* modalElement, bool enable)
    engine->RegisterObjectMethod(className, "bool SetModalElement(UIElement@+, bool)", AS_METHODPR(T, SetModalElement, (UIElement*, bool), bool), AS_CALL_THISCALL);

    // void UI::SetNonFocusedMouseWheel(bool nonFocusedMouseWheel)
    engine->RegisterObjectMethod(className, "void SetNonFocusedMouseWheel(bool)", AS_METHODPR(T, SetNonFocusedMouseWheel, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_nonFocusedMouseWheel(bool)", AS_METHODPR(T, SetNonFocusedMouseWheel, (bool), void), AS_CALL_THISCALL);

    // void UI::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // void UI::SetUseMutableGlyphs(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseMutableGlyphs(bool)", AS_METHODPR(T, SetUseMutableGlyphs, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useMutableGlyphs(bool)", AS_METHODPR(T, SetUseMutableGlyphs, (bool), void), AS_CALL_THISCALL);

    // void UI::SetUseScreenKeyboard(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseScreenKeyboard(bool)", AS_METHODPR(T, SetUseScreenKeyboard, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useScreenKeyboard(bool)", AS_METHODPR(T, SetUseScreenKeyboard, (bool), void), AS_CALL_THISCALL);

    // void UI::SetUseSystemClipboard(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseSystemClipboard(bool)", AS_METHODPR(T, SetUseSystemClipboard, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useSystemClipboard(bool)", AS_METHODPR(T, SetUseSystemClipboard, (bool), void), AS_CALL_THISCALL);

    // void UI::SetWidth(float width)
    engine->RegisterObjectMethod(className, "void SetWidth(float)", AS_METHODPR(T, SetWidth, (float), void), AS_CALL_THISCALL);

    // void UI::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_UI
        REGISTER_MEMBERS_MANUAL_PART_UI();
    #endif
}

// class VectorBuffer | File: ../IO/VectorBuffer.h
template <class T> void RegisterMembers_VectorBuffer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_AbstractFile<T>(engine, className);

    // const PODVector<unsigned char>& VectorBuffer::GetBuffer() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // const unsigned char* VectorBuffer::GetData() const
    // Error: type "const unsigned char*" can not automatically bind
    // unsigned char* VectorBuffer::GetModifiableData()
    // Error: type "unsigned char*" can not automatically bind
    // void VectorBuffer::SetData(const PODVector<unsigned char>& data)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void VectorBuffer::SetData(const void* data, unsigned size)
    // Error: type "const void*" can not automatically bind

    // void VectorBuffer::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void VectorBuffer::Resize(unsigned size)
    engine->RegisterObjectMethod(className, "void Resize(uint)", AS_METHODPR(T, Resize, (unsigned), void), AS_CALL_THISCALL);

    // void VectorBuffer::SetData(Deserializer& source, unsigned size)
    engine->RegisterObjectMethod(className, "void SetData(Deserializer&, uint)", AS_METHODPR(T, SetData, (Deserializer&, unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VectorBuffer
        REGISTER_MEMBERS_MANUAL_PART_VectorBuffer();
    #endif
}

// const PODVector<VertexElement>& VertexBuffer::GetElements() const
template <class T> CScriptArray* VertexBuffer_constspPODVectorlesVertexElementgreamp_GetElements_void_template(T* _ptr)
{
    const PODVector<VertexElement>& result = _ptr->GetElements();
    return VectorToArray(result, "Array<VertexElement>");
}

// bool VertexBuffer::SetSize(unsigned vertexCount, const PODVector<VertexElement>& elements, bool dynamic = false)
template <class T> bool VertexBuffer_bool_SetSize_unsigned_constspPODVectorlesVertexElementgreamp_bool_template(T* _ptr, unsigned vertexCount, CScriptArray* elements_conv, bool dynamic)
{
    PODVector<VertexElement> elements = ArrayToPODVector<VertexElement>(elements_conv);
    bool result = _ptr->SetSize(vertexCount, elements, dynamic);
    return result;
}

// static bool VertexBuffer::HasElement(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0)
template <class T> bool VertexBuffer_bool_HasElement_constspPODVectorlesVertexElementgreamp_VertexElementType_VertexElementSemantic_unsignedspchar(CScriptArray* elements_conv, VertexElementType type, VertexElementSemantic semantic, unsigned char index)
{
    PODVector<VertexElement> elements = ArrayToPODVector<VertexElement>(elements_conv);
    bool result = T::HasElement(elements, type, semantic, index);
    return result;
}

// static unsigned VertexBuffer::GetElementOffset(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0)
template <class T> unsigned VertexBuffer_unsigned_GetElementOffset_constspPODVectorlesVertexElementgreamp_VertexElementType_VertexElementSemantic_unsignedspchar(CScriptArray* elements_conv, VertexElementType type, VertexElementSemantic semantic, unsigned char index)
{
    PODVector<VertexElement> elements = ArrayToPODVector<VertexElement>(elements_conv);
    unsigned result = T::GetElementOffset(elements, type, semantic, index);
    return result;
}

// static PODVector<VertexElement> VertexBuffer::GetElements(unsigned elementMask)
template <class T> CScriptArray* VertexBuffer_PODVectorlesVertexElementgre_GetElements_unsigned(unsigned elementMask)
{
    PODVector<VertexElement> result = T::GetElements(elementMask);
    return VectorToArray(result, "Array<VertexElement>");
}

// static unsigned VertexBuffer::GetVertexSize(const PODVector<VertexElement>& elements)
template <class T> unsigned VertexBuffer_unsigned_GetVertexSize_constspPODVectorlesVertexElementgreamp(CScriptArray* elements_conv)
{
    PODVector<VertexElement> elements = ArrayToPODVector<VertexElement>(elements_conv);
    unsigned result = T::GetVertexSize(elements);
    return result;
}

// class VertexBuffer | File: ../Graphics/VertexBuffer.h
template <class T> void RegisterMembers_VertexBuffer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);
    RegisterMembers_GPUObject<T>(engine, className);

    // const VertexElement* VertexBuffer::GetElement(VertexElementSemantic semantic, unsigned char index = 0) const
    // Error: type "const VertexElement*" can not automatically bind
    // const VertexElement* VertexBuffer::GetElement(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0) const
    // Error: type "const VertexElement*" can not automatically bind
    // unsigned char* VertexBuffer::GetShadowData() const
    // Error: type "unsigned char*" can not automatically bind
    // SharedArrayPtr<unsigned char> VertexBuffer::GetShadowDataShared() const
    // Error: type "SharedArrayPtr<unsigned char>" can not automatically bind
    // void* VertexBuffer::Lock(unsigned start, unsigned count, bool discard = false)
    // Error: type "void*" can not automatically bind
    // bool VertexBuffer::SetData(const void* data)
    // Error: type "const void*" can not automatically bind
    // bool VertexBuffer::SetDataRange(const void* data, unsigned start, unsigned count, bool discard = false)
    // Error: type "const void*" can not automatically bind

    // unsigned long long VertexBuffer::GetBufferHash(unsigned streamIndex)
    engine->RegisterObjectMethod(className, "uint64 GetBufferHash(uint)", AS_METHODPR(T, GetBufferHash, (unsigned), unsigned long long), AS_CALL_THISCALL);

    // VertexMaskFlags VertexBuffer::GetElementMask() const
    engine->RegisterObjectMethod(className, "VertexMaskFlags GetElementMask() const", AS_METHODPR(T, GetElementMask, () const, VertexMaskFlags), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "VertexMaskFlags get_elementMask() const", AS_METHODPR(T, GetElementMask, () const, VertexMaskFlags), AS_CALL_THISCALL);

    // unsigned VertexBuffer::GetElementOffset(VertexElementSemantic semantic, unsigned char index = 0) const
    engine->RegisterObjectMethod(className, "uint GetElementOffset(VertexElementSemantic, uint8 = 0) const", AS_METHODPR(T, GetElementOffset, (VertexElementSemantic, unsigned char) const, unsigned), AS_CALL_THISCALL);

    // unsigned VertexBuffer::GetElementOffset(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0) const
    engine->RegisterObjectMethod(className, "uint GetElementOffset(VertexElementType, VertexElementSemantic, uint8 = 0) const", AS_METHODPR(T, GetElementOffset, (VertexElementType, VertexElementSemantic, unsigned char) const, unsigned), AS_CALL_THISCALL);

    // const PODVector<VertexElement>& VertexBuffer::GetElements() const
    engine->RegisterObjectMethod(className, "Array<VertexElement>@ GetElements() const", AS_FUNCTION_OBJFIRST(VertexBuffer_constspPODVectorlesVertexElementgreamp_GetElements_void_template<VertexBuffer>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<VertexElement>@ get_elements() const", AS_FUNCTION_OBJFIRST(VertexBuffer_constspPODVectorlesVertexElementgreamp_GetElements_void_template<VertexBuffer>), AS_CALL_CDECL_OBJFIRST);

    // unsigned VertexBuffer::GetVertexCount() const
    engine->RegisterObjectMethod(className, "uint GetVertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_vertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);

    // unsigned VertexBuffer::GetVertexSize() const
    engine->RegisterObjectMethod(className, "uint GetVertexSize() const", AS_METHODPR(T, GetVertexSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_vertexSize() const", AS_METHODPR(T, GetVertexSize, () const, unsigned), AS_CALL_THISCALL);

    // bool VertexBuffer::HasElement(VertexElementSemantic semantic, unsigned char index = 0) const
    engine->RegisterObjectMethod(className, "bool HasElement(VertexElementSemantic, uint8 = 0) const", AS_METHODPR(T, HasElement, (VertexElementSemantic, unsigned char) const, bool), AS_CALL_THISCALL);

    // bool VertexBuffer::HasElement(VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0) const
    engine->RegisterObjectMethod(className, "bool HasElement(VertexElementType, VertexElementSemantic, uint8 = 0) const", AS_METHODPR(T, HasElement, (VertexElementType, VertexElementSemantic, unsigned char) const, bool), AS_CALL_THISCALL);

    // bool VertexBuffer::IsDynamic() const
    engine->RegisterObjectMethod(className, "bool IsDynamic() const", AS_METHODPR(T, IsDynamic, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dynamic() const", AS_METHODPR(T, IsDynamic, () const, bool), AS_CALL_THISCALL);

    // bool VertexBuffer::IsLocked() const
    engine->RegisterObjectMethod(className, "bool IsLocked() const", AS_METHODPR(T, IsLocked, () const, bool), AS_CALL_THISCALL);

    // bool VertexBuffer::IsShadowed() const
    engine->RegisterObjectMethod(className, "bool IsShadowed() const", AS_METHODPR(T, IsShadowed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_shadowed() const", AS_METHODPR(T, IsShadowed, () const, bool), AS_CALL_THISCALL);

    // void VertexBuffer::SetShadowed(bool enable)
    engine->RegisterObjectMethod(className, "void SetShadowed(bool)", AS_METHODPR(T, SetShadowed, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowed(bool)", AS_METHODPR(T, SetShadowed, (bool), void), AS_CALL_THISCALL);

    // bool VertexBuffer::SetSize(unsigned vertexCount, const PODVector<VertexElement>& elements, bool dynamic = false)
    engine->RegisterObjectMethod(className, "bool SetSize(uint, Array<VertexElement>@+, bool = false)", AS_FUNCTION_OBJFIRST(VertexBuffer_bool_SetSize_unsigned_constspPODVectorlesVertexElementgreamp_bool_template<VertexBuffer>), AS_CALL_CDECL_OBJFIRST);

    // bool VertexBuffer::SetSize(unsigned vertexCount, unsigned elementMask, bool dynamic = false)
    engine->RegisterObjectMethod(className, "bool SetSize(uint, uint, bool = false)", AS_METHODPR(T, SetSize, (unsigned, unsigned, bool), bool), AS_CALL_THISCALL);

    // void VertexBuffer::Unlock()
    engine->RegisterObjectMethod(className, "void Unlock()", AS_METHODPR(T, Unlock, (), void), AS_CALL_THISCALL);

    // static const VertexElement* VertexBuffer::GetElement(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0)
    // Error: type "const VertexElement*" can not automatically bind
    // static void VertexBuffer::UpdateOffsets(PODVector<VertexElement>& elements)
    // Error: type "PODVector<VertexElement>&" can not automatically bind

    // static bool VertexBuffer::HasElement(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool HasElement(Array<VertexElement>@+, VertexElementType, VertexElementSemantic, uint8 = 0)", AS_FUNCTION(VertexBuffer_bool_HasElement_constspPODVectorlesVertexElementgreamp_VertexElementType_VertexElementSemantic_unsignedspchar<VertexBuffer>), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned VertexBuffer::GetElementOffset(const PODVector<VertexElement>& elements, VertexElementType type, VertexElementSemantic semantic, unsigned char index = 0)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetElementOffset(Array<VertexElement>@+, VertexElementType, VertexElementSemantic, uint8 = 0)", AS_FUNCTION(VertexBuffer_unsigned_GetElementOffset_constspPODVectorlesVertexElementgreamp_VertexElementType_VertexElementSemantic_unsignedspchar<VertexBuffer>), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static PODVector<VertexElement> VertexBuffer::GetElements(unsigned elementMask)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("Array<VertexElement>@ GetElements(uint)", AS_FUNCTION(VertexBuffer_PODVectorlesVertexElementgre_GetElements_unsigned<VertexBuffer>), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned VertexBuffer::GetVertexSize(const PODVector<VertexElement>& elements)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetVertexSize(Array<VertexElement>@+)", AS_FUNCTION(VertexBuffer_unsigned_GetVertexSize_constspPODVectorlesVertexElementgreamp<VertexBuffer>), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned VertexBuffer::GetVertexSize(unsigned elementMask)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetVertexSize(uint)", AS_FUNCTIONPR(T::GetVertexSize, (unsigned), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_VertexBuffer
        REGISTER_MEMBERS_MANUAL_PART_VertexBuffer();
    #endif
}

// const PODVector<Drawable*>& View::GetGeometries() const
template <class T> CScriptArray* View_constspPODVectorlesDrawablestargreamp_GetGeometries_void_template(T* _ptr)
{
    const PODVector<Drawable*>& result = _ptr->GetGeometries();
    return VectorToHandleArray(result, "Array<Drawable@>");
}

// const PODVector<Light*>& View::GetLights() const
template <class T> CScriptArray* View_constspPODVectorlesLightstargreamp_GetLights_void_template(T* _ptr)
{
    const PODVector<Light*>& result = _ptr->GetLights();
    return VectorToHandleArray(result, "Array<Light@>");
}

// const PODVector<Drawable*>& View::GetOccluders() const
template <class T> CScriptArray* View_constspPODVectorlesDrawablestargreamp_GetOccluders_void_template(T* _ptr)
{
    const PODVector<Drawable*>& result = _ptr->GetOccluders();
    return VectorToHandleArray(result, "Array<Drawable@>");
}

// class View | File: ../Graphics/View.h
template <class T> void RegisterMembers_View(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // const Vector<LightBatchQueue>& View::GetLightQueues() const
    // Error: type "const Vector<LightBatchQueue>&" can not automatically bind

    // bool View::Define(RenderSurface* renderTarget, Viewport* viewport)
    engine->RegisterObjectMethod(className, "bool Define(RenderSurface@+, Viewport@+)", AS_METHODPR(T, Define, (RenderSurface*, Viewport*), bool), AS_CALL_THISCALL);

    // void View::DrawFullscreenQuad(bool setIdentityProjection = false)
    engine->RegisterObjectMethod(className, "void DrawFullscreenQuad(bool = false)", AS_METHODPR(T, DrawFullscreenQuad, (bool), void), AS_CALL_THISCALL);

    // Texture* View::FindNamedTexture(const String& name, bool isRenderTarget, bool isVolumeMap = false)
    engine->RegisterObjectMethod(className, "Texture@+ FindNamedTexture(const String&in, bool, bool = false)", AS_METHODPR(T, FindNamedTexture, (const String&, bool, bool), Texture*), AS_CALL_THISCALL);

    // Camera* View::GetCamera() const
    engine->RegisterObjectMethod(className, "Camera@+ GetCamera() const", AS_METHODPR(T, GetCamera, () const, Camera*), AS_CALL_THISCALL);

    // Camera* View::GetCullCamera() const
    engine->RegisterObjectMethod(className, "Camera@+ GetCullCamera() const", AS_METHODPR(T, GetCullCamera, () const, Camera*), AS_CALL_THISCALL);

    // bool View::GetDrawDebug() const
    engine->RegisterObjectMethod(className, "bool GetDrawDebug() const", AS_METHODPR(T, GetDrawDebug, () const, bool), AS_CALL_THISCALL);

    // const FrameInfo& View::GetFrameInfo() const
    engine->RegisterObjectMethod(className, "const FrameInfo& GetFrameInfo() const", AS_METHODPR(T, GetFrameInfo, () const, const FrameInfo&), AS_CALL_THISCALL);

    // const PODVector<Drawable*>& View::GetGeometries() const
    engine->RegisterObjectMethod(className, "Array<Drawable@>@ GetGeometries() const", AS_FUNCTION_OBJFIRST(View_constspPODVectorlesDrawablestargreamp_GetGeometries_void_template<View>), AS_CALL_CDECL_OBJFIRST);

    // Graphics* View::GetGraphics() const
    engine->RegisterObjectMethod(className, "Graphics@+ GetGraphics() const", AS_METHODPR(T, GetGraphics, () const, Graphics*), AS_CALL_THISCALL);

    // const PODVector<Light*>& View::GetLights() const
    engine->RegisterObjectMethod(className, "Array<Light@>@ GetLights() const", AS_FUNCTION_OBJFIRST(View_constspPODVectorlesLightstargreamp_GetLights_void_template<View>), AS_CALL_CDECL_OBJFIRST);

    // unsigned View::GetNumActiveOccluders() const
    engine->RegisterObjectMethod(className, "uint GetNumActiveOccluders() const", AS_METHODPR(T, GetNumActiveOccluders, () const, unsigned), AS_CALL_THISCALL);

    // const PODVector<Drawable*>& View::GetOccluders() const
    engine->RegisterObjectMethod(className, "Array<Drawable@>@ GetOccluders() const", AS_FUNCTION_OBJFIRST(View_constspPODVectorlesDrawablestargreamp_GetOccluders_void_template<View>), AS_CALL_CDECL_OBJFIRST);

    // OcclusionBuffer* View::GetOcclusionBuffer() const
    engine->RegisterObjectMethod(className, "OcclusionBuffer@+ GetOcclusionBuffer() const", AS_METHODPR(T, GetOcclusionBuffer, () const, OcclusionBuffer*), AS_CALL_THISCALL);

    // Octree* View::GetOctree() const
    engine->RegisterObjectMethod(className, "Octree@+ GetOctree() const", AS_METHODPR(T, GetOctree, () const, Octree*), AS_CALL_THISCALL);

    // Renderer* View::GetRenderer() const
    engine->RegisterObjectMethod(className, "Renderer@+ GetRenderer() const", AS_METHODPR(T, GetRenderer, () const, Renderer*), AS_CALL_THISCALL);

    // RenderSurface* View::GetRenderTarget() const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetRenderTarget() const", AS_METHODPR(T, GetRenderTarget, () const, RenderSurface*), AS_CALL_THISCALL);

    // Scene* View::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // View* View::GetSourceView() const
    engine->RegisterObjectMethod(className, "View@+ GetSourceView() const", AS_METHODPR(T, GetSourceView, () const, View*), AS_CALL_THISCALL);

    // const IntRect& View::GetViewRect() const
    engine->RegisterObjectMethod(className, "const IntRect& GetViewRect() const", AS_METHODPR(T, GetViewRect, () const, const IntRect&), AS_CALL_THISCALL);

    // const IntVector2& View::GetViewSize() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetViewSize() const", AS_METHODPR(T, GetViewSize, () const, const IntVector2&), AS_CALL_THISCALL);

    // void View::Render()
    engine->RegisterObjectMethod(className, "void Render()", AS_METHODPR(T, Render, (), void), AS_CALL_THISCALL);

    // void View::SetCameraShaderParameters(Camera* camera)
    engine->RegisterObjectMethod(className, "void SetCameraShaderParameters(Camera@+)", AS_METHODPR(T, SetCameraShaderParameters, (Camera*), void), AS_CALL_THISCALL);

    // void View::SetCommandShaderParameters(const RenderPathCommand& command)
    engine->RegisterObjectMethod(className, "void SetCommandShaderParameters(const RenderPathCommand&in)", AS_METHODPR(T, SetCommandShaderParameters, (const RenderPathCommand&), void), AS_CALL_THISCALL);

    // void View::SetGBufferShaderParameters(const IntVector2& texSize, const IntRect& viewRect)
    engine->RegisterObjectMethod(className, "void SetGBufferShaderParameters(const IntVector2&in, const IntRect&in)", AS_METHODPR(T, SetGBufferShaderParameters, (const IntVector2&, const IntRect&), void), AS_CALL_THISCALL);

    // void View::SetGlobalShaderParameters()
    engine->RegisterObjectMethod(className, "void SetGlobalShaderParameters()", AS_METHODPR(T, SetGlobalShaderParameters, (), void), AS_CALL_THISCALL);

    // void View::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_View
        REGISTER_MEMBERS_MANUAL_PART_View();
    #endif
}

// class Viewport | File: ../Graphics/Viewport.h
template <class T> void RegisterMembers_Viewport(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Viewport::AllocateView()
    engine->RegisterObjectMethod(className, "void AllocateView()", AS_METHODPR(T, AllocateView, (), void), AS_CALL_THISCALL);

    // Camera* Viewport::GetCamera() const
    engine->RegisterObjectMethod(className, "Camera@+ GetCamera() const", AS_METHODPR(T, GetCamera, () const, Camera*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Camera@+ get_camera() const", AS_METHODPR(T, GetCamera, () const, Camera*), AS_CALL_THISCALL);

    // Camera* Viewport::GetCullCamera() const
    engine->RegisterObjectMethod(className, "Camera@+ GetCullCamera() const", AS_METHODPR(T, GetCullCamera, () const, Camera*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Camera@+ get_cullCamera() const", AS_METHODPR(T, GetCullCamera, () const, Camera*), AS_CALL_THISCALL);

    // bool Viewport::GetDrawDebug() const
    engine->RegisterObjectMethod(className, "bool GetDrawDebug() const", AS_METHODPR(T, GetDrawDebug, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawDebug() const", AS_METHODPR(T, GetDrawDebug, () const, bool), AS_CALL_THISCALL);

    // const IntRect& Viewport::GetRect() const
    engine->RegisterObjectMethod(className, "const IntRect& GetRect() const", AS_METHODPR(T, GetRect, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_rect() const", AS_METHODPR(T, GetRect, () const, const IntRect&), AS_CALL_THISCALL);

    // RenderPath* Viewport::GetRenderPath() const
    engine->RegisterObjectMethod(className, "RenderPath@+ GetRenderPath() const", AS_METHODPR(T, GetRenderPath, () const, RenderPath*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderPath@+ get_renderPath() const", AS_METHODPR(T, GetRenderPath, () const, RenderPath*), AS_CALL_THISCALL);

    // Scene* Viewport::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Scene@+ get_scene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // Ray Viewport::GetScreenRay(int x, int y) const
    engine->RegisterObjectMethod(className, "Ray GetScreenRay(int, int) const", AS_METHODPR(T, GetScreenRay, (int, int) const, Ray), AS_CALL_THISCALL);

    // View* Viewport::GetView() const
    engine->RegisterObjectMethod(className, "View@+ GetView() const", AS_METHODPR(T, GetView, () const, View*), AS_CALL_THISCALL);

    // Vector3 Viewport::ScreenToWorldPoint(int x, int y, float depth) const
    engine->RegisterObjectMethod(className, "Vector3 ScreenToWorldPoint(int, int, float) const", AS_METHODPR(T, ScreenToWorldPoint, (int, int, float) const, Vector3), AS_CALL_THISCALL);

    // void Viewport::SetCamera(Camera* camera)
    engine->RegisterObjectMethod(className, "void SetCamera(Camera@+)", AS_METHODPR(T, SetCamera, (Camera*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_camera(Camera@+)", AS_METHODPR(T, SetCamera, (Camera*), void), AS_CALL_THISCALL);

    // void Viewport::SetCullCamera(Camera* camera)
    engine->RegisterObjectMethod(className, "void SetCullCamera(Camera@+)", AS_METHODPR(T, SetCullCamera, (Camera*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cullCamera(Camera@+)", AS_METHODPR(T, SetCullCamera, (Camera*), void), AS_CALL_THISCALL);

    // void Viewport::SetDrawDebug(bool enable)
    engine->RegisterObjectMethod(className, "void SetDrawDebug(bool)", AS_METHODPR(T, SetDrawDebug, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawDebug(bool)", AS_METHODPR(T, SetDrawDebug, (bool), void), AS_CALL_THISCALL);

    // void Viewport::SetRect(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetRect(const IntRect&in)", AS_METHODPR(T, SetRect, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rect(const IntRect&in)", AS_METHODPR(T, SetRect, (const IntRect&), void), AS_CALL_THISCALL);

    // void Viewport::SetRenderPath(RenderPath* renderPath)
    engine->RegisterObjectMethod(className, "void SetRenderPath(RenderPath@+)", AS_METHODPR(T, SetRenderPath, (RenderPath*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_renderPath(RenderPath@+)", AS_METHODPR(T, SetRenderPath, (RenderPath*), void), AS_CALL_THISCALL);

    // bool Viewport::SetRenderPath(XMLFile* file)
    engine->RegisterObjectMethod(className, "bool SetRenderPath(XMLFile@+)", AS_METHODPR(T, SetRenderPath, (XMLFile*), bool), AS_CALL_THISCALL);

    // void Viewport::SetScene(Scene* scene)
    engine->RegisterObjectMethod(className, "void SetScene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);

    // IntVector2 Viewport::WorldToScreenPoint(const Vector3& worldPos) const
    engine->RegisterObjectMethod(className, "IntVector2 WorldToScreenPoint(const Vector3&in) const", AS_METHODPR(T, WorldToScreenPoint, (const Vector3&) const, IntVector2), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Viewport
        REGISTER_MEMBERS_MANUAL_PART_Viewport();
    #endif
}

// class WorkQueue | File: ../Core/WorkQueue.h
template <class T> void RegisterMembers_WorkQueue(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void WorkQueue::AddWorkItem(const SharedPtr<WorkItem>& item)
    // Error: type "const SharedPtr<WorkItem>&" can not automatically bind
    // SharedPtr<WorkItem> WorkQueue::GetFreeItem()
    // Error: type "SharedPtr<WorkItem>" can not automatically bind
    // bool WorkQueue::RemoveWorkItem(SharedPtr<WorkItem> item)
    // Error: type "SharedPtr<WorkItem>" can not automatically bind
    // unsigned WorkQueue::RemoveWorkItems(const Vector<SharedPtr<WorkItem>>& items)
    // Error: type "const Vector<SharedPtr<WorkItem>>&" can not automatically bind

    // void WorkQueue::Complete(unsigned priority)
    engine->RegisterObjectMethod(className, "void Complete(uint)", AS_METHODPR(T, Complete, (unsigned), void), AS_CALL_THISCALL);

    // void WorkQueue::CreateThreads(unsigned numThreads)
    engine->RegisterObjectMethod(className, "void CreateThreads(uint)", AS_METHODPR(T, CreateThreads, (unsigned), void), AS_CALL_THISCALL);

    // int WorkQueue::GetNonThreadedWorkMs() const
    engine->RegisterObjectMethod(className, "int GetNonThreadedWorkMs() const", AS_METHODPR(T, GetNonThreadedWorkMs, () const, int), AS_CALL_THISCALL);

    // unsigned WorkQueue::GetNumThreads() const
    engine->RegisterObjectMethod(className, "uint GetNumThreads() const", AS_METHODPR(T, GetNumThreads, () const, unsigned), AS_CALL_THISCALL);

    // int WorkQueue::GetTolerance() const
    engine->RegisterObjectMethod(className, "int GetTolerance() const", AS_METHODPR(T, GetTolerance, () const, int), AS_CALL_THISCALL);

    // bool WorkQueue::IsCompleted(unsigned priority) const
    engine->RegisterObjectMethod(className, "bool IsCompleted(uint) const", AS_METHODPR(T, IsCompleted, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool WorkQueue::IsCompleting() const
    engine->RegisterObjectMethod(className, "bool IsCompleting() const", AS_METHODPR(T, IsCompleting, () const, bool), AS_CALL_THISCALL);

    // void WorkQueue::Pause()
    engine->RegisterObjectMethod(className, "void Pause()", AS_METHODPR(T, Pause, (), void), AS_CALL_THISCALL);

    // void WorkQueue::Resume()
    engine->RegisterObjectMethod(className, "void Resume()", AS_METHODPR(T, Resume, (), void), AS_CALL_THISCALL);

    // void WorkQueue::SetNonThreadedWorkMs(int ms)
    engine->RegisterObjectMethod(className, "void SetNonThreadedWorkMs(int)", AS_METHODPR(T, SetNonThreadedWorkMs, (int), void), AS_CALL_THISCALL);

    // void WorkQueue::SetTolerance(int tolerance)
    engine->RegisterObjectMethod(className, "void SetTolerance(int)", AS_METHODPR(T, SetTolerance, (int), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_WorkQueue
        REGISTER_MEMBERS_MANUAL_PART_WorkQueue();
    #endif
}

#ifdef URHO3D_DATABASE

// class Database | File: ../Database/Database.h
template <class T> void RegisterMembers_Database(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // DbConnection* Database::Connect(const String& connectionString)
    engine->RegisterObjectMethod(className, "DbConnection@+ Connect(const String&in)", AS_METHODPR(T, Connect, (const String&), DbConnection*), AS_CALL_THISCALL);

    // void Database::Disconnect(DbConnection* connection)
    engine->RegisterObjectMethod(className, "void Disconnect(DbConnection@+)", AS_METHODPR(T, Disconnect, (DbConnection*), void), AS_CALL_THISCALL);

    // unsigned Database::GetPoolSize() const
    engine->RegisterObjectMethod(className, "uint GetPoolSize() const", AS_METHODPR(T, GetPoolSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_poolSize() const", AS_METHODPR(T, GetPoolSize, () const, unsigned), AS_CALL_THISCALL);

    // bool Database::IsPooling() const
    engine->RegisterObjectMethod(className, "bool IsPooling() const", AS_METHODPR(T, IsPooling, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_pooling() const", AS_METHODPR(T, IsPooling, () const, bool), AS_CALL_THISCALL);

    // void Database::SetPoolSize(unsigned poolSize)
    engine->RegisterObjectMethod(className, "void SetPoolSize(uint)", AS_METHODPR(T, SetPoolSize, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_poolSize(uint)", AS_METHODPR(T, SetPoolSize, (unsigned), void), AS_CALL_THISCALL);

    // static DBAPI Database::GetAPI()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("DBAPI GetAPI()", AS_FUNCTIONPR(T::GetAPI, (), DBAPI), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Database
        REGISTER_MEMBERS_MANUAL_PART_Database();
    #endif
}

#endif // def URHO3D_DATABASE

#ifdef URHO3D_NETWORK

// class Connection | File: ../Network/Connection.h
template <class T> void RegisterMembers_Connection(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // const SLNet::AddressOrGUID& Connection::GetAddressOrGUID() const
    // Error: type "const SLNet::AddressOrGUID&" can not automatically bind
    // bool Connection::ProcessMessage(int msgID, MemoryBuffer& buffer)
    // Error: type "MemoryBuffer" can not automatically bind bacause have @nobind mark
    // void Connection::SendMessage(int msgID, bool reliable, bool inOrder, const unsigned char* data, unsigned numBytes, unsigned contentID = 0)
    // Error: type "const unsigned char*" can not automatically bind
    // void Connection::SetAddressOrGUID(const SLNet::AddressOrGUID& addr)
    // Error: type "const SLNet::AddressOrGUID&" can not automatically bind

    // void Connection::Ban()
    engine->RegisterObjectMethod(className, "void Ban()", AS_METHODPR(T, Ban, (), void), AS_CALL_THISCALL);

    // void Connection::ConfigureNetworkSimulator(int latencyMs, float packetLoss)
    engine->RegisterObjectMethod(className, "void ConfigureNetworkSimulator(int, float)", AS_METHODPR(T, ConfigureNetworkSimulator, (int, float), void), AS_CALL_THISCALL);

    // void Connection::Disconnect(int waitMSec = 0)
    engine->RegisterObjectMethod(className, "void Disconnect(int = 0)", AS_METHODPR(T, Disconnect, (int), void), AS_CALL_THISCALL);

    // String Connection::GetAddress() const
    engine->RegisterObjectMethod(className, "String GetAddress() const", AS_METHODPR(T, GetAddress, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_address() const", AS_METHODPR(T, GetAddress, () const, String), AS_CALL_THISCALL);

    // float Connection::GetBytesInPerSec() const
    engine->RegisterObjectMethod(className, "float GetBytesInPerSec() const", AS_METHODPR(T, GetBytesInPerSec, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_bytesInPerSec() const", AS_METHODPR(T, GetBytesInPerSec, () const, float), AS_CALL_THISCALL);

    // float Connection::GetBytesOutPerSec() const
    engine->RegisterObjectMethod(className, "float GetBytesOutPerSec() const", AS_METHODPR(T, GetBytesOutPerSec, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_bytesOutPerSec() const", AS_METHODPR(T, GetBytesOutPerSec, () const, float), AS_CALL_THISCALL);

    // const Controls& Connection::GetControls() const
    engine->RegisterObjectMethod(className, "const Controls& GetControls() const", AS_METHODPR(T, GetControls, () const, const Controls&), AS_CALL_THISCALL);

    // const String& Connection::GetDownloadName() const
    engine->RegisterObjectMethod(className, "const String& GetDownloadName() const", AS_METHODPR(T, GetDownloadName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_downloadName() const", AS_METHODPR(T, GetDownloadName, () const, const String&), AS_CALL_THISCALL);

    // float Connection::GetDownloadProgress() const
    engine->RegisterObjectMethod(className, "float GetDownloadProgress() const", AS_METHODPR(T, GetDownloadProgress, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_downloadProgress() const", AS_METHODPR(T, GetDownloadProgress, () const, float), AS_CALL_THISCALL);

    // VariantMap& Connection::GetIdentity()
    engine->RegisterObjectMethod(className, "VariantMap& GetIdentity()", AS_METHODPR(T, GetIdentity, (), VariantMap&), AS_CALL_THISCALL);

    // unsigned Connection::GetLastHeardTime() const
    engine->RegisterObjectMethod(className, "uint GetLastHeardTime() const", AS_METHODPR(T, GetLastHeardTime, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_lastHeardTime() const", AS_METHODPR(T, GetLastHeardTime, () const, unsigned), AS_CALL_THISCALL);

    // bool Connection::GetLogStatistics() const
    engine->RegisterObjectMethod(className, "bool GetLogStatistics() const", AS_METHODPR(T, GetLogStatistics, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_logStatistics() const", AS_METHODPR(T, GetLogStatistics, () const, bool), AS_CALL_THISCALL);

    // unsigned Connection::GetNumDownloads() const
    engine->RegisterObjectMethod(className, "uint GetNumDownloads() const", AS_METHODPR(T, GetNumDownloads, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numDownloads() const", AS_METHODPR(T, GetNumDownloads, () const, unsigned), AS_CALL_THISCALL);

    // int Connection::GetPacketsInPerSec() const
    engine->RegisterObjectMethod(className, "int GetPacketsInPerSec() const", AS_METHODPR(T, GetPacketsInPerSec, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_packetsInPerSec() const", AS_METHODPR(T, GetPacketsInPerSec, () const, int), AS_CALL_THISCALL);

    // int Connection::GetPacketsOutPerSec() const
    engine->RegisterObjectMethod(className, "int GetPacketsOutPerSec() const", AS_METHODPR(T, GetPacketsOutPerSec, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_packetsOutPerSec() const", AS_METHODPR(T, GetPacketsOutPerSec, () const, int), AS_CALL_THISCALL);

    // PacketType Connection::GetPacketType(bool reliable, bool inOrder)
    engine->RegisterObjectMethod(className, "PacketType GetPacketType(bool, bool)", AS_METHODPR(T, GetPacketType, (bool, bool), PacketType), AS_CALL_THISCALL);

    // unsigned short Connection::GetPort() const
    engine->RegisterObjectMethod(className, "uint16 GetPort() const", AS_METHODPR(T, GetPort, () const, unsigned short), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint16 get_port() const", AS_METHODPR(T, GetPort, () const, unsigned short), AS_CALL_THISCALL);

    // const Vector3& Connection::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_position() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // const Quaternion& Connection::GetRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetRotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_rotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // float Connection::GetRoundTripTime() const
    engine->RegisterObjectMethod(className, "float GetRoundTripTime() const", AS_METHODPR(T, GetRoundTripTime, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_roundTripTime() const", AS_METHODPR(T, GetRoundTripTime, () const, float), AS_CALL_THISCALL);

    // Scene* Connection::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Scene@+ get_scene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // unsigned char Connection::GetTimeStamp() const
    engine->RegisterObjectMethod(className, "uint8 GetTimeStamp() const", AS_METHODPR(T, GetTimeStamp, () const, unsigned char), AS_CALL_THISCALL);

    // bool Connection::IsClient() const
    engine->RegisterObjectMethod(className, "bool IsClient() const", AS_METHODPR(T, IsClient, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_client() const", AS_METHODPR(T, IsClient, () const, bool), AS_CALL_THISCALL);

    // bool Connection::IsConnected() const
    engine->RegisterObjectMethod(className, "bool IsConnected() const", AS_METHODPR(T, IsConnected, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_connected() const", AS_METHODPR(T, IsConnected, () const, bool), AS_CALL_THISCALL);

    // bool Connection::IsConnectPending() const
    engine->RegisterObjectMethod(className, "bool IsConnectPending() const", AS_METHODPR(T, IsConnectPending, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_connectPending() const", AS_METHODPR(T, IsConnectPending, () const, bool), AS_CALL_THISCALL);

    // bool Connection::IsSceneLoaded() const
    engine->RegisterObjectMethod(className, "bool IsSceneLoaded() const", AS_METHODPR(T, IsSceneLoaded, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sceneLoaded() const", AS_METHODPR(T, IsSceneLoaded, () const, bool), AS_CALL_THISCALL);

    // void Connection::ProcessPendingLatestData()
    engine->RegisterObjectMethod(className, "void ProcessPendingLatestData()", AS_METHODPR(T, ProcessPendingLatestData, (), void), AS_CALL_THISCALL);

    // void Connection::SendAllBuffers()
    engine->RegisterObjectMethod(className, "void SendAllBuffers()", AS_METHODPR(T, SendAllBuffers, (), void), AS_CALL_THISCALL);

    // void Connection::SendBuffer(PacketType type)
    engine->RegisterObjectMethod(className, "void SendBuffer(PacketType)", AS_METHODPR(T, SendBuffer, (PacketType), void), AS_CALL_THISCALL);

    // void Connection::SendClientUpdate()
    engine->RegisterObjectMethod(className, "void SendClientUpdate()", AS_METHODPR(T, SendClientUpdate, (), void), AS_CALL_THISCALL);

    // void Connection::SendMessage(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0)
    engine->RegisterObjectMethod(className, "void SendMessage(int, bool, bool, const VectorBuffer&in, uint = 0)", AS_METHODPR(T, SendMessage, (int, bool, bool, const VectorBuffer&, unsigned), void), AS_CALL_THISCALL);

    // void Connection::SendPackages()
    engine->RegisterObjectMethod(className, "void SendPackages()", AS_METHODPR(T, SendPackages, (), void), AS_CALL_THISCALL);

    // void Connection::SendPackageToClient(PackageFile* package)
    engine->RegisterObjectMethod(className, "void SendPackageToClient(PackageFile@+)", AS_METHODPR(T, SendPackageToClient, (PackageFile*), void), AS_CALL_THISCALL);

    // void Connection::SendRemoteEvent(StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "void SendRemoteEvent(StringHash, bool, const VariantMap&in = VariantMap())", AS_METHODPR(T, SendRemoteEvent, (StringHash, bool, const VariantMap&), void), AS_CALL_THISCALL);

    // void Connection::SendRemoteEvent(Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "void SendRemoteEvent(Node@+, StringHash, bool, const VariantMap&in = VariantMap())", AS_METHODPR(T, SendRemoteEvent, (Node*, StringHash, bool, const VariantMap&), void), AS_CALL_THISCALL);

    // void Connection::SendRemoteEvents()
    engine->RegisterObjectMethod(className, "void SendRemoteEvents()", AS_METHODPR(T, SendRemoteEvents, (), void), AS_CALL_THISCALL);

    // void Connection::SendServerUpdate()
    engine->RegisterObjectMethod(className, "void SendServerUpdate()", AS_METHODPR(T, SendServerUpdate, (), void), AS_CALL_THISCALL);

    // void Connection::SetConnectPending(bool connectPending)
    engine->RegisterObjectMethod(className, "void SetConnectPending(bool)", AS_METHODPR(T, SetConnectPending, (bool), void), AS_CALL_THISCALL);

    // void Connection::SetControls(const Controls& newControls)
    engine->RegisterObjectMethod(className, "void SetControls(const Controls&in)", AS_METHODPR(T, SetControls, (const Controls&), void), AS_CALL_THISCALL);

    // void Connection::SetIdentity(const VariantMap& identity)
    engine->RegisterObjectMethod(className, "void SetIdentity(const VariantMap&in)", AS_METHODPR(T, SetIdentity, (const VariantMap&), void), AS_CALL_THISCALL);

    // void Connection::SetLogStatistics(bool enable)
    engine->RegisterObjectMethod(className, "void SetLogStatistics(bool)", AS_METHODPR(T, SetLogStatistics, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_logStatistics(bool)", AS_METHODPR(T, SetLogStatistics, (bool), void), AS_CALL_THISCALL);

    // void Connection::SetPacketSizeLimit(int limit)
    engine->RegisterObjectMethod(className, "void SetPacketSizeLimit(int)", AS_METHODPR(T, SetPacketSizeLimit, (int), void), AS_CALL_THISCALL);

    // void Connection::SetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void Connection::SetRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void Connection::SetScene(Scene* newScene)
    engine->RegisterObjectMethod(className, "void SetScene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);

    // String Connection::ToString() const
    engine->RegisterObjectMethod(className, "String ToString() const", AS_METHODPR(T, ToString, () const, String), AS_CALL_THISCALL);

    // Controls Connection::controls_
    engine->RegisterObjectProperty(className, "Controls controls", offsetof(T, controls_));

    // unsigned char Connection::timeStamp_
    engine->RegisterObjectProperty(className, "uint8 timeStamp", offsetof(T, timeStamp_));

    // VariantMap Connection::identity_
    engine->RegisterObjectProperty(className, "VariantMap identity", offsetof(T, identity_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Connection
        REGISTER_MEMBERS_MANUAL_PART_Connection();
    #endif
}

// Vector<SharedPtr<Connection>> Network::GetClientConnections() const
template <class T> CScriptArray* Network_VectorlesSharedPtrlesConnectiongregre_GetClientConnections_void_template(T* _ptr)
{
    Vector<SharedPtr<Connection>> result = _ptr->GetClientConnections();
    return VectorToHandleArray(result, "Array<Connection@>");
}

// SharedPtr<HttpRequest> Network::MakeHttpRequest(const String& url, const String& verb = String::EMPTY, const Vector<String>& headers = Vector<String>(), const String& postData = String::EMPTY)
template <class T> HttpRequest* Network_SharedPtrlesHttpRequestgre_MakeHttpRequest_constspStringamp_constspStringamp_constspVectorlesStringgreamp_constspStringamp_template(T* _ptr, const String& url, const String& verb, CScriptArray* headers_conv, const String& postData)
{
    Vector<String> headers = ArrayToVector<String>(headers_conv);
    SharedPtr<HttpRequest> result = _ptr->MakeHttpRequest(url, verb, headers, postData);
    return result.Detach();
}

// class Network | File: ../Network/Network.h
template <class T> void RegisterMembers_Network(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Object<T>(engine, className);

    // void Network::BroadcastMessage(int msgID, bool reliable, bool inOrder, const unsigned char* data, unsigned numBytes, unsigned contentID = 0)
    // Error: type "const unsigned char*" can not automatically bind
    // void Network::ClientDisconnected(const SLNet::AddressOrGUID& connection)
    // Error: type "const SLNet::AddressOrGUID&" can not automatically bind
    // Connection* Network::GetConnection(const SLNet::AddressOrGUID& connection) const
    // Error: type "const SLNet::AddressOrGUID&" can not automatically bind
    // void Network::HandleMessage(const SLNet::AddressOrGUID& source, int packetID, int msgID, const char* data, size_t numBytes)
    // Error: type "const SLNet::AddressOrGUID&" can not automatically bind
    // void Network::NewConnectionEstablished(const SLNet::AddressOrGUID& connection)
    // Error: type "const SLNet::AddressOrGUID&" can not automatically bind

    // void Network::AttemptNATPunchtrough(const String& guid, Scene* scene, const VariantMap& identity = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "void AttemptNATPunchtrough(const String&in, Scene@+, const VariantMap&in = VariantMap())", AS_METHODPR(T, AttemptNATPunchtrough, (const String&, Scene*, const VariantMap&), void), AS_CALL_THISCALL);

    // void Network::BanAddress(const String& address)
    engine->RegisterObjectMethod(className, "void BanAddress(const String&in)", AS_METHODPR(T, BanAddress, (const String&), void), AS_CALL_THISCALL);

    // void Network::BroadcastMessage(int msgID, bool reliable, bool inOrder, const VectorBuffer& msg, unsigned contentID = 0)
    engine->RegisterObjectMethod(className, "void BroadcastMessage(int, bool, bool, const VectorBuffer&in, uint = 0)", AS_METHODPR(T, BroadcastMessage, (int, bool, bool, const VectorBuffer&, unsigned), void), AS_CALL_THISCALL);

    // void Network::BroadcastRemoteEvent(StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "void BroadcastRemoteEvent(StringHash, bool, const VariantMap&in = VariantMap())", AS_METHODPR(T, BroadcastRemoteEvent, (StringHash, bool, const VariantMap&), void), AS_CALL_THISCALL);

    // void Network::BroadcastRemoteEvent(Scene* scene, StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "void BroadcastRemoteEvent(Scene@+, StringHash, bool, const VariantMap&in = VariantMap())", AS_METHODPR(T, BroadcastRemoteEvent, (Scene*, StringHash, bool, const VariantMap&), void), AS_CALL_THISCALL);

    // void Network::BroadcastRemoteEvent(Node* node, StringHash eventType, bool inOrder, const VariantMap& eventData = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "void BroadcastRemoteEvent(Node@+, StringHash, bool, const VariantMap&in = VariantMap())", AS_METHODPR(T, BroadcastRemoteEvent, (Node*, StringHash, bool, const VariantMap&), void), AS_CALL_THISCALL);

    // bool Network::CheckRemoteEvent(StringHash eventType) const
    engine->RegisterObjectMethod(className, "bool CheckRemoteEvent(StringHash) const", AS_METHODPR(T, CheckRemoteEvent, (StringHash) const, bool), AS_CALL_THISCALL);

    // bool Network::Connect(const String& address, unsigned short port, Scene* scene, const VariantMap& identity = Variant::emptyVariantMap)
    engine->RegisterObjectMethod(className, "bool Connect(const String&in, uint16, Scene@+, const VariantMap&in = VariantMap())", AS_METHODPR(T, Connect, (const String&, unsigned short, Scene*, const VariantMap&), bool), AS_CALL_THISCALL);

    // void Network::Disconnect(int waitMSec = 0)
    engine->RegisterObjectMethod(className, "void Disconnect(int = 0)", AS_METHODPR(T, Disconnect, (int), void), AS_CALL_THISCALL);

    // void Network::DiscoverHosts(unsigned port)
    engine->RegisterObjectMethod(className, "void DiscoverHosts(uint)", AS_METHODPR(T, DiscoverHosts, (unsigned), void), AS_CALL_THISCALL);

    // Vector<SharedPtr<Connection>> Network::GetClientConnections() const
    engine->RegisterObjectMethod(className, "Array<Connection@>@ GetClientConnections() const", AS_FUNCTION_OBJFIRST(Network_VectorlesSharedPtrlesConnectiongregre_GetClientConnections_void_template<Network>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<Connection@>@ get_clientConnections() const", AS_FUNCTION_OBJFIRST(Network_VectorlesSharedPtrlesConnectiongregre_GetClientConnections_void_template<Network>), AS_CALL_CDECL_OBJFIRST);

    // const String& Network::GetGUID() const
    engine->RegisterObjectMethod(className, "const String& GetGUID() const", AS_METHODPR(T, GetGUID, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_guid() const", AS_METHODPR(T, GetGUID, () const, const String&), AS_CALL_THISCALL);

    // const String& Network::GetPackageCacheDir() const
    engine->RegisterObjectMethod(className, "const String& GetPackageCacheDir() const", AS_METHODPR(T, GetPackageCacheDir, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_packageCacheDir() const", AS_METHODPR(T, GetPackageCacheDir, () const, const String&), AS_CALL_THISCALL);

    // Connection* Network::GetServerConnection() const
    engine->RegisterObjectMethod(className, "Connection@+ GetServerConnection() const", AS_METHODPR(T, GetServerConnection, () const, Connection*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Connection@+ get_serverConnection() const", AS_METHODPR(T, GetServerConnection, () const, Connection*), AS_CALL_THISCALL);

    // int Network::GetSimulatedLatency() const
    engine->RegisterObjectMethod(className, "int GetSimulatedLatency() const", AS_METHODPR(T, GetSimulatedLatency, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_simulatedLatency() const", AS_METHODPR(T, GetSimulatedLatency, () const, int), AS_CALL_THISCALL);

    // float Network::GetSimulatedPacketLoss() const
    engine->RegisterObjectMethod(className, "float GetSimulatedPacketLoss() const", AS_METHODPR(T, GetSimulatedPacketLoss, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_simulatedPacketLoss() const", AS_METHODPR(T, GetSimulatedPacketLoss, () const, float), AS_CALL_THISCALL);

    // int Network::GetUpdateFps() const
    engine->RegisterObjectMethod(className, "int GetUpdateFps() const", AS_METHODPR(T, GetUpdateFps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_updateFps() const", AS_METHODPR(T, GetUpdateFps, () const, int), AS_CALL_THISCALL);

    // bool Network::IsServerRunning() const
    engine->RegisterObjectMethod(className, "bool IsServerRunning() const", AS_METHODPR(T, IsServerRunning, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_serverRunning() const", AS_METHODPR(T, IsServerRunning, () const, bool), AS_CALL_THISCALL);

    // SharedPtr<HttpRequest> Network::MakeHttpRequest(const String& url, const String& verb = String::EMPTY, const Vector<String>& headers = Vector<String>(), const String& postData = String::EMPTY)
    engine->RegisterObjectMethod(className, "HttpRequest@+ MakeHttpRequest(const String&in, const String&in = String::EMPTY, Array<String>@+ = null, const String&in = String::EMPTY)", AS_FUNCTION_OBJFIRST(Network_SharedPtrlesHttpRequestgre_MakeHttpRequest_constspStringamp_constspStringamp_constspVectorlesStringgreamp_constspStringamp_template<Network>), AS_CALL_CDECL_OBJFIRST);

    // void Network::PostUpdate(float timeStep)
    engine->RegisterObjectMethod(className, "void PostUpdate(float)", AS_METHODPR(T, PostUpdate, (float), void), AS_CALL_THISCALL);

    // void Network::RegisterRemoteEvent(StringHash eventType)
    engine->RegisterObjectMethod(className, "void RegisterRemoteEvent(StringHash)", AS_METHODPR(T, RegisterRemoteEvent, (StringHash), void), AS_CALL_THISCALL);

    // void Network::SendPackageToClients(Scene* scene, PackageFile* package)
    engine->RegisterObjectMethod(className, "void SendPackageToClients(Scene@+, PackageFile@+)", AS_METHODPR(T, SendPackageToClients, (Scene*, PackageFile*), void), AS_CALL_THISCALL);

    // void Network::SetDiscoveryBeacon(const VariantMap& data)
    engine->RegisterObjectMethod(className, "void SetDiscoveryBeacon(const VariantMap&in)", AS_METHODPR(T, SetDiscoveryBeacon, (const VariantMap&), void), AS_CALL_THISCALL);

    // void Network::SetNATServerInfo(const String& address, unsigned short port)
    engine->RegisterObjectMethod(className, "void SetNATServerInfo(const String&in, uint16)", AS_METHODPR(T, SetNATServerInfo, (const String&, unsigned short), void), AS_CALL_THISCALL);

    // void Network::SetPackageCacheDir(const String& path)
    engine->RegisterObjectMethod(className, "void SetPackageCacheDir(const String&in)", AS_METHODPR(T, SetPackageCacheDir, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_packageCacheDir(const String&in)", AS_METHODPR(T, SetPackageCacheDir, (const String&), void), AS_CALL_THISCALL);

    // void Network::SetPassword(const String& password)
    engine->RegisterObjectMethod(className, "void SetPassword(const String&in)", AS_METHODPR(T, SetPassword, (const String&), void), AS_CALL_THISCALL);

    // void Network::SetSimulatedLatency(int ms)
    engine->RegisterObjectMethod(className, "void SetSimulatedLatency(int)", AS_METHODPR(T, SetSimulatedLatency, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_simulatedLatency(int)", AS_METHODPR(T, SetSimulatedLatency, (int), void), AS_CALL_THISCALL);

    // void Network::SetSimulatedPacketLoss(float probability)
    engine->RegisterObjectMethod(className, "void SetSimulatedPacketLoss(float)", AS_METHODPR(T, SetSimulatedPacketLoss, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_simulatedPacketLoss(float)", AS_METHODPR(T, SetSimulatedPacketLoss, (float), void), AS_CALL_THISCALL);

    // void Network::SetUpdateFps(int fps)
    engine->RegisterObjectMethod(className, "void SetUpdateFps(int)", AS_METHODPR(T, SetUpdateFps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateFps(int)", AS_METHODPR(T, SetUpdateFps, (int), void), AS_CALL_THISCALL);

    // void Network::StartNATClient()
    engine->RegisterObjectMethod(className, "void StartNATClient()", AS_METHODPR(T, StartNATClient, (), void), AS_CALL_THISCALL);

    // bool Network::StartServer(unsigned short port, unsigned int maxConnections = 128)
    engine->RegisterObjectMethod(className, "bool StartServer(uint16, uint = 128)", AS_METHODPR(T, StartServer, (unsigned short, unsigned int), bool), AS_CALL_THISCALL);

    // void Network::StopServer()
    engine->RegisterObjectMethod(className, "void StopServer()", AS_METHODPR(T, StopServer, (), void), AS_CALL_THISCALL);

    // void Network::UnregisterAllRemoteEvents()
    engine->RegisterObjectMethod(className, "void UnregisterAllRemoteEvents()", AS_METHODPR(T, UnregisterAllRemoteEvents, (), void), AS_CALL_THISCALL);

    // void Network::UnregisterRemoteEvent(StringHash eventType)
    engine->RegisterObjectMethod(className, "void UnregisterRemoteEvent(StringHash)", AS_METHODPR(T, UnregisterRemoteEvent, (StringHash), void), AS_CALL_THISCALL);

    // void Network::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Network
        REGISTER_MEMBERS_MANUAL_PART_Network();
    #endif
}

#endif // def URHO3D_NETWORK

#ifdef URHO3D_PHYSICS

// void ConvexData::BuildHull(const PODVector<Vector3>& vertices)
template <class T> void ConvexData_void_BuildHull_constspPODVectorlesVector3greamp_template(T* _ptr, CScriptArray* vertices_conv)
{
    PODVector<Vector3> vertices = ArrayToPODVector<Vector3>(vertices_conv);
    _ptr->BuildHull(vertices);
}

// struct ConvexData | File: ../Physics/CollisionShape.h
template <class T> void RegisterMembers_ConvexData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionGeometryData<T>(engine, className);

    // void ConvexData::BuildHull(const PODVector<Vector3>& vertices)
    engine->RegisterObjectMethod(className, "void BuildHull(Array<Vector3>@+)", AS_FUNCTION_OBJFIRST(ConvexData_void_BuildHull_constspPODVectorlesVector3greamp_template<ConvexData>), AS_CALL_CDECL_OBJFIRST);

    // SharedArrayPtr<Vector3> ConvexData::vertexData_
    // Error: type "SharedArrayPtr<Vector3>" can not automatically bind
    // SharedArrayPtr<unsigned> ConvexData::indexData_
    // Error: type "SharedArrayPtr<unsigned>" can not automatically bind

    // unsigned ConvexData::vertexCount_
    engine->RegisterObjectProperty(className, "uint vertexCount", offsetof(T, vertexCount_));

    // unsigned ConvexData::indexCount_
    engine->RegisterObjectProperty(className, "uint indexCount", offsetof(T, indexCount_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConvexData
        REGISTER_MEMBERS_MANUAL_PART_ConvexData();
    #endif
}

// struct GImpactMeshData | File: ../Physics/CollisionShape.h
template <class T> void RegisterMembers_GImpactMeshData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionGeometryData<T>(engine, className);

    // UniquePtr<TriangleMeshInterface> GImpactMeshData::meshInterface_
    // Error: type "UniquePtr<TriangleMeshInterface>" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_GImpactMeshData
        REGISTER_MEMBERS_MANUAL_PART_GImpactMeshData();
    #endif
}

// struct HeightfieldData | File: ../Physics/CollisionShape.h
template <class T> void RegisterMembers_HeightfieldData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionGeometryData<T>(engine, className);

    // SharedArrayPtr<float> HeightfieldData::heightData_
    // Error: type "SharedArrayPtr<float>" can not automatically bind

    // Vector3 HeightfieldData::spacing_
    engine->RegisterObjectProperty(className, "Vector3 spacing", offsetof(T, spacing_));

    // IntVector2 HeightfieldData::size_
    engine->RegisterObjectProperty(className, "IntVector2 size", offsetof(T, size_));

    // float HeightfieldData::minHeight_
    engine->RegisterObjectProperty(className, "float minHeight", offsetof(T, minHeight_));

    // float HeightfieldData::maxHeight_
    engine->RegisterObjectProperty(className, "float maxHeight", offsetof(T, maxHeight_));

    #ifdef REGISTER_MEMBERS_MANUAL_PART_HeightfieldData
        REGISTER_MEMBERS_MANUAL_PART_HeightfieldData();
    #endif
}

// struct TriangleMeshData | File: ../Physics/CollisionShape.h
template <class T> void RegisterMembers_TriangleMeshData(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionGeometryData<T>(engine, className);

    // UniquePtr<TriangleMeshInterface> TriangleMeshData::meshInterface_
    // Error: type "UniquePtr<TriangleMeshInterface>" can not automatically bind
    // UniquePtr<btBvhTriangleMeshShape> TriangleMeshData::shape_
    // Error: type "UniquePtr<btBvhTriangleMeshShape>" can not automatically bind
    // UniquePtr<btTriangleInfoMap> TriangleMeshData::infoMap_
    // Error: type "UniquePtr<btTriangleInfoMap>" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TriangleMeshData
        REGISTER_MEMBERS_MANUAL_PART_TriangleMeshData();
    #endif
}

#endif // def URHO3D_PHYSICS

#ifdef URHO3D_URHO2D

// class TmxImageLayer2D | File: ../Urho2D/TmxFile2D.h
template <class T> void RegisterMembers_TmxImageLayer2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_TmxLayer2D<T>(engine, className);

    // const Vector2& TmxImageLayer2D::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector2&), AS_CALL_THISCALL);

    // const String& TmxImageLayer2D::GetSource() const
    engine->RegisterObjectMethod(className, "const String& GetSource() const", AS_METHODPR(T, GetSource, () const, const String&), AS_CALL_THISCALL);

    // Sprite2D* TmxImageLayer2D::GetSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // bool TmxImageLayer2D::Load(const XMLElement& element, const TileMapInfo2D& info)
    engine->RegisterObjectMethod(className, "bool Load(const XMLElement&in, const TileMapInfo2D&in)", AS_METHODPR(T, Load, (const XMLElement&, const TileMapInfo2D&), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TmxImageLayer2D
        REGISTER_MEMBERS_MANUAL_PART_TmxImageLayer2D();
    #endif
}

// class TmxObjectGroup2D | File: ../Urho2D/TmxFile2D.h
template <class T> void RegisterMembers_TmxObjectGroup2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_TmxLayer2D<T>(engine, className);

    // void TmxObjectGroup2D::StoreObject(const XMLElement& objectElem, const SharedPtr<TileMapObject2D>& object, const TileMapInfo2D& info, bool isTile = false)
    // Error: type "const SharedPtr<TileMapObject2D>&" can not automatically bind

    // unsigned TmxObjectGroup2D::GetNumObjects() const
    engine->RegisterObjectMethod(className, "uint GetNumObjects() const", AS_METHODPR(T, GetNumObjects, () const, unsigned), AS_CALL_THISCALL);

    // TileMapObject2D* TmxObjectGroup2D::GetObject(unsigned index) const
    engine->RegisterObjectMethod(className, "TileMapObject2D@+ GetObject(uint) const", AS_METHODPR(T, GetObject, (unsigned) const, TileMapObject2D*), AS_CALL_THISCALL);

    // bool TmxObjectGroup2D::Load(const XMLElement& element, const TileMapInfo2D& info)
    engine->RegisterObjectMethod(className, "bool Load(const XMLElement&in, const TileMapInfo2D&in)", AS_METHODPR(T, Load, (const XMLElement&, const TileMapInfo2D&), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TmxObjectGroup2D
        REGISTER_MEMBERS_MANUAL_PART_TmxObjectGroup2D();
    #endif
}

// class TmxTileLayer2D | File: ../Urho2D/TmxFile2D.h
template <class T> void RegisterMembers_TmxTileLayer2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_TmxLayer2D<T>(engine, className);

    // Tile2D* TmxTileLayer2D::GetTile(int x, int y) const
    engine->RegisterObjectMethod(className, "Tile2D@+ GetTile(int, int) const", AS_METHODPR(T, GetTile, (int, int) const, Tile2D*), AS_CALL_THISCALL);

    // bool TmxTileLayer2D::Load(const XMLElement& element, const TileMapInfo2D& info)
    engine->RegisterObjectMethod(className, "bool Load(const XMLElement&in, const TileMapInfo2D&in)", AS_METHODPR(T, Load, (const XMLElement&, const TileMapInfo2D&), bool), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TmxTileLayer2D
        REGISTER_MEMBERS_MANUAL_PART_TmxTileLayer2D();
    #endif
}

#endif // def URHO3D_URHO2D

// class Animatable | File: ../Scene/Animatable.h
template <class T> void RegisterMembers_Animatable(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Serializable<T>(engine, className);

    // bool Animatable::GetAnimationEnabled() const
    engine->RegisterObjectMethod(className, "bool GetAnimationEnabled() const", AS_METHODPR(T, GetAnimationEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_animationEnabled() const", AS_METHODPR(T, GetAnimationEnabled, () const, bool), AS_CALL_THISCALL);

    // ValueAnimation* Animatable::GetAttributeAnimation(const String& name) const
    engine->RegisterObjectMethod(className, "ValueAnimation@+ GetAttributeAnimation(const String&in) const", AS_METHODPR(T, GetAttributeAnimation, (const String&) const, ValueAnimation*), AS_CALL_THISCALL);

    // float Animatable::GetAttributeAnimationSpeed(const String& name) const
    engine->RegisterObjectMethod(className, "float GetAttributeAnimationSpeed(const String&in) const", AS_METHODPR(T, GetAttributeAnimationSpeed, (const String&) const, float), AS_CALL_THISCALL);

    // float Animatable::GetAttributeAnimationTime(const String& name) const
    engine->RegisterObjectMethod(className, "float GetAttributeAnimationTime(const String&in) const", AS_METHODPR(T, GetAttributeAnimationTime, (const String&) const, float), AS_CALL_THISCALL);

    // WrapMode Animatable::GetAttributeAnimationWrapMode(const String& name) const
    engine->RegisterObjectMethod(className, "WrapMode GetAttributeAnimationWrapMode(const String&in) const", AS_METHODPR(T, GetAttributeAnimationWrapMode, (const String&) const, WrapMode), AS_CALL_THISCALL);

    // ObjectAnimation* Animatable::GetObjectAnimation() const
    engine->RegisterObjectMethod(className, "ObjectAnimation@+ GetObjectAnimation() const", AS_METHODPR(T, GetObjectAnimation, () const, ObjectAnimation*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ObjectAnimation@+ get_objectAnimation() const", AS_METHODPR(T, GetObjectAnimation, () const, ObjectAnimation*), AS_CALL_THISCALL);

    // ResourceRef Animatable::GetObjectAnimationAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetObjectAnimationAttr() const", AS_METHODPR(T, GetObjectAnimationAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // void Animatable::RemoveAttributeAnimation(const String& name)
    engine->RegisterObjectMethod(className, "void RemoveAttributeAnimation(const String&in)", AS_METHODPR(T, RemoveAttributeAnimation, (const String&), void), AS_CALL_THISCALL);

    // void Animatable::RemoveObjectAnimation()
    engine->RegisterObjectMethod(className, "void RemoveObjectAnimation()", AS_METHODPR(T, RemoveObjectAnimation, (), void), AS_CALL_THISCALL);

    // void Animatable::SetAnimationEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetAnimationEnabled(bool)", AS_METHODPR(T, SetAnimationEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationEnabled(bool)", AS_METHODPR(T, SetAnimationEnabled, (bool), void), AS_CALL_THISCALL);

    // void Animatable::SetAnimationTime(float time)
    engine->RegisterObjectMethod(className, "void SetAnimationTime(float)", AS_METHODPR(T, SetAnimationTime, (float), void), AS_CALL_THISCALL);

    // void Animatable::SetAttributeAnimation(const String& name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)
    engine->RegisterObjectMethod(className, "void SetAttributeAnimation(const String&in, ValueAnimation@+, WrapMode = WM_LOOP, float = 1.0f)", AS_METHODPR(T, SetAttributeAnimation, (const String&, ValueAnimation*, WrapMode, float), void), AS_CALL_THISCALL);

    // void Animatable::SetAttributeAnimationSpeed(const String& name, float speed)
    engine->RegisterObjectMethod(className, "void SetAttributeAnimationSpeed(const String&in, float)", AS_METHODPR(T, SetAttributeAnimationSpeed, (const String&, float), void), AS_CALL_THISCALL);

    // void Animatable::SetAttributeAnimationTime(const String& name, float time)
    engine->RegisterObjectMethod(className, "void SetAttributeAnimationTime(const String&in, float)", AS_METHODPR(T, SetAttributeAnimationTime, (const String&, float), void), AS_CALL_THISCALL);

    // void Animatable::SetAttributeAnimationWrapMode(const String& name, WrapMode wrapMode)
    engine->RegisterObjectMethod(className, "void SetAttributeAnimationWrapMode(const String&in, WrapMode)", AS_METHODPR(T, SetAttributeAnimationWrapMode, (const String&, WrapMode), void), AS_CALL_THISCALL);

    // void Animatable::SetObjectAnimation(ObjectAnimation* objectAnimation)
    engine->RegisterObjectMethod(className, "void SetObjectAnimation(ObjectAnimation@+)", AS_METHODPR(T, SetObjectAnimation, (ObjectAnimation*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_objectAnimation(ObjectAnimation@+)", AS_METHODPR(T, SetObjectAnimation, (ObjectAnimation*), void), AS_CALL_THISCALL);

    // void Animatable::SetObjectAnimationAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetObjectAnimationAttr(const ResourceRef&in)", AS_METHODPR(T, SetObjectAnimationAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // static void Animatable::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Animatable
        REGISTER_MEMBERS_MANUAL_PART_Animatable();
    #endif
}

// class EventProfiler | File: ../Core/EventProfiler.h
template <class T> void RegisterMembers_EventProfiler(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Profiler<T>(engine, className);

    // void EventProfiler::BeginBlock(StringHash eventID)
    engine->RegisterObjectMethod(className, "void BeginBlock(StringHash)", AS_METHODPR(T, BeginBlock, (StringHash), void), AS_CALL_THISCALL);

    // static void EventProfiler::SetActive(bool newActive)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("void SetActive(bool)", AS_FUNCTIONPR(T::SetActive, (bool), void), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static bool EventProfiler::IsActive()
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool IsActive()", AS_FUNCTIONPR(T::IsActive, (), bool), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_EventProfiler
        REGISTER_MEMBERS_MANUAL_PART_EventProfiler();
    #endif
}

// class Font | File: ../UI/Font.h
template <class T> void RegisterMembers_Font(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // const IntVector2& Font::GetAbsoluteGlyphOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetAbsoluteGlyphOffset() const", AS_METHODPR(T, GetAbsoluteGlyphOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_absoluteGlyphOffset() const", AS_METHODPR(T, GetAbsoluteGlyphOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // FontFace* Font::GetFace(float pointSize)
    engine->RegisterObjectMethod(className, "FontFace@+ GetFace(float)", AS_METHODPR(T, GetFace, (float), FontFace*), AS_CALL_THISCALL);

    // FontType Font::GetFontType() const
    engine->RegisterObjectMethod(className, "FontType GetFontType() const", AS_METHODPR(T, GetFontType, () const, FontType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FontType get_fontType() const", AS_METHODPR(T, GetFontType, () const, FontType), AS_CALL_THISCALL);

    // const Vector2& Font::GetScaledGlyphOffset() const
    engine->RegisterObjectMethod(className, "const Vector2& GetScaledGlyphOffset() const", AS_METHODPR(T, GetScaledGlyphOffset, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_scaledGlyphOffset() const", AS_METHODPR(T, GetScaledGlyphOffset, () const, const Vector2&), AS_CALL_THISCALL);

    // IntVector2 Font::GetTotalGlyphOffset(float pointSize) const
    engine->RegisterObjectMethod(className, "IntVector2 GetTotalGlyphOffset(float) const", AS_METHODPR(T, GetTotalGlyphOffset, (float) const, IntVector2), AS_CALL_THISCALL);

    // bool Font::IsSDFFont() const
    engine->RegisterObjectMethod(className, "bool IsSDFFont() const", AS_METHODPR(T, IsSDFFont, () const, bool), AS_CALL_THISCALL);

    // void Font::ReleaseFaces()
    engine->RegisterObjectMethod(className, "void ReleaseFaces()", AS_METHODPR(T, ReleaseFaces, (), void), AS_CALL_THISCALL);

    // bool Font::SaveXML(Serializer& dest, int pointSize, bool usedGlyphs = false, const String& indentation = "\t")
    engine->RegisterObjectMethod(className, "bool SaveXML(Serializer&, int, bool = false, const String&in = \"\t\")", AS_METHODPR(T, SaveXML, (Serializer&, int, bool, const String&), bool), AS_CALL_THISCALL);

    // void Font::SetAbsoluteGlyphOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetAbsoluteGlyphOffset(const IntVector2&in)", AS_METHODPR(T, SetAbsoluteGlyphOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_absoluteGlyphOffset(const IntVector2&in)", AS_METHODPR(T, SetAbsoluteGlyphOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Font::SetScaledGlyphOffset(const Vector2& offset)
    engine->RegisterObjectMethod(className, "void SetScaledGlyphOffset(const Vector2&in)", AS_METHODPR(T, SetScaledGlyphOffset, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scaledGlyphOffset(const Vector2&in)", AS_METHODPR(T, SetScaledGlyphOffset, (const Vector2&), void), AS_CALL_THISCALL);

    // static void Font::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Font
        REGISTER_MEMBERS_MANUAL_PART_Font();
    #endif
}

// SharedPtr<Image> Image::ConvertToRGBA() const
template <class T> Image* Image_SharedPtrlesImagegre_ConvertToRGBA_void_template(T* _ptr)
{
    SharedPtr<Image> result = _ptr->ConvertToRGBA();
    return result.Detach();
}

// SharedPtr<Image> Image::GetDecompressedImage() const
template <class T> Image* Image_SharedPtrlesImagegre_GetDecompressedImage_void_template(T* _ptr)
{
    SharedPtr<Image> result = _ptr->GetDecompressedImage();
    return result.Detach();
}

// SharedPtr<Image> Image::GetNextLevel() const
template <class T> Image* Image_SharedPtrlesImagegre_GetNextLevel_void_template(T* _ptr)
{
    SharedPtr<Image> result = _ptr->GetNextLevel();
    return result.Detach();
}

// SharedPtr<Image> Image::GetNextSibling() const
template <class T> Image* Image_SharedPtrlesImagegre_GetNextSibling_void_template(T* _ptr)
{
    SharedPtr<Image> result = _ptr->GetNextSibling();
    return result.Detach();
}

// class Image | File: ../Resource/Image.h
template <class T> void RegisterMembers_Image(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // unsigned char* Image::GetData() const
    // Error: type "unsigned char*" can not automatically bind
    // void Image::GetLevels(PODVector<Image*>& levels)
    // Error: type "PODVector<Image*>&" can not automatically bind
    // void Image::GetLevels(PODVector<const Image*>& levels) const
    // Error: type "PODVector<const Image*>&" can not automatically bind
    // SDL_Surface* Image::GetSDLSurface(const IntRect& rect = IntRect::ZERO) const
    // Error: type "SDL_Surface*" can not automatically bind
    // void Image::SetData(const unsigned char* pixelData)
    // Error: type "const unsigned char*" can not automatically bind

    // void Image::CleanupLevels()
    engine->RegisterObjectMethod(className, "void CleanupLevels()", AS_METHODPR(T, CleanupLevels, (), void), AS_CALL_THISCALL);

    // void Image::Clear(const Color& color)
    engine->RegisterObjectMethod(className, "void Clear(const Color&in)", AS_METHODPR(T, Clear, (const Color&), void), AS_CALL_THISCALL);

    // void Image::ClearInt(unsigned uintColor)
    engine->RegisterObjectMethod(className, "void ClearInt(uint)", AS_METHODPR(T, ClearInt, (unsigned), void), AS_CALL_THISCALL);

    // SharedPtr<Image> Image::ConvertToRGBA() const
    engine->RegisterObjectMethod(className, "Image@+ ConvertToRGBA() const", AS_FUNCTION_OBJFIRST(Image_SharedPtrlesImagegre_ConvertToRGBA_void_template<Image>), AS_CALL_CDECL_OBJFIRST);

    // bool Image::FlipHorizontal()
    engine->RegisterObjectMethod(className, "bool FlipHorizontal()", AS_METHODPR(T, FlipHorizontal, (), bool), AS_CALL_THISCALL);

    // bool Image::FlipVertical()
    engine->RegisterObjectMethod(className, "bool FlipVertical()", AS_METHODPR(T, FlipVertical, (), bool), AS_CALL_THISCALL);

    // unsigned Image::GetComponents() const
    engine->RegisterObjectMethod(className, "uint GetComponents() const", AS_METHODPR(T, GetComponents, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_components() const", AS_METHODPR(T, GetComponents, () const, unsigned), AS_CALL_THISCALL);

    // CompressedFormat Image::GetCompressedFormat() const
    engine->RegisterObjectMethod(className, "CompressedFormat GetCompressedFormat() const", AS_METHODPR(T, GetCompressedFormat, () const, CompressedFormat), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CompressedFormat get_compressedFormat() const", AS_METHODPR(T, GetCompressedFormat, () const, CompressedFormat), AS_CALL_THISCALL);

    // CompressedLevel Image::GetCompressedLevel(unsigned index) const
    engine->RegisterObjectMethod(className, "CompressedLevel GetCompressedLevel(uint) const", AS_METHODPR(T, GetCompressedLevel, (unsigned) const, CompressedLevel), AS_CALL_THISCALL);

    // SharedPtr<Image> Image::GetDecompressedImage() const
    engine->RegisterObjectMethod(className, "Image@+ GetDecompressedImage() const", AS_FUNCTION_OBJFIRST(Image_SharedPtrlesImagegre_GetDecompressedImage_void_template<Image>), AS_CALL_CDECL_OBJFIRST);

    // int Image::GetDepth() const
    engine->RegisterObjectMethod(className, "int GetDepth() const", AS_METHODPR(T, GetDepth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_depth() const", AS_METHODPR(T, GetDepth, () const, int), AS_CALL_THISCALL);

    // int Image::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // SharedPtr<Image> Image::GetNextLevel() const
    engine->RegisterObjectMethod(className, "Image@+ GetNextLevel() const", AS_FUNCTION_OBJFIRST(Image_SharedPtrlesImagegre_GetNextLevel_void_template<Image>), AS_CALL_CDECL_OBJFIRST);

    // SharedPtr<Image> Image::GetNextSibling() const
    engine->RegisterObjectMethod(className, "Image@+ GetNextSibling() const", AS_FUNCTION_OBJFIRST(Image_SharedPtrlesImagegre_GetNextSibling_void_template<Image>), AS_CALL_CDECL_OBJFIRST);

    // unsigned Image::GetNumCompressedLevels() const
    engine->RegisterObjectMethod(className, "uint GetNumCompressedLevels() const", AS_METHODPR(T, GetNumCompressedLevels, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numCompressedLevels() const", AS_METHODPR(T, GetNumCompressedLevels, () const, unsigned), AS_CALL_THISCALL);

    // Color Image::GetPixel(int x, int y) const
    engine->RegisterObjectMethod(className, "Color GetPixel(int, int) const", AS_METHODPR(T, GetPixel, (int, int) const, Color), AS_CALL_THISCALL);

    // Color Image::GetPixel(int x, int y, int z) const
    engine->RegisterObjectMethod(className, "Color GetPixel(int, int, int) const", AS_METHODPR(T, GetPixel, (int, int, int) const, Color), AS_CALL_THISCALL);

    // Color Image::GetPixelBilinear(float x, float y) const
    engine->RegisterObjectMethod(className, "Color GetPixelBilinear(float, float) const", AS_METHODPR(T, GetPixelBilinear, (float, float) const, Color), AS_CALL_THISCALL);

    // unsigned Image::GetPixelInt(int x, int y) const
    engine->RegisterObjectMethod(className, "uint GetPixelInt(int, int) const", AS_METHODPR(T, GetPixelInt, (int, int) const, unsigned), AS_CALL_THISCALL);

    // unsigned Image::GetPixelInt(int x, int y, int z) const
    engine->RegisterObjectMethod(className, "uint GetPixelInt(int, int, int) const", AS_METHODPR(T, GetPixelInt, (int, int, int) const, unsigned), AS_CALL_THISCALL);

    // Color Image::GetPixelTrilinear(float x, float y, float z) const
    engine->RegisterObjectMethod(className, "Color GetPixelTrilinear(float, float, float) const", AS_METHODPR(T, GetPixelTrilinear, (float, float, float) const, Color), AS_CALL_THISCALL);

    // Image* Image::GetSubimage(const IntRect& rect) const
    engine->RegisterObjectMethod(className, "Image@+ GetSubimage(const IntRect&in) const", AS_METHODPR(T, GetSubimage, (const IntRect&) const, Image*), AS_CALL_THISCALL);

    // int Image::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool Image::HasAlphaChannel() const
    engine->RegisterObjectMethod(className, "bool HasAlphaChannel() const", AS_METHODPR(T, HasAlphaChannel, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hasAlphaChannel() const", AS_METHODPR(T, HasAlphaChannel, () const, bool), AS_CALL_THISCALL);

    // bool Image::IsArray() const
    engine->RegisterObjectMethod(className, "bool IsArray() const", AS_METHODPR(T, IsArray, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_array() const", AS_METHODPR(T, IsArray, () const, bool), AS_CALL_THISCALL);

    // bool Image::IsCompressed() const
    engine->RegisterObjectMethod(className, "bool IsCompressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_compressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);

    // bool Image::IsCubemap() const
    engine->RegisterObjectMethod(className, "bool IsCubemap() const", AS_METHODPR(T, IsCubemap, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_cubemap() const", AS_METHODPR(T, IsCubemap, () const, bool), AS_CALL_THISCALL);

    // bool Image::IsSRGB() const
    engine->RegisterObjectMethod(className, "bool IsSRGB() const", AS_METHODPR(T, IsSRGB, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sRGB() const", AS_METHODPR(T, IsSRGB, () const, bool), AS_CALL_THISCALL);

    // bool Image::LoadColorLUT(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadColorLUT(Deserializer&)", AS_METHODPR(T, LoadColorLUT, (Deserializer&), bool), AS_CALL_THISCALL);

    // void Image::PrecalculateLevels()
    engine->RegisterObjectMethod(className, "void PrecalculateLevels()", AS_METHODPR(T, PrecalculateLevels, (), void), AS_CALL_THISCALL);

    // bool Image::Resize(int width, int height)
    engine->RegisterObjectMethod(className, "bool Resize(int, int)", AS_METHODPR(T, Resize, (int, int), bool), AS_CALL_THISCALL);

    // bool Image::SaveBMP(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool SaveBMP(const String&in) const", AS_METHODPR(T, SaveBMP, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Image::SaveDDS(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool SaveDDS(const String&in) const", AS_METHODPR(T, SaveDDS, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Image::SaveJPG(const String& fileName, int quality) const
    engine->RegisterObjectMethod(className, "bool SaveJPG(const String&in, int) const", AS_METHODPR(T, SaveJPG, (const String&, int) const, bool), AS_CALL_THISCALL);

    // bool Image::SavePNG(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool SavePNG(const String&in) const", AS_METHODPR(T, SavePNG, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Image::SaveTGA(const String& fileName) const
    engine->RegisterObjectMethod(className, "bool SaveTGA(const String&in) const", AS_METHODPR(T, SaveTGA, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Image::SaveWEBP(const String& fileName, float compression = 0.0f) const
    engine->RegisterObjectMethod(className, "bool SaveWEBP(const String&in, float = 0.0f) const", AS_METHODPR(T, SaveWEBP, (const String&, float) const, bool), AS_CALL_THISCALL);

    // void Image::SetPixel(int x, int y, const Color& color)
    engine->RegisterObjectMethod(className, "void SetPixel(int, int, const Color&in)", AS_METHODPR(T, SetPixel, (int, int, const Color&), void), AS_CALL_THISCALL);

    // void Image::SetPixel(int x, int y, int z, const Color& color)
    engine->RegisterObjectMethod(className, "void SetPixel(int, int, int, const Color&in)", AS_METHODPR(T, SetPixel, (int, int, int, const Color&), void), AS_CALL_THISCALL);

    // void Image::SetPixelInt(int x, int y, unsigned uintColor)
    engine->RegisterObjectMethod(className, "void SetPixelInt(int, int, uint)", AS_METHODPR(T, SetPixelInt, (int, int, unsigned), void), AS_CALL_THISCALL);

    // void Image::SetPixelInt(int x, int y, int z, unsigned uintColor)
    engine->RegisterObjectMethod(className, "void SetPixelInt(int, int, int, uint)", AS_METHODPR(T, SetPixelInt, (int, int, int, unsigned), void), AS_CALL_THISCALL);

    // bool Image::SetSize(int width, int height, unsigned components)
    engine->RegisterObjectMethod(className, "bool SetSize(int, int, uint)", AS_METHODPR(T, SetSize, (int, int, unsigned), bool), AS_CALL_THISCALL);

    // bool Image::SetSize(int width, int height, int depth, unsigned components)
    engine->RegisterObjectMethod(className, "bool SetSize(int, int, int, uint)", AS_METHODPR(T, SetSize, (int, int, int, unsigned), bool), AS_CALL_THISCALL);

    // bool Image::SetSubimage(const Image* image, const IntRect& rect)
    engine->RegisterObjectMethod(className, "bool SetSubimage(Image@+, const IntRect&in)", AS_METHODPR(T, SetSubimage, (const Image*, const IntRect&), bool), AS_CALL_THISCALL);

    // static void Image::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Image
        REGISTER_MEMBERS_MANUAL_PART_Image();
    #endif
}

// class JSONFile | File: ../Resource/JSONFile.h
template <class T> void RegisterMembers_JSONFile(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // bool JSONFile::FromString(const String& source)
    engine->RegisterObjectMethod(className, "bool FromString(const String&in)", AS_METHODPR(T, FromString, (const String&), bool), AS_CALL_THISCALL);

    // JSONValue& JSONFile::GetRoot()
    engine->RegisterObjectMethod(className, "JSONValue& GetRoot()", AS_METHODPR(T, GetRoot, (), JSONValue&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "JSONValue& get_root()", AS_METHODPR(T, GetRoot, (), JSONValue&), AS_CALL_THISCALL);

    // const JSONValue& JSONFile::GetRoot() const
    engine->RegisterObjectMethod(className, "const JSONValue& GetRoot() const", AS_METHODPR(T, GetRoot, () const, const JSONValue&), AS_CALL_THISCALL);

    // bool JSONFile::Save(Serializer& dest, const String& indendation) const
    engine->RegisterObjectMethod(className, "bool Save(Serializer&, const String&in) const", AS_METHODPR(T, Save, (Serializer&, const String&) const, bool), AS_CALL_THISCALL);

    // String JSONFile::ToString(const String& indendation = "\t") const
    engine->RegisterObjectMethod(className, "String ToString(const String&in = \"\t\") const", AS_METHODPR(T, ToString, (const String&) const, String), AS_CALL_THISCALL);

    // static void JSONFile::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_JSONFile
        REGISTER_MEMBERS_MANUAL_PART_JSONFile();
    #endif
}

// SharedPtr<Material> Material::Clone(const String& cloneName = String::EMPTY) const
template <class T> Material* Material_SharedPtrlesMaterialgre_Clone_constspStringamp_template(T* _ptr, const String& cloneName)
{
    SharedPtr<Material> result = _ptr->Clone(cloneName);
    return result.Detach();
}

// class Material | File: ../Graphics/Material.h
template <class T> void RegisterMembers_Material(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // const HashMap<StringHash, MaterialShaderParameter>& Material::GetShaderParameters() const
    // Error: type "const HashMap<StringHash, MaterialShaderParameter>&" can not automatically bind
    // const Vector<TechniqueEntry>& Material::GetTechniques() const
    // Error: type "const Vector<TechniqueEntry>&" can not automatically bind
    // const HashMap<TextureUnit, SharedPtr<Texture>>& Material::GetTextures() const
    // Error: type "const HashMap<TextureUnit, SharedPtr<Texture>>&" can not automatically bind

    // SharedPtr<Material> Material::Clone(const String& cloneName = String::EMPTY) const
    engine->RegisterObjectMethod(className, "Material@+ Clone(const String&in = String::EMPTY) const", AS_FUNCTION_OBJFIRST(Material_SharedPtrlesMaterialgre_Clone_constspStringamp_template<Material>), AS_CALL_CDECL_OBJFIRST);

    // bool Material::GetAlphaToCoverage() const
    engine->RegisterObjectMethod(className, "bool GetAlphaToCoverage() const", AS_METHODPR(T, GetAlphaToCoverage, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_alphaToCoverage() const", AS_METHODPR(T, GetAlphaToCoverage, () const, bool), AS_CALL_THISCALL);

    // unsigned Material::GetAuxViewFrameNumber() const
    engine->RegisterObjectMethod(className, "uint GetAuxViewFrameNumber() const", AS_METHODPR(T, GetAuxViewFrameNumber, () const, unsigned), AS_CALL_THISCALL);

    // CullMode Material::GetCullMode() const
    engine->RegisterObjectMethod(className, "CullMode GetCullMode() const", AS_METHODPR(T, GetCullMode, () const, CullMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CullMode get_cullMode() const", AS_METHODPR(T, GetCullMode, () const, CullMode), AS_CALL_THISCALL);

    // const BiasParameters& Material::GetDepthBias() const
    engine->RegisterObjectMethod(className, "const BiasParameters& GetDepthBias() const", AS_METHODPR(T, GetDepthBias, () const, const BiasParameters&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BiasParameters& get_depthBias() const", AS_METHODPR(T, GetDepthBias, () const, const BiasParameters&), AS_CALL_THISCALL);

    // FillMode Material::GetFillMode() const
    engine->RegisterObjectMethod(className, "FillMode GetFillMode() const", AS_METHODPR(T, GetFillMode, () const, FillMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FillMode get_fillMode() const", AS_METHODPR(T, GetFillMode, () const, FillMode), AS_CALL_THISCALL);

    // bool Material::GetLineAntiAlias() const
    engine->RegisterObjectMethod(className, "bool GetLineAntiAlias() const", AS_METHODPR(T, GetLineAntiAlias, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_lineAntiAlias() const", AS_METHODPR(T, GetLineAntiAlias, () const, bool), AS_CALL_THISCALL);

    // unsigned Material::GetNumTechniques() const
    engine->RegisterObjectMethod(className, "uint GetNumTechniques() const", AS_METHODPR(T, GetNumTechniques, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numTechniques() const", AS_METHODPR(T, GetNumTechniques, () const, unsigned), AS_CALL_THISCALL);

    // bool Material::GetOcclusion() const
    engine->RegisterObjectMethod(className, "bool GetOcclusion() const", AS_METHODPR(T, GetOcclusion, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occlusion() const", AS_METHODPR(T, GetOcclusion, () const, bool), AS_CALL_THISCALL);

    // Pass* Material::GetPass(unsigned index, const String& passName) const
    engine->RegisterObjectMethod(className, "Pass@+ GetPass(uint, const String&in) const", AS_METHODPR(T, GetPass, (unsigned, const String&) const, Pass*), AS_CALL_THISCALL);

    // const String& Material::GetPixelShaderDefines() const
    engine->RegisterObjectMethod(className, "const String& GetPixelShaderDefines() const", AS_METHODPR(T, GetPixelShaderDefines, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_pixelShaderDefines() const", AS_METHODPR(T, GetPixelShaderDefines, () const, const String&), AS_CALL_THISCALL);

    // unsigned char Material::GetRenderOrder() const
    engine->RegisterObjectMethod(className, "uint8 GetRenderOrder() const", AS_METHODPR(T, GetRenderOrder, () const, unsigned char), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint8 get_renderOrder() const", AS_METHODPR(T, GetRenderOrder, () const, unsigned char), AS_CALL_THISCALL);

    // Scene* Material::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Scene@+ get_scene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // const Variant& Material::GetShaderParameter(const String& name) const
    engine->RegisterObjectMethod(className, "const Variant& GetShaderParameter(const String&in) const", AS_METHODPR(T, GetShaderParameter, (const String&) const, const Variant&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Variant& get_shaderParameters(const String&in) const", AS_METHODPR(T, GetShaderParameter, (const String&) const, const Variant&), AS_CALL_THISCALL);

    // ValueAnimation* Material::GetShaderParameterAnimation(const String& name) const
    engine->RegisterObjectMethod(className, "ValueAnimation@+ GetShaderParameterAnimation(const String&in) const", AS_METHODPR(T, GetShaderParameterAnimation, (const String&) const, ValueAnimation*), AS_CALL_THISCALL);

    // float Material::GetShaderParameterAnimationSpeed(const String& name) const
    engine->RegisterObjectMethod(className, "float GetShaderParameterAnimationSpeed(const String&in) const", AS_METHODPR(T, GetShaderParameterAnimationSpeed, (const String&) const, float), AS_CALL_THISCALL);

    // WrapMode Material::GetShaderParameterAnimationWrapMode(const String& name) const
    engine->RegisterObjectMethod(className, "WrapMode GetShaderParameterAnimationWrapMode(const String&in) const", AS_METHODPR(T, GetShaderParameterAnimationWrapMode, (const String&) const, WrapMode), AS_CALL_THISCALL);

    // unsigned Material::GetShaderParameterHash() const
    engine->RegisterObjectMethod(className, "uint GetShaderParameterHash() const", AS_METHODPR(T, GetShaderParameterHash, () const, unsigned), AS_CALL_THISCALL);

    // CullMode Material::GetShadowCullMode() const
    engine->RegisterObjectMethod(className, "CullMode GetShadowCullMode() const", AS_METHODPR(T, GetShadowCullMode, () const, CullMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CullMode get_shadowCullMode() const", AS_METHODPR(T, GetShadowCullMode, () const, CullMode), AS_CALL_THISCALL);

    // bool Material::GetSpecular() const
    engine->RegisterObjectMethod(className, "bool GetSpecular() const", AS_METHODPR(T, GetSpecular, () const, bool), AS_CALL_THISCALL);

    // Technique* Material::GetTechnique(unsigned index) const
    engine->RegisterObjectMethod(className, "Technique@+ GetTechnique(uint) const", AS_METHODPR(T, GetTechnique, (unsigned) const, Technique*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Technique@+ get_techniques(uint) const", AS_METHODPR(T, GetTechnique, (unsigned) const, Technique*), AS_CALL_THISCALL);

    // const TechniqueEntry& Material::GetTechniqueEntry(unsigned index) const
    engine->RegisterObjectMethod(className, "const TechniqueEntry& GetTechniqueEntry(uint) const", AS_METHODPR(T, GetTechniqueEntry, (unsigned) const, const TechniqueEntry&), AS_CALL_THISCALL);

    // Texture* Material::GetTexture(TextureUnit unit) const
    engine->RegisterObjectMethod(className, "Texture@+ GetTexture(TextureUnit) const", AS_METHODPR(T, GetTexture, (TextureUnit) const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_textures(TextureUnit) const", AS_METHODPR(T, GetTexture, (TextureUnit) const, Texture*), AS_CALL_THISCALL);

    // const String& Material::GetVertexShaderDefines() const
    engine->RegisterObjectMethod(className, "const String& GetVertexShaderDefines() const", AS_METHODPR(T, GetVertexShaderDefines, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_vertexShaderDefines() const", AS_METHODPR(T, GetVertexShaderDefines, () const, const String&), AS_CALL_THISCALL);

    // bool Material::Load(const XMLElement& source)
    engine->RegisterObjectMethod(className, "bool Load(const XMLElement&in)", AS_METHODPR(T, Load, (const XMLElement&), bool), AS_CALL_THISCALL);

    // bool Material::Load(const JSONValue& source)
    engine->RegisterObjectMethod(className, "bool Load(const JSONValue&in)", AS_METHODPR(T, Load, (const JSONValue&), bool), AS_CALL_THISCALL);

    // void Material::MarkForAuxView(unsigned frameNumber)
    engine->RegisterObjectMethod(className, "void MarkForAuxView(uint)", AS_METHODPR(T, MarkForAuxView, (unsigned), void), AS_CALL_THISCALL);

    // void Material::ReleaseShaders()
    engine->RegisterObjectMethod(className, "void ReleaseShaders()", AS_METHODPR(T, ReleaseShaders, (), void), AS_CALL_THISCALL);

    // void Material::RemoveShaderParameter(const String& name)
    engine->RegisterObjectMethod(className, "void RemoveShaderParameter(const String&in)", AS_METHODPR(T, RemoveShaderParameter, (const String&), void), AS_CALL_THISCALL);

    // bool Material::Save(XMLElement& dest) const
    engine->RegisterObjectMethod(className, "bool Save(XMLElement&) const", AS_METHODPR(T, Save, (XMLElement&) const, bool), AS_CALL_THISCALL);

    // bool Material::Save(JSONValue& dest) const
    engine->RegisterObjectMethod(className, "bool Save(JSONValue&) const", AS_METHODPR(T, Save, (JSONValue&) const, bool), AS_CALL_THISCALL);

    // void Material::SetAlphaToCoverage(bool enable)
    engine->RegisterObjectMethod(className, "void SetAlphaToCoverage(bool)", AS_METHODPR(T, SetAlphaToCoverage, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_alphaToCoverage(bool)", AS_METHODPR(T, SetAlphaToCoverage, (bool), void), AS_CALL_THISCALL);

    // void Material::SetCullMode(CullMode mode)
    engine->RegisterObjectMethod(className, "void SetCullMode(CullMode)", AS_METHODPR(T, SetCullMode, (CullMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cullMode(CullMode)", AS_METHODPR(T, SetCullMode, (CullMode), void), AS_CALL_THISCALL);

    // void Material::SetDepthBias(const BiasParameters& parameters)
    engine->RegisterObjectMethod(className, "void SetDepthBias(const BiasParameters&in)", AS_METHODPR(T, SetDepthBias, (const BiasParameters&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_depthBias(const BiasParameters&in)", AS_METHODPR(T, SetDepthBias, (const BiasParameters&), void), AS_CALL_THISCALL);

    // void Material::SetFillMode(FillMode mode)
    engine->RegisterObjectMethod(className, "void SetFillMode(FillMode)", AS_METHODPR(T, SetFillMode, (FillMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fillMode(FillMode)", AS_METHODPR(T, SetFillMode, (FillMode), void), AS_CALL_THISCALL);

    // void Material::SetLineAntiAlias(bool enable)
    engine->RegisterObjectMethod(className, "void SetLineAntiAlias(bool)", AS_METHODPR(T, SetLineAntiAlias, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lineAntiAlias(bool)", AS_METHODPR(T, SetLineAntiAlias, (bool), void), AS_CALL_THISCALL);

    // void Material::SetNumTechniques(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumTechniques(uint)", AS_METHODPR(T, SetNumTechniques, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numTechniques(uint)", AS_METHODPR(T, SetNumTechniques, (unsigned), void), AS_CALL_THISCALL);

    // void Material::SetOcclusion(bool enable)
    engine->RegisterObjectMethod(className, "void SetOcclusion(bool)", AS_METHODPR(T, SetOcclusion, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occlusion(bool)", AS_METHODPR(T, SetOcclusion, (bool), void), AS_CALL_THISCALL);

    // void Material::SetPixelShaderDefines(const String& defines)
    engine->RegisterObjectMethod(className, "void SetPixelShaderDefines(const String&in)", AS_METHODPR(T, SetPixelShaderDefines, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pixelShaderDefines(const String&in)", AS_METHODPR(T, SetPixelShaderDefines, (const String&), void), AS_CALL_THISCALL);

    // void Material::SetRenderOrder(unsigned char order)
    engine->RegisterObjectMethod(className, "void SetRenderOrder(uint8)", AS_METHODPR(T, SetRenderOrder, (unsigned char), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_renderOrder(uint8)", AS_METHODPR(T, SetRenderOrder, (unsigned char), void), AS_CALL_THISCALL);

    // void Material::SetScene(Scene* scene)
    engine->RegisterObjectMethod(className, "void SetScene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);

    // void Material::SetShaderParameter(const String& name, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetShaderParameter(const String&in, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (const String&, const Variant&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shaderParameters(const String&in, const Variant&in)", AS_METHODPR(T, SetShaderParameter, (const String&, const Variant&), void), AS_CALL_THISCALL);

    // void Material::SetShaderParameterAnimation(const String& name, ValueAnimation* animation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)
    engine->RegisterObjectMethod(className, "void SetShaderParameterAnimation(const String&in, ValueAnimation@+, WrapMode = WM_LOOP, float = 1.0f)", AS_METHODPR(T, SetShaderParameterAnimation, (const String&, ValueAnimation*, WrapMode, float), void), AS_CALL_THISCALL);

    // void Material::SetShaderParameterAnimationSpeed(const String& name, float speed)
    engine->RegisterObjectMethod(className, "void SetShaderParameterAnimationSpeed(const String&in, float)", AS_METHODPR(T, SetShaderParameterAnimationSpeed, (const String&, float), void), AS_CALL_THISCALL);

    // void Material::SetShaderParameterAnimationWrapMode(const String& name, WrapMode wrapMode)
    engine->RegisterObjectMethod(className, "void SetShaderParameterAnimationWrapMode(const String&in, WrapMode)", AS_METHODPR(T, SetShaderParameterAnimationWrapMode, (const String&, WrapMode), void), AS_CALL_THISCALL);

    // void Material::SetShadowCullMode(CullMode mode)
    engine->RegisterObjectMethod(className, "void SetShadowCullMode(CullMode)", AS_METHODPR(T, SetShadowCullMode, (CullMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowCullMode(CullMode)", AS_METHODPR(T, SetShadowCullMode, (CullMode), void), AS_CALL_THISCALL);

    // void Material::SetTechnique(unsigned index, Technique* tech, MaterialQuality qualityLevel = QUALITY_LOW, float lodDistance = 0.0f)
    engine->RegisterObjectMethod(className, "void SetTechnique(uint, Technique@+, MaterialQuality = QUALITY_LOW, float = 0.0f)", AS_METHODPR(T, SetTechnique, (unsigned, Technique*, MaterialQuality, float), void), AS_CALL_THISCALL);

    // void Material::SetTexture(TextureUnit unit, Texture* texture)
    engine->RegisterObjectMethod(className, "void SetTexture(TextureUnit, Texture@+)", AS_METHODPR(T, SetTexture, (TextureUnit, Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textures(TextureUnit, Texture@+)", AS_METHODPR(T, SetTexture, (TextureUnit, Texture*), void), AS_CALL_THISCALL);

    // void Material::SetUVTransform(const Vector2& offset, float rotation, const Vector2& repeat)
    engine->RegisterObjectMethod(className, "void SetUVTransform(const Vector2&in, float, const Vector2&in)", AS_METHODPR(T, SetUVTransform, (const Vector2&, float, const Vector2&), void), AS_CALL_THISCALL);

    // void Material::SetUVTransform(const Vector2& offset, float rotation, float repeat)
    engine->RegisterObjectMethod(className, "void SetUVTransform(const Vector2&in, float, float)", AS_METHODPR(T, SetUVTransform, (const Vector2&, float, float), void), AS_CALL_THISCALL);

    // void Material::SetVertexShaderDefines(const String& defines)
    engine->RegisterObjectMethod(className, "void SetVertexShaderDefines(const String&in)", AS_METHODPR(T, SetVertexShaderDefines, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexShaderDefines(const String&in)", AS_METHODPR(T, SetVertexShaderDefines, (const String&), void), AS_CALL_THISCALL);

    // void Material::SortTechniques()
    engine->RegisterObjectMethod(className, "void SortTechniques()", AS_METHODPR(T, SortTechniques, (), void), AS_CALL_THISCALL);

    // static void Material::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    // static String Material::GetTextureUnitName(TextureUnit unit)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("String GetTextureUnitName(TextureUnit)", AS_FUNCTIONPR(T::GetTextureUnitName, (TextureUnit), String), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static Variant Material::ParseShaderParameterValue(const String& value)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("Variant ParseShaderParameterValue(const String&in)", AS_FUNCTIONPR(T::ParseShaderParameterValue, (const String&), Variant), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Material
        REGISTER_MEMBERS_MANUAL_PART_Material();
    #endif
}

// class ObjectAnimation | File: ../Scene/ObjectAnimation.h
template <class T> void RegisterMembers_ObjectAnimation(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // const HashMap<String, SharedPtr<ValueAnimationInfo>>& ObjectAnimation::GetAttributeAnimationInfos() const
    // Error: type "const HashMap<String, SharedPtr<ValueAnimationInfo>>&" can not automatically bind

    // void ObjectAnimation::AddAttributeAnimation(const String& name, ValueAnimation* attributeAnimation, WrapMode wrapMode = WM_LOOP, float speed = 1.0f)
    engine->RegisterObjectMethod(className, "void AddAttributeAnimation(const String&in, ValueAnimation@+, WrapMode = WM_LOOP, float = 1.0f)", AS_METHODPR(T, AddAttributeAnimation, (const String&, ValueAnimation*, WrapMode, float), void), AS_CALL_THISCALL);

    // ValueAnimation* ObjectAnimation::GetAttributeAnimation(const String& name) const
    engine->RegisterObjectMethod(className, "ValueAnimation@+ GetAttributeAnimation(const String&in) const", AS_METHODPR(T, GetAttributeAnimation, (const String&) const, ValueAnimation*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ValueAnimation@+ get_attributeAnimations(const String&in) const", AS_METHODPR(T, GetAttributeAnimation, (const String&) const, ValueAnimation*), AS_CALL_THISCALL);

    // ValueAnimationInfo* ObjectAnimation::GetAttributeAnimationInfo(const String& name) const
    engine->RegisterObjectMethod(className, "ValueAnimationInfo@+ GetAttributeAnimationInfo(const String&in) const", AS_METHODPR(T, GetAttributeAnimationInfo, (const String&) const, ValueAnimationInfo*), AS_CALL_THISCALL);

    // float ObjectAnimation::GetAttributeAnimationSpeed(const String& name) const
    engine->RegisterObjectMethod(className, "float GetAttributeAnimationSpeed(const String&in) const", AS_METHODPR(T, GetAttributeAnimationSpeed, (const String&) const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_speeds(const String&in) const", AS_METHODPR(T, GetAttributeAnimationSpeed, (const String&) const, float), AS_CALL_THISCALL);

    // WrapMode ObjectAnimation::GetAttributeAnimationWrapMode(const String& name) const
    engine->RegisterObjectMethod(className, "WrapMode GetAttributeAnimationWrapMode(const String&in) const", AS_METHODPR(T, GetAttributeAnimationWrapMode, (const String&) const, WrapMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "WrapMode get_wrapModes(const String&in) const", AS_METHODPR(T, GetAttributeAnimationWrapMode, (const String&) const, WrapMode), AS_CALL_THISCALL);

    // bool ObjectAnimation::LoadJSON(const JSONValue& source)
    engine->RegisterObjectMethod(className, "bool LoadJSON(const JSONValue&in)", AS_METHODPR(T, LoadJSON, (const JSONValue&), bool), AS_CALL_THISCALL);

    // bool ObjectAnimation::LoadXML(const XMLElement& source)
    engine->RegisterObjectMethod(className, "bool LoadXML(const XMLElement&in)", AS_METHODPR(T, LoadXML, (const XMLElement&), bool), AS_CALL_THISCALL);

    // void ObjectAnimation::RemoveAttributeAnimation(const String& name)
    engine->RegisterObjectMethod(className, "void RemoveAttributeAnimation(const String&in)", AS_METHODPR(T, RemoveAttributeAnimation, (const String&), void), AS_CALL_THISCALL);

    // void ObjectAnimation::RemoveAttributeAnimation(ValueAnimation* attributeAnimation)
    engine->RegisterObjectMethod(className, "void RemoveAttributeAnimation(ValueAnimation@+)", AS_METHODPR(T, RemoveAttributeAnimation, (ValueAnimation*), void), AS_CALL_THISCALL);

    // bool ObjectAnimation::SaveJSON(JSONValue& dest) const
    engine->RegisterObjectMethod(className, "bool SaveJSON(JSONValue&) const", AS_METHODPR(T, SaveJSON, (JSONValue&) const, bool), AS_CALL_THISCALL);

    // bool ObjectAnimation::SaveXML(XMLElement& dest) const
    engine->RegisterObjectMethod(className, "bool SaveXML(XMLElement&) const", AS_METHODPR(T, SaveXML, (XMLElement&) const, bool), AS_CALL_THISCALL);

    // static void ObjectAnimation::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ObjectAnimation
        REGISTER_MEMBERS_MANUAL_PART_ObjectAnimation();
    #endif
}

// SharedPtr<ParticleEffect> ParticleEffect::Clone(const String& cloneName = String::EMPTY) const
template <class T> ParticleEffect* ParticleEffect_SharedPtrlesParticleEffectgre_Clone_constspStringamp_template(T* _ptr, const String& cloneName)
{
    SharedPtr<ParticleEffect> result = _ptr->Clone(cloneName);
    return result.Detach();
}

// class ParticleEffect | File: ../Graphics/ParticleEffect.h
template <class T> void RegisterMembers_ParticleEffect(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // const Vector<ColorFrame>& ParticleEffect::GetColorFrames() const
    // Error: type "const Vector<ColorFrame>&" can not automatically bind
    // const Vector<TextureFrame>& ParticleEffect::GetTextureFrames() const
    // Error: type "const Vector<TextureFrame>&" can not automatically bind
    // void ParticleEffect::SetColorFrames(const Vector<ColorFrame>& colorFrames)
    // Error: type "const Vector<ColorFrame>&" can not automatically bind
    // void ParticleEffect::SetTextureFrames(const Vector<TextureFrame>& textureFrames)
    // Error: type "const Vector<TextureFrame>&" can not automatically bind

    // void ParticleEffect::AddColorFrame(const ColorFrame& colorFrame)
    engine->RegisterObjectMethod(className, "void AddColorFrame(const ColorFrame&in)", AS_METHODPR(T, AddColorFrame, (const ColorFrame&), void), AS_CALL_THISCALL);

    // void ParticleEffect::AddColorTime(const Color& color, float time)
    engine->RegisterObjectMethod(className, "void AddColorTime(const Color&in, float)", AS_METHODPR(T, AddColorTime, (const Color&, float), void), AS_CALL_THISCALL);

    // void ParticleEffect::AddTextureFrame(const TextureFrame& textureFrame)
    engine->RegisterObjectMethod(className, "void AddTextureFrame(const TextureFrame&in)", AS_METHODPR(T, AddTextureFrame, (const TextureFrame&), void), AS_CALL_THISCALL);

    // void ParticleEffect::AddTextureTime(const Rect& uv, float time)
    engine->RegisterObjectMethod(className, "void AddTextureTime(const Rect&in, float)", AS_METHODPR(T, AddTextureTime, (const Rect&, float), void), AS_CALL_THISCALL);

    // SharedPtr<ParticleEffect> ParticleEffect::Clone(const String& cloneName = String::EMPTY) const
    engine->RegisterObjectMethod(className, "ParticleEffect@+ Clone(const String&in = String::EMPTY) const", AS_FUNCTION_OBJFIRST(ParticleEffect_SharedPtrlesParticleEffectgre_Clone_constspStringamp_template<ParticleEffect>), AS_CALL_CDECL_OBJFIRST);

    // float ParticleEffect::GetActiveTime() const
    engine->RegisterObjectMethod(className, "float GetActiveTime() const", AS_METHODPR(T, GetActiveTime, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_activeTime() const", AS_METHODPR(T, GetActiveTime, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetAnimationLodBias() const
    engine->RegisterObjectMethod(className, "float GetAnimationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_animationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);

    // const ColorFrame* ParticleEffect::GetColorFrame(unsigned index) const
    engine->RegisterObjectMethod(className, "ColorFrame@+ GetColorFrame(uint) const", AS_METHODPR(T, GetColorFrame, (unsigned) const, const ColorFrame*), AS_CALL_THISCALL);

    // const Vector3& ParticleEffect::GetConstantForce() const
    engine->RegisterObjectMethod(className, "const Vector3& GetConstantForce() const", AS_METHODPR(T, GetConstantForce, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_constantForce() const", AS_METHODPR(T, GetConstantForce, () const, const Vector3&), AS_CALL_THISCALL);

    // float ParticleEffect::GetDampingForce() const
    engine->RegisterObjectMethod(className, "float GetDampingForce() const", AS_METHODPR(T, GetDampingForce, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_dampingForce() const", AS_METHODPR(T, GetDampingForce, () const, float), AS_CALL_THISCALL);

    // const Vector3& ParticleEffect::GetEmitterSize() const
    engine->RegisterObjectMethod(className, "const Vector3& GetEmitterSize() const", AS_METHODPR(T, GetEmitterSize, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_emitterSize() const", AS_METHODPR(T, GetEmitterSize, () const, const Vector3&), AS_CALL_THISCALL);

    // EmitterType ParticleEffect::GetEmitterType() const
    engine->RegisterObjectMethod(className, "EmitterType GetEmitterType() const", AS_METHODPR(T, GetEmitterType, () const, EmitterType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "EmitterType get_emitterType() const", AS_METHODPR(T, GetEmitterType, () const, EmitterType), AS_CALL_THISCALL);

    // FaceCameraMode ParticleEffect::GetFaceCameraMode() const
    engine->RegisterObjectMethod(className, "FaceCameraMode GetFaceCameraMode() const", AS_METHODPR(T, GetFaceCameraMode, () const, FaceCameraMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FaceCameraMode get_faceCameraMode() const", AS_METHODPR(T, GetFaceCameraMode, () const, FaceCameraMode), AS_CALL_THISCALL);

    // float ParticleEffect::GetInactiveTime() const
    engine->RegisterObjectMethod(className, "float GetInactiveTime() const", AS_METHODPR(T, GetInactiveTime, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_inactiveTime() const", AS_METHODPR(T, GetInactiveTime, () const, float), AS_CALL_THISCALL);

    // Material* ParticleEffect::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // const Vector3& ParticleEffect::GetMaxDirection() const
    engine->RegisterObjectMethod(className, "const Vector3& GetMaxDirection() const", AS_METHODPR(T, GetMaxDirection, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_maxDirection() const", AS_METHODPR(T, GetMaxDirection, () const, const Vector3&), AS_CALL_THISCALL);

    // float ParticleEffect::GetMaxEmissionRate() const
    engine->RegisterObjectMethod(className, "float GetMaxEmissionRate() const", AS_METHODPR(T, GetMaxEmissionRate, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxEmissionRate() const", AS_METHODPR(T, GetMaxEmissionRate, () const, float), AS_CALL_THISCALL);

    // const Vector2& ParticleEffect::GetMaxParticleSize() const
    engine->RegisterObjectMethod(className, "const Vector2& GetMaxParticleSize() const", AS_METHODPR(T, GetMaxParticleSize, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_maxParticleSize() const", AS_METHODPR(T, GetMaxParticleSize, () const, const Vector2&), AS_CALL_THISCALL);

    // float ParticleEffect::GetMaxRotation() const
    engine->RegisterObjectMethod(className, "float GetMaxRotation() const", AS_METHODPR(T, GetMaxRotation, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxRotation() const", AS_METHODPR(T, GetMaxRotation, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetMaxRotationSpeed() const
    engine->RegisterObjectMethod(className, "float GetMaxRotationSpeed() const", AS_METHODPR(T, GetMaxRotationSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxRotationSpeed() const", AS_METHODPR(T, GetMaxRotationSpeed, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetMaxTimeToLive() const
    engine->RegisterObjectMethod(className, "float GetMaxTimeToLive() const", AS_METHODPR(T, GetMaxTimeToLive, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxTimeToLive() const", AS_METHODPR(T, GetMaxTimeToLive, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetMaxVelocity() const
    engine->RegisterObjectMethod(className, "float GetMaxVelocity() const", AS_METHODPR(T, GetMaxVelocity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxVelocity() const", AS_METHODPR(T, GetMaxVelocity, () const, float), AS_CALL_THISCALL);

    // const Vector3& ParticleEffect::GetMinDirection() const
    engine->RegisterObjectMethod(className, "const Vector3& GetMinDirection() const", AS_METHODPR(T, GetMinDirection, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_minDirection() const", AS_METHODPR(T, GetMinDirection, () const, const Vector3&), AS_CALL_THISCALL);

    // float ParticleEffect::GetMinEmissionRate() const
    engine->RegisterObjectMethod(className, "float GetMinEmissionRate() const", AS_METHODPR(T, GetMinEmissionRate, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minEmissionRate() const", AS_METHODPR(T, GetMinEmissionRate, () const, float), AS_CALL_THISCALL);

    // const Vector2& ParticleEffect::GetMinParticleSize() const
    engine->RegisterObjectMethod(className, "const Vector2& GetMinParticleSize() const", AS_METHODPR(T, GetMinParticleSize, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_minParticleSize() const", AS_METHODPR(T, GetMinParticleSize, () const, const Vector2&), AS_CALL_THISCALL);

    // float ParticleEffect::GetMinRotation() const
    engine->RegisterObjectMethod(className, "float GetMinRotation() const", AS_METHODPR(T, GetMinRotation, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minRotation() const", AS_METHODPR(T, GetMinRotation, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetMinRotationSpeed() const
    engine->RegisterObjectMethod(className, "float GetMinRotationSpeed() const", AS_METHODPR(T, GetMinRotationSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minRotationSpeed() const", AS_METHODPR(T, GetMinRotationSpeed, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetMinTimeToLive() const
    engine->RegisterObjectMethod(className, "float GetMinTimeToLive() const", AS_METHODPR(T, GetMinTimeToLive, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minTimeToLive() const", AS_METHODPR(T, GetMinTimeToLive, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetMinVelocity() const
    engine->RegisterObjectMethod(className, "float GetMinVelocity() const", AS_METHODPR(T, GetMinVelocity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minVelocity() const", AS_METHODPR(T, GetMinVelocity, () const, float), AS_CALL_THISCALL);

    // unsigned ParticleEffect::GetNumColorFrames() const
    engine->RegisterObjectMethod(className, "uint GetNumColorFrames() const", AS_METHODPR(T, GetNumColorFrames, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numColorFrames() const", AS_METHODPR(T, GetNumColorFrames, () const, unsigned), AS_CALL_THISCALL);

    // unsigned ParticleEffect::GetNumParticles() const
    engine->RegisterObjectMethod(className, "uint GetNumParticles() const", AS_METHODPR(T, GetNumParticles, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numParticles() const", AS_METHODPR(T, GetNumParticles, () const, unsigned), AS_CALL_THISCALL);

    // unsigned ParticleEffect::GetNumTextureFrames() const
    engine->RegisterObjectMethod(className, "uint GetNumTextureFrames() const", AS_METHODPR(T, GetNumTextureFrames, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numTextureFrames() const", AS_METHODPR(T, GetNumTextureFrames, () const, unsigned), AS_CALL_THISCALL);

    // Vector3 ParticleEffect::GetRandomDirection() const
    engine->RegisterObjectMethod(className, "Vector3 GetRandomDirection() const", AS_METHODPR(T, GetRandomDirection, () const, Vector3), AS_CALL_THISCALL);

    // float ParticleEffect::GetRandomRotation() const
    engine->RegisterObjectMethod(className, "float GetRandomRotation() const", AS_METHODPR(T, GetRandomRotation, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetRandomRotationSpeed() const
    engine->RegisterObjectMethod(className, "float GetRandomRotationSpeed() const", AS_METHODPR(T, GetRandomRotationSpeed, () const, float), AS_CALL_THISCALL);

    // Vector2 ParticleEffect::GetRandomSize() const
    engine->RegisterObjectMethod(className, "Vector2 GetRandomSize() const", AS_METHODPR(T, GetRandomSize, () const, Vector2), AS_CALL_THISCALL);

    // float ParticleEffect::GetRandomTimeToLive() const
    engine->RegisterObjectMethod(className, "float GetRandomTimeToLive() const", AS_METHODPR(T, GetRandomTimeToLive, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetRandomVelocity() const
    engine->RegisterObjectMethod(className, "float GetRandomVelocity() const", AS_METHODPR(T, GetRandomVelocity, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetSizeAdd() const
    engine->RegisterObjectMethod(className, "float GetSizeAdd() const", AS_METHODPR(T, GetSizeAdd, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_sizeAdd() const", AS_METHODPR(T, GetSizeAdd, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect::GetSizeMul() const
    engine->RegisterObjectMethod(className, "float GetSizeMul() const", AS_METHODPR(T, GetSizeMul, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_sizeMul() const", AS_METHODPR(T, GetSizeMul, () const, float), AS_CALL_THISCALL);

    // const TextureFrame* ParticleEffect::GetTextureFrame(unsigned index) const
    engine->RegisterObjectMethod(className, "TextureFrame@+ GetTextureFrame(uint) const", AS_METHODPR(T, GetTextureFrame, (unsigned) const, const TextureFrame*), AS_CALL_THISCALL);

    // bool ParticleEffect::GetUpdateInvisible() const
    engine->RegisterObjectMethod(className, "bool GetUpdateInvisible() const", AS_METHODPR(T, GetUpdateInvisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateInvisible() const", AS_METHODPR(T, GetUpdateInvisible, () const, bool), AS_CALL_THISCALL);

    // bool ParticleEffect::IsFixedScreenSize() const
    engine->RegisterObjectMethod(className, "bool IsFixedScreenSize() const", AS_METHODPR(T, IsFixedScreenSize, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedScreenSize() const", AS_METHODPR(T, IsFixedScreenSize, () const, bool), AS_CALL_THISCALL);

    // bool ParticleEffect::IsRelative() const
    engine->RegisterObjectMethod(className, "bool IsRelative() const", AS_METHODPR(T, IsRelative, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_relative() const", AS_METHODPR(T, IsRelative, () const, bool), AS_CALL_THISCALL);

    // bool ParticleEffect::IsScaled() const
    engine->RegisterObjectMethod(className, "bool IsScaled() const", AS_METHODPR(T, IsScaled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_scaled() const", AS_METHODPR(T, IsScaled, () const, bool), AS_CALL_THISCALL);

    // bool ParticleEffect::IsSorted() const
    engine->RegisterObjectMethod(className, "bool IsSorted() const", AS_METHODPR(T, IsSorted, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sorted() const", AS_METHODPR(T, IsSorted, () const, bool), AS_CALL_THISCALL);

    // bool ParticleEffect::Load(const XMLElement& source)
    engine->RegisterObjectMethod(className, "bool Load(const XMLElement&in)", AS_METHODPR(T, Load, (const XMLElement&), bool), AS_CALL_THISCALL);

    // void ParticleEffect::RemoveColorFrame(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveColorFrame(uint)", AS_METHODPR(T, RemoveColorFrame, (unsigned), void), AS_CALL_THISCALL);

    // void ParticleEffect::RemoveTextureFrame(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveTextureFrame(uint)", AS_METHODPR(T, RemoveTextureFrame, (unsigned), void), AS_CALL_THISCALL);

    // bool ParticleEffect::Save(XMLElement& dest) const
    engine->RegisterObjectMethod(className, "bool Save(XMLElement&) const", AS_METHODPR(T, Save, (XMLElement&) const, bool), AS_CALL_THISCALL);

    // void ParticleEffect::SetActiveTime(float time)
    engine->RegisterObjectMethod(className, "void SetActiveTime(float)", AS_METHODPR(T, SetActiveTime, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_activeTime(float)", AS_METHODPR(T, SetActiveTime, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetAnimationLodBias(float lodBias)
    engine->RegisterObjectMethod(className, "void SetAnimationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetColorFrame(unsigned index, const ColorFrame& colorFrame)
    engine->RegisterObjectMethod(className, "void SetColorFrame(uint, const ColorFrame&in)", AS_METHODPR(T, SetColorFrame, (unsigned, const ColorFrame&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetConstantForce(const Vector3& force)
    engine->RegisterObjectMethod(className, "void SetConstantForce(const Vector3&in)", AS_METHODPR(T, SetConstantForce, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_constantForce(const Vector3&in)", AS_METHODPR(T, SetConstantForce, (const Vector3&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetDampingForce(float force)
    engine->RegisterObjectMethod(className, "void SetDampingForce(float)", AS_METHODPR(T, SetDampingForce, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dampingForce(float)", AS_METHODPR(T, SetDampingForce, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetEmitterSize(const Vector3& size)
    engine->RegisterObjectMethod(className, "void SetEmitterSize(const Vector3&in)", AS_METHODPR(T, SetEmitterSize, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_emitterSize(const Vector3&in)", AS_METHODPR(T, SetEmitterSize, (const Vector3&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetEmitterType(EmitterType type)
    engine->RegisterObjectMethod(className, "void SetEmitterType(EmitterType)", AS_METHODPR(T, SetEmitterType, (EmitterType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_emitterType(EmitterType)", AS_METHODPR(T, SetEmitterType, (EmitterType), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetFaceCameraMode(FaceCameraMode mode)
    engine->RegisterObjectMethod(className, "void SetFaceCameraMode(FaceCameraMode)", AS_METHODPR(T, SetFaceCameraMode, (FaceCameraMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_faceCameraMode(FaceCameraMode)", AS_METHODPR(T, SetFaceCameraMode, (FaceCameraMode), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetFixedScreenSize(bool enable)
    engine->RegisterObjectMethod(className, "void SetFixedScreenSize(bool)", AS_METHODPR(T, SetFixedScreenSize, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedScreenSize(bool)", AS_METHODPR(T, SetFixedScreenSize, (bool), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetInactiveTime(float time)
    engine->RegisterObjectMethod(className, "void SetInactiveTime(float)", AS_METHODPR(T, SetInactiveTime, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_inactiveTime(float)", AS_METHODPR(T, SetInactiveTime, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxDirection(const Vector3& direction)
    engine->RegisterObjectMethod(className, "void SetMaxDirection(const Vector3&in)", AS_METHODPR(T, SetMaxDirection, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxDirection(const Vector3&in)", AS_METHODPR(T, SetMaxDirection, (const Vector3&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxEmissionRate(float rate)
    engine->RegisterObjectMethod(className, "void SetMaxEmissionRate(float)", AS_METHODPR(T, SetMaxEmissionRate, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxEmissionRate(float)", AS_METHODPR(T, SetMaxEmissionRate, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxParticleSize(const Vector2& size)
    engine->RegisterObjectMethod(className, "void SetMaxParticleSize(const Vector2&in)", AS_METHODPR(T, SetMaxParticleSize, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxParticleSize(const Vector2&in)", AS_METHODPR(T, SetMaxParticleSize, (const Vector2&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxRotation(float rotation)
    engine->RegisterObjectMethod(className, "void SetMaxRotation(float)", AS_METHODPR(T, SetMaxRotation, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxRotation(float)", AS_METHODPR(T, SetMaxRotation, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxRotationSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetMaxRotationSpeed(float)", AS_METHODPR(T, SetMaxRotationSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxRotationSpeed(float)", AS_METHODPR(T, SetMaxRotationSpeed, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxTimeToLive(float time)
    engine->RegisterObjectMethod(className, "void SetMaxTimeToLive(float)", AS_METHODPR(T, SetMaxTimeToLive, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxTimeToLive(float)", AS_METHODPR(T, SetMaxTimeToLive, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMaxVelocity(float velocity)
    engine->RegisterObjectMethod(className, "void SetMaxVelocity(float)", AS_METHODPR(T, SetMaxVelocity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxVelocity(float)", AS_METHODPR(T, SetMaxVelocity, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinDirection(const Vector3& direction)
    engine->RegisterObjectMethod(className, "void SetMinDirection(const Vector3&in)", AS_METHODPR(T, SetMinDirection, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minDirection(const Vector3&in)", AS_METHODPR(T, SetMinDirection, (const Vector3&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinEmissionRate(float rate)
    engine->RegisterObjectMethod(className, "void SetMinEmissionRate(float)", AS_METHODPR(T, SetMinEmissionRate, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minEmissionRate(float)", AS_METHODPR(T, SetMinEmissionRate, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinParticleSize(const Vector2& size)
    engine->RegisterObjectMethod(className, "void SetMinParticleSize(const Vector2&in)", AS_METHODPR(T, SetMinParticleSize, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minParticleSize(const Vector2&in)", AS_METHODPR(T, SetMinParticleSize, (const Vector2&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinRotation(float rotation)
    engine->RegisterObjectMethod(className, "void SetMinRotation(float)", AS_METHODPR(T, SetMinRotation, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minRotation(float)", AS_METHODPR(T, SetMinRotation, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinRotationSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetMinRotationSpeed(float)", AS_METHODPR(T, SetMinRotationSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minRotationSpeed(float)", AS_METHODPR(T, SetMinRotationSpeed, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinTimeToLive(float time)
    engine->RegisterObjectMethod(className, "void SetMinTimeToLive(float)", AS_METHODPR(T, SetMinTimeToLive, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minTimeToLive(float)", AS_METHODPR(T, SetMinTimeToLive, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetMinVelocity(float velocity)
    engine->RegisterObjectMethod(className, "void SetMinVelocity(float)", AS_METHODPR(T, SetMinVelocity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minVelocity(float)", AS_METHODPR(T, SetMinVelocity, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetNumColorFrames(unsigned number)
    engine->RegisterObjectMethod(className, "void SetNumColorFrames(uint)", AS_METHODPR(T, SetNumColorFrames, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numColorFrames(uint)", AS_METHODPR(T, SetNumColorFrames, (unsigned), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetNumParticles(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumParticles(uint)", AS_METHODPR(T, SetNumParticles, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numParticles(uint)", AS_METHODPR(T, SetNumParticles, (unsigned), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetNumTextureFrames(unsigned number)
    engine->RegisterObjectMethod(className, "void SetNumTextureFrames(uint)", AS_METHODPR(T, SetNumTextureFrames, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numTextureFrames(uint)", AS_METHODPR(T, SetNumTextureFrames, (unsigned), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetRelative(bool enable)
    engine->RegisterObjectMethod(className, "void SetRelative(bool)", AS_METHODPR(T, SetRelative, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_relative(bool)", AS_METHODPR(T, SetRelative, (bool), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetScaled(bool enable)
    engine->RegisterObjectMethod(className, "void SetScaled(bool)", AS_METHODPR(T, SetScaled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scaled(bool)", AS_METHODPR(T, SetScaled, (bool), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetSizeAdd(float sizeAdd)
    engine->RegisterObjectMethod(className, "void SetSizeAdd(float)", AS_METHODPR(T, SetSizeAdd, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sizeAdd(float)", AS_METHODPR(T, SetSizeAdd, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetSizeMul(float sizeMul)
    engine->RegisterObjectMethod(className, "void SetSizeMul(float)", AS_METHODPR(T, SetSizeMul, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sizeMul(float)", AS_METHODPR(T, SetSizeMul, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetSorted(bool enable)
    engine->RegisterObjectMethod(className, "void SetSorted(bool)", AS_METHODPR(T, SetSorted, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sorted(bool)", AS_METHODPR(T, SetSorted, (bool), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetTextureFrame(unsigned index, const TextureFrame& textureFrame)
    engine->RegisterObjectMethod(className, "void SetTextureFrame(uint, const TextureFrame&in)", AS_METHODPR(T, SetTextureFrame, (unsigned, const TextureFrame&), void), AS_CALL_THISCALL);

    // void ParticleEffect::SetUpdateInvisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetUpdateInvisible(bool)", AS_METHODPR(T, SetUpdateInvisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateInvisible(bool)", AS_METHODPR(T, SetUpdateInvisible, (bool), void), AS_CALL_THISCALL);

    // void ParticleEffect::SortColorFrames()
    engine->RegisterObjectMethod(className, "void SortColorFrames()", AS_METHODPR(T, SortColorFrames, (), void), AS_CALL_THISCALL);

    // void ParticleEffect::SortTextureFrames()
    engine->RegisterObjectMethod(className, "void SortTextureFrames()", AS_METHODPR(T, SortTextureFrames, (), void), AS_CALL_THISCALL);

    // static void ParticleEffect::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ParticleEffect
        REGISTER_MEMBERS_MANUAL_PART_ParticleEffect();
    #endif
}

// class ResourceWithMetadata | File: ../Resource/Resource.h
template <class T> void RegisterMembers_ResourceWithMetadata(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // void ResourceWithMetadata::AddMetadata(const String& name, const Variant& value)
    engine->RegisterObjectMethod(className, "void AddMetadata(const String&in, const Variant&in)", AS_METHODPR(T, AddMetadata, (const String&, const Variant&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_metadata(const String&in, const Variant&in)", AS_METHODPR(T, AddMetadata, (const String&, const Variant&), void), AS_CALL_THISCALL);

    // const Variant& ResourceWithMetadata::GetMetadata(const String& name) const
    engine->RegisterObjectMethod(className, "const Variant& GetMetadata(const String&in) const", AS_METHODPR(T, GetMetadata, (const String&) const, const Variant&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Variant& get_metadata(const String&in) const", AS_METHODPR(T, GetMetadata, (const String&) const, const Variant&), AS_CALL_THISCALL);

    // bool ResourceWithMetadata::HasMetadata() const
    engine->RegisterObjectMethod(className, "bool HasMetadata() const", AS_METHODPR(T, HasMetadata, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hasMetadata() const", AS_METHODPR(T, HasMetadata, () const, bool), AS_CALL_THISCALL);

    // void ResourceWithMetadata::RemoveAllMetadata()
    engine->RegisterObjectMethod(className, "void RemoveAllMetadata()", AS_METHODPR(T, RemoveAllMetadata, (), void), AS_CALL_THISCALL);

    // void ResourceWithMetadata::RemoveMetadata(const String& name)
    engine->RegisterObjectMethod(className, "void RemoveMetadata(const String&in)", AS_METHODPR(T, RemoveMetadata, (const String&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ResourceWithMetadata
        REGISTER_MEMBERS_MANUAL_PART_ResourceWithMetadata();
    #endif
}

// class Shader | File: ../Graphics/Shader.h
template <class T> void RegisterMembers_Shader(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // ShaderVariation* Shader::GetVariation(ShaderType type, const char* defines)
    // Error: type "const char*" can not automatically bind

    // const String& Shader::GetSourceCode(ShaderType type) const
    engine->RegisterObjectMethod(className, "const String& GetSourceCode(ShaderType) const", AS_METHODPR(T, GetSourceCode, (ShaderType) const, const String&), AS_CALL_THISCALL);

    // unsigned Shader::GetTimeStamp() const
    engine->RegisterObjectMethod(className, "uint GetTimeStamp() const", AS_METHODPR(T, GetTimeStamp, () const, unsigned), AS_CALL_THISCALL);

    // ShaderVariation* Shader::GetVariation(ShaderType type, const String& defines)
    engine->RegisterObjectMethod(className, "ShaderVariation@+ GetVariation(ShaderType, const String&in)", AS_METHODPR(T, GetVariation, (ShaderType, const String&), ShaderVariation*), AS_CALL_THISCALL);

    // static void Shader::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Shader
        REGISTER_MEMBERS_MANUAL_PART_Shader();
    #endif
}

// SharedPtr<Technique> Technique::Clone(const String& cloneName = String::EMPTY) const
template <class T> Technique* Technique_SharedPtrlesTechniquegre_Clone_constspStringamp_template(T* _ptr, const String& cloneName)
{
    SharedPtr<Technique> result = _ptr->Clone(cloneName);
    return result.Detach();
}

// SharedPtr<Technique> Technique::CloneWithDefines(const String& vsDefines, const String& psDefines)
template <class T> Technique* Technique_SharedPtrlesTechniquegre_CloneWithDefines_constspStringamp_constspStringamp_template(T* _ptr, const String& vsDefines, const String& psDefines)
{
    SharedPtr<Technique> result = _ptr->CloneWithDefines(vsDefines, psDefines);
    return result.Detach();
}

// PODVector<Pass*> Technique::GetPasses() const
template <class T> CScriptArray* Technique_PODVectorlesPassstargre_GetPasses_void_template(T* _ptr)
{
    PODVector<Pass*> result = _ptr->GetPasses();
    return VectorToHandleArray(result, "Array<Pass@>");
}

// Vector<String> Technique::GetPassNames() const
template <class T> CScriptArray* Technique_VectorlesStringgre_GetPassNames_void_template(T* _ptr)
{
    Vector<String> result = _ptr->GetPassNames();
    return VectorToArray<String>(result, "Array<String>");
}

// class Technique | File: ../Graphics/Technique.h
template <class T> void RegisterMembers_Technique(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // SharedPtr<Technique> Technique::Clone(const String& cloneName = String::EMPTY) const
    engine->RegisterObjectMethod(className, "Technique@+ Clone(const String&in = String::EMPTY) const", AS_FUNCTION_OBJFIRST(Technique_SharedPtrlesTechniquegre_Clone_constspStringamp_template<Technique>), AS_CALL_CDECL_OBJFIRST);

    // SharedPtr<Technique> Technique::CloneWithDefines(const String& vsDefines, const String& psDefines)
    engine->RegisterObjectMethod(className, "Technique@+ CloneWithDefines(const String&in, const String&in)", AS_FUNCTION_OBJFIRST(Technique_SharedPtrlesTechniquegre_CloneWithDefines_constspStringamp_constspStringamp_template<Technique>), AS_CALL_CDECL_OBJFIRST);

    // Pass* Technique::CreatePass(const String& name)
    engine->RegisterObjectMethod(className, "Pass@+ CreatePass(const String&in)", AS_METHODPR(T, CreatePass, (const String&), Pass*), AS_CALL_THISCALL);

    // unsigned Technique::GetNumPasses() const
    engine->RegisterObjectMethod(className, "uint GetNumPasses() const", AS_METHODPR(T, GetNumPasses, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numPasses() const", AS_METHODPR(T, GetNumPasses, () const, unsigned), AS_CALL_THISCALL);

    // Pass* Technique::GetPass(unsigned passIndex) const
    engine->RegisterObjectMethod(className, "Pass@+ GetPass(uint) const", AS_METHODPR(T, GetPass, (unsigned) const, Pass*), AS_CALL_THISCALL);

    // Pass* Technique::GetPass(const String& name) const
    engine->RegisterObjectMethod(className, "Pass@+ GetPass(const String&in) const", AS_METHODPR(T, GetPass, (const String&) const, Pass*), AS_CALL_THISCALL);

    // PODVector<Pass*> Technique::GetPasses() const
    engine->RegisterObjectMethod(className, "Array<Pass@>@ GetPasses() const", AS_FUNCTION_OBJFIRST(Technique_PODVectorlesPassstargre_GetPasses_void_template<Technique>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<Pass@>@ get_passes() const", AS_FUNCTION_OBJFIRST(Technique_PODVectorlesPassstargre_GetPasses_void_template<Technique>), AS_CALL_CDECL_OBJFIRST);

    // Vector<String> Technique::GetPassNames() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetPassNames() const", AS_FUNCTION_OBJFIRST(Technique_VectorlesStringgre_GetPassNames_void_template<Technique>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<String>@ get_passNames() const", AS_FUNCTION_OBJFIRST(Technique_VectorlesStringgre_GetPassNames_void_template<Technique>), AS_CALL_CDECL_OBJFIRST);

    // Pass* Technique::GetSupportedPass(unsigned passIndex) const
    engine->RegisterObjectMethod(className, "Pass@+ GetSupportedPass(uint) const", AS_METHODPR(T, GetSupportedPass, (unsigned) const, Pass*), AS_CALL_THISCALL);

    // Pass* Technique::GetSupportedPass(const String& name) const
    engine->RegisterObjectMethod(className, "Pass@+ GetSupportedPass(const String&in) const", AS_METHODPR(T, GetSupportedPass, (const String&) const, Pass*), AS_CALL_THISCALL);

    // bool Technique::HasPass(unsigned passIndex) const
    engine->RegisterObjectMethod(className, "bool HasPass(uint) const", AS_METHODPR(T, HasPass, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool Technique::HasPass(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasPass(const String&in) const", AS_METHODPR(T, HasPass, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Technique::IsDesktop() const
    engine->RegisterObjectMethod(className, "bool IsDesktop() const", AS_METHODPR(T, IsDesktop, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_desktop() const", AS_METHODPR(T, IsDesktop, () const, bool), AS_CALL_THISCALL);

    // bool Technique::IsSupported() const
    engine->RegisterObjectMethod(className, "bool IsSupported() const", AS_METHODPR(T, IsSupported, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_supported() const", AS_METHODPR(T, IsSupported, () const, bool), AS_CALL_THISCALL);

    // void Technique::ReleaseShaders()
    engine->RegisterObjectMethod(className, "void ReleaseShaders()", AS_METHODPR(T, ReleaseShaders, (), void), AS_CALL_THISCALL);

    // void Technique::RemovePass(const String& name)
    engine->RegisterObjectMethod(className, "void RemovePass(const String&in)", AS_METHODPR(T, RemovePass, (const String&), void), AS_CALL_THISCALL);

    // void Technique::SetIsDesktop(bool enable)
    engine->RegisterObjectMethod(className, "void SetIsDesktop(bool)", AS_METHODPR(T, SetIsDesktop, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_desktop(bool)", AS_METHODPR(T, SetIsDesktop, (bool), void), AS_CALL_THISCALL);

    // static void Technique::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    // static unsigned Technique::GetPassIndex(const String& passName)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint GetPassIndex(const String&in)", AS_FUNCTIONPR(T::GetPassIndex, (const String&), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Technique::basePassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint basePassIndex", (void*)&T::basePassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::alphaPassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint alphaPassIndex", (void*)&T::alphaPassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::materialPassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint materialPassIndex", (void*)&T::materialPassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::deferredPassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint deferredPassIndex", (void*)&T::deferredPassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::lightPassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint lightPassIndex", (void*)&T::lightPassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::litBasePassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint litBasePassIndex", (void*)&T::litBasePassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::litAlphaPassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint litAlphaPassIndex", (void*)&T::litAlphaPassIndex);engine->SetDefaultNamespace("");

    // static unsigned Technique::shadowPassIndex
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("uint shadowPassIndex", (void*)&T::shadowPassIndex);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Technique
        REGISTER_MEMBERS_MANUAL_PART_Technique();
    #endif
}

// class ValueAnimation | File: ../Scene/ValueAnimation.h
template <class T> void RegisterMembers_ValueAnimation(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // void ValueAnimation::GetEventFrames(float beginTime, float endTime, PODVector<const VAnimEventFrame*>& eventFrames) const
    // Error: type "PODVector<const VAnimEventFrame*>&" can not automatically bind
    // const Vector<VAnimKeyFrame>& ValueAnimation::GetKeyFrames() const
    // Error: type "const Vector<VAnimKeyFrame>&" can not automatically bind
    // void* ValueAnimation::GetOwner() const
    // Error: type "void*" can not automatically bind
    // void ValueAnimation::SetOwner(void* owner)
    // Error: type "void*" can not automatically bind

    // Variant ValueAnimation::GetAnimationValue(float scaledTime) const
    engine->RegisterObjectMethod(className, "Variant GetAnimationValue(float) const", AS_METHODPR(T, GetAnimationValue, (float) const, Variant), AS_CALL_THISCALL);

    // float ValueAnimation::GetBeginTime() const
    engine->RegisterObjectMethod(className, "float GetBeginTime() const", AS_METHODPR(T, GetBeginTime, () const, float), AS_CALL_THISCALL);

    // float ValueAnimation::GetEndTime() const
    engine->RegisterObjectMethod(className, "float GetEndTime() const", AS_METHODPR(T, GetEndTime, () const, float), AS_CALL_THISCALL);

    // InterpMethod ValueAnimation::GetInterpolationMethod() const
    engine->RegisterObjectMethod(className, "InterpMethod GetInterpolationMethod() const", AS_METHODPR(T, GetInterpolationMethod, () const, InterpMethod), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "InterpMethod get_interpolationMethod() const", AS_METHODPR(T, GetInterpolationMethod, () const, InterpMethod), AS_CALL_THISCALL);

    // float ValueAnimation::GetSplineTension() const
    engine->RegisterObjectMethod(className, "float GetSplineTension() const", AS_METHODPR(T, GetSplineTension, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_splineTension() const", AS_METHODPR(T, GetSplineTension, () const, float), AS_CALL_THISCALL);

    // VariantType ValueAnimation::GetValueType() const
    engine->RegisterObjectMethod(className, "VariantType GetValueType() const", AS_METHODPR(T, GetValueType, () const, VariantType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "VariantType get_valueType() const", AS_METHODPR(T, GetValueType, () const, VariantType), AS_CALL_THISCALL);

    // bool ValueAnimation::HasEventFrames() const
    engine->RegisterObjectMethod(className, "bool HasEventFrames() const", AS_METHODPR(T, HasEventFrames, () const, bool), AS_CALL_THISCALL);

    // bool ValueAnimation::IsValid() const
    engine->RegisterObjectMethod(className, "bool IsValid() const", AS_METHODPR(T, IsValid, () const, bool), AS_CALL_THISCALL);

    // bool ValueAnimation::LoadJSON(const JSONValue& source)
    engine->RegisterObjectMethod(className, "bool LoadJSON(const JSONValue&in)", AS_METHODPR(T, LoadJSON, (const JSONValue&), bool), AS_CALL_THISCALL);

    // bool ValueAnimation::LoadXML(const XMLElement& source)
    engine->RegisterObjectMethod(className, "bool LoadXML(const XMLElement&in)", AS_METHODPR(T, LoadXML, (const XMLElement&), bool), AS_CALL_THISCALL);

    // bool ValueAnimation::SaveJSON(JSONValue& dest) const
    engine->RegisterObjectMethod(className, "bool SaveJSON(JSONValue&) const", AS_METHODPR(T, SaveJSON, (JSONValue&) const, bool), AS_CALL_THISCALL);

    // bool ValueAnimation::SaveXML(XMLElement& dest) const
    engine->RegisterObjectMethod(className, "bool SaveXML(XMLElement&) const", AS_METHODPR(T, SaveXML, (XMLElement&) const, bool), AS_CALL_THISCALL);

    // void ValueAnimation::SetEventFrame(float time, const StringHash& eventType, const VariantMap& eventData = VariantMap())
    engine->RegisterObjectMethod(className, "void SetEventFrame(float, const StringHash&in, const VariantMap&in = VariantMap())", AS_METHODPR(T, SetEventFrame, (float, const StringHash&, const VariantMap&), void), AS_CALL_THISCALL);

    // void ValueAnimation::SetInterpolationMethod(InterpMethod method)
    engine->RegisterObjectMethod(className, "void SetInterpolationMethod(InterpMethod)", AS_METHODPR(T, SetInterpolationMethod, (InterpMethod), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_interpolationMethod(InterpMethod)", AS_METHODPR(T, SetInterpolationMethod, (InterpMethod), void), AS_CALL_THISCALL);

    // bool ValueAnimation::SetKeyFrame(float time, const Variant& value)
    engine->RegisterObjectMethod(className, "bool SetKeyFrame(float, const Variant&in)", AS_METHODPR(T, SetKeyFrame, (float, const Variant&), bool), AS_CALL_THISCALL);

    // void ValueAnimation::SetSplineTension(float tension)
    engine->RegisterObjectMethod(className, "void SetSplineTension(float)", AS_METHODPR(T, SetSplineTension, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_splineTension(float)", AS_METHODPR(T, SetSplineTension, (float), void), AS_CALL_THISCALL);

    // void ValueAnimation::SetValueType(VariantType valueType)
    engine->RegisterObjectMethod(className, "void SetValueType(VariantType)", AS_METHODPR(T, SetValueType, (VariantType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_valueType(VariantType)", AS_METHODPR(T, SetValueType, (VariantType), void), AS_CALL_THISCALL);

    // static void ValueAnimation::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ValueAnimation
        REGISTER_MEMBERS_MANUAL_PART_ValueAnimation();
    #endif
}

// class XMLFile | File: ../Resource/XMLFile.h
template <class T> void RegisterMembers_XMLFile(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // pugi::xml_document* XMLFile::GetDocument() const
    // Error: type "pugi::xml_document*" can not automatically bind

    // XMLElement XMLFile::CreateRoot(const String& name)
    engine->RegisterObjectMethod(className, "XMLElement CreateRoot(const String&in)", AS_METHODPR(T, CreateRoot, (const String&), XMLElement), AS_CALL_THISCALL);

    // bool XMLFile::FromString(const String& source)
    engine->RegisterObjectMethod(className, "bool FromString(const String&in)", AS_METHODPR(T, FromString, (const String&), bool), AS_CALL_THISCALL);

    // XMLElement XMLFile::GetOrCreateRoot(const String& name)
    engine->RegisterObjectMethod(className, "XMLElement GetOrCreateRoot(const String&in)", AS_METHODPR(T, GetOrCreateRoot, (const String&), XMLElement), AS_CALL_THISCALL);

    // XMLElement XMLFile::GetRoot(const String& name = String::EMPTY)
    engine->RegisterObjectMethod(className, "XMLElement GetRoot(const String&in = String::EMPTY)", AS_METHODPR(T, GetRoot, (const String&), XMLElement), AS_CALL_THISCALL);

    // void XMLFile::Patch(XMLFile* patchFile)
    engine->RegisterObjectMethod(className, "void Patch(XMLFile@+)", AS_METHODPR(T, Patch, (XMLFile*), void), AS_CALL_THISCALL);

    // void XMLFile::Patch(const XMLElement& patchElement)
    engine->RegisterObjectMethod(className, "void Patch(const XMLElement&in)", AS_METHODPR(T, Patch, (const XMLElement&), void), AS_CALL_THISCALL);

    // bool XMLFile::Save(Serializer& dest, const String& indentation) const
    engine->RegisterObjectMethod(className, "bool Save(Serializer&, const String&in) const", AS_METHODPR(T, Save, (Serializer&, const String&) const, bool), AS_CALL_THISCALL);

    // String XMLFile::ToString(const String& indentation = "\t") const
    engine->RegisterObjectMethod(className, "String ToString(const String&in = \"\t\") const", AS_METHODPR(T, ToString, (const String&) const, String), AS_CALL_THISCALL);

    // static void XMLFile::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_XMLFile
        REGISTER_MEMBERS_MANUAL_PART_XMLFile();
    #endif
}

#ifdef URHO3D_URHO2D

// class AnimationSet2D | File: ../Urho2D/AnimationSet2D.h
template <class T> void RegisterMembers_AnimationSet2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // Spriter::SpriterData* AnimationSet2D::GetSpriterData() const
    // Error: type "Spriter::SpriterData*" can not automatically bind

    // String AnimationSet2D::GetAnimation(unsigned index) const
    engine->RegisterObjectMethod(className, "String GetAnimation(uint) const", AS_METHODPR(T, GetAnimation, (unsigned) const, String), AS_CALL_THISCALL);

    // unsigned AnimationSet2D::GetNumAnimations() const
    engine->RegisterObjectMethod(className, "uint GetNumAnimations() const", AS_METHODPR(T, GetNumAnimations, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAnimations() const", AS_METHODPR(T, GetNumAnimations, () const, unsigned), AS_CALL_THISCALL);

    // Sprite2D* AnimationSet2D::GetSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // Sprite2D* AnimationSet2D::GetSpriterFileSprite(int folderId, int fileId) const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSpriterFileSprite(int, int) const", AS_METHODPR(T, GetSpriterFileSprite, (int, int) const, Sprite2D*), AS_CALL_THISCALL);

    // bool AnimationSet2D::HasAnimation(const String& animationName) const
    engine->RegisterObjectMethod(className, "bool HasAnimation(const String&in) const", AS_METHODPR(T, HasAnimation, (const String&) const, bool), AS_CALL_THISCALL);

    // static void AnimationSet2D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationSet2D
        REGISTER_MEMBERS_MANUAL_PART_AnimationSet2D();
    #endif
}

// SharedPtr<ParticleEffect2D> ParticleEffect2D::Clone(const String& cloneName = String::EMPTY) const
template <class T> ParticleEffect2D* ParticleEffect2D_SharedPtrlesParticleEffect2Dgre_Clone_constspStringamp_template(T* _ptr, const String& cloneName)
{
    SharedPtr<ParticleEffect2D> result = _ptr->Clone(cloneName);
    return result.Detach();
}

// class ParticleEffect2D | File: ../Urho2D/ParticleEffect2D.h
template <class T> void RegisterMembers_ParticleEffect2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // SharedPtr<ParticleEffect2D> ParticleEffect2D::Clone(const String& cloneName = String::EMPTY) const
    engine->RegisterObjectMethod(className, "ParticleEffect2D@+ Clone(const String&in = String::EMPTY) const", AS_FUNCTION_OBJFIRST(ParticleEffect2D_SharedPtrlesParticleEffect2Dgre_Clone_constspStringamp_template<ParticleEffect2D>), AS_CALL_CDECL_OBJFIRST);

    // float ParticleEffect2D::GetAngle() const
    engine->RegisterObjectMethod(className, "float GetAngle() const", AS_METHODPR(T, GetAngle, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetAngleVariance() const
    engine->RegisterObjectMethod(className, "float GetAngleVariance() const", AS_METHODPR(T, GetAngleVariance, () const, float), AS_CALL_THISCALL);

    // BlendMode ParticleEffect2D::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetDuration() const
    engine->RegisterObjectMethod(className, "float GetDuration() const", AS_METHODPR(T, GetDuration, () const, float), AS_CALL_THISCALL);

    // EmitterType2D ParticleEffect2D::GetEmitterType() const
    engine->RegisterObjectMethod(className, "EmitterType2D GetEmitterType() const", AS_METHODPR(T, GetEmitterType, () const, EmitterType2D), AS_CALL_THISCALL);

    // const Color& ParticleEffect2D::GetFinishColor() const
    engine->RegisterObjectMethod(className, "const Color& GetFinishColor() const", AS_METHODPR(T, GetFinishColor, () const, const Color&), AS_CALL_THISCALL);

    // const Color& ParticleEffect2D::GetFinishColorVariance() const
    engine->RegisterObjectMethod(className, "const Color& GetFinishColorVariance() const", AS_METHODPR(T, GetFinishColorVariance, () const, const Color&), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetFinishParticleSize() const
    engine->RegisterObjectMethod(className, "float GetFinishParticleSize() const", AS_METHODPR(T, GetFinishParticleSize, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetFinishParticleSizeVariance() const
    engine->RegisterObjectMethod(className, "float GetFinishParticleSizeVariance() const", AS_METHODPR(T, GetFinishParticleSizeVariance, () const, float), AS_CALL_THISCALL);

    // const Vector2& ParticleEffect2D::GetGravity() const
    engine->RegisterObjectMethod(className, "const Vector2& GetGravity() const", AS_METHODPR(T, GetGravity, () const, const Vector2&), AS_CALL_THISCALL);

    // int ParticleEffect2D::GetMaxParticles() const
    engine->RegisterObjectMethod(className, "int GetMaxParticles() const", AS_METHODPR(T, GetMaxParticles, () const, int), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetMaxRadius() const
    engine->RegisterObjectMethod(className, "float GetMaxRadius() const", AS_METHODPR(T, GetMaxRadius, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetMaxRadiusVariance() const
    engine->RegisterObjectMethod(className, "float GetMaxRadiusVariance() const", AS_METHODPR(T, GetMaxRadiusVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetMinRadius() const
    engine->RegisterObjectMethod(className, "float GetMinRadius() const", AS_METHODPR(T, GetMinRadius, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetMinRadiusVariance() const
    engine->RegisterObjectMethod(className, "float GetMinRadiusVariance() const", AS_METHODPR(T, GetMinRadiusVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetParticleLifeSpan() const
    engine->RegisterObjectMethod(className, "float GetParticleLifeSpan() const", AS_METHODPR(T, GetParticleLifeSpan, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetParticleLifespanVariance() const
    engine->RegisterObjectMethod(className, "float GetParticleLifespanVariance() const", AS_METHODPR(T, GetParticleLifespanVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRadialAcceleration() const
    engine->RegisterObjectMethod(className, "float GetRadialAcceleration() const", AS_METHODPR(T, GetRadialAcceleration, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRadialAccelVariance() const
    engine->RegisterObjectMethod(className, "float GetRadialAccelVariance() const", AS_METHODPR(T, GetRadialAccelVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRotatePerSecond() const
    engine->RegisterObjectMethod(className, "float GetRotatePerSecond() const", AS_METHODPR(T, GetRotatePerSecond, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRotatePerSecondVariance() const
    engine->RegisterObjectMethod(className, "float GetRotatePerSecondVariance() const", AS_METHODPR(T, GetRotatePerSecondVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRotationEnd() const
    engine->RegisterObjectMethod(className, "float GetRotationEnd() const", AS_METHODPR(T, GetRotationEnd, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRotationEndVariance() const
    engine->RegisterObjectMethod(className, "float GetRotationEndVariance() const", AS_METHODPR(T, GetRotationEndVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRotationStart() const
    engine->RegisterObjectMethod(className, "float GetRotationStart() const", AS_METHODPR(T, GetRotationStart, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetRotationStartVariance() const
    engine->RegisterObjectMethod(className, "float GetRotationStartVariance() const", AS_METHODPR(T, GetRotationStartVariance, () const, float), AS_CALL_THISCALL);

    // const Vector2& ParticleEffect2D::GetSourcePositionVariance() const
    engine->RegisterObjectMethod(className, "const Vector2& GetSourcePositionVariance() const", AS_METHODPR(T, GetSourcePositionVariance, () const, const Vector2&), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetSpeed() const
    engine->RegisterObjectMethod(className, "float GetSpeed() const", AS_METHODPR(T, GetSpeed, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetSpeedVariance() const
    engine->RegisterObjectMethod(className, "float GetSpeedVariance() const", AS_METHODPR(T, GetSpeedVariance, () const, float), AS_CALL_THISCALL);

    // Sprite2D* ParticleEffect2D::GetSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // const Color& ParticleEffect2D::GetStartColor() const
    engine->RegisterObjectMethod(className, "const Color& GetStartColor() const", AS_METHODPR(T, GetStartColor, () const, const Color&), AS_CALL_THISCALL);

    // const Color& ParticleEffect2D::GetStartColorVariance() const
    engine->RegisterObjectMethod(className, "const Color& GetStartColorVariance() const", AS_METHODPR(T, GetStartColorVariance, () const, const Color&), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetStartParticleSize() const
    engine->RegisterObjectMethod(className, "float GetStartParticleSize() const", AS_METHODPR(T, GetStartParticleSize, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetStartParticleSizeVariance() const
    engine->RegisterObjectMethod(className, "float GetStartParticleSizeVariance() const", AS_METHODPR(T, GetStartParticleSizeVariance, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetTangentialAcceleration() const
    engine->RegisterObjectMethod(className, "float GetTangentialAcceleration() const", AS_METHODPR(T, GetTangentialAcceleration, () const, float), AS_CALL_THISCALL);

    // float ParticleEffect2D::GetTangentialAccelVariance() const
    engine->RegisterObjectMethod(className, "float GetTangentialAccelVariance() const", AS_METHODPR(T, GetTangentialAccelVariance, () const, float), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetAngle(float angle)
    engine->RegisterObjectMethod(className, "void SetAngle(float)", AS_METHODPR(T, SetAngle, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetAngleVariance(float angleVariance)
    engine->RegisterObjectMethod(className, "void SetAngleVariance(float)", AS_METHODPR(T, SetAngleVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetBlendMode(BlendMode blendMode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetDuration(float duration)
    engine->RegisterObjectMethod(className, "void SetDuration(float)", AS_METHODPR(T, SetDuration, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetEmitterType(EmitterType2D emitterType)
    engine->RegisterObjectMethod(className, "void SetEmitterType(EmitterType2D)", AS_METHODPR(T, SetEmitterType, (EmitterType2D), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetFinishColor(const Color& finishColor)
    engine->RegisterObjectMethod(className, "void SetFinishColor(const Color&in)", AS_METHODPR(T, SetFinishColor, (const Color&), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetFinishColorVariance(const Color& finishColorVariance)
    engine->RegisterObjectMethod(className, "void SetFinishColorVariance(const Color&in)", AS_METHODPR(T, SetFinishColorVariance, (const Color&), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetFinishParticleSize(float finishParticleSize)
    engine->RegisterObjectMethod(className, "void SetFinishParticleSize(float)", AS_METHODPR(T, SetFinishParticleSize, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetFinishParticleSizeVariance(float finishParticleSizeVariance)
    engine->RegisterObjectMethod(className, "void SetFinishParticleSizeVariance(float)", AS_METHODPR(T, SetFinishParticleSizeVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetGravity(const Vector2& gravity)
    engine->RegisterObjectMethod(className, "void SetGravity(const Vector2&in)", AS_METHODPR(T, SetGravity, (const Vector2&), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetMaxParticles(int maxParticles)
    engine->RegisterObjectMethod(className, "void SetMaxParticles(int)", AS_METHODPR(T, SetMaxParticles, (int), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetMaxRadius(float maxRadius)
    engine->RegisterObjectMethod(className, "void SetMaxRadius(float)", AS_METHODPR(T, SetMaxRadius, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetMaxRadiusVariance(float maxRadiusVariance)
    engine->RegisterObjectMethod(className, "void SetMaxRadiusVariance(float)", AS_METHODPR(T, SetMaxRadiusVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetMinRadius(float minRadius)
    engine->RegisterObjectMethod(className, "void SetMinRadius(float)", AS_METHODPR(T, SetMinRadius, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetMinRadiusVariance(float minRadiusVariance)
    engine->RegisterObjectMethod(className, "void SetMinRadiusVariance(float)", AS_METHODPR(T, SetMinRadiusVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetParticleLifeSpan(float particleLifeSpan)
    engine->RegisterObjectMethod(className, "void SetParticleLifeSpan(float)", AS_METHODPR(T, SetParticleLifeSpan, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetParticleLifespanVariance(float particleLifespanVariance)
    engine->RegisterObjectMethod(className, "void SetParticleLifespanVariance(float)", AS_METHODPR(T, SetParticleLifespanVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRadialAcceleration(float radialAcceleration)
    engine->RegisterObjectMethod(className, "void SetRadialAcceleration(float)", AS_METHODPR(T, SetRadialAcceleration, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRadialAccelVariance(float radialAccelVariance)
    engine->RegisterObjectMethod(className, "void SetRadialAccelVariance(float)", AS_METHODPR(T, SetRadialAccelVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRotatePerSecond(float rotatePerSecond)
    engine->RegisterObjectMethod(className, "void SetRotatePerSecond(float)", AS_METHODPR(T, SetRotatePerSecond, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRotatePerSecondVariance(float rotatePerSecondVariance)
    engine->RegisterObjectMethod(className, "void SetRotatePerSecondVariance(float)", AS_METHODPR(T, SetRotatePerSecondVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRotationEnd(float rotationEnd)
    engine->RegisterObjectMethod(className, "void SetRotationEnd(float)", AS_METHODPR(T, SetRotationEnd, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRotationEndVariance(float rotationEndVariance)
    engine->RegisterObjectMethod(className, "void SetRotationEndVariance(float)", AS_METHODPR(T, SetRotationEndVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRotationStart(float rotationStart)
    engine->RegisterObjectMethod(className, "void SetRotationStart(float)", AS_METHODPR(T, SetRotationStart, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetRotationStartVariance(float rotationStartVariance)
    engine->RegisterObjectMethod(className, "void SetRotationStartVariance(float)", AS_METHODPR(T, SetRotationStartVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetSourcePositionVariance(const Vector2& sourcePositionVariance)
    engine->RegisterObjectMethod(className, "void SetSourcePositionVariance(const Vector2&in)", AS_METHODPR(T, SetSourcePositionVariance, (const Vector2&), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetSpeed(float)", AS_METHODPR(T, SetSpeed, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetSpeedVariance(float speedVariance)
    engine->RegisterObjectMethod(className, "void SetSpeedVariance(float)", AS_METHODPR(T, SetSpeedVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetSprite(Sprite2D* sprite)
    engine->RegisterObjectMethod(className, "void SetSprite(Sprite2D@+)", AS_METHODPR(T, SetSprite, (Sprite2D*), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetStartColor(const Color& startColor)
    engine->RegisterObjectMethod(className, "void SetStartColor(const Color&in)", AS_METHODPR(T, SetStartColor, (const Color&), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetStartColorVariance(const Color& startColorVariance)
    engine->RegisterObjectMethod(className, "void SetStartColorVariance(const Color&in)", AS_METHODPR(T, SetStartColorVariance, (const Color&), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetStartParticleSize(float startParticleSize)
    engine->RegisterObjectMethod(className, "void SetStartParticleSize(float)", AS_METHODPR(T, SetStartParticleSize, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetStartParticleSizeVariance(float startParticleSizeVariance)
    engine->RegisterObjectMethod(className, "void SetStartParticleSizeVariance(float)", AS_METHODPR(T, SetStartParticleSizeVariance, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetTangentialAcceleration(float tangentialAcceleration)
    engine->RegisterObjectMethod(className, "void SetTangentialAcceleration(float)", AS_METHODPR(T, SetTangentialAcceleration, (float), void), AS_CALL_THISCALL);

    // void ParticleEffect2D::SetTangentialAccelVariance(float tangentialAccelVariance)
    engine->RegisterObjectMethod(className, "void SetTangentialAccelVariance(float)", AS_METHODPR(T, SetTangentialAccelVariance, (float), void), AS_CALL_THISCALL);

    // static void ParticleEffect2D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ParticleEffect2D
        REGISTER_MEMBERS_MANUAL_PART_ParticleEffect2D();
    #endif
}

// class Sprite2D | File: ../Urho2D/Sprite2D.h
template <class T> void RegisterMembers_Sprite2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // bool Sprite2D::GetDrawRectangle(Rect& rect, bool flipX = false, bool flipY = false) const
    engine->RegisterObjectMethod(className, "bool GetDrawRectangle(Rect&, bool = false, bool = false) const", AS_METHODPR(T, GetDrawRectangle, (Rect&, bool, bool) const, bool), AS_CALL_THISCALL);

    // bool Sprite2D::GetDrawRectangle(Rect& rect, const Vector2& hotSpot, bool flipX = false, bool flipY = false) const
    engine->RegisterObjectMethod(className, "bool GetDrawRectangle(Rect&, const Vector2&in, bool = false, bool = false) const", AS_METHODPR(T, GetDrawRectangle, (Rect&, const Vector2&, bool, bool) const, bool), AS_CALL_THISCALL);

    // const Vector2& Sprite2D::GetHotSpot() const
    engine->RegisterObjectMethod(className, "const Vector2& GetHotSpot() const", AS_METHODPR(T, GetHotSpot, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_hotSpot() const", AS_METHODPR(T, GetHotSpot, () const, const Vector2&), AS_CALL_THISCALL);

    // const IntVector2& Sprite2D::GetOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetOffset() const", AS_METHODPR(T, GetOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_offset() const", AS_METHODPR(T, GetOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntRect& Sprite2D::GetRectangle() const
    engine->RegisterObjectMethod(className, "const IntRect& GetRectangle() const", AS_METHODPR(T, GetRectangle, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_rectangle() const", AS_METHODPR(T, GetRectangle, () const, const IntRect&), AS_CALL_THISCALL);

    // SpriteSheet2D* Sprite2D::GetSpriteSheet() const
    engine->RegisterObjectMethod(className, "SpriteSheet2D@+ GetSpriteSheet() const", AS_METHODPR(T, GetSpriteSheet, () const, SpriteSheet2D*), AS_CALL_THISCALL);

    // Texture2D* Sprite2D::GetTexture() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetTexture() const", AS_METHODPR(T, GetTexture, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_texture() const", AS_METHODPR(T, GetTexture, () const, Texture2D*), AS_CALL_THISCALL);

    // float Sprite2D::GetTextureEdgeOffset() const
    engine->RegisterObjectMethod(className, "float GetTextureEdgeOffset() const", AS_METHODPR(T, GetTextureEdgeOffset, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_textureEdgeOffset() const", AS_METHODPR(T, GetTextureEdgeOffset, () const, float), AS_CALL_THISCALL);

    // bool Sprite2D::GetTextureRectangle(Rect& rect, bool flipX = false, bool flipY = false) const
    engine->RegisterObjectMethod(className, "bool GetTextureRectangle(Rect&, bool = false, bool = false) const", AS_METHODPR(T, GetTextureRectangle, (Rect&, bool, bool) const, bool), AS_CALL_THISCALL);

    // void Sprite2D::SetHotSpot(const Vector2& hotSpot)
    engine->RegisterObjectMethod(className, "void SetHotSpot(const Vector2&in)", AS_METHODPR(T, SetHotSpot, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hotSpot(const Vector2&in)", AS_METHODPR(T, SetHotSpot, (const Vector2&), void), AS_CALL_THISCALL);

    // void Sprite2D::SetOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetOffset(const IntVector2&in)", AS_METHODPR(T, SetOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_offset(const IntVector2&in)", AS_METHODPR(T, SetOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Sprite2D::SetRectangle(const IntRect& rectangle)
    engine->RegisterObjectMethod(className, "void SetRectangle(const IntRect&in)", AS_METHODPR(T, SetRectangle, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rectangle(const IntRect&in)", AS_METHODPR(T, SetRectangle, (const IntRect&), void), AS_CALL_THISCALL);

    // void Sprite2D::SetSpriteSheet(SpriteSheet2D* spriteSheet)
    engine->RegisterObjectMethod(className, "void SetSpriteSheet(SpriteSheet2D@+)", AS_METHODPR(T, SetSpriteSheet, (SpriteSheet2D*), void), AS_CALL_THISCALL);

    // void Sprite2D::SetTexture(Texture2D* texture)
    engine->RegisterObjectMethod(className, "void SetTexture(Texture2D@+)", AS_METHODPR(T, SetTexture, (Texture2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_texture(Texture2D@+)", AS_METHODPR(T, SetTexture, (Texture2D*), void), AS_CALL_THISCALL);

    // void Sprite2D::SetTextureEdgeOffset(float offset)
    engine->RegisterObjectMethod(className, "void SetTextureEdgeOffset(float)", AS_METHODPR(T, SetTextureEdgeOffset, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textureEdgeOffset(float)", AS_METHODPR(T, SetTextureEdgeOffset, (float), void), AS_CALL_THISCALL);

    // static void Sprite2D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    // static ResourceRef Sprite2D::SaveToResourceRef(Sprite2D* sprite)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("ResourceRef SaveToResourceRef(Sprite2D@+)", AS_FUNCTIONPR(T::SaveToResourceRef, (Sprite2D*), ResourceRef), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static Sprite2D* Sprite2D::LoadFromResourceRef(Object* object, const ResourceRef& value)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("Sprite2D@+ LoadFromResourceRef(Object@+, const ResourceRef&in)", AS_FUNCTIONPR(T::LoadFromResourceRef, (Object*, const ResourceRef&), Sprite2D*), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Sprite2D
        REGISTER_MEMBERS_MANUAL_PART_Sprite2D();
    #endif
}

// class SpriteSheet2D | File: ../Urho2D/SpriteSheet2D.h
template <class T> void RegisterMembers_SpriteSheet2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // const HashMap<String, SharedPtr<Sprite2D>>& SpriteSheet2D::GetSpriteMapping() const
    // Error: type "const HashMap<String, SharedPtr<Sprite2D>>&" can not automatically bind

    // void SpriteSheet2D::DefineSprite(const String& name, const IntRect& rectangle, const Vector2& hotSpot = Vector2(0.5f, 0.5f), const IntVector2& offset = IntVector2::ZERO)
    engine->RegisterObjectMethod(className, "void DefineSprite(const String&in, const IntRect&in, const Vector2&in = Vector2(0.5f, 0.5f), const IntVector2&in = IntVector2::ZERO)", AS_METHODPR(T, DefineSprite, (const String&, const IntRect&, const Vector2&, const IntVector2&), void), AS_CALL_THISCALL);

    // Sprite2D* SpriteSheet2D::GetSprite(const String& name) const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite(const String&in) const", AS_METHODPR(T, GetSprite, (const String&) const, Sprite2D*), AS_CALL_THISCALL);

    // Texture2D* SpriteSheet2D::GetTexture() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetTexture() const", AS_METHODPR(T, GetTexture, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_texture() const", AS_METHODPR(T, GetTexture, () const, Texture2D*), AS_CALL_THISCALL);

    // void SpriteSheet2D::SetTexture(Texture2D* texture)
    engine->RegisterObjectMethod(className, "void SetTexture(Texture2D@+)", AS_METHODPR(T, SetTexture, (Texture2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_texture(Texture2D@+)", AS_METHODPR(T, SetTexture, (Texture2D*), void), AS_CALL_THISCALL);

    // static void SpriteSheet2D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SpriteSheet2D
        REGISTER_MEMBERS_MANUAL_PART_SpriteSheet2D();
    #endif
}

// Vector<SharedPtr<TileMapObject2D>> TmxFile2D::GetTileCollisionShapes(unsigned gid) const
template <class T> CScriptArray* TmxFile2D_VectorlesSharedPtrlesTileMapObject2Dgregre_GetTileCollisionShapes_unsigned_template(T* _ptr, unsigned gid)
{
    Vector<SharedPtr<TileMapObject2D>> result = _ptr->GetTileCollisionShapes(gid);
    return VectorToHandleArray(result, "Array<TileMapObject2D@>");
}

// class TmxFile2D | File: ../Urho2D/TmxFile2D.h
template <class T> void RegisterMembers_TmxFile2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Resource<T>(engine, className);

    // void TmxFile2D::AddLayer(Urho3D::TmxLayer2D* layer)
    // Error: type "Urho3D::TmxLayer2D*" can not automatically bind

    // void TmxFile2D::AddLayer(unsigned index, TmxLayer2D* layer)
    engine->RegisterObjectMethod(className, "void AddLayer(uint, TmxLayer2D@+)", AS_METHODPR(T, AddLayer, (unsigned, TmxLayer2D*), void), AS_CALL_THISCALL);

    // const TileMapInfo2D& TmxFile2D::GetInfo() const
    engine->RegisterObjectMethod(className, "const TileMapInfo2D& GetInfo() const", AS_METHODPR(T, GetInfo, () const, const TileMapInfo2D&), AS_CALL_THISCALL);

    // const TmxLayer2D* TmxFile2D::GetLayer(unsigned index) const
    engine->RegisterObjectMethod(className, "TmxLayer2D@+ GetLayer(uint) const", AS_METHODPR(T, GetLayer, (unsigned) const, const TmxLayer2D*), AS_CALL_THISCALL);

    // unsigned TmxFile2D::GetNumLayers() const
    engine->RegisterObjectMethod(className, "uint GetNumLayers() const", AS_METHODPR(T, GetNumLayers, () const, unsigned), AS_CALL_THISCALL);

    // float TmxFile2D::GetSpriteTextureEdgeOffset() const
    engine->RegisterObjectMethod(className, "float GetSpriteTextureEdgeOffset() const", AS_METHODPR(T, GetSpriteTextureEdgeOffset, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_edgeOffset() const", AS_METHODPR(T, GetSpriteTextureEdgeOffset, () const, float), AS_CALL_THISCALL);

    // Vector<SharedPtr<TileMapObject2D>> TmxFile2D::GetTileCollisionShapes(unsigned gid) const
    engine->RegisterObjectMethod(className, "Array<TileMapObject2D@>@ GetTileCollisionShapes(uint) const", AS_FUNCTION_OBJFIRST(TmxFile2D_VectorlesSharedPtrlesTileMapObject2Dgregre_GetTileCollisionShapes_unsigned_template<TmxFile2D>), AS_CALL_CDECL_OBJFIRST);

    // PropertySet2D* TmxFile2D::GetTilePropertySet(unsigned gid) const
    engine->RegisterObjectMethod(className, "PropertySet2D@+ GetTilePropertySet(uint) const", AS_METHODPR(T, GetTilePropertySet, (unsigned) const, PropertySet2D*), AS_CALL_THISCALL);

    // Sprite2D* TmxFile2D::GetTileSprite(unsigned gid) const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetTileSprite(uint) const", AS_METHODPR(T, GetTileSprite, (unsigned) const, Sprite2D*), AS_CALL_THISCALL);

    // bool TmxFile2D::SetInfo(Orientation2D orientation, int width, int height, float tileWidth, float tileHeight)
    engine->RegisterObjectMethod(className, "bool SetInfo(Orientation2D, int, int, float, float)", AS_METHODPR(T, SetInfo, (Orientation2D, int, int, float, float), bool), AS_CALL_THISCALL);

    // void TmxFile2D::SetSpriteTextureEdgeOffset(float offset)
    engine->RegisterObjectMethod(className, "void SetSpriteTextureEdgeOffset(float)", AS_METHODPR(T, SetSpriteTextureEdgeOffset, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_edgeOffset(float)", AS_METHODPR(T, SetSpriteTextureEdgeOffset, (float), void), AS_CALL_THISCALL);

    // static void TmxFile2D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TmxFile2D
        REGISTER_MEMBERS_MANUAL_PART_TmxFile2D();
    #endif
}

#endif // def URHO3D_URHO2D

// SharedPtr<Animation> Animation::Clone(const String& cloneName = String::EMPTY) const
template <class T> Animation* Animation_SharedPtrlesAnimationgre_Clone_constspStringamp_template(T* _ptr, const String& cloneName)
{
    SharedPtr<Animation> result = _ptr->Clone(cloneName);
    return result.Detach();
}

// class Animation | File: ../Graphics/Animation.h
template <class T> void RegisterMembers_Animation(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ResourceWithMetadata<T>(engine, className);

    // const HashMap<StringHash, AnimationTrack>& Animation::GetTracks() const
    // Error: type "const HashMap<StringHash, AnimationTrack>&" can not automatically bind
    // AnimationTriggerPoint* Animation::GetTrigger(unsigned index)
    // Error: type "AnimationTriggerPoint*" can not automatically bind
    // const Vector<AnimationTriggerPoint>& Animation::GetTriggers() const
    // Error: type "const Vector<AnimationTriggerPoint>&" can not automatically bind

    // void Animation::AddTrigger(const AnimationTriggerPoint& trigger)
    engine->RegisterObjectMethod(className, "void AddTrigger(const AnimationTriggerPoint&in)", AS_METHODPR(T, AddTrigger, (const AnimationTriggerPoint&), void), AS_CALL_THISCALL);

    // void Animation::AddTrigger(float time, bool timeIsNormalized, const Variant& data)
    engine->RegisterObjectMethod(className, "void AddTrigger(float, bool, const Variant&in)", AS_METHODPR(T, AddTrigger, (float, bool, const Variant&), void), AS_CALL_THISCALL);

    // SharedPtr<Animation> Animation::Clone(const String& cloneName = String::EMPTY) const
    engine->RegisterObjectMethod(className, "Animation@+ Clone(const String&in = String::EMPTY) const", AS_FUNCTION_OBJFIRST(Animation_SharedPtrlesAnimationgre_Clone_constspStringamp_template<Animation>), AS_CALL_CDECL_OBJFIRST);

    // AnimationTrack* Animation::CreateTrack(const String& name)
    engine->RegisterObjectMethod(className, "AnimationTrack@+ CreateTrack(const String&in)", AS_METHODPR(T, CreateTrack, (const String&), AnimationTrack*), AS_CALL_THISCALL);

    // const String& Animation::GetAnimationName() const
    engine->RegisterObjectMethod(className, "const String& GetAnimationName() const", AS_METHODPR(T, GetAnimationName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_animationName() const", AS_METHODPR(T, GetAnimationName, () const, const String&), AS_CALL_THISCALL);

    // StringHash Animation::GetAnimationNameHash() const
    engine->RegisterObjectMethod(className, "StringHash GetAnimationNameHash() const", AS_METHODPR(T, GetAnimationNameHash, () const, StringHash), AS_CALL_THISCALL);

    // float Animation::GetLength() const
    engine->RegisterObjectMethod(className, "float GetLength() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);

    // unsigned Animation::GetNumTracks() const
    engine->RegisterObjectMethod(className, "uint GetNumTracks() const", AS_METHODPR(T, GetNumTracks, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numTracks() const", AS_METHODPR(T, GetNumTracks, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Animation::GetNumTriggers() const
    engine->RegisterObjectMethod(className, "uint GetNumTriggers() const", AS_METHODPR(T, GetNumTriggers, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numTriggers() const", AS_METHODPR(T, GetNumTriggers, () const, unsigned), AS_CALL_THISCALL);

    // AnimationTrack* Animation::GetTrack(unsigned index)
    engine->RegisterObjectMethod(className, "AnimationTrack@+ GetTrack(uint)", AS_METHODPR(T, GetTrack, (unsigned), AnimationTrack*), AS_CALL_THISCALL);

    // AnimationTrack* Animation::GetTrack(const String& name)
    engine->RegisterObjectMethod(className, "AnimationTrack@+ GetTrack(const String&in)", AS_METHODPR(T, GetTrack, (const String&), AnimationTrack*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AnimationTrack@+ get_tracks(const String&in)", AS_METHODPR(T, GetTrack, (const String&), AnimationTrack*), AS_CALL_THISCALL);

    // AnimationTrack* Animation::GetTrack(StringHash nameHash)
    engine->RegisterObjectMethod(className, "AnimationTrack@+ GetTrack(StringHash)", AS_METHODPR(T, GetTrack, (StringHash), AnimationTrack*), AS_CALL_THISCALL);

    // void Animation::RemoveAllTracks()
    engine->RegisterObjectMethod(className, "void RemoveAllTracks()", AS_METHODPR(T, RemoveAllTracks, (), void), AS_CALL_THISCALL);

    // void Animation::RemoveAllTriggers()
    engine->RegisterObjectMethod(className, "void RemoveAllTriggers()", AS_METHODPR(T, RemoveAllTriggers, (), void), AS_CALL_THISCALL);

    // bool Animation::RemoveTrack(const String& name)
    engine->RegisterObjectMethod(className, "bool RemoveTrack(const String&in)", AS_METHODPR(T, RemoveTrack, (const String&), bool), AS_CALL_THISCALL);

    // void Animation::RemoveTrigger(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveTrigger(uint)", AS_METHODPR(T, RemoveTrigger, (unsigned), void), AS_CALL_THISCALL);

    // void Animation::SetAnimationName(const String& name)
    engine->RegisterObjectMethod(className, "void SetAnimationName(const String&in)", AS_METHODPR(T, SetAnimationName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationName(const String&in)", AS_METHODPR(T, SetAnimationName, (const String&), void), AS_CALL_THISCALL);

    // void Animation::SetLength(float length)
    engine->RegisterObjectMethod(className, "void SetLength(float)", AS_METHODPR(T, SetLength, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_length(float)", AS_METHODPR(T, SetLength, (float), void), AS_CALL_THISCALL);

    // void Animation::SetNumTriggers(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumTriggers(uint)", AS_METHODPR(T, SetNumTriggers, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numTriggers(uint)", AS_METHODPR(T, SetNumTriggers, (unsigned), void), AS_CALL_THISCALL);

    // void Animation::SetTrigger(unsigned index, const AnimationTriggerPoint& trigger)
    engine->RegisterObjectMethod(className, "void SetTrigger(uint, const AnimationTriggerPoint&in)", AS_METHODPR(T, SetTrigger, (unsigned, const AnimationTriggerPoint&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_triggers(uint, const AnimationTriggerPoint&in)", AS_METHODPR(T, SetTrigger, (unsigned, const AnimationTriggerPoint&), void), AS_CALL_THISCALL);

    // static void Animation::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Animation
        REGISTER_MEMBERS_MANUAL_PART_Animation();
    #endif
}

// class Component | File: ../Scene/Component.h
template <class T> void RegisterMembers_Component(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Animatable<T>(engine, className);

    // void Component::AddReplicationState(ComponentReplicationState* state)
    // Error: type "ComponentReplicationState*" can not automatically bind
    // void Component::CleanupConnection(Connection* connection)
    // Not registered because have @manualbind mark
    // void Component::GetComponents(PODVector<Component*>& dest, StringHash type) const
    // Error: type "PODVector<Component*>&" can not automatically bind
    // virtual void Component::GetDependencyNodes(PODVector<Node*>& dest)
    // Error: type "PODVector<Node*>&" can not automatically bind
    // virtual void Component::OnSetEnabled()
    // Can not be registered here bacause hidden in derived classes: LogicComponent

    // Component* Component::GetComponent(StringHash type) const
    engine->RegisterObjectMethod(className, "Component@+ GetComponent(StringHash) const", AS_METHODPR(T, GetComponent, (StringHash) const, Component*), AS_CALL_THISCALL);

    // unsigned Component::GetID() const
    engine->RegisterObjectMethod(className, "uint GetID() const", AS_METHODPR(T, GetID, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_id() const", AS_METHODPR(T, GetID, () const, unsigned), AS_CALL_THISCALL);

    // Node* Component::GetNode() const
    engine->RegisterObjectMethod(className, "Node@+ GetNode() const", AS_METHODPR(T, GetNode, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_node() const", AS_METHODPR(T, GetNode, () const, Node*), AS_CALL_THISCALL);

    // Scene* Component::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // bool Component::IsEnabled() const
    engine->RegisterObjectMethod(className, "bool IsEnabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);

    // bool Component::IsEnabledEffective() const
    engine->RegisterObjectMethod(className, "bool IsEnabledEffective() const", AS_METHODPR(T, IsEnabledEffective, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabledEffective() const", AS_METHODPR(T, IsEnabledEffective, () const, bool), AS_CALL_THISCALL);

    // bool Component::IsReplicated() const
    engine->RegisterObjectMethod(className, "bool IsReplicated() const", AS_METHODPR(T, IsReplicated, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_replicated() const", AS_METHODPR(T, IsReplicated, () const, bool), AS_CALL_THISCALL);

    // void Component::PrepareNetworkUpdate()
    engine->RegisterObjectMethod(className, "void PrepareNetworkUpdate()", AS_METHODPR(T, PrepareNetworkUpdate, (), void), AS_CALL_THISCALL);

    // void Component::Remove()
    engine->RegisterObjectMethod(className, "void Remove()", AS_METHODPR(T, Remove, (), void), AS_CALL_THISCALL);

    // void Component::SetEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetEnabled(bool)", AS_METHODPR(T, SetEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enabled(bool)", AS_METHODPR(T, SetEnabled, (bool), void), AS_CALL_THISCALL);

    // template <class T> T* Component::GetComponent() const
    // Not registered because template
    // template <class T> void Component::GetComponents(PODVector<T*>& dest) const
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Component
        REGISTER_MEMBERS_MANUAL_PART_Component();
    #endif
}

// SharedPtr<Model> Model::Clone(const String& cloneName = String::EMPTY) const
template <class T> Model* Model_SharedPtrlesModelgre_Clone_constspStringamp_template(T* _ptr, const String& cloneName)
{
    SharedPtr<Model> result = _ptr->Clone(cloneName);
    return result.Detach();
}

// const PODVector<Vector3>& Model::GetGeometryCenters() const
template <class T> CScriptArray* Model_constspPODVectorlesVector3greamp_GetGeometryCenters_void_template(T* _ptr)
{
    const PODVector<Vector3>& result = _ptr->GetGeometryCenters();
    return VectorToArray(result, "Array<Vector3>");
}

// const Vector<SharedPtr<IndexBuffer>>& Model::GetIndexBuffers() const
template <class T> CScriptArray* Model_constspVectorlesSharedPtrlesIndexBuffergregreamp_GetIndexBuffers_void_template(T* _ptr)
{
    const Vector<SharedPtr<IndexBuffer>>& result = _ptr->GetIndexBuffers();
    return VectorToHandleArray(result, "Array<IndexBuffer@>");
}

// const Vector<SharedPtr<VertexBuffer>>& Model::GetVertexBuffers() const
template <class T> CScriptArray* Model_constspVectorlesSharedPtrlesVertexBuffergregreamp_GetVertexBuffers_void_template(T* _ptr)
{
    const Vector<SharedPtr<VertexBuffer>>& result = _ptr->GetVertexBuffers();
    return VectorToHandleArray(result, "Array<VertexBuffer@>");
}

// bool Model::SetIndexBuffers(const Vector<SharedPtr<IndexBuffer>>& buffers)
template <class T> bool Model_bool_SetIndexBuffers_constspVectorlesSharedPtrlesIndexBuffergregreamp_template(T* _ptr, CScriptArray* buffers_conv)
{
    Vector<SharedPtr<IndexBuffer>> buffers = HandleArrayToVector<IndexBuffer>(buffers_conv);
    bool result = _ptr->SetIndexBuffers(buffers);
    return result;
}

// bool Model::SetVertexBuffers(const Vector<SharedPtr<VertexBuffer>>& buffers, const PODVector<unsigned>& morphRangeStarts, const PODVector<unsigned>& morphRangeCounts)
template <class T> bool Model_bool_SetVertexBuffers_constspVectorlesSharedPtrlesVertexBuffergregreamp_constspPODVectorlesunsignedgreamp_constspPODVectorlesunsignedgreamp_template(T* _ptr, CScriptArray* buffers_conv, CScriptArray* morphRangeStarts_conv, CScriptArray* morphRangeCounts_conv)
{
    Vector<SharedPtr<VertexBuffer>> buffers = HandleArrayToVector<VertexBuffer>(buffers_conv);
    PODVector<unsigned> morphRangeStarts = ArrayToPODVector<unsigned>(morphRangeStarts_conv);
    PODVector<unsigned> morphRangeCounts = ArrayToPODVector<unsigned>(morphRangeCounts_conv);
    bool result = _ptr->SetVertexBuffers(buffers, morphRangeStarts, morphRangeCounts);
    return result;
}

// class Model | File: ../Graphics/Model.h
template <class T> void RegisterMembers_Model(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ResourceWithMetadata<T>(engine, className);

    // const Vector<Vector<SharedPtr<Geometry>>>& Model::GetGeometries() const
    // Error: type "const Vector<Vector<SharedPtr<Geometry>>>&" can not automatically bind
    // const Vector<PODVector<unsigned>>& Model::GetGeometryBoneMappings() const
    // Error: type "const Vector<PODVector<unsigned>>&" can not automatically bind
    // const ModelMorph* Model::GetMorph(unsigned index) const
    // Error: type "const ModelMorph*" can not automatically bind
    // const ModelMorph* Model::GetMorph(const String& name) const
    // Error: type "const ModelMorph*" can not automatically bind
    // const ModelMorph* Model::GetMorph(StringHash nameHash) const
    // Error: type "const ModelMorph*" can not automatically bind
    // const Vector<ModelMorph>& Model::GetMorphs() const
    // Error: type "const Vector<ModelMorph>&" can not automatically bind
    // void Model::SetGeometryBoneMappings(const Vector<PODVector<unsigned>>& geometryBoneMappings)
    // Error: type "const Vector<PODVector<unsigned>>&" can not automatically bind
    // void Model::SetMorphs(const Vector<ModelMorph>& morphs)
    // Error: type "const Vector<ModelMorph>&" can not automatically bind

    // SharedPtr<Model> Model::Clone(const String& cloneName = String::EMPTY) const
    engine->RegisterObjectMethod(className, "Model@+ Clone(const String&in = String::EMPTY) const", AS_FUNCTION_OBJFIRST(Model_SharedPtrlesModelgre_Clone_constspStringamp_template<Model>), AS_CALL_CDECL_OBJFIRST);

    // const BoundingBox& Model::GetBoundingBox() const
    engine->RegisterObjectMethod(className, "const BoundingBox& GetBoundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_boundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);

    // Geometry* Model::GetGeometry(unsigned index, unsigned lodLevel) const
    engine->RegisterObjectMethod(className, "Geometry@+ GetGeometry(uint, uint) const", AS_METHODPR(T, GetGeometry, (unsigned, unsigned) const, Geometry*), AS_CALL_THISCALL);

    // const Vector3& Model::GetGeometryCenter(unsigned index) const
    engine->RegisterObjectMethod(className, "const Vector3& GetGeometryCenter(uint) const", AS_METHODPR(T, GetGeometryCenter, (unsigned) const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_geometryCenters(uint) const", AS_METHODPR(T, GetGeometryCenter, (unsigned) const, const Vector3&), AS_CALL_THISCALL);

    // const PODVector<Vector3>& Model::GetGeometryCenters() const
    engine->RegisterObjectMethod(className, "Array<Vector3>@ GetGeometryCenters() const", AS_FUNCTION_OBJFIRST(Model_constspPODVectorlesVector3greamp_GetGeometryCenters_void_template<Model>), AS_CALL_CDECL_OBJFIRST);

    // const Vector<SharedPtr<IndexBuffer>>& Model::GetIndexBuffers() const
    engine->RegisterObjectMethod(className, "Array<IndexBuffer@>@ GetIndexBuffers() const", AS_FUNCTION_OBJFIRST(Model_constspVectorlesSharedPtrlesIndexBuffergregreamp_GetIndexBuffers_void_template<Model>), AS_CALL_CDECL_OBJFIRST);

    // unsigned Model::GetMorphRangeCount(unsigned bufferIndex) const
    engine->RegisterObjectMethod(className, "uint GetMorphRangeCount(uint) const", AS_METHODPR(T, GetMorphRangeCount, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // unsigned Model::GetMorphRangeStart(unsigned bufferIndex) const
    engine->RegisterObjectMethod(className, "uint GetMorphRangeStart(uint) const", AS_METHODPR(T, GetMorphRangeStart, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // unsigned Model::GetNumGeometries() const
    engine->RegisterObjectMethod(className, "uint GetNumGeometries() const", AS_METHODPR(T, GetNumGeometries, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numGeometries() const", AS_METHODPR(T, GetNumGeometries, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Model::GetNumGeometryLodLevels(unsigned index) const
    engine->RegisterObjectMethod(className, "uint GetNumGeometryLodLevels(uint) const", AS_METHODPR(T, GetNumGeometryLodLevels, (unsigned) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numGeometryLodLevels(uint) const", AS_METHODPR(T, GetNumGeometryLodLevels, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // unsigned Model::GetNumMorphs() const
    engine->RegisterObjectMethod(className, "uint GetNumMorphs() const", AS_METHODPR(T, GetNumMorphs, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numMorphs() const", AS_METHODPR(T, GetNumMorphs, () const, unsigned), AS_CALL_THISCALL);

    // Skeleton& Model::GetSkeleton()
    engine->RegisterObjectMethod(className, "Skeleton& GetSkeleton()", AS_METHODPR(T, GetSkeleton, (), Skeleton&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Skeleton& get_skeleton()", AS_METHODPR(T, GetSkeleton, (), Skeleton&), AS_CALL_THISCALL);

    // const Vector<SharedPtr<VertexBuffer>>& Model::GetVertexBuffers() const
    engine->RegisterObjectMethod(className, "Array<VertexBuffer@>@ GetVertexBuffers() const", AS_FUNCTION_OBJFIRST(Model_constspVectorlesSharedPtrlesVertexBuffergregreamp_GetVertexBuffers_void_template<Model>), AS_CALL_CDECL_OBJFIRST);

    // void Model::SetBoundingBox(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void SetBoundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_boundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);

    // bool Model::SetGeometry(unsigned index, unsigned lodLevel, Geometry* geometry)
    engine->RegisterObjectMethod(className, "bool SetGeometry(uint, uint, Geometry@+)", AS_METHODPR(T, SetGeometry, (unsigned, unsigned, Geometry*), bool), AS_CALL_THISCALL);

    // bool Model::SetGeometryCenter(unsigned index, const Vector3& center)
    engine->RegisterObjectMethod(className, "bool SetGeometryCenter(uint, const Vector3&in)", AS_METHODPR(T, SetGeometryCenter, (unsigned, const Vector3&), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_geometryCenters(uint, const Vector3&in)", AS_METHODPR(T, SetGeometryCenter, (unsigned, const Vector3&), bool), AS_CALL_THISCALL);

    // bool Model::SetIndexBuffers(const Vector<SharedPtr<IndexBuffer>>& buffers)
    engine->RegisterObjectMethod(className, "bool SetIndexBuffers(Array<IndexBuffer@>@+)", AS_FUNCTION_OBJFIRST(Model_bool_SetIndexBuffers_constspVectorlesSharedPtrlesIndexBuffergregreamp_template<Model>), AS_CALL_CDECL_OBJFIRST);

    // void Model::SetNumGeometries(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumGeometries(uint)", AS_METHODPR(T, SetNumGeometries, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numGeometries(uint)", AS_METHODPR(T, SetNumGeometries, (unsigned), void), AS_CALL_THISCALL);

    // bool Model::SetNumGeometryLodLevels(unsigned index, unsigned num)
    engine->RegisterObjectMethod(className, "bool SetNumGeometryLodLevels(uint, uint)", AS_METHODPR(T, SetNumGeometryLodLevels, (unsigned, unsigned), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_numGeometryLodLevels(uint, uint)", AS_METHODPR(T, SetNumGeometryLodLevels, (unsigned, unsigned), bool), AS_CALL_THISCALL);

    // void Model::SetSkeleton(const Skeleton& skeleton)
    engine->RegisterObjectMethod(className, "void SetSkeleton(const Skeleton&in)", AS_METHODPR(T, SetSkeleton, (const Skeleton&), void), AS_CALL_THISCALL);

    // bool Model::SetVertexBuffers(const Vector<SharedPtr<VertexBuffer>>& buffers, const PODVector<unsigned>& morphRangeStarts, const PODVector<unsigned>& morphRangeCounts)
    engine->RegisterObjectMethod(className, "bool SetVertexBuffers(Array<VertexBuffer@>@+, Array<uint>@+, Array<uint>@+)", AS_FUNCTION_OBJFIRST(Model_bool_SetVertexBuffers_constspVectorlesSharedPtrlesVertexBuffergregreamp_constspPODVectorlesunsignedgreamp_constspPODVectorlesunsignedgreamp_template<Model>), AS_CALL_CDECL_OBJFIRST);

    // static void Model::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Model
        REGISTER_MEMBERS_MANUAL_PART_Model();
    #endif
}

// void Node::AddTags(const StringVector& tags)
template <class T> void Node_void_AddTags_constspStringVectoramp_template(T* _ptr, CScriptArray* tags_conv)
{
    StringVector tags = ArrayToVector<String>(tags_conv);
    _ptr->AddTags(tags);
}

// const Vector<SharedPtr<Node>>& Node::GetChildren() const
template <class T> CScriptArray* Node_constspVectorlesSharedPtrlesNodegregreamp_GetChildren_void_template(T* _ptr)
{
    const Vector<SharedPtr<Node>>& result = _ptr->GetChildren();
    return VectorToHandleArray(result, "Array<Node@>");
}

// PODVector<Node*> Node::GetChildren(bool recursive) const
template <class T> CScriptArray* Node_PODVectorlesNodestargre_GetChildren_bool_template(T* _ptr, bool recursive)
{
    PODVector<Node*> result = _ptr->GetChildren(recursive);
    return VectorToHandleArray(result, "Array<Node@>");
}

// PODVector<Node*> Node::GetChildrenWithComponent(StringHash type, bool recursive = false) const
template <class T> CScriptArray* Node_PODVectorlesNodestargre_GetChildrenWithComponent_StringHash_bool_template(T* _ptr, StringHash type, bool recursive)
{
    PODVector<Node*> result = _ptr->GetChildrenWithComponent(type, recursive);
    return VectorToHandleArray(result, "Array<Node@>");
}

// PODVector<Node*> Node::GetChildrenWithTag(const String& tag, bool recursive = false) const
template <class T> CScriptArray* Node_PODVectorlesNodestargre_GetChildrenWithTag_constspStringamp_bool_template(T* _ptr, const String& tag, bool recursive)
{
    PODVector<Node*> result = _ptr->GetChildrenWithTag(tag, recursive);
    return VectorToHandleArray(result, "Array<Node@>");
}

// const Vector<SharedPtr<Component>>& Node::GetComponents() const
template <class T> CScriptArray* Node_constspVectorlesSharedPtrlesComponentgregreamp_GetComponents_void_template(T* _ptr)
{
    const Vector<SharedPtr<Component>>& result = _ptr->GetComponents();
    return VectorToHandleArray(result, "Array<Component@>");
}

// const PODVector<Node*>& Node::GetDependencyNodes() const
template <class T> CScriptArray* Node_constspPODVectorlesNodestargreamp_GetDependencyNodes_void_template(T* _ptr)
{
    const PODVector<Node*>& result = _ptr->GetDependencyNodes();
    return VectorToHandleArray(result, "Array<Node@>");
}

// const StringVector& Node::GetTags() const
template <class T> CScriptArray* Node_constspStringVectoramp_GetTags_void_template(T* _ptr)
{
    const StringVector& result = _ptr->GetTags();
    return VectorToArray<String>(result, "Array<String>");
}

// void Node::SetTags(const StringVector& tags)
template <class T> void Node_void_SetTags_constspStringVectoramp_template(T* _ptr, CScriptArray* tags_conv)
{
    StringVector tags = ArrayToVector<String>(tags_conv);
    _ptr->SetTags(tags);
}

// class Node | File: ../Scene/Node.h
template <class T> void RegisterMembers_Node(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Animatable<T>(engine, className);

    // virtual void Node::AddReplicationState(NodeReplicationState* state)
    // Error: type "NodeReplicationState*" can not automatically bind
    // void Node::CleanupConnection(Connection* connection)
    // Not registered because have @manualbind mark
    // Node* Node::GetChild(const char* name, bool recursive = false) const
    // Error: type "const char*" can not automatically bind
    // void Node::GetChildren(PODVector<Node*>& dest, bool recursive = false) const
    // Error: type "PODVector<Node*>&" can not automatically bind
    // void Node::GetChildrenWithComponent(PODVector<Node*>& dest, StringHash type, bool recursive = false) const
    // Error: type "PODVector<Node*>&" can not automatically bind
    // void Node::GetChildrenWithTag(PODVector<Node*>& dest, const String& tag, bool recursive = false) const
    // Error: type "PODVector<Node*>&" can not automatically bind
    // void Node::GetComponents(PODVector<Component*>& dest, StringHash type, bool recursive = false) const
    // Error: type "PODVector<Component*>&" can not automatically bind
    // const Vector<WeakPtr<Component>> Node::GetListeners() const
    // Error: type "const Vector<WeakPtr<Component>>" can not automatically bind
    // const PODVector<unsigned char>& Node::GetNetParentAttr() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // const PODVector<unsigned char>& Node::GetNetRotationAttr() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // Connection* Node::GetOwner() const
    // Not registered because have @manualbind mark
    // bool Node::Load(Deserializer& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)
    // Can not be registered here bacause hidden in derived classes: Scene
    // bool Node::LoadJSON(const JSONValue& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)
    // Can not be registered here bacause hidden in derived classes: Scene
    // bool Node::LoadXML(const XMLElement& source, SceneResolver& resolver, bool loadChildren = true, bool rewriteIDs = false, CreateMode mode = REPLICATED)
    // Can not be registered here bacause hidden in derived classes: Scene
    // void Node::MarkReplicationDirty()
    // Can not be registered here bacause hidden in derived classes: Scene
    // void Node::SetNetParentAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void Node::SetNetRotationAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void Node::SetOwner(Connection* owner)
    // Not registered because have @manualbind mark

    // void Node::AddChild(Node* node, unsigned index = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void AddChild(Node@+, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, AddChild, (Node*, unsigned), void), AS_CALL_THISCALL);

    // void Node::AddComponent(Component* component, unsigned id, CreateMode mode)
    engine->RegisterObjectMethod(className, "void AddComponent(Component@+, uint, CreateMode)", AS_METHODPR(T, AddComponent, (Component*, unsigned, CreateMode), void), AS_CALL_THISCALL);

    // void Node::AddListener(Component* component)
    engine->RegisterObjectMethod(className, "void AddListener(Component@+)", AS_METHODPR(T, AddListener, (Component*), void), AS_CALL_THISCALL);

    // void Node::AddTag(const String& tag)
    engine->RegisterObjectMethod(className, "void AddTag(const String&in)", AS_METHODPR(T, AddTag, (const String&), void), AS_CALL_THISCALL);

    // void Node::AddTags(const String& tags, char separator = ';')
    engine->RegisterObjectMethod(className, "void AddTags(const String&in, int8 = ';')", AS_METHODPR(T, AddTags, (const String&, char), void), AS_CALL_THISCALL);

    // void Node::AddTags(const StringVector& tags)
    engine->RegisterObjectMethod(className, "void AddTags(Array<String>@+)", AS_FUNCTION_OBJFIRST(Node_void_AddTags_constspStringVectoramp_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // Node* Node::Clone(CreateMode mode = REPLICATED)
    engine->RegisterObjectMethod(className, "Node@+ Clone(CreateMode = REPLICATED)", AS_METHODPR(T, Clone, (CreateMode), Node*), AS_CALL_THISCALL);

    // Component* Node::CloneComponent(Component* component, unsigned id = 0)
    engine->RegisterObjectMethod(className, "Component@+ CloneComponent(Component@+, uint = 0)", AS_METHODPR(T, CloneComponent, (Component*, unsigned), Component*), AS_CALL_THISCALL);

    // Component* Node::CloneComponent(Component* component, CreateMode mode, unsigned id = 0)
    engine->RegisterObjectMethod(className, "Component@+ CloneComponent(Component@+, CreateMode, uint = 0)", AS_METHODPR(T, CloneComponent, (Component*, CreateMode, unsigned), Component*), AS_CALL_THISCALL);

    // Node* Node::CreateChild(const String& name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0, bool temporary = false)
    engine->RegisterObjectMethod(className, "Node@+ CreateChild(const String&in = String::EMPTY, CreateMode = REPLICATED, uint = 0, bool = false)", AS_METHODPR(T, CreateChild, (const String&, CreateMode, unsigned, bool), Node*), AS_CALL_THISCALL);

    // Node* Node::CreateChild(unsigned id, CreateMode mode, bool temporary = false)
    engine->RegisterObjectMethod(className, "Node@+ CreateChild(uint, CreateMode, bool = false)", AS_METHODPR(T, CreateChild, (unsigned, CreateMode, bool), Node*), AS_CALL_THISCALL);

    // Component* Node::CreateComponent(StringHash type, CreateMode mode = REPLICATED, unsigned id = 0)
    engine->RegisterObjectMethod(className, "Component@+ CreateComponent(StringHash, CreateMode = REPLICATED, uint = 0)", AS_METHODPR(T, CreateComponent, (StringHash, CreateMode, unsigned), Component*), AS_CALL_THISCALL);

    // Node* Node::CreateTemporaryChild(const String& name = String::EMPTY, CreateMode mode = REPLICATED, unsigned id = 0)
    engine->RegisterObjectMethod(className, "Node@+ CreateTemporaryChild(const String&in = String::EMPTY, CreateMode = REPLICATED, uint = 0)", AS_METHODPR(T, CreateTemporaryChild, (const String&, CreateMode, unsigned), Node*), AS_CALL_THISCALL);

    // Node* Node::GetChild(unsigned index) const
    engine->RegisterObjectMethod(className, "Node@+ GetChild(uint) const", AS_METHODPR(T, GetChild, (unsigned) const, Node*), AS_CALL_THISCALL);

    // Node* Node::GetChild(const String& name, bool recursive = false) const
    engine->RegisterObjectMethod(className, "Node@+ GetChild(const String&in, bool = false) const", AS_METHODPR(T, GetChild, (const String&, bool) const, Node*), AS_CALL_THISCALL);

    // Node* Node::GetChild(StringHash nameHash, bool recursive = false) const
    engine->RegisterObjectMethod(className, "Node@+ GetChild(StringHash, bool = false) const", AS_METHODPR(T, GetChild, (StringHash, bool) const, Node*), AS_CALL_THISCALL);

    // const Vector<SharedPtr<Node>>& Node::GetChildren() const
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildren() const", AS_FUNCTION_OBJFIRST(Node_constspVectorlesSharedPtrlesNodegregreamp_GetChildren_void_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // PODVector<Node*> Node::GetChildren(bool recursive) const
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildren(bool) const", AS_FUNCTION_OBJFIRST(Node_PODVectorlesNodestargre_GetChildren_bool_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // PODVector<Node*> Node::GetChildrenWithComponent(StringHash type, bool recursive = false) const
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildrenWithComponent(StringHash, bool = false) const", AS_FUNCTION_OBJFIRST(Node_PODVectorlesNodestargre_GetChildrenWithComponent_StringHash_bool_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // PODVector<Node*> Node::GetChildrenWithTag(const String& tag, bool recursive = false) const
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetChildrenWithTag(const String&in, bool = false) const", AS_FUNCTION_OBJFIRST(Node_PODVectorlesNodestargre_GetChildrenWithTag_constspStringamp_bool_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // Component* Node::GetComponent(StringHash type, bool recursive = false) const
    engine->RegisterObjectMethod(className, "Component@+ GetComponent(StringHash, bool = false) const", AS_METHODPR(T, GetComponent, (StringHash, bool) const, Component*), AS_CALL_THISCALL);

    // const Vector<SharedPtr<Component>>& Node::GetComponents() const
    engine->RegisterObjectMethod(className, "Array<Component@>@ GetComponents() const", AS_FUNCTION_OBJFIRST(Node_constspVectorlesSharedPtrlesComponentgregreamp_GetComponents_void_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // const PODVector<Node*>& Node::GetDependencyNodes() const
    engine->RegisterObjectMethod(className, "Array<Node@>@ GetDependencyNodes() const", AS_FUNCTION_OBJFIRST(Node_constspPODVectorlesNodestargreamp_GetDependencyNodes_void_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // Vector3 Node::GetDirection() const
    engine->RegisterObjectMethod(className, "Vector3 GetDirection() const", AS_METHODPR(T, GetDirection, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_direction() const", AS_METHODPR(T, GetDirection, () const, Vector3), AS_CALL_THISCALL);

    // unsigned Node::GetID() const
    engine->RegisterObjectMethod(className, "uint GetID() const", AS_METHODPR(T, GetID, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_id() const", AS_METHODPR(T, GetID, () const, unsigned), AS_CALL_THISCALL);

    // const String& Node::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // StringHash Node::GetNameHash() const
    engine->RegisterObjectMethod(className, "StringHash GetNameHash() const", AS_METHODPR(T, GetNameHash, () const, StringHash), AS_CALL_THISCALL);

    // const Vector3& Node::GetNetPositionAttr() const
    engine->RegisterObjectMethod(className, "const Vector3& GetNetPositionAttr() const", AS_METHODPR(T, GetNetPositionAttr, () const, const Vector3&), AS_CALL_THISCALL);

    // unsigned Node::GetNumChildren(bool recursive = false) const
    engine->RegisterObjectMethod(className, "uint GetNumChildren(bool = false) const", AS_METHODPR(T, GetNumChildren, (bool) const, unsigned), AS_CALL_THISCALL);

    // unsigned Node::GetNumComponents() const
    engine->RegisterObjectMethod(className, "uint GetNumComponents() const", AS_METHODPR(T, GetNumComponents, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numComponents() const", AS_METHODPR(T, GetNumComponents, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Node::GetNumNetworkComponents() const
    engine->RegisterObjectMethod(className, "uint GetNumNetworkComponents() const", AS_METHODPR(T, GetNumNetworkComponents, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Node::GetNumPersistentChildren() const
    engine->RegisterObjectMethod(className, "uint GetNumPersistentChildren() const", AS_METHODPR(T, GetNumPersistentChildren, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Node::GetNumPersistentComponents() const
    engine->RegisterObjectMethod(className, "uint GetNumPersistentComponents() const", AS_METHODPR(T, GetNumPersistentComponents, () const, unsigned), AS_CALL_THISCALL);

    // Component* Node::GetOrCreateComponent(StringHash type, CreateMode mode = REPLICATED, unsigned id = 0)
    engine->RegisterObjectMethod(className, "Component@+ GetOrCreateComponent(StringHash, CreateMode = REPLICATED, uint = 0)", AS_METHODPR(T, GetOrCreateComponent, (StringHash, CreateMode, unsigned), Component*), AS_CALL_THISCALL);

    // Node* Node::GetParent() const
    engine->RegisterObjectMethod(className, "Node@+ GetParent() const", AS_METHODPR(T, GetParent, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_parent() const", AS_METHODPR(T, GetParent, () const, Node*), AS_CALL_THISCALL);

    // Component* Node::GetParentComponent(StringHash type, bool fullTraversal = false) const
    engine->RegisterObjectMethod(className, "Component@+ GetParentComponent(StringHash, bool = false) const", AS_METHODPR(T, GetParentComponent, (StringHash, bool) const, Component*), AS_CALL_THISCALL);

    // const Vector3& Node::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_position() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // Vector2 Node::GetPosition2D() const
    engine->RegisterObjectMethod(className, "Vector2 GetPosition2D() const", AS_METHODPR(T, GetPosition2D, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_position2D() const", AS_METHODPR(T, GetPosition2D, () const, Vector2), AS_CALL_THISCALL);

    // Vector3 Node::GetRight() const
    engine->RegisterObjectMethod(className, "Vector3 GetRight() const", AS_METHODPR(T, GetRight, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_right() const", AS_METHODPR(T, GetRight, () const, Vector3), AS_CALL_THISCALL);

    // const Quaternion& Node::GetRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetRotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_rotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // float Node::GetRotation2D() const
    engine->RegisterObjectMethod(className, "float GetRotation2D() const", AS_METHODPR(T, GetRotation2D, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rotation2D() const", AS_METHODPR(T, GetRotation2D, () const, float), AS_CALL_THISCALL);

    // const Vector3& Node::GetScale() const
    engine->RegisterObjectMethod(className, "const Vector3& GetScale() const", AS_METHODPR(T, GetScale, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_scale() const", AS_METHODPR(T, GetScale, () const, const Vector3&), AS_CALL_THISCALL);

    // Vector2 Node::GetScale2D() const
    engine->RegisterObjectMethod(className, "Vector2 GetScale2D() const", AS_METHODPR(T, GetScale2D, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_scale2D() const", AS_METHODPR(T, GetScale2D, () const, Vector2), AS_CALL_THISCALL);

    // Scene* Node::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Scene@+ get_scene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // Vector3 Node::GetSignedWorldScale() const
    engine->RegisterObjectMethod(className, "Vector3 GetSignedWorldScale() const", AS_METHODPR(T, GetSignedWorldScale, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_signedWorldScale() const", AS_METHODPR(T, GetSignedWorldScale, () const, Vector3), AS_CALL_THISCALL);

    // const StringVector& Node::GetTags() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetTags() const", AS_FUNCTION_OBJFIRST(Node_constspStringVectoramp_GetTags_void_template<Node>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<String>@ get_tags() const", AS_FUNCTION_OBJFIRST(Node_constspStringVectoramp_GetTags_void_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // Matrix3x4 Node::GetTransform() const
    engine->RegisterObjectMethod(className, "Matrix3x4 GetTransform() const", AS_METHODPR(T, GetTransform, () const, Matrix3x4), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3x4 get_transform() const", AS_METHODPR(T, GetTransform, () const, Matrix3x4), AS_CALL_THISCALL);

    // Vector3 Node::GetUp() const
    engine->RegisterObjectMethod(className, "Vector3 GetUp() const", AS_METHODPR(T, GetUp, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_up() const", AS_METHODPR(T, GetUp, () const, Vector3), AS_CALL_THISCALL);

    // const Variant& Node::GetVar(StringHash key) const
    engine->RegisterObjectMethod(className, "const Variant& GetVar(StringHash) const", AS_METHODPR(T, GetVar, (StringHash) const, const Variant&), AS_CALL_THISCALL);

    // const VariantMap& Node::GetVars() const
    engine->RegisterObjectMethod(className, "const VariantMap& GetVars() const", AS_METHODPR(T, GetVars, () const, const VariantMap&), AS_CALL_THISCALL);

    // Vector3 Node::GetWorldDirection() const
    engine->RegisterObjectMethod(className, "Vector3 GetWorldDirection() const", AS_METHODPR(T, GetWorldDirection, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldDirection() const", AS_METHODPR(T, GetWorldDirection, () const, Vector3), AS_CALL_THISCALL);

    // Vector3 Node::GetWorldPosition() const
    engine->RegisterObjectMethod(className, "Vector3 GetWorldPosition() const", AS_METHODPR(T, GetWorldPosition, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldPosition() const", AS_METHODPR(T, GetWorldPosition, () const, Vector3), AS_CALL_THISCALL);

    // Vector2 Node::GetWorldPosition2D() const
    engine->RegisterObjectMethod(className, "Vector2 GetWorldPosition2D() const", AS_METHODPR(T, GetWorldPosition2D, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_worldPosition2D() const", AS_METHODPR(T, GetWorldPosition2D, () const, Vector2), AS_CALL_THISCALL);

    // Vector3 Node::GetWorldRight() const
    engine->RegisterObjectMethod(className, "Vector3 GetWorldRight() const", AS_METHODPR(T, GetWorldRight, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldRight() const", AS_METHODPR(T, GetWorldRight, () const, Vector3), AS_CALL_THISCALL);

    // Quaternion Node::GetWorldRotation() const
    engine->RegisterObjectMethod(className, "Quaternion GetWorldRotation() const", AS_METHODPR(T, GetWorldRotation, () const, Quaternion), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Quaternion get_worldRotation() const", AS_METHODPR(T, GetWorldRotation, () const, Quaternion), AS_CALL_THISCALL);

    // float Node::GetWorldRotation2D() const
    engine->RegisterObjectMethod(className, "float GetWorldRotation2D() const", AS_METHODPR(T, GetWorldRotation2D, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_worldRotation2D() const", AS_METHODPR(T, GetWorldRotation2D, () const, float), AS_CALL_THISCALL);

    // Vector3 Node::GetWorldScale() const
    engine->RegisterObjectMethod(className, "Vector3 GetWorldScale() const", AS_METHODPR(T, GetWorldScale, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldScale() const", AS_METHODPR(T, GetWorldScale, () const, Vector3), AS_CALL_THISCALL);

    // Vector2 Node::GetWorldScale2D() const
    engine->RegisterObjectMethod(className, "Vector2 GetWorldScale2D() const", AS_METHODPR(T, GetWorldScale2D, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_worldScale2D() const", AS_METHODPR(T, GetWorldScale2D, () const, Vector2), AS_CALL_THISCALL);

    // const Matrix3x4& Node::GetWorldTransform() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetWorldTransform() const", AS_METHODPR(T, GetWorldTransform, () const, const Matrix3x4&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Matrix3x4& get_worldTransform() const", AS_METHODPR(T, GetWorldTransform, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // Vector3 Node::GetWorldUp() const
    engine->RegisterObjectMethod(className, "Vector3 GetWorldUp() const", AS_METHODPR(T, GetWorldUp, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldUp() const", AS_METHODPR(T, GetWorldUp, () const, Vector3), AS_CALL_THISCALL);

    // bool Node::HasComponent(StringHash type) const
    engine->RegisterObjectMethod(className, "bool HasComponent(StringHash) const", AS_METHODPR(T, HasComponent, (StringHash) const, bool), AS_CALL_THISCALL);

    // bool Node::HasTag(const String& tag) const
    engine->RegisterObjectMethod(className, "bool HasTag(const String&in) const", AS_METHODPR(T, HasTag, (const String&) const, bool), AS_CALL_THISCALL);

    // bool Node::IsChildOf(Node* node) const
    engine->RegisterObjectMethod(className, "bool IsChildOf(Node@+) const", AS_METHODPR(T, IsChildOf, (Node*) const, bool), AS_CALL_THISCALL);

    // bool Node::IsDirty() const
    engine->RegisterObjectMethod(className, "bool IsDirty() const", AS_METHODPR(T, IsDirty, () const, bool), AS_CALL_THISCALL);

    // bool Node::IsEnabled() const
    engine->RegisterObjectMethod(className, "bool IsEnabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);

    // bool Node::IsEnabledSelf() const
    engine->RegisterObjectMethod(className, "bool IsEnabledSelf() const", AS_METHODPR(T, IsEnabledSelf, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabledSelf() const", AS_METHODPR(T, IsEnabledSelf, () const, bool), AS_CALL_THISCALL);

    // bool Node::IsReplicated() const
    engine->RegisterObjectMethod(className, "bool IsReplicated() const", AS_METHODPR(T, IsReplicated, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_replicated() const", AS_METHODPR(T, IsReplicated, () const, bool), AS_CALL_THISCALL);

    // Vector3 Node::LocalToWorld(const Vector3& position) const
    engine->RegisterObjectMethod(className, "Vector3 LocalToWorld(const Vector3&in) const", AS_METHODPR(T, LocalToWorld, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Node::LocalToWorld(const Vector4& vector) const
    engine->RegisterObjectMethod(className, "Vector3 LocalToWorld(const Vector4&in) const", AS_METHODPR(T, LocalToWorld, (const Vector4&) const, Vector3), AS_CALL_THISCALL);

    // Vector2 Node::LocalToWorld2D(const Vector2& vector) const
    engine->RegisterObjectMethod(className, "Vector2 LocalToWorld2D(const Vector2&in) const", AS_METHODPR(T, LocalToWorld2D, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // bool Node::LookAt(const Vector3& target, const Vector3& up = Vector3::UP, TransformSpace space = TS_WORLD)
    engine->RegisterObjectMethod(className, "bool LookAt(const Vector3&in, const Vector3&in = Vector3::UP, TransformSpace = TS_WORLD)", AS_METHODPR(T, LookAt, (const Vector3&, const Vector3&, TransformSpace), bool), AS_CALL_THISCALL);

    // void Node::MarkDirty()
    engine->RegisterObjectMethod(className, "void MarkDirty()", AS_METHODPR(T, MarkDirty, (), void), AS_CALL_THISCALL);

    // void Node::Pitch(float angle, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Pitch(float, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Pitch, (float, TransformSpace), void), AS_CALL_THISCALL);

    // void Node::PrepareNetworkUpdate()
    engine->RegisterObjectMethod(className, "void PrepareNetworkUpdate()", AS_METHODPR(T, PrepareNetworkUpdate, (), void), AS_CALL_THISCALL);

    // void Node::Remove()
    engine->RegisterObjectMethod(className, "void Remove()", AS_METHODPR(T, Remove, (), void), AS_CALL_THISCALL);

    // void Node::RemoveAllChildren()
    engine->RegisterObjectMethod(className, "void RemoveAllChildren()", AS_METHODPR(T, RemoveAllChildren, (), void), AS_CALL_THISCALL);

    // void Node::RemoveAllComponents()
    engine->RegisterObjectMethod(className, "void RemoveAllComponents()", AS_METHODPR(T, RemoveAllComponents, (), void), AS_CALL_THISCALL);

    // void Node::RemoveAllTags()
    engine->RegisterObjectMethod(className, "void RemoveAllTags()", AS_METHODPR(T, RemoveAllTags, (), void), AS_CALL_THISCALL);

    // void Node::RemoveChild(Node* node)
    engine->RegisterObjectMethod(className, "void RemoveChild(Node@+)", AS_METHODPR(T, RemoveChild, (Node*), void), AS_CALL_THISCALL);

    // void Node::RemoveChildren(bool removeReplicated, bool removeLocal, bool recursive)
    engine->RegisterObjectMethod(className, "void RemoveChildren(bool, bool, bool)", AS_METHODPR(T, RemoveChildren, (bool, bool, bool), void), AS_CALL_THISCALL);

    // void Node::RemoveComponent(Component* component)
    engine->RegisterObjectMethod(className, "void RemoveComponent(Component@+)", AS_METHODPR(T, RemoveComponent, (Component*), void), AS_CALL_THISCALL);

    // void Node::RemoveComponent(StringHash type)
    engine->RegisterObjectMethod(className, "void RemoveComponent(StringHash)", AS_METHODPR(T, RemoveComponent, (StringHash), void), AS_CALL_THISCALL);

    // void Node::RemoveComponents(bool removeReplicated, bool removeLocal)
    engine->RegisterObjectMethod(className, "void RemoveComponents(bool, bool)", AS_METHODPR(T, RemoveComponents, (bool, bool), void), AS_CALL_THISCALL);

    // void Node::RemoveComponents(StringHash type)
    engine->RegisterObjectMethod(className, "void RemoveComponents(StringHash)", AS_METHODPR(T, RemoveComponents, (StringHash), void), AS_CALL_THISCALL);

    // void Node::RemoveListener(Component* component)
    engine->RegisterObjectMethod(className, "void RemoveListener(Component@+)", AS_METHODPR(T, RemoveListener, (Component*), void), AS_CALL_THISCALL);

    // bool Node::RemoveTag(const String& tag)
    engine->RegisterObjectMethod(className, "bool RemoveTag(const String&in)", AS_METHODPR(T, RemoveTag, (const String&), bool), AS_CALL_THISCALL);

    // void Node::ReorderComponent(Component* component, unsigned index)
    engine->RegisterObjectMethod(className, "void ReorderComponent(Component@+, uint)", AS_METHODPR(T, ReorderComponent, (Component*, unsigned), void), AS_CALL_THISCALL);

    // void Node::ResetDeepEnabled()
    engine->RegisterObjectMethod(className, "void ResetDeepEnabled()", AS_METHODPR(T, ResetDeepEnabled, (), void), AS_CALL_THISCALL);

    // void Node::ResetScene()
    engine->RegisterObjectMethod(className, "void ResetScene()", AS_METHODPR(T, ResetScene, (), void), AS_CALL_THISCALL);

    // void Node::Roll(float angle, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Roll(float, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Roll, (float, TransformSpace), void), AS_CALL_THISCALL);

    // void Node::Rotate(const Quaternion& delta, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Rotate(const Quaternion&in, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Rotate, (const Quaternion&, TransformSpace), void), AS_CALL_THISCALL);

    // void Node::Rotate2D(float delta, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Rotate2D(float, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Rotate2D, (float, TransformSpace), void), AS_CALL_THISCALL);

    // void Node::RotateAround(const Vector3& point, const Quaternion& delta, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void RotateAround(const Vector3&in, const Quaternion&in, TransformSpace = TS_LOCAL)", AS_METHODPR(T, RotateAround, (const Vector3&, const Quaternion&, TransformSpace), void), AS_CALL_THISCALL);

    // void Node::RotateAround2D(const Vector2& point, float delta, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void RotateAround2D(const Vector2&in, float, TransformSpace = TS_LOCAL)", AS_METHODPR(T, RotateAround2D, (const Vector2&, float, TransformSpace), void), AS_CALL_THISCALL);

    // bool Node::SaveJSON(Serializer& dest, const String& indentation = "\t") const
    engine->RegisterObjectMethod(className, "bool SaveJSON(Serializer&, const String&in = \"\t\") const", AS_METHODPR(T, SaveJSON, (Serializer&, const String&) const, bool), AS_CALL_THISCALL);

    // bool Node::SaveXML(Serializer& dest, const String& indentation = "\t") const
    engine->RegisterObjectMethod(className, "bool SaveXML(Serializer&, const String&in = \"\t\") const", AS_METHODPR(T, SaveXML, (Serializer&, const String&) const, bool), AS_CALL_THISCALL);

    // void Node::Scale(float scale)
    engine->RegisterObjectMethod(className, "void Scale(float)", AS_METHODPR(T, Scale, (float), void), AS_CALL_THISCALL);

    // void Node::Scale(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void Scale(const Vector3&in)", AS_METHODPR(T, Scale, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::Scale2D(const Vector2& scale)
    engine->RegisterObjectMethod(className, "void Scale2D(const Vector2&in)", AS_METHODPR(T, Scale2D, (const Vector2&), void), AS_CALL_THISCALL);

    // void Node::SetDeepEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetDeepEnabled(bool)", AS_METHODPR(T, SetDeepEnabled, (bool), void), AS_CALL_THISCALL);

    // void Node::SetDirection(const Vector3& direction)
    engine->RegisterObjectMethod(className, "void SetDirection(const Vector3&in)", AS_METHODPR(T, SetDirection, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_direction(const Vector3&in)", AS_METHODPR(T, SetDirection, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetEnabled(bool)", AS_METHODPR(T, SetEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enabled(bool)", AS_METHODPR(T, SetEnabled, (bool), void), AS_CALL_THISCALL);

    // void Node::SetEnabledRecursive(bool enable)
    engine->RegisterObjectMethod(className, "void SetEnabledRecursive(bool)", AS_METHODPR(T, SetEnabledRecursive, (bool), void), AS_CALL_THISCALL);

    // void Node::SetID(unsigned id)
    engine->RegisterObjectMethod(className, "void SetID(uint)", AS_METHODPR(T, SetID, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_id(uint)", AS_METHODPR(T, SetID, (unsigned), void), AS_CALL_THISCALL);

    // void Node::SetName(const String& name)
    engine->RegisterObjectMethod(className, "void SetName(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_name(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);

    // void Node::SetNetPositionAttr(const Vector3& value)
    engine->RegisterObjectMethod(className, "void SetNetPositionAttr(const Vector3&in)", AS_METHODPR(T, SetNetPositionAttr, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetParent(Node* parent)
    engine->RegisterObjectMethod(className, "void SetParent(Node@+)", AS_METHODPR(T, SetParent, (Node*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_parent(Node@+)", AS_METHODPR(T, SetParent, (Node*), void), AS_CALL_THISCALL);

    // void Node::SetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetPosition2D(const Vector2& position)
    engine->RegisterObjectMethod(className, "void SetPosition2D(const Vector2&in)", AS_METHODPR(T, SetPosition2D, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position2D(const Vector2&in)", AS_METHODPR(T, SetPosition2D, (const Vector2&), void), AS_CALL_THISCALL);

    // void Node::SetPosition2D(float x, float y)
    engine->RegisterObjectMethod(className, "void SetPosition2D(float, float)", AS_METHODPR(T, SetPosition2D, (float, float), void), AS_CALL_THISCALL);

    // void Node::SetPositionSilent(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetPositionSilent(const Vector3&in)", AS_METHODPR(T, SetPositionSilent, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void Node::SetRotation2D(float rotation)
    engine->RegisterObjectMethod(className, "void SetRotation2D(float)", AS_METHODPR(T, SetRotation2D, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation2D(float)", AS_METHODPR(T, SetRotation2D, (float), void), AS_CALL_THISCALL);

    // void Node::SetRotationSilent(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetRotationSilent(const Quaternion&in)", AS_METHODPR(T, SetRotationSilent, (const Quaternion&), void), AS_CALL_THISCALL);

    // void Node::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // void Node::SetScale(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetScale(const Vector3&in)", AS_METHODPR(T, SetScale, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scale(const Vector3&in)", AS_METHODPR(T, SetScale, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetScale2D(const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetScale2D(const Vector2&in)", AS_METHODPR(T, SetScale2D, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scale2D(const Vector2&in)", AS_METHODPR(T, SetScale2D, (const Vector2&), void), AS_CALL_THISCALL);

    // void Node::SetScale2D(float x, float y)
    engine->RegisterObjectMethod(className, "void SetScale2D(float, float)", AS_METHODPR(T, SetScale2D, (float, float), void), AS_CALL_THISCALL);

    // void Node::SetScaleSilent(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetScaleSilent(const Vector3&in)", AS_METHODPR(T, SetScaleSilent, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetScene(Scene* scene)
    engine->RegisterObjectMethod(className, "void SetScene(Scene@+)", AS_METHODPR(T, SetScene, (Scene*), void), AS_CALL_THISCALL);

    // void Node::SetTags(const StringVector& tags)
    engine->RegisterObjectMethod(className, "void SetTags(Array<String>@+)", AS_FUNCTION_OBJFIRST(Node_void_SetTags_constspStringVectoramp_template<Node>), AS_CALL_CDECL_OBJFIRST);

    // void Node::SetTransform(const Vector3& position, const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in)", AS_METHODPR(T, SetTransform, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void Node::SetTransform(const Vector3& position, const Quaternion& rotation, float scale)
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in, float)", AS_METHODPR(T, SetTransform, (const Vector3&, const Quaternion&, float), void), AS_CALL_THISCALL);

    // void Node::SetTransform(const Vector3& position, const Quaternion& rotation, const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in, const Vector3&in)", AS_METHODPR(T, SetTransform, (const Vector3&, const Quaternion&, const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetTransform(const Matrix3x4& matrix)
    engine->RegisterObjectMethod(className, "void SetTransform(const Matrix3x4&in)", AS_METHODPR(T, SetTransform, (const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Node::SetTransform2D(const Vector2& position, float rotation)
    engine->RegisterObjectMethod(className, "void SetTransform2D(const Vector2&in, float)", AS_METHODPR(T, SetTransform2D, (const Vector2&, float), void), AS_CALL_THISCALL);

    // void Node::SetTransform2D(const Vector2& position, float rotation, float scale)
    engine->RegisterObjectMethod(className, "void SetTransform2D(const Vector2&in, float, float)", AS_METHODPR(T, SetTransform2D, (const Vector2&, float, float), void), AS_CALL_THISCALL);

    // void Node::SetTransform2D(const Vector2& position, float rotation, const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetTransform2D(const Vector2&in, float, const Vector2&in)", AS_METHODPR(T, SetTransform2D, (const Vector2&, float, const Vector2&), void), AS_CALL_THISCALL);

    // void Node::SetTransformSilent(const Vector3& position, const Quaternion& rotation, const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetTransformSilent(const Vector3&in, const Quaternion&in, const Vector3&in)", AS_METHODPR(T, SetTransformSilent, (const Vector3&, const Quaternion&, const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetVar(StringHash key, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetVar(StringHash, const Variant&in)", AS_METHODPR(T, SetVar, (StringHash, const Variant&), void), AS_CALL_THISCALL);

    // void Node::SetWorldDirection(const Vector3& direction)
    engine->RegisterObjectMethod(className, "void SetWorldDirection(const Vector3&in)", AS_METHODPR(T, SetWorldDirection, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldDirection(const Vector3&in)", AS_METHODPR(T, SetWorldDirection, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetWorldPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetWorldPosition(const Vector3&in)", AS_METHODPR(T, SetWorldPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldPosition(const Vector3&in)", AS_METHODPR(T, SetWorldPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetWorldPosition2D(const Vector2& position)
    engine->RegisterObjectMethod(className, "void SetWorldPosition2D(const Vector2&in)", AS_METHODPR(T, SetWorldPosition2D, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldPosition2D(const Vector2&in)", AS_METHODPR(T, SetWorldPosition2D, (const Vector2&), void), AS_CALL_THISCALL);

    // void Node::SetWorldPosition2D(float x, float y)
    engine->RegisterObjectMethod(className, "void SetWorldPosition2D(float, float)", AS_METHODPR(T, SetWorldPosition2D, (float, float), void), AS_CALL_THISCALL);

    // void Node::SetWorldRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetWorldRotation(const Quaternion&in)", AS_METHODPR(T, SetWorldRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldRotation(const Quaternion&in)", AS_METHODPR(T, SetWorldRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void Node::SetWorldRotation2D(float rotation)
    engine->RegisterObjectMethod(className, "void SetWorldRotation2D(float)", AS_METHODPR(T, SetWorldRotation2D, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldRotation2D(float)", AS_METHODPR(T, SetWorldRotation2D, (float), void), AS_CALL_THISCALL);

    // void Node::SetWorldScale(float scale)
    engine->RegisterObjectMethod(className, "void SetWorldScale(float)", AS_METHODPR(T, SetWorldScale, (float), void), AS_CALL_THISCALL);

    // void Node::SetWorldScale(const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetWorldScale(const Vector3&in)", AS_METHODPR(T, SetWorldScale, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldScale(const Vector3&in)", AS_METHODPR(T, SetWorldScale, (const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetWorldScale2D(const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetWorldScale2D(const Vector2&in)", AS_METHODPR(T, SetWorldScale2D, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldScale2D(const Vector2&in)", AS_METHODPR(T, SetWorldScale2D, (const Vector2&), void), AS_CALL_THISCALL);

    // void Node::SetWorldScale2D(float x, float y)
    engine->RegisterObjectMethod(className, "void SetWorldScale2D(float, float)", AS_METHODPR(T, SetWorldScale2D, (float, float), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform(const Vector3& position, const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Vector3&in, const Quaternion&in)", AS_METHODPR(T, SetWorldTransform, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform(const Vector3& position, const Quaternion& rotation, float scale)
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Vector3&in, const Quaternion&in, float)", AS_METHODPR(T, SetWorldTransform, (const Vector3&, const Quaternion&, float), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform(const Vector3& position, const Quaternion& rotation, const Vector3& scale)
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Vector3&in, const Quaternion&in, const Vector3&in)", AS_METHODPR(T, SetWorldTransform, (const Vector3&, const Quaternion&, const Vector3&), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform(const Matrix3x4& worldTransform)
    engine->RegisterObjectMethod(className, "void SetWorldTransform(const Matrix3x4&in)", AS_METHODPR(T, SetWorldTransform, (const Matrix3x4&), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform2D(const Vector2& position, float rotation)
    engine->RegisterObjectMethod(className, "void SetWorldTransform2D(const Vector2&in, float)", AS_METHODPR(T, SetWorldTransform2D, (const Vector2&, float), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform2D(const Vector2& position, float rotation, float scale)
    engine->RegisterObjectMethod(className, "void SetWorldTransform2D(const Vector2&in, float, float)", AS_METHODPR(T, SetWorldTransform2D, (const Vector2&, float, float), void), AS_CALL_THISCALL);

    // void Node::SetWorldTransform2D(const Vector2& position, float rotation, const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetWorldTransform2D(const Vector2&in, float, const Vector2&in)", AS_METHODPR(T, SetWorldTransform2D, (const Vector2&, float, const Vector2&), void), AS_CALL_THISCALL);

    // void Node::Translate(const Vector3& delta, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Translate(const Vector3&in, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Translate, (const Vector3&, TransformSpace), void), AS_CALL_THISCALL);

    // void Node::Translate2D(const Vector2& delta, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Translate2D(const Vector2&in, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Translate2D, (const Vector2&, TransformSpace), void), AS_CALL_THISCALL);

    // Vector3 Node::WorldToLocal(const Vector3& position) const
    engine->RegisterObjectMethod(className, "Vector3 WorldToLocal(const Vector3&in) const", AS_METHODPR(T, WorldToLocal, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Vector3 Node::WorldToLocal(const Vector4& vector) const
    engine->RegisterObjectMethod(className, "Vector3 WorldToLocal(const Vector4&in) const", AS_METHODPR(T, WorldToLocal, (const Vector4&) const, Vector3), AS_CALL_THISCALL);

    // Vector2 Node::WorldToLocal2D(const Vector2& vector) const
    engine->RegisterObjectMethod(className, "Vector2 WorldToLocal2D(const Vector2&in) const", AS_METHODPR(T, WorldToLocal2D, (const Vector2&) const, Vector2), AS_CALL_THISCALL);

    // void Node::Yaw(float angle, TransformSpace space = TS_LOCAL)
    engine->RegisterObjectMethod(className, "void Yaw(float, TransformSpace = TS_LOCAL)", AS_METHODPR(T, Yaw, (float, TransformSpace), void), AS_CALL_THISCALL);

    // template <class T> T* Node::CreateComponent(CreateMode mode = REPLICATED, unsigned id = 0)
    // Not registered because template
    // template <class T> void Node::GetChildrenWithComponent(PODVector<Node*>& dest, bool recursive = false) const
    // Not registered because template
    // template <class T> T* Node::GetComponent(bool recursive = false) const
    // Not registered because template
    // template <class T> void Node::GetComponents(PODVector<T*>& dest, bool recursive = false) const
    // Not registered because template
    // template <class T> T* Node::GetDerivedComponent(bool recursive = false) const
    // Not registered because template
    // template <class T> void Node::GetDerivedComponents(PODVector<T*>& dest, bool recursive = false, bool clearVector = true) const
    // Not registered because template
    // template <class T> T* Node::GetOrCreateComponent(CreateMode mode = REPLICATED, unsigned id = 0)
    // Not registered because template
    // template <class T> T* Node::GetParentComponent(bool fullTraversal = false) const
    // Not registered because template
    // template <class T> T* Node::GetParentDerivedComponent(bool fullTraversal = false) const
    // Not registered because template
    // template <class T> bool Node::HasComponent() const
    // Not registered because template
    // template <class T> void Node::RemoveComponent()
    // Not registered because template
    // template <class T> void Node::RemoveComponents()
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Node
        REGISTER_MEMBERS_MANUAL_PART_Node();
    #endif
}

// SharedPtr<SoundStream> Sound::GetDecoderStream() const
template <class T> SoundStream* Sound_SharedPtrlesSoundStreamgre_GetDecoderStream_void_template(T* _ptr)
{
    SharedPtr<SoundStream> result = _ptr->GetDecoderStream();
    return result.Detach();
}

// class Sound | File: ../Audio/Sound.h
template <class T> void RegisterMembers_Sound(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ResourceWithMetadata<T>(engine, className);

    // SharedArrayPtr<signed char> Sound::GetData() const
    // Error: type "SharedArrayPtr<signed char>" can not automatically bind
    // signed char* Sound::GetEnd() const
    // Error: type "signed char*" can not automatically bind
    // signed char* Sound::GetRepeat() const
    // Error: type "signed char*" can not automatically bind
    // signed char* Sound::GetStart() const
    // Error: type "signed char*" can not automatically bind
    // void Sound::SetData(const void* data, unsigned dataSize)
    // Error: type "const void*" can not automatically bind

    // void Sound::FixInterpolation()
    engine->RegisterObjectMethod(className, "void FixInterpolation()", AS_METHODPR(T, FixInterpolation, (), void), AS_CALL_THISCALL);

    // unsigned Sound::GetDataSize() const
    engine->RegisterObjectMethod(className, "uint GetDataSize() const", AS_METHODPR(T, GetDataSize, () const, unsigned), AS_CALL_THISCALL);

    // SharedPtr<SoundStream> Sound::GetDecoderStream() const
    engine->RegisterObjectMethod(className, "SoundStream@+ GetDecoderStream() const", AS_FUNCTION_OBJFIRST(Sound_SharedPtrlesSoundStreamgre_GetDecoderStream_void_template<Sound>), AS_CALL_CDECL_OBJFIRST);

    // float Sound::GetFrequency() const
    engine->RegisterObjectMethod(className, "float GetFrequency() const", AS_METHODPR(T, GetFrequency, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequency() const", AS_METHODPR(T, GetFrequency, () const, float), AS_CALL_THISCALL);

    // unsigned Sound::GetIntFrequency() const
    engine->RegisterObjectMethod(className, "uint GetIntFrequency() const", AS_METHODPR(T, GetIntFrequency, () const, unsigned), AS_CALL_THISCALL);

    // float Sound::GetLength() const
    engine->RegisterObjectMethod(className, "float GetLength() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);

    // unsigned Sound::GetSampleSize() const
    engine->RegisterObjectMethod(className, "uint GetSampleSize() const", AS_METHODPR(T, GetSampleSize, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_sampleSize() const", AS_METHODPR(T, GetSampleSize, () const, unsigned), AS_CALL_THISCALL);

    // bool Sound::IsCompressed() const
    engine->RegisterObjectMethod(className, "bool IsCompressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_compressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);

    // bool Sound::IsLooped() const
    engine->RegisterObjectMethod(className, "bool IsLooped() const", AS_METHODPR(T, IsLooped, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_looped() const", AS_METHODPR(T, IsLooped, () const, bool), AS_CALL_THISCALL);

    // bool Sound::IsSixteenBit() const
    engine->RegisterObjectMethod(className, "bool IsSixteenBit() const", AS_METHODPR(T, IsSixteenBit, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sixteenBit() const", AS_METHODPR(T, IsSixteenBit, () const, bool), AS_CALL_THISCALL);

    // bool Sound::IsStereo() const
    engine->RegisterObjectMethod(className, "bool IsStereo() const", AS_METHODPR(T, IsStereo, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_stereo() const", AS_METHODPR(T, IsStereo, () const, bool), AS_CALL_THISCALL);

    // bool Sound::LoadOggVorbis(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadOggVorbis(Deserializer&)", AS_METHODPR(T, LoadOggVorbis, (Deserializer&), bool), AS_CALL_THISCALL);

    // bool Sound::LoadRaw(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadRaw(Deserializer&)", AS_METHODPR(T, LoadRaw, (Deserializer&), bool), AS_CALL_THISCALL);

    // bool Sound::LoadWav(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadWav(Deserializer&)", AS_METHODPR(T, LoadWav, (Deserializer&), bool), AS_CALL_THISCALL);

    // void Sound::SetFormat(unsigned frequency, bool sixteenBit, bool stereo)
    engine->RegisterObjectMethod(className, "void SetFormat(uint, bool, bool)", AS_METHODPR(T, SetFormat, (unsigned, bool, bool), void), AS_CALL_THISCALL);

    // void Sound::SetLoop(unsigned repeatOffset, unsigned endOffset)
    engine->RegisterObjectMethod(className, "void SetLoop(uint, uint)", AS_METHODPR(T, SetLoop, (unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Sound::SetLooped(bool enable)
    engine->RegisterObjectMethod(className, "void SetLooped(bool)", AS_METHODPR(T, SetLooped, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_looped(bool)", AS_METHODPR(T, SetLooped, (bool), void), AS_CALL_THISCALL);

    // void Sound::SetSize(unsigned dataSize)
    engine->RegisterObjectMethod(className, "void SetSize(uint)", AS_METHODPR(T, SetSize, (unsigned), void), AS_CALL_THISCALL);

    // static void Sound::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Sound
        REGISTER_MEMBERS_MANUAL_PART_Sound();
    #endif
}

// class Texture | File: ../Graphics/Texture.h
template <class T> void RegisterMembers_Texture(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ResourceWithMetadata<T>(engine, className);
    RegisterMembers_GPUObject<T>(engine, className);

    // void* Texture::GetResolveTexture() const
    // Error: type "void*" can not automatically bind
    // void* Texture::GetSampler() const
    // Error: type "void*" can not automatically bind
    // void* Texture::GetShaderResourceView() const
    // Error: type "void*" can not automatically bind
    // unsigned Texture::GetSRGBFormat(unsigned format)
    // Not registered because have @nobind mark

    // TextureAddressMode Texture::GetAddressMode(TextureCoordinate coord) const
    engine->RegisterObjectMethod(className, "TextureAddressMode GetAddressMode(TextureCoordinate) const", AS_METHODPR(T, GetAddressMode, (TextureCoordinate) const, TextureAddressMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureAddressMode get_addressMode(TextureCoordinate) const", AS_METHODPR(T, GetAddressMode, (TextureCoordinate) const, TextureAddressMode), AS_CALL_THISCALL);

    // unsigned Texture::GetAnisotropy() const
    engine->RegisterObjectMethod(className, "uint GetAnisotropy() const", AS_METHODPR(T, GetAnisotropy, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_anisotropy() const", AS_METHODPR(T, GetAnisotropy, () const, unsigned), AS_CALL_THISCALL);

    // bool Texture::GetAutoResolve() const
    engine->RegisterObjectMethod(className, "bool GetAutoResolve() const", AS_METHODPR(T, GetAutoResolve, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoResolve() const", AS_METHODPR(T, GetAutoResolve, () const, bool), AS_CALL_THISCALL);

    // Texture* Texture::GetBackupTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetBackupTexture() const", AS_METHODPR(T, GetBackupTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_backupTexture() const", AS_METHODPR(T, GetBackupTexture, () const, Texture*), AS_CALL_THISCALL);

    // const Color& Texture::GetBorderColor() const
    engine->RegisterObjectMethod(className, "const Color& GetBorderColor() const", AS_METHODPR(T, GetBorderColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_borderColor() const", AS_METHODPR(T, GetBorderColor, () const, const Color&), AS_CALL_THISCALL);

    // unsigned Texture::GetComponents() const
    engine->RegisterObjectMethod(className, "uint GetComponents() const", AS_METHODPR(T, GetComponents, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_components() const", AS_METHODPR(T, GetComponents, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Texture::GetDataSize(int width, int height) const
    engine->RegisterObjectMethod(className, "uint GetDataSize(int, int) const", AS_METHODPR(T, GetDataSize, (int, int) const, unsigned), AS_CALL_THISCALL);

    // unsigned Texture::GetDataSize(int width, int height, int depth) const
    engine->RegisterObjectMethod(className, "uint GetDataSize(int, int, int) const", AS_METHODPR(T, GetDataSize, (int, int, int) const, unsigned), AS_CALL_THISCALL);

    // int Texture::GetDepth() const
    engine->RegisterObjectMethod(className, "int GetDepth() const", AS_METHODPR(T, GetDepth, () const, int), AS_CALL_THISCALL);

    // TextureFilterMode Texture::GetFilterMode() const
    engine->RegisterObjectMethod(className, "TextureFilterMode GetFilterMode() const", AS_METHODPR(T, GetFilterMode, () const, TextureFilterMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureFilterMode get_filterMode() const", AS_METHODPR(T, GetFilterMode, () const, TextureFilterMode), AS_CALL_THISCALL);

    // unsigned Texture::GetFormat() const
    engine->RegisterObjectMethod(className, "uint GetFormat() const", AS_METHODPR(T, GetFormat, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_format() const", AS_METHODPR(T, GetFormat, () const, unsigned), AS_CALL_THISCALL);

    // int Texture::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // int Texture::GetLevelDepth(unsigned level) const
    engine->RegisterObjectMethod(className, "int GetLevelDepth(uint) const", AS_METHODPR(T, GetLevelDepth, (unsigned) const, int), AS_CALL_THISCALL);

    // int Texture::GetLevelHeight(unsigned level) const
    engine->RegisterObjectMethod(className, "int GetLevelHeight(uint) const", AS_METHODPR(T, GetLevelHeight, (unsigned) const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_levelHeight(uint) const", AS_METHODPR(T, GetLevelHeight, (unsigned) const, int), AS_CALL_THISCALL);

    // unsigned Texture::GetLevels() const
    engine->RegisterObjectMethod(className, "uint GetLevels() const", AS_METHODPR(T, GetLevels, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_levels() const", AS_METHODPR(T, GetLevels, () const, unsigned), AS_CALL_THISCALL);

    // bool Texture::GetLevelsDirty() const
    engine->RegisterObjectMethod(className, "bool GetLevelsDirty() const", AS_METHODPR(T, GetLevelsDirty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_levelsDirty() const", AS_METHODPR(T, GetLevelsDirty, () const, bool), AS_CALL_THISCALL);

    // int Texture::GetLevelWidth(unsigned level) const
    engine->RegisterObjectMethod(className, "int GetLevelWidth(uint) const", AS_METHODPR(T, GetLevelWidth, (unsigned) const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_levelWidth(uint) const", AS_METHODPR(T, GetLevelWidth, (unsigned) const, int), AS_CALL_THISCALL);

    // int Texture::GetMipsToSkip(MaterialQuality quality) const
    engine->RegisterObjectMethod(className, "int GetMipsToSkip(MaterialQuality) const", AS_METHODPR(T, GetMipsToSkip, (MaterialQuality) const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_mipsToSkip(MaterialQuality) const", AS_METHODPR(T, GetMipsToSkip, (MaterialQuality) const, int), AS_CALL_THISCALL);

    // int Texture::GetMultiSample() const
    engine->RegisterObjectMethod(className, "int GetMultiSample() const", AS_METHODPR(T, GetMultiSample, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_multiSample() const", AS_METHODPR(T, GetMultiSample, () const, int), AS_CALL_THISCALL);

    // bool Texture::GetParametersDirty() const
    engine->RegisterObjectMethod(className, "bool GetParametersDirty() const", AS_METHODPR(T, GetParametersDirty, () const, bool), AS_CALL_THISCALL);

    // unsigned Texture::GetRowDataSize(int width) const
    engine->RegisterObjectMethod(className, "uint GetRowDataSize(int) const", AS_METHODPR(T, GetRowDataSize, (int) const, unsigned), AS_CALL_THISCALL);

    // bool Texture::GetShadowCompare() const
    engine->RegisterObjectMethod(className, "bool GetShadowCompare() const", AS_METHODPR(T, GetShadowCompare, () const, bool), AS_CALL_THISCALL);

    // bool Texture::GetSRGB() const
    engine->RegisterObjectMethod(className, "bool GetSRGB() const", AS_METHODPR(T, GetSRGB, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sRGB() const", AS_METHODPR(T, GetSRGB, () const, bool), AS_CALL_THISCALL);

    // unsigned Texture::GetTarget() const
    engine->RegisterObjectMethod(className, "uint GetTarget() const", AS_METHODPR(T, GetTarget, () const, unsigned), AS_CALL_THISCALL);

    // TextureUsage Texture::GetUsage() const
    engine->RegisterObjectMethod(className, "TextureUsage GetUsage() const", AS_METHODPR(T, GetUsage, () const, TextureUsage), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextureUsage get_usage() const", AS_METHODPR(T, GetUsage, () const, TextureUsage), AS_CALL_THISCALL);

    // int Texture::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool Texture::IsCompressed() const
    engine->RegisterObjectMethod(className, "bool IsCompressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_compressed() const", AS_METHODPR(T, IsCompressed, () const, bool), AS_CALL_THISCALL);

    // bool Texture::IsResolveDirty() const
    engine->RegisterObjectMethod(className, "bool IsResolveDirty() const", AS_METHODPR(T, IsResolveDirty, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resolveDirty() const", AS_METHODPR(T, IsResolveDirty, () const, bool), AS_CALL_THISCALL);

    // void Texture::RegenerateLevels()
    engine->RegisterObjectMethod(className, "void RegenerateLevels()", AS_METHODPR(T, RegenerateLevels, (), void), AS_CALL_THISCALL);

    // void Texture::SetAddressMode(TextureCoordinate coord, TextureAddressMode mode)
    engine->RegisterObjectMethod(className, "void SetAddressMode(TextureCoordinate, TextureAddressMode)", AS_METHODPR(T, SetAddressMode, (TextureCoordinate, TextureAddressMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_addressMode(TextureCoordinate, TextureAddressMode)", AS_METHODPR(T, SetAddressMode, (TextureCoordinate, TextureAddressMode), void), AS_CALL_THISCALL);

    // void Texture::SetAnisotropy(unsigned level)
    engine->RegisterObjectMethod(className, "void SetAnisotropy(uint)", AS_METHODPR(T, SetAnisotropy, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anisotropy(uint)", AS_METHODPR(T, SetAnisotropy, (unsigned), void), AS_CALL_THISCALL);

    // void Texture::SetBackupTexture(Texture* texture)
    engine->RegisterObjectMethod(className, "void SetBackupTexture(Texture@+)", AS_METHODPR(T, SetBackupTexture, (Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_backupTexture(Texture@+)", AS_METHODPR(T, SetBackupTexture, (Texture*), void), AS_CALL_THISCALL);

    // void Texture::SetBorderColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetBorderColor(const Color&in)", AS_METHODPR(T, SetBorderColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_borderColor(const Color&in)", AS_METHODPR(T, SetBorderColor, (const Color&), void), AS_CALL_THISCALL);

    // void Texture::SetFilterMode(TextureFilterMode mode)
    engine->RegisterObjectMethod(className, "void SetFilterMode(TextureFilterMode)", AS_METHODPR(T, SetFilterMode, (TextureFilterMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_filterMode(TextureFilterMode)", AS_METHODPR(T, SetFilterMode, (TextureFilterMode), void), AS_CALL_THISCALL);

    // void Texture::SetLevelsDirty()
    engine->RegisterObjectMethod(className, "void SetLevelsDirty()", AS_METHODPR(T, SetLevelsDirty, (), void), AS_CALL_THISCALL);

    // void Texture::SetMipsToSkip(MaterialQuality quality, int toSkip)
    engine->RegisterObjectMethod(className, "void SetMipsToSkip(MaterialQuality, int)", AS_METHODPR(T, SetMipsToSkip, (MaterialQuality, int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mipsToSkip(MaterialQuality, int)", AS_METHODPR(T, SetMipsToSkip, (MaterialQuality, int), void), AS_CALL_THISCALL);

    // void Texture::SetNumLevels(unsigned levels)
    engine->RegisterObjectMethod(className, "void SetNumLevels(uint)", AS_METHODPR(T, SetNumLevels, (unsigned), void), AS_CALL_THISCALL);

    // void Texture::SetParameters(XMLFile* file)
    engine->RegisterObjectMethod(className, "void SetParameters(XMLFile@+)", AS_METHODPR(T, SetParameters, (XMLFile*), void), AS_CALL_THISCALL);

    // void Texture::SetParameters(const XMLElement& element)
    engine->RegisterObjectMethod(className, "void SetParameters(const XMLElement&in)", AS_METHODPR(T, SetParameters, (const XMLElement&), void), AS_CALL_THISCALL);

    // void Texture::SetParametersDirty()
    engine->RegisterObjectMethod(className, "void SetParametersDirty()", AS_METHODPR(T, SetParametersDirty, (), void), AS_CALL_THISCALL);

    // void Texture::SetResolveDirty(bool enable)
    engine->RegisterObjectMethod(className, "void SetResolveDirty(bool)", AS_METHODPR(T, SetResolveDirty, (bool), void), AS_CALL_THISCALL);

    // void Texture::SetShadowCompare(bool enable)
    engine->RegisterObjectMethod(className, "void SetShadowCompare(bool)", AS_METHODPR(T, SetShadowCompare, (bool), void), AS_CALL_THISCALL);

    // void Texture::SetSRGB(bool enable)
    engine->RegisterObjectMethod(className, "void SetSRGB(bool)", AS_METHODPR(T, SetSRGB, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sRGB(bool)", AS_METHODPR(T, SetSRGB, (bool), void), AS_CALL_THISCALL);

    // void Texture::UpdateParameters()
    engine->RegisterObjectMethod(className, "void UpdateParameters()", AS_METHODPR(T, UpdateParameters, (), void), AS_CALL_THISCALL);

    // static unsigned Texture::GetSRVFormat(unsigned format)
    // Not registered because have @nobind mark
    // static unsigned Texture::GetDSVFormat(unsigned format)
    // Not registered because have @nobind mark
    // static unsigned Texture::GetExternalFormat(unsigned format)
    // Not registered because have @nobind mark
    // static unsigned Texture::GetDataType(unsigned format)
    // Not registered because have @nobind mark

    // static unsigned Texture::CheckMaxLevels(int width, int height, unsigned requestedLevels)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint CheckMaxLevels(int, int, uint)", AS_FUNCTIONPR(T::CheckMaxLevels, (int, int, unsigned), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    // static unsigned Texture::CheckMaxLevels(int width, int height, int depth, unsigned requestedLevels)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("uint CheckMaxLevels(int, int, int, uint)", AS_FUNCTIONPR(T::CheckMaxLevels, (int, int, int, unsigned), unsigned), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Texture
        REGISTER_MEMBERS_MANUAL_PART_Texture();
    #endif
}

// void UIElement::AddTags(const StringVector& tags)
template <class T> void UIElement_void_AddTags_constspStringVectoramp_template(T* _ptr, CScriptArray* tags_conv)
{
    StringVector tags = ArrayToVector<String>(tags_conv);
    _ptr->AddTags(tags);
}

// const Vector<SharedPtr<UIElement>>& UIElement::GetChildren() const
template <class T> CScriptArray* UIElement_constspVectorlesSharedPtrlesUIElementgregreamp_GetChildren_void_template(T* _ptr)
{
    const Vector<SharedPtr<UIElement>>& result = _ptr->GetChildren();
    return VectorToHandleArray(result, "Array<UIElement@>");
}

// PODVector<UIElement*> UIElement::GetChildren(bool recursive) const
template <class T> CScriptArray* UIElement_PODVectorlesUIElementstargre_GetChildren_bool_template(T* _ptr, bool recursive)
{
    PODVector<UIElement*> result = _ptr->GetChildren(recursive);
    return VectorToHandleArray(result, "Array<UIElement@>");
}

// PODVector<UIElement*> UIElement::GetChildrenWithTag(const String& tag, bool recursive = false) const
template <class T> CScriptArray* UIElement_PODVectorlesUIElementstargre_GetChildrenWithTag_constspStringamp_bool_template(T* _ptr, const String& tag, bool recursive)
{
    PODVector<UIElement*> result = _ptr->GetChildrenWithTag(tag, recursive);
    return VectorToHandleArray(result, "Array<UIElement@>");
}

// const StringVector& UIElement::GetTags() const
template <class T> CScriptArray* UIElement_constspStringVectoramp_GetTags_void_template(T* _ptr)
{
    const StringVector& result = _ptr->GetTags();
    return VectorToArray<String>(result, "Array<String>");
}

// void UIElement::SetTags(const StringVector& tags)
template <class T> void UIElement_void_SetTags_constspStringVectoramp_template(T* _ptr, CScriptArray* tags_conv)
{
    StringVector tags = ArrayToVector<String>(tags_conv);
    _ptr->SetTags(tags);
}

// class UIElement | File: ../UI/UIElement.h
template <class T> void RegisterMembers_UIElement(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Animatable<T>(engine, className);

    // virtual void UIElement::GetBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor)
    // Error: type "PODVector<UIBatch>&" can not automatically bind
    // void UIElement::GetBatchesWithOffset(IntVector2& offset, PODVector<UIBatch>& batches, PODVector<float>& vertexData, IntRect currentScissor)
    // Error: type "PODVector<UIBatch>&" can not automatically bind
    // void UIElement::GetChildren(PODVector<UIElement*>& dest, bool recursive = false) const
    // Error: type "PODVector<UIElement*>&" can not automatically bind
    // void UIElement::GetChildrenWithTag(PODVector<UIElement*>& dest, const String& tag, bool recursive = false) const
    // Error: type "PODVector<UIElement*>&" can not automatically bind
    // virtual void UIElement::GetDebugDrawBatches(PODVector<UIBatch>& batches, PODVector<float>& vertexData, const IntRect& currentScissor)
    // Error: type "PODVector<UIBatch>&" can not automatically bind
    // const IntVector2& UIElement::GetPosition() const
    // Can not be registered here bacause hidden in derived classes: Sprite
    // bool UIElement::IsSelected() const
    // Can not be registered here bacause hidden in derived classes: ListView
    // void UIElement::SetPosition(const IntVector2& position)
    // Can not be registered here bacause hidden in derived classes: Sprite
    // void UIElement::SetPosition(int x, int y)
    // Can not be registered here bacause hidden in derived classes: Sprite

    // void UIElement::AddChild(UIElement* element)
    engine->RegisterObjectMethod(className, "void AddChild(UIElement@+)", AS_METHODPR(T, AddChild, (UIElement*), void), AS_CALL_THISCALL);

    // void UIElement::AddTag(const String& tag)
    engine->RegisterObjectMethod(className, "void AddTag(const String&in)", AS_METHODPR(T, AddTag, (const String&), void), AS_CALL_THISCALL);

    // void UIElement::AddTags(const String& tags, char separator = ';')
    engine->RegisterObjectMethod(className, "void AddTags(const String&in, int8 = ';')", AS_METHODPR(T, AddTags, (const String&, char), void), AS_CALL_THISCALL);

    // void UIElement::AddTags(const StringVector& tags)
    engine->RegisterObjectMethod(className, "void AddTags(Array<String>@+)", AS_FUNCTION_OBJFIRST(UIElement_void_AddTags_constspStringVectoramp_template<UIElement>), AS_CALL_CDECL_OBJFIRST);

    // void UIElement::AdjustScissor(IntRect& currentScissor)
    engine->RegisterObjectMethod(className, "void AdjustScissor(IntRect&)", AS_METHODPR(T, AdjustScissor, (IntRect&), void), AS_CALL_THISCALL);

    // void UIElement::BringToFront()
    engine->RegisterObjectMethod(className, "void BringToFront()", AS_METHODPR(T, BringToFront, (), void), AS_CALL_THISCALL);

    // UIElement* UIElement::CreateChild(StringHash type, const String& name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "UIElement@+ CreateChild(StringHash, const String&in = String::EMPTY, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, CreateChild, (StringHash, const String&, unsigned), UIElement*), AS_CALL_THISCALL);

    // void UIElement::DisableLayoutUpdate()
    engine->RegisterObjectMethod(className, "void DisableLayoutUpdate()", AS_METHODPR(T, DisableLayoutUpdate, (), void), AS_CALL_THISCALL);

    // virtual IntVector2 UIElement::ElementToScreen(const IntVector2& position)
    engine->RegisterObjectMethod(className, "IntVector2 ElementToScreen(const IntVector2&in)", AS_METHODPR(T, ElementToScreen, (const IntVector2&), IntVector2), AS_CALL_THISCALL);

    // void UIElement::EnableLayoutUpdate()
    engine->RegisterObjectMethod(className, "void EnableLayoutUpdate()", AS_METHODPR(T, EnableLayoutUpdate, (), void), AS_CALL_THISCALL);

    // bool UIElement::FilterAttributes(XMLElement& dest) const
    engine->RegisterObjectMethod(className, "bool FilterAttributes(XMLElement&) const", AS_METHODPR(T, FilterAttributes, (XMLElement&) const, bool), AS_CALL_THISCALL);

    // unsigned UIElement::FindChild(UIElement* element) const
    engine->RegisterObjectMethod(className, "uint FindChild(UIElement@+) const", AS_METHODPR(T, FindChild, (UIElement*) const, unsigned), AS_CALL_THISCALL);

    // const String& UIElement::GetAppliedStyle() const
    engine->RegisterObjectMethod(className, "const String& GetAppliedStyle() const", AS_METHODPR(T, GetAppliedStyle, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_style() const", AS_METHODPR(T, GetAppliedStyle, () const, const String&), AS_CALL_THISCALL);

    // bool UIElement::GetBringToBack() const
    engine->RegisterObjectMethod(className, "bool GetBringToBack() const", AS_METHODPR(T, GetBringToBack, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_bringToBack() const", AS_METHODPR(T, GetBringToBack, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::GetBringToFront() const
    engine->RegisterObjectMethod(className, "bool GetBringToFront() const", AS_METHODPR(T, GetBringToFront, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_bringToFront() const", AS_METHODPR(T, GetBringToFront, () const, bool), AS_CALL_THISCALL);

    // UIElement* UIElement::GetChild(unsigned index) const
    engine->RegisterObjectMethod(className, "UIElement@+ GetChild(uint) const", AS_METHODPR(T, GetChild, (unsigned) const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_children(uint) const", AS_METHODPR(T, GetChild, (unsigned) const, UIElement*), AS_CALL_THISCALL);

    // UIElement* UIElement::GetChild(const String& name, bool recursive = false) const
    engine->RegisterObjectMethod(className, "UIElement@+ GetChild(const String&in, bool = false) const", AS_METHODPR(T, GetChild, (const String&, bool) const, UIElement*), AS_CALL_THISCALL);

    // UIElement* UIElement::GetChild(const StringHash& key, const Variant& value = Variant::EMPTY, bool recursive = false) const
    engine->RegisterObjectMethod(className, "UIElement@+ GetChild(const StringHash&in, const Variant&in = Variant::EMPTY, bool = false) const", AS_METHODPR(T, GetChild, (const StringHash&, const Variant&, bool) const, UIElement*), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetChildOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetChildOffset() const", AS_METHODPR(T, GetChildOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_childOffset() const", AS_METHODPR(T, GetChildOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const Vector<SharedPtr<UIElement>>& UIElement::GetChildren() const
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetChildren() const", AS_FUNCTION_OBJFIRST(UIElement_constspVectorlesSharedPtrlesUIElementgregreamp_GetChildren_void_template<UIElement>), AS_CALL_CDECL_OBJFIRST);

    // PODVector<UIElement*> UIElement::GetChildren(bool recursive) const
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetChildren(bool) const", AS_FUNCTION_OBJFIRST(UIElement_PODVectorlesUIElementstargre_GetChildren_bool_template<UIElement>), AS_CALL_CDECL_OBJFIRST);

    // PODVector<UIElement*> UIElement::GetChildrenWithTag(const String& tag, bool recursive = false) const
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetChildrenWithTag(const String&in, bool = false) const", AS_FUNCTION_OBJFIRST(UIElement_PODVectorlesUIElementstargre_GetChildrenWithTag_constspStringamp_bool_template<UIElement>), AS_CALL_CDECL_OBJFIRST);

    // const IntRect& UIElement::GetClipBorder() const
    engine->RegisterObjectMethod(className, "const IntRect& GetClipBorder() const", AS_METHODPR(T, GetClipBorder, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_clipBorder() const", AS_METHODPR(T, GetClipBorder, () const, const IntRect&), AS_CALL_THISCALL);

    // bool UIElement::GetClipChildren() const
    engine->RegisterObjectMethod(className, "bool GetClipChildren() const", AS_METHODPR(T, GetClipChildren, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_clipChildren() const", AS_METHODPR(T, GetClipChildren, () const, bool), AS_CALL_THISCALL);

    // const Color& UIElement::GetColor(Corner corner) const
    engine->RegisterObjectMethod(className, "const Color& GetColor(Corner) const", AS_METHODPR(T, GetColor, (Corner) const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_colors(Corner) const", AS_METHODPR(T, GetColor, (Corner) const, const Color&), AS_CALL_THISCALL);

    // const Color& UIElement::GetColorAttr() const
    engine->RegisterObjectMethod(className, "const Color& GetColorAttr() const", AS_METHODPR(T, GetColorAttr, () const, const Color&), AS_CALL_THISCALL);

    // IntRect UIElement::GetCombinedScreenRect()
    engine->RegisterObjectMethod(className, "IntRect GetCombinedScreenRect()", AS_METHODPR(T, GetCombinedScreenRect, (), IntRect), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntRect get_combinedScreenRect()", AS_METHODPR(T, GetCombinedScreenRect, (), IntRect), AS_CALL_THISCALL);

    // XMLFile* UIElement::GetDefaultStyle(bool recursiveUp = true) const
    engine->RegisterObjectMethod(className, "XMLFile@+ GetDefaultStyle(bool = true) const", AS_METHODPR(T, GetDefaultStyle, (bool) const, XMLFile*), AS_CALL_THISCALL);

    // const Color& UIElement::GetDerivedColor() const
    engine->RegisterObjectMethod(className, "const Color& GetDerivedColor() const", AS_METHODPR(T, GetDerivedColor, () const, const Color&), AS_CALL_THISCALL);

    // float UIElement::GetDerivedOpacity() const
    engine->RegisterObjectMethod(className, "float GetDerivedOpacity() const", AS_METHODPR(T, GetDerivedOpacity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_derivedOpacity() const", AS_METHODPR(T, GetDerivedOpacity, () const, float), AS_CALL_THISCALL);

    // MouseButtonFlags UIElement::GetDragButtonCombo() const
    engine->RegisterObjectMethod(className, "MouseButtonFlags GetDragButtonCombo() const", AS_METHODPR(T, GetDragButtonCombo, () const, MouseButtonFlags), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "MouseButtonFlags get_dragButtonCombo() const", AS_METHODPR(T, GetDragButtonCombo, () const, MouseButtonFlags), AS_CALL_THISCALL);

    // unsigned UIElement::GetDragButtonCount() const
    engine->RegisterObjectMethod(className, "uint GetDragButtonCount() const", AS_METHODPR(T, GetDragButtonCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_dragButtonCount() const", AS_METHODPR(T, GetDragButtonCount, () const, unsigned), AS_CALL_THISCALL);

    // DragAndDropModeFlags UIElement::GetDragDropMode() const
    engine->RegisterObjectMethod(className, "DragAndDropModeFlags GetDragDropMode() const", AS_METHODPR(T, GetDragDropMode, () const, DragAndDropModeFlags), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "DragAndDropModeFlags get_dragDropMode() const", AS_METHODPR(T, GetDragDropMode, () const, DragAndDropModeFlags), AS_CALL_THISCALL);

    // IntVector2 UIElement::GetEffectiveMinSize() const
    engine->RegisterObjectMethod(className, "IntVector2 GetEffectiveMinSize() const", AS_METHODPR(T, GetEffectiveMinSize, () const, IntVector2), AS_CALL_THISCALL);

    // UIElement* UIElement::GetElementEventSender() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetElementEventSender() const", AS_METHODPR(T, GetElementEventSender, () const, UIElement*), AS_CALL_THISCALL);

    // bool UIElement::GetEnableAnchor() const
    engine->RegisterObjectMethod(className, "bool GetEnableAnchor() const", AS_METHODPR(T, GetEnableAnchor, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableAnchor() const", AS_METHODPR(T, GetEnableAnchor, () const, bool), AS_CALL_THISCALL);

    // FocusMode UIElement::GetFocusMode() const
    engine->RegisterObjectMethod(className, "FocusMode GetFocusMode() const", AS_METHODPR(T, GetFocusMode, () const, FocusMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FocusMode get_focusMode() const", AS_METHODPR(T, GetFocusMode, () const, FocusMode), AS_CALL_THISCALL);

    // int UIElement::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // HorizontalAlignment UIElement::GetHorizontalAlignment() const
    engine->RegisterObjectMethod(className, "HorizontalAlignment GetHorizontalAlignment() const", AS_METHODPR(T, GetHorizontalAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "HorizontalAlignment get_horizontalAlignment() const", AS_METHODPR(T, GetHorizontalAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);

    // int UIElement::GetIndent() const
    engine->RegisterObjectMethod(className, "int GetIndent() const", AS_METHODPR(T, GetIndent, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_indent() const", AS_METHODPR(T, GetIndent, () const, int), AS_CALL_THISCALL);

    // int UIElement::GetIndentSpacing() const
    engine->RegisterObjectMethod(className, "int GetIndentSpacing() const", AS_METHODPR(T, GetIndentSpacing, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_indentSpacing() const", AS_METHODPR(T, GetIndentSpacing, () const, int), AS_CALL_THISCALL);

    // int UIElement::GetIndentWidth() const
    engine->RegisterObjectMethod(className, "int GetIndentWidth() const", AS_METHODPR(T, GetIndentWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_indentWidth() const", AS_METHODPR(T, GetIndentWidth, () const, int), AS_CALL_THISCALL);

    // const IntRect& UIElement::GetLayoutBorder() const
    engine->RegisterObjectMethod(className, "const IntRect& GetLayoutBorder() const", AS_METHODPR(T, GetLayoutBorder, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_layoutBorder() const", AS_METHODPR(T, GetLayoutBorder, () const, const IntRect&), AS_CALL_THISCALL);

    // int UIElement::GetLayoutElementMaxSize() const
    engine->RegisterObjectMethod(className, "int GetLayoutElementMaxSize() const", AS_METHODPR(T, GetLayoutElementMaxSize, () const, int), AS_CALL_THISCALL);

    // const Vector2& UIElement::GetLayoutFlexScale() const
    engine->RegisterObjectMethod(className, "const Vector2& GetLayoutFlexScale() const", AS_METHODPR(T, GetLayoutFlexScale, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_layoutFlexScale() const", AS_METHODPR(T, GetLayoutFlexScale, () const, const Vector2&), AS_CALL_THISCALL);

    // LayoutMode UIElement::GetLayoutMode() const
    engine->RegisterObjectMethod(className, "LayoutMode GetLayoutMode() const", AS_METHODPR(T, GetLayoutMode, () const, LayoutMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LayoutMode get_layoutMode() const", AS_METHODPR(T, GetLayoutMode, () const, LayoutMode), AS_CALL_THISCALL);

    // int UIElement::GetLayoutSpacing() const
    engine->RegisterObjectMethod(className, "int GetLayoutSpacing() const", AS_METHODPR(T, GetLayoutSpacing, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_layoutSpacing() const", AS_METHODPR(T, GetLayoutSpacing, () const, int), AS_CALL_THISCALL);

    // const Vector2& UIElement::GetMaxAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetMaxAnchor() const", AS_METHODPR(T, GetMaxAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_maxAnchor() const", AS_METHODPR(T, GetMaxAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // int UIElement::GetMaxHeight() const
    engine->RegisterObjectMethod(className, "int GetMaxHeight() const", AS_METHODPR(T, GetMaxHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxHeight() const", AS_METHODPR(T, GetMaxHeight, () const, int), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetMaxOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetMaxOffset() const", AS_METHODPR(T, GetMaxOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_maxOffset() const", AS_METHODPR(T, GetMaxOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetMaxSize() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetMaxSize() const", AS_METHODPR(T, GetMaxSize, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_maxSize() const", AS_METHODPR(T, GetMaxSize, () const, const IntVector2&), AS_CALL_THISCALL);

    // int UIElement::GetMaxWidth() const
    engine->RegisterObjectMethod(className, "int GetMaxWidth() const", AS_METHODPR(T, GetMaxWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxWidth() const", AS_METHODPR(T, GetMaxWidth, () const, int), AS_CALL_THISCALL);

    // const Vector2& UIElement::GetMinAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetMinAnchor() const", AS_METHODPR(T, GetMinAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_minAnchor() const", AS_METHODPR(T, GetMinAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // int UIElement::GetMinHeight() const
    engine->RegisterObjectMethod(className, "int GetMinHeight() const", AS_METHODPR(T, GetMinHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_minHeight() const", AS_METHODPR(T, GetMinHeight, () const, int), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetMinOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetMinOffset() const", AS_METHODPR(T, GetMinOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_minOffset() const", AS_METHODPR(T, GetMinOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetMinSize() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetMinSize() const", AS_METHODPR(T, GetMinSize, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_minSize() const", AS_METHODPR(T, GetMinSize, () const, const IntVector2&), AS_CALL_THISCALL);

    // int UIElement::GetMinWidth() const
    engine->RegisterObjectMethod(className, "int GetMinWidth() const", AS_METHODPR(T, GetMinWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_minWidth() const", AS_METHODPR(T, GetMinWidth, () const, int), AS_CALL_THISCALL);

    // const String& UIElement::GetName() const
    engine->RegisterObjectMethod(className, "const String& GetName() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_name() const", AS_METHODPR(T, GetName, () const, const String&), AS_CALL_THISCALL);

    // unsigned UIElement::GetNumChildren(bool recursive = false) const
    engine->RegisterObjectMethod(className, "uint GetNumChildren(bool = false) const", AS_METHODPR(T, GetNumChildren, (bool) const, unsigned), AS_CALL_THISCALL);

    // float UIElement::GetOpacity() const
    engine->RegisterObjectMethod(className, "float GetOpacity() const", AS_METHODPR(T, GetOpacity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_opacity() const", AS_METHODPR(T, GetOpacity, () const, float), AS_CALL_THISCALL);

    // UIElement* UIElement::GetParent() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetParent() const", AS_METHODPR(T, GetParent, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_parent() const", AS_METHODPR(T, GetParent, () const, UIElement*), AS_CALL_THISCALL);

    // const Vector2& UIElement::GetPivot() const
    engine->RegisterObjectMethod(className, "const Vector2& GetPivot() const", AS_METHODPR(T, GetPivot, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_pivot() const", AS_METHODPR(T, GetPivot, () const, const Vector2&), AS_CALL_THISCALL);

    // int UIElement::GetPriority() const
    engine->RegisterObjectMethod(className, "int GetPriority() const", AS_METHODPR(T, GetPriority, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_priority() const", AS_METHODPR(T, GetPriority, () const, int), AS_CALL_THISCALL);

    // UIElement* UIElement::GetRoot() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetRoot() const", AS_METHODPR(T, GetRoot, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_root() const", AS_METHODPR(T, GetRoot, () const, UIElement*), AS_CALL_THISCALL);

    // virtual const IntVector2& UIElement::GetScreenPosition() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetScreenPosition() const", AS_METHODPR(T, GetScreenPosition, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_screenPosition() const", AS_METHODPR(T, GetScreenPosition, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetSize() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetSize() const", AS_METHODPR(T, GetSize, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_size() const", AS_METHODPR(T, GetSize, () const, const IntVector2&), AS_CALL_THISCALL);

    // bool UIElement::GetSortChildren() const
    engine->RegisterObjectMethod(className, "bool GetSortChildren() const", AS_METHODPR(T, GetSortChildren, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sortChildren() const", AS_METHODPR(T, GetSortChildren, () const, bool), AS_CALL_THISCALL);

    // const StringVector& UIElement::GetTags() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetTags() const", AS_FUNCTION_OBJFIRST(UIElement_constspStringVectoramp_GetTags_void_template<UIElement>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<String>@ get_tags() const", AS_FUNCTION_OBJFIRST(UIElement_constspStringVectoramp_GetTags_void_template<UIElement>), AS_CALL_CDECL_OBJFIRST);

    // TraversalMode UIElement::GetTraversalMode() const
    engine->RegisterObjectMethod(className, "TraversalMode GetTraversalMode() const", AS_METHODPR(T, GetTraversalMode, () const, TraversalMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TraversalMode get_traversalMode() const", AS_METHODPR(T, GetTraversalMode, () const, TraversalMode), AS_CALL_THISCALL);

    // bool UIElement::GetUseDerivedOpacity() const
    engine->RegisterObjectMethod(className, "bool GetUseDerivedOpacity() const", AS_METHODPR(T, GetUseDerivedOpacity, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useDerivedOpacity() const", AS_METHODPR(T, GetUseDerivedOpacity, () const, bool), AS_CALL_THISCALL);

    // const Variant& UIElement::GetVar(const StringHash& key) const
    engine->RegisterObjectMethod(className, "const Variant& GetVar(const StringHash&in) const", AS_METHODPR(T, GetVar, (const StringHash&) const, const Variant&), AS_CALL_THISCALL);

    // const VariantMap& UIElement::GetVars() const
    engine->RegisterObjectMethod(className, "const VariantMap& GetVars() const", AS_METHODPR(T, GetVars, () const, const VariantMap&), AS_CALL_THISCALL);

    // VerticalAlignment UIElement::GetVerticalAlignment() const
    engine->RegisterObjectMethod(className, "VerticalAlignment GetVerticalAlignment() const", AS_METHODPR(T, GetVerticalAlignment, () const, VerticalAlignment), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "VerticalAlignment get_verticalAlignment() const", AS_METHODPR(T, GetVerticalAlignment, () const, VerticalAlignment), AS_CALL_THISCALL);

    // int UIElement::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool UIElement::HasColorGradient() const
    engine->RegisterObjectMethod(className, "bool HasColorGradient() const", AS_METHODPR(T, HasColorGradient, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_colorGradient() const", AS_METHODPR(T, HasColorGradient, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::HasFocus() const
    engine->RegisterObjectMethod(className, "bool HasFocus() const", AS_METHODPR(T, HasFocus, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_focus() const", AS_METHODPR(T, HasFocus, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::HasTag(const String& tag) const
    engine->RegisterObjectMethod(className, "bool HasTag(const String&in) const", AS_METHODPR(T, HasTag, (const String&) const, bool), AS_CALL_THISCALL);

    // void UIElement::InsertChild(unsigned index, UIElement* element)
    engine->RegisterObjectMethod(className, "void InsertChild(uint, UIElement@+)", AS_METHODPR(T, InsertChild, (unsigned, UIElement*), void), AS_CALL_THISCALL);

    // bool UIElement::IsChildOf(UIElement* element) const
    engine->RegisterObjectMethod(className, "bool IsChildOf(UIElement@+) const", AS_METHODPR(T, IsChildOf, (UIElement*) const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsEditable() const
    engine->RegisterObjectMethod(className, "bool IsEditable() const", AS_METHODPR(T, IsEditable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_editable() const", AS_METHODPR(T, IsEditable, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsElementEventSender() const
    engine->RegisterObjectMethod(className, "bool IsElementEventSender() const", AS_METHODPR(T, IsElementEventSender, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_elementEventSender() const", AS_METHODPR(T, IsElementEventSender, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsEnabled() const
    engine->RegisterObjectMethod(className, "bool IsEnabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabled() const", AS_METHODPR(T, IsEnabled, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsEnabledSelf() const
    engine->RegisterObjectMethod(className, "bool IsEnabledSelf() const", AS_METHODPR(T, IsEnabledSelf, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enabledSelf() const", AS_METHODPR(T, IsEnabledSelf, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsFixedHeight() const
    engine->RegisterObjectMethod(className, "bool IsFixedHeight() const", AS_METHODPR(T, IsFixedHeight, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedHeight() const", AS_METHODPR(T, IsFixedHeight, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsFixedSize() const
    engine->RegisterObjectMethod(className, "bool IsFixedSize() const", AS_METHODPR(T, IsFixedSize, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedSize() const", AS_METHODPR(T, IsFixedSize, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsFixedWidth() const
    engine->RegisterObjectMethod(className, "bool IsFixedWidth() const", AS_METHODPR(T, IsFixedWidth, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedWidth() const", AS_METHODPR(T, IsFixedWidth, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsHovering() const
    engine->RegisterObjectMethod(className, "bool IsHovering() const", AS_METHODPR(T, IsHovering, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hovering() const", AS_METHODPR(T, IsHovering, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsInside(IntVector2 position, bool isScreen)
    engine->RegisterObjectMethod(className, "bool IsInside(IntVector2, bool)", AS_METHODPR(T, IsInside, (IntVector2, bool), bool), AS_CALL_THISCALL);

    // bool UIElement::IsInsideCombined(IntVector2 position, bool isScreen)
    engine->RegisterObjectMethod(className, "bool IsInsideCombined(IntVector2, bool)", AS_METHODPR(T, IsInsideCombined, (IntVector2, bool), bool), AS_CALL_THISCALL);

    // bool UIElement::IsInternal() const
    engine->RegisterObjectMethod(className, "bool IsInternal() const", AS_METHODPR(T, IsInternal, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_internal() const", AS_METHODPR(T, IsInternal, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsVisible() const
    engine->RegisterObjectMethod(className, "bool IsVisible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_visible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);

    // bool UIElement::IsVisibleEffective() const
    engine->RegisterObjectMethod(className, "bool IsVisibleEffective() const", AS_METHODPR(T, IsVisibleEffective, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_visibleEffective() const", AS_METHODPR(T, IsVisibleEffective, () const, bool), AS_CALL_THISCALL);

    // virtual bool UIElement::IsWheelHandler() const
    engine->RegisterObjectMethod(className, "bool IsWheelHandler() const", AS_METHODPR(T, IsWheelHandler, () const, bool), AS_CALL_THISCALL);

    // virtual bool UIElement::IsWithinScissor(const IntRect& currentScissor)
    engine->RegisterObjectMethod(className, "bool IsWithinScissor(const IntRect&in)", AS_METHODPR(T, IsWithinScissor, (const IntRect&), bool), AS_CALL_THISCALL);

    // virtual UIElement* UIElement::LoadChildXML(const XMLElement& childElem, XMLFile* styleFile)
    engine->RegisterObjectMethod(className, "UIElement@+ LoadChildXML(const XMLElement&in, XMLFile@+)", AS_METHODPR(T, LoadChildXML, (const XMLElement&, XMLFile*), UIElement*), AS_CALL_THISCALL);

    // virtual bool UIElement::LoadXML(const XMLElement& source, XMLFile* styleFile)
    engine->RegisterObjectMethod(className, "bool LoadXML(const XMLElement&in, XMLFile@+)", AS_METHODPR(T, LoadXML, (const XMLElement&, XMLFile*), bool), AS_CALL_THISCALL);

    // bool UIElement::LoadXML(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadXML(Deserializer&)", AS_METHODPR(T, LoadXML, (Deserializer&), bool), AS_CALL_THISCALL);

    // virtual void UIElement::OnClickBegin(const IntVector2& position, const IntVector2& screenPosition, MouseButton button, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnClickBegin(const IntVector2&in, const IntVector2&in, MouseButton, MouseButtonFlags, QualifierFlags, Cursor@+)", AS_METHODPR(T, OnClickBegin, (const IntVector2&, const IntVector2&, MouseButton, MouseButtonFlags, QualifierFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnClickEnd(const IntVector2& position, const IntVector2& screenPosition, MouseButton button, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor, UIElement* beginElement)
    engine->RegisterObjectMethod(className, "void OnClickEnd(const IntVector2&in, const IntVector2&in, MouseButton, MouseButtonFlags, QualifierFlags, Cursor@+, UIElement@+)", AS_METHODPR(T, OnClickEnd, (const IntVector2&, const IntVector2&, MouseButton, MouseButtonFlags, QualifierFlags, Cursor*, UIElement*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnDoubleClick(const IntVector2& position, const IntVector2& screenPosition, MouseButton button, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnDoubleClick(const IntVector2&in, const IntVector2&in, MouseButton, MouseButtonFlags, QualifierFlags, Cursor@+)", AS_METHODPR(T, OnDoubleClick, (const IntVector2&, const IntVector2&, MouseButton, MouseButtonFlags, QualifierFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnDragBegin(const IntVector2& position, const IntVector2& screenPosition, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnDragBegin(const IntVector2&in, const IntVector2&in, MouseButtonFlags, QualifierFlags, Cursor@+)", AS_METHODPR(T, OnDragBegin, (const IntVector2&, const IntVector2&, MouseButtonFlags, QualifierFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnDragCancel(const IntVector2& position, const IntVector2& screenPosition, MouseButtonFlags dragButtons, MouseButtonFlags cancelButtons, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnDragCancel(const IntVector2&in, const IntVector2&in, MouseButtonFlags, MouseButtonFlags, Cursor@+)", AS_METHODPR(T, OnDragCancel, (const IntVector2&, const IntVector2&, MouseButtonFlags, MouseButtonFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual bool UIElement::OnDragDropFinish(UIElement* source)
    engine->RegisterObjectMethod(className, "bool OnDragDropFinish(UIElement@+)", AS_METHODPR(T, OnDragDropFinish, (UIElement*), bool), AS_CALL_THISCALL);

    // virtual bool UIElement::OnDragDropTest(UIElement* source)
    engine->RegisterObjectMethod(className, "bool OnDragDropTest(UIElement@+)", AS_METHODPR(T, OnDragDropTest, (UIElement*), bool), AS_CALL_THISCALL);

    // virtual void UIElement::OnDragEnd(const IntVector2& position, const IntVector2& screenPosition, MouseButtonFlags dragButtons, MouseButtonFlags releaseButtons, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnDragEnd(const IntVector2&in, const IntVector2&in, MouseButtonFlags, MouseButtonFlags, Cursor@+)", AS_METHODPR(T, OnDragEnd, (const IntVector2&, const IntVector2&, MouseButtonFlags, MouseButtonFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnDragMove(const IntVector2& position, const IntVector2& screenPosition, const IntVector2& deltaPos, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnDragMove(const IntVector2&in, const IntVector2&in, const IntVector2&in, MouseButtonFlags, QualifierFlags, Cursor@+)", AS_METHODPR(T, OnDragMove, (const IntVector2&, const IntVector2&, const IntVector2&, MouseButtonFlags, QualifierFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnHover(const IntVector2& position, const IntVector2& screenPosition, MouseButtonFlags buttons, QualifierFlags qualifiers, Cursor* cursor)
    engine->RegisterObjectMethod(className, "void OnHover(const IntVector2&in, const IntVector2&in, MouseButtonFlags, QualifierFlags, Cursor@+)", AS_METHODPR(T, OnHover, (const IntVector2&, const IntVector2&, MouseButtonFlags, QualifierFlags, Cursor*), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnIndentSet()
    engine->RegisterObjectMethod(className, "void OnIndentSet()", AS_METHODPR(T, OnIndentSet, (), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnKey(Key key, MouseButtonFlags buttons, QualifierFlags qualifiers)
    engine->RegisterObjectMethod(className, "void OnKey(Key, MouseButtonFlags, QualifierFlags)", AS_METHODPR(T, OnKey, (Key, MouseButtonFlags, QualifierFlags), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnPositionSet(const IntVector2& newPosition)
    engine->RegisterObjectMethod(className, "void OnPositionSet(const IntVector2&in)", AS_METHODPR(T, OnPositionSet, (const IntVector2&), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnResize(const IntVector2& newSize, const IntVector2& delta)
    engine->RegisterObjectMethod(className, "void OnResize(const IntVector2&in, const IntVector2&in)", AS_METHODPR(T, OnResize, (const IntVector2&, const IntVector2&), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnSetEditable()
    engine->RegisterObjectMethod(className, "void OnSetEditable()", AS_METHODPR(T, OnSetEditable, (), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnTextInput(const String& text)
    engine->RegisterObjectMethod(className, "void OnTextInput(const String&in)", AS_METHODPR(T, OnTextInput, (const String&), void), AS_CALL_THISCALL);

    // virtual void UIElement::OnWheel(int delta, MouseButtonFlags buttons, QualifierFlags qualifiers)
    engine->RegisterObjectMethod(className, "void OnWheel(int, MouseButtonFlags, QualifierFlags)", AS_METHODPR(T, OnWheel, (int, MouseButtonFlags, QualifierFlags), void), AS_CALL_THISCALL);

    // void UIElement::Remove()
    engine->RegisterObjectMethod(className, "void Remove()", AS_METHODPR(T, Remove, (), void), AS_CALL_THISCALL);

    // void UIElement::RemoveAllChildren()
    engine->RegisterObjectMethod(className, "void RemoveAllChildren()", AS_METHODPR(T, RemoveAllChildren, (), void), AS_CALL_THISCALL);

    // void UIElement::RemoveAllTags()
    engine->RegisterObjectMethod(className, "void RemoveAllTags()", AS_METHODPR(T, RemoveAllTags, (), void), AS_CALL_THISCALL);

    // void UIElement::RemoveChild(UIElement* element, unsigned index = 0)
    engine->RegisterObjectMethod(className, "void RemoveChild(UIElement@+, uint = 0)", AS_METHODPR(T, RemoveChild, (UIElement*, unsigned), void), AS_CALL_THISCALL);

    // void UIElement::RemoveChildAtIndex(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveChildAtIndex(uint)", AS_METHODPR(T, RemoveChildAtIndex, (unsigned), void), AS_CALL_THISCALL);

    // bool UIElement::RemoveTag(const String& tag)
    engine->RegisterObjectMethod(className, "bool RemoveTag(const String&in)", AS_METHODPR(T, RemoveTag, (const String&), bool), AS_CALL_THISCALL);

    // void UIElement::ResetDeepEnabled()
    engine->RegisterObjectMethod(className, "void ResetDeepEnabled()", AS_METHODPR(T, ResetDeepEnabled, (), void), AS_CALL_THISCALL);

    // bool UIElement::SaveXML(Serializer& dest, const String& indentation = "\t") const
    engine->RegisterObjectMethod(className, "bool SaveXML(Serializer&, const String&in = \"\t\") const", AS_METHODPR(T, SaveXML, (Serializer&, const String&) const, bool), AS_CALL_THISCALL);

    // virtual IntVector2 UIElement::ScreenToElement(const IntVector2& screenPosition)
    engine->RegisterObjectMethod(className, "IntVector2 ScreenToElement(const IntVector2&in)", AS_METHODPR(T, ScreenToElement, (const IntVector2&), IntVector2), AS_CALL_THISCALL);

    // void UIElement::SetAlignment(HorizontalAlignment hAlign, VerticalAlignment vAlign)
    engine->RegisterObjectMethod(className, "void SetAlignment(HorizontalAlignment, VerticalAlignment)", AS_METHODPR(T, SetAlignment, (HorizontalAlignment, VerticalAlignment), void), AS_CALL_THISCALL);

    // void UIElement::SetBringToBack(bool enable)
    engine->RegisterObjectMethod(className, "void SetBringToBack(bool)", AS_METHODPR(T, SetBringToBack, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bringToBack(bool)", AS_METHODPR(T, SetBringToBack, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetBringToFront(bool enable)
    engine->RegisterObjectMethod(className, "void SetBringToFront(bool)", AS_METHODPR(T, SetBringToFront, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bringToFront(bool)", AS_METHODPR(T, SetBringToFront, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetChildOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetChildOffset(const IntVector2&in)", AS_METHODPR(T, SetChildOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetClipBorder(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetClipBorder(const IntRect&in)", AS_METHODPR(T, SetClipBorder, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clipBorder(const IntRect&in)", AS_METHODPR(T, SetClipBorder, (const IntRect&), void), AS_CALL_THISCALL);

    // void UIElement::SetClipChildren(bool enable)
    engine->RegisterObjectMethod(className, "void SetClipChildren(bool)", AS_METHODPR(T, SetClipChildren, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clipChildren(bool)", AS_METHODPR(T, SetClipChildren, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetColor(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_color(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);

    // void UIElement::SetColor(Corner corner, const Color& color)
    engine->RegisterObjectMethod(className, "void SetColor(Corner, const Color&in)", AS_METHODPR(T, SetColor, (Corner, const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_colors(Corner, const Color&in)", AS_METHODPR(T, SetColor, (Corner, const Color&), void), AS_CALL_THISCALL);

    // void UIElement::SetDeepEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetDeepEnabled(bool)", AS_METHODPR(T, SetDeepEnabled, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetDefaultStyle(XMLFile* style)
    engine->RegisterObjectMethod(className, "void SetDefaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_defaultStyle(XMLFile@+)", AS_METHODPR(T, SetDefaultStyle, (XMLFile*), void), AS_CALL_THISCALL);

    // void UIElement::SetDragDropMode(DragAndDropModeFlags mode)
    engine->RegisterObjectMethod(className, "void SetDragDropMode(DragAndDropModeFlags)", AS_METHODPR(T, SetDragDropMode, (DragAndDropModeFlags), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dragDropMode(DragAndDropModeFlags)", AS_METHODPR(T, SetDragDropMode, (DragAndDropModeFlags), void), AS_CALL_THISCALL);

    // void UIElement::SetEditable(bool enable)
    engine->RegisterObjectMethod(className, "void SetEditable(bool)", AS_METHODPR(T, SetEditable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_editable(bool)", AS_METHODPR(T, SetEditable, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetElementEventSender(bool flag)
    engine->RegisterObjectMethod(className, "void SetElementEventSender(bool)", AS_METHODPR(T, SetElementEventSender, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_elementEventSender(bool)", AS_METHODPR(T, SetElementEventSender, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetEnableAnchor(bool enable)
    engine->RegisterObjectMethod(className, "void SetEnableAnchor(bool)", AS_METHODPR(T, SetEnableAnchor, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableAnchor(bool)", AS_METHODPR(T, SetEnableAnchor, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetEnabled(bool)", AS_METHODPR(T, SetEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enabled(bool)", AS_METHODPR(T, SetEnabled, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetEnabledRecursive(bool enable)
    engine->RegisterObjectMethod(className, "void SetEnabledRecursive(bool)", AS_METHODPR(T, SetEnabledRecursive, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetFixedHeight(int height)
    engine->RegisterObjectMethod(className, "void SetFixedHeight(int)", AS_METHODPR(T, SetFixedHeight, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetFixedSize(const IntVector2& size)
    engine->RegisterObjectMethod(className, "void SetFixedSize(const IntVector2&in)", AS_METHODPR(T, SetFixedSize, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetFixedSize(int width, int height)
    engine->RegisterObjectMethod(className, "void SetFixedSize(int, int)", AS_METHODPR(T, SetFixedSize, (int, int), void), AS_CALL_THISCALL);

    // void UIElement::SetFixedWidth(int width)
    engine->RegisterObjectMethod(className, "void SetFixedWidth(int)", AS_METHODPR(T, SetFixedWidth, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetFocus(bool enable)
    engine->RegisterObjectMethod(className, "void SetFocus(bool)", AS_METHODPR(T, SetFocus, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_focus(bool)", AS_METHODPR(T, SetFocus, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetFocusMode(FocusMode mode)
    engine->RegisterObjectMethod(className, "void SetFocusMode(FocusMode)", AS_METHODPR(T, SetFocusMode, (FocusMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_focusMode(FocusMode)", AS_METHODPR(T, SetFocusMode, (FocusMode), void), AS_CALL_THISCALL);

    // void UIElement::SetHeight(int height)
    engine->RegisterObjectMethod(className, "void SetHeight(int)", AS_METHODPR(T, SetHeight, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_height(int)", AS_METHODPR(T, SetHeight, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetHorizontalAlignment(HorizontalAlignment align)
    engine->RegisterObjectMethod(className, "void SetHorizontalAlignment(HorizontalAlignment)", AS_METHODPR(T, SetHorizontalAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_horizontalAlignment(HorizontalAlignment)", AS_METHODPR(T, SetHorizontalAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);

    // void UIElement::SetHovering(bool enable)
    engine->RegisterObjectMethod(className, "void SetHovering(bool)", AS_METHODPR(T, SetHovering, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetIndent(int indent)
    engine->RegisterObjectMethod(className, "void SetIndent(int)", AS_METHODPR(T, SetIndent, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_indent(int)", AS_METHODPR(T, SetIndent, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetIndentSpacing(int indentSpacing)
    engine->RegisterObjectMethod(className, "void SetIndentSpacing(int)", AS_METHODPR(T, SetIndentSpacing, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_indentSpacing(int)", AS_METHODPR(T, SetIndentSpacing, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetInternal(bool enable)
    engine->RegisterObjectMethod(className, "void SetInternal(bool)", AS_METHODPR(T, SetInternal, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_internal(bool)", AS_METHODPR(T, SetInternal, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetLayout(LayoutMode mode, int spacing = 0, const IntRect& border = IntRect::ZERO)
    engine->RegisterObjectMethod(className, "void SetLayout(LayoutMode, int = 0, const IntRect&in = IntRect::ZERO)", AS_METHODPR(T, SetLayout, (LayoutMode, int, const IntRect&), void), AS_CALL_THISCALL);

    // void UIElement::SetLayoutBorder(const IntRect& border)
    engine->RegisterObjectMethod(className, "void SetLayoutBorder(const IntRect&in)", AS_METHODPR(T, SetLayoutBorder, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutBorder(const IntRect&in)", AS_METHODPR(T, SetLayoutBorder, (const IntRect&), void), AS_CALL_THISCALL);

    // void UIElement::SetLayoutFlexScale(const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetLayoutFlexScale(const Vector2&in)", AS_METHODPR(T, SetLayoutFlexScale, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutFlexScale(const Vector2&in)", AS_METHODPR(T, SetLayoutFlexScale, (const Vector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetLayoutMode(LayoutMode mode)
    engine->RegisterObjectMethod(className, "void SetLayoutMode(LayoutMode)", AS_METHODPR(T, SetLayoutMode, (LayoutMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutMode(LayoutMode)", AS_METHODPR(T, SetLayoutMode, (LayoutMode), void), AS_CALL_THISCALL);

    // void UIElement::SetLayoutSpacing(int spacing)
    engine->RegisterObjectMethod(className, "void SetLayoutSpacing(int)", AS_METHODPR(T, SetLayoutSpacing, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layoutSpacing(int)", AS_METHODPR(T, SetLayoutSpacing, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetMaxAnchor(const Vector2&in)", AS_METHODPR(T, SetMaxAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxAnchor(const Vector2&in)", AS_METHODPR(T, SetMaxAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxAnchor(float x, float y)
    engine->RegisterObjectMethod(className, "void SetMaxAnchor(float, float)", AS_METHODPR(T, SetMaxAnchor, (float, float), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxHeight(int height)
    engine->RegisterObjectMethod(className, "void SetMaxHeight(int)", AS_METHODPR(T, SetMaxHeight, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxHeight(int)", AS_METHODPR(T, SetMaxHeight, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetMaxOffset(const IntVector2&in)", AS_METHODPR(T, SetMaxOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxOffset(const IntVector2&in)", AS_METHODPR(T, SetMaxOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxSize(const IntVector2& maxSize)
    engine->RegisterObjectMethod(className, "void SetMaxSize(const IntVector2&in)", AS_METHODPR(T, SetMaxSize, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxSize(const IntVector2&in)", AS_METHODPR(T, SetMaxSize, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxSize(int width, int height)
    engine->RegisterObjectMethod(className, "void SetMaxSize(int, int)", AS_METHODPR(T, SetMaxSize, (int, int), void), AS_CALL_THISCALL);

    // void UIElement::SetMaxWidth(int width)
    engine->RegisterObjectMethod(className, "void SetMaxWidth(int)", AS_METHODPR(T, SetMaxWidth, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxWidth(int)", AS_METHODPR(T, SetMaxWidth, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetMinAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetMinAnchor(const Vector2&in)", AS_METHODPR(T, SetMinAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minAnchor(const Vector2&in)", AS_METHODPR(T, SetMinAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetMinAnchor(float x, float y)
    engine->RegisterObjectMethod(className, "void SetMinAnchor(float, float)", AS_METHODPR(T, SetMinAnchor, (float, float), void), AS_CALL_THISCALL);

    // void UIElement::SetMinHeight(int height)
    engine->RegisterObjectMethod(className, "void SetMinHeight(int)", AS_METHODPR(T, SetMinHeight, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minHeight(int)", AS_METHODPR(T, SetMinHeight, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetMinOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetMinOffset(const IntVector2&in)", AS_METHODPR(T, SetMinOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minOffset(const IntVector2&in)", AS_METHODPR(T, SetMinOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetMinSize(const IntVector2& minSize)
    engine->RegisterObjectMethod(className, "void SetMinSize(const IntVector2&in)", AS_METHODPR(T, SetMinSize, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minSize(const IntVector2&in)", AS_METHODPR(T, SetMinSize, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetMinSize(int width, int height)
    engine->RegisterObjectMethod(className, "void SetMinSize(int, int)", AS_METHODPR(T, SetMinSize, (int, int), void), AS_CALL_THISCALL);

    // void UIElement::SetMinWidth(int width)
    engine->RegisterObjectMethod(className, "void SetMinWidth(int)", AS_METHODPR(T, SetMinWidth, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minWidth(int)", AS_METHODPR(T, SetMinWidth, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetName(const String& name)
    engine->RegisterObjectMethod(className, "void SetName(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_name(const String&in)", AS_METHODPR(T, SetName, (const String&), void), AS_CALL_THISCALL);

    // void UIElement::SetOpacity(float opacity)
    engine->RegisterObjectMethod(className, "void SetOpacity(float)", AS_METHODPR(T, SetOpacity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_opacity(float)", AS_METHODPR(T, SetOpacity, (float), void), AS_CALL_THISCALL);

    // void UIElement::SetParent(UIElement* parent, unsigned index = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void SetParent(UIElement@+, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, SetParent, (UIElement*, unsigned), void), AS_CALL_THISCALL);

    // void UIElement::SetPivot(const Vector2& pivot)
    engine->RegisterObjectMethod(className, "void SetPivot(const Vector2&in)", AS_METHODPR(T, SetPivot, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pivot(const Vector2&in)", AS_METHODPR(T, SetPivot, (const Vector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetPivot(float x, float y)
    engine->RegisterObjectMethod(className, "void SetPivot(float, float)", AS_METHODPR(T, SetPivot, (float, float), void), AS_CALL_THISCALL);

    // void UIElement::SetPriority(int priority)
    engine->RegisterObjectMethod(className, "void SetPriority(int)", AS_METHODPR(T, SetPriority, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_priority(int)", AS_METHODPR(T, SetPriority, (int), void), AS_CALL_THISCALL);

    // void UIElement::SetRenderTexture(Texture2D* texture)
    engine->RegisterObjectMethod(className, "void SetRenderTexture(Texture2D@+)", AS_METHODPR(T, SetRenderTexture, (Texture2D*), void), AS_CALL_THISCALL);

    // void UIElement::SetSelected(bool enable)
    engine->RegisterObjectMethod(className, "void SetSelected(bool)", AS_METHODPR(T, SetSelected, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_selected(bool)", AS_METHODPR(T, SetSelected, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetSize(const IntVector2& size)
    engine->RegisterObjectMethod(className, "void SetSize(const IntVector2&in)", AS_METHODPR(T, SetSize, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_size(const IntVector2&in)", AS_METHODPR(T, SetSize, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetSize(int width, int height)
    engine->RegisterObjectMethod(className, "void SetSize(int, int)", AS_METHODPR(T, SetSize, (int, int), void), AS_CALL_THISCALL);

    // void UIElement::SetSortChildren(bool enable)
    engine->RegisterObjectMethod(className, "void SetSortChildren(bool)", AS_METHODPR(T, SetSortChildren, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sortChildren(bool)", AS_METHODPR(T, SetSortChildren, (bool), void), AS_CALL_THISCALL);

    // bool UIElement::SetStyle(const String& styleName, XMLFile* file = nullptr)
    engine->RegisterObjectMethod(className, "bool SetStyle(const String&in, XMLFile@+ = null)", AS_METHODPR(T, SetStyle, (const String&, XMLFile*), bool), AS_CALL_THISCALL);

    // bool UIElement::SetStyle(const XMLElement& element)
    engine->RegisterObjectMethod(className, "bool SetStyle(const XMLElement&in)", AS_METHODPR(T, SetStyle, (const XMLElement&), bool), AS_CALL_THISCALL);

    // bool UIElement::SetStyleAuto(XMLFile* file = nullptr)
    engine->RegisterObjectMethod(className, "bool SetStyleAuto(XMLFile@+ = null)", AS_METHODPR(T, SetStyleAuto, (XMLFile*), bool), AS_CALL_THISCALL);

    // void UIElement::SetTags(const StringVector& tags)
    engine->RegisterObjectMethod(className, "void SetTags(Array<String>@+)", AS_FUNCTION_OBJFIRST(UIElement_void_SetTags_constspStringVectoramp_template<UIElement>), AS_CALL_CDECL_OBJFIRST);

    // void UIElement::SetTraversalMode(TraversalMode traversalMode)
    engine->RegisterObjectMethod(className, "void SetTraversalMode(TraversalMode)", AS_METHODPR(T, SetTraversalMode, (TraversalMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_traversalMode(TraversalMode)", AS_METHODPR(T, SetTraversalMode, (TraversalMode), void), AS_CALL_THISCALL);

    // void UIElement::SetUseDerivedOpacity(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseDerivedOpacity(bool)", AS_METHODPR(T, SetUseDerivedOpacity, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useDerivedOpacity(bool)", AS_METHODPR(T, SetUseDerivedOpacity, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetVar(StringHash key, const Variant& value)
    engine->RegisterObjectMethod(className, "void SetVar(StringHash, const Variant&in)", AS_METHODPR(T, SetVar, (StringHash, const Variant&), void), AS_CALL_THISCALL);

    // void UIElement::SetVerticalAlignment(VerticalAlignment align)
    engine->RegisterObjectMethod(className, "void SetVerticalAlignment(VerticalAlignment)", AS_METHODPR(T, SetVerticalAlignment, (VerticalAlignment), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_verticalAlignment(VerticalAlignment)", AS_METHODPR(T, SetVerticalAlignment, (VerticalAlignment), void), AS_CALL_THISCALL);

    // void UIElement::SetVisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetVisible(bool)", AS_METHODPR(T, SetVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_visible(bool)", AS_METHODPR(T, SetVisible, (bool), void), AS_CALL_THISCALL);

    // void UIElement::SetWidth(int width)
    engine->RegisterObjectMethod(className, "void SetWidth(int)", AS_METHODPR(T, SetWidth, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_width(int)", AS_METHODPR(T, SetWidth, (int), void), AS_CALL_THISCALL);

    // void UIElement::SortChildren()
    engine->RegisterObjectMethod(className, "void SortChildren()", AS_METHODPR(T, SortChildren, (), void), AS_CALL_THISCALL);

    // virtual void UIElement::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    // void UIElement::UpdateLayout()
    engine->RegisterObjectMethod(className, "void UpdateLayout()", AS_METHODPR(T, UpdateLayout, (), void), AS_CALL_THISCALL);

    // template <class T> T* UIElement::CreateChild(const String& name = String::EMPTY, unsigned index = M_MAX_UNSIGNED)
    // Not registered because template
    // template <class T> T* UIElement::GetChildDynamicCast(unsigned index) const
    // Not registered because template
    // template <class T> T* UIElement::GetChildDynamicCast(const String& name, bool recursive = false) const
    // Not registered because template
    // template <class T> T* UIElement::GetChildDynamicCast(const StringHash& key, const Variant& value = Variant::EMPTY, bool recursive = false) const
    // Not registered because template
    // template <class T> T* UIElement::GetChildStaticCast(unsigned index) const
    // Not registered because template
    // template <class T> T* UIElement::GetChildStaticCast(const String& name, bool recursive = false) const
    // Not registered because template
    // template <class T> T* UIElement::GetChildStaticCast(const StringHash& key, const Variant& value = Variant::EMPTY, bool recursive = false) const
    // Not registered because template

    #ifdef REGISTER_MEMBERS_MANUAL_PART_UIElement
        REGISTER_MEMBERS_MANUAL_PART_UIElement();
    #endif
}

// class AnimationController | File: ../Graphics/AnimationController.h
template <class T> void RegisterMembers_AnimationController(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // const Vector<AnimationControl>& AnimationController::GetAnimations() const
    // Error: type "const Vector<AnimationControl>&" can not automatically bind
    // VariantVector AnimationController::GetAnimationsAttr() const
    // Error: type "VariantVector" can not automatically bind
    // const PODVector<unsigned char>& AnimationController::GetNetAnimationsAttr() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // VariantVector AnimationController::GetNodeAnimationStatesAttr() const
    // Error: type "VariantVector" can not automatically bind
    // void AnimationController::SetAnimationsAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind
    // void AnimationController::SetNetAnimationsAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void AnimationController::SetNodeAnimationStatesAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // bool AnimationController::Fade(const String& name, float targetWeight, float fadeTime)
    engine->RegisterObjectMethod(className, "bool Fade(const String&in, float, float)", AS_METHODPR(T, Fade, (const String&, float, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::FadeOthers(const String& name, float targetWeight, float fadeTime)
    engine->RegisterObjectMethod(className, "bool FadeOthers(const String&in, float, float)", AS_METHODPR(T, FadeOthers, (const String&, float, float), bool), AS_CALL_THISCALL);

    // AnimationState* AnimationController::GetAnimationState(const String& name) const
    engine->RegisterObjectMethod(className, "AnimationState@+ GetAnimationState(const String&in) const", AS_METHODPR(T, GetAnimationState, (const String&) const, AnimationState*), AS_CALL_THISCALL);

    // AnimationState* AnimationController::GetAnimationState(StringHash nameHash) const
    engine->RegisterObjectMethod(className, "AnimationState@+ GetAnimationState(StringHash) const", AS_METHODPR(T, GetAnimationState, (StringHash) const, AnimationState*), AS_CALL_THISCALL);

    // float AnimationController::GetAutoFade(const String& name) const
    engine->RegisterObjectMethod(className, "float GetAutoFade(const String&in) const", AS_METHODPR(T, GetAutoFade, (const String&) const, float), AS_CALL_THISCALL);

    // AnimationBlendMode AnimationController::GetBlendMode(const String& name) const
    engine->RegisterObjectMethod(className, "AnimationBlendMode GetBlendMode(const String&in) const", AS_METHODPR(T, GetBlendMode, (const String&) const, AnimationBlendMode), AS_CALL_THISCALL);

    // float AnimationController::GetFadeTarget(const String& name) const
    engine->RegisterObjectMethod(className, "float GetFadeTarget(const String&in) const", AS_METHODPR(T, GetFadeTarget, (const String&) const, float), AS_CALL_THISCALL);

    // float AnimationController::GetFadeTime(const String& name) const
    engine->RegisterObjectMethod(className, "float GetFadeTime(const String&in) const", AS_METHODPR(T, GetFadeTime, (const String&) const, float), AS_CALL_THISCALL);

    // unsigned char AnimationController::GetLayer(const String& name) const
    engine->RegisterObjectMethod(className, "uint8 GetLayer(const String&in) const", AS_METHODPR(T, GetLayer, (const String&) const, unsigned char), AS_CALL_THISCALL);

    // float AnimationController::GetLength(const String& name) const
    engine->RegisterObjectMethod(className, "float GetLength(const String&in) const", AS_METHODPR(T, GetLength, (const String&) const, float), AS_CALL_THISCALL);

    // bool AnimationController::GetRemoveOnCompletion(const String& name) const
    engine->RegisterObjectMethod(className, "bool GetRemoveOnCompletion(const String&in) const", AS_METHODPR(T, GetRemoveOnCompletion, (const String&) const, bool), AS_CALL_THISCALL);

    // float AnimationController::GetSpeed(const String& name) const
    engine->RegisterObjectMethod(className, "float GetSpeed(const String&in) const", AS_METHODPR(T, GetSpeed, (const String&) const, float), AS_CALL_THISCALL);

    // Bone* AnimationController::GetStartBone(const String& name) const
    engine->RegisterObjectMethod(className, "Bone@+ GetStartBone(const String&in) const", AS_METHODPR(T, GetStartBone, (const String&) const, Bone*), AS_CALL_THISCALL);

    // const String& AnimationController::GetStartBoneName(const String& name) const
    engine->RegisterObjectMethod(className, "const String& GetStartBoneName(const String&in) const", AS_METHODPR(T, GetStartBoneName, (const String&) const, const String&), AS_CALL_THISCALL);

    // float AnimationController::GetTime(const String& name) const
    engine->RegisterObjectMethod(className, "float GetTime(const String&in) const", AS_METHODPR(T, GetTime, (const String&) const, float), AS_CALL_THISCALL);

    // float AnimationController::GetWeight(const String& name) const
    engine->RegisterObjectMethod(className, "float GetWeight(const String&in) const", AS_METHODPR(T, GetWeight, (const String&) const, float), AS_CALL_THISCALL);

    // bool AnimationController::IsAtEnd(const String& name) const
    engine->RegisterObjectMethod(className, "bool IsAtEnd(const String&in) const", AS_METHODPR(T, IsAtEnd, (const String&) const, bool), AS_CALL_THISCALL);

    // bool AnimationController::IsFadingIn(const String& name) const
    engine->RegisterObjectMethod(className, "bool IsFadingIn(const String&in) const", AS_METHODPR(T, IsFadingIn, (const String&) const, bool), AS_CALL_THISCALL);

    // bool AnimationController::IsFadingOut(const String& name) const
    engine->RegisterObjectMethod(className, "bool IsFadingOut(const String&in) const", AS_METHODPR(T, IsFadingOut, (const String&) const, bool), AS_CALL_THISCALL);

    // bool AnimationController::IsLooped(const String& name) const
    engine->RegisterObjectMethod(className, "bool IsLooped(const String&in) const", AS_METHODPR(T, IsLooped, (const String&) const, bool), AS_CALL_THISCALL);

    // bool AnimationController::IsPlaying(const String& name) const
    engine->RegisterObjectMethod(className, "bool IsPlaying(const String&in) const", AS_METHODPR(T, IsPlaying, (const String&) const, bool), AS_CALL_THISCALL);

    // bool AnimationController::IsPlaying(unsigned char layer) const
    engine->RegisterObjectMethod(className, "bool IsPlaying(uint8) const", AS_METHODPR(T, IsPlaying, (unsigned char) const, bool), AS_CALL_THISCALL);

    // void AnimationController::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // bool AnimationController::Play(const String& name, unsigned char layer, bool looped, float fadeInTime = 0.0f)
    engine->RegisterObjectMethod(className, "bool Play(const String&in, uint8, bool, float = 0.0f)", AS_METHODPR(T, Play, (const String&, unsigned char, bool, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::PlayExclusive(const String& name, unsigned char layer, bool looped, float fadeTime = 0.0f)
    engine->RegisterObjectMethod(className, "bool PlayExclusive(const String&in, uint8, bool, float = 0.0f)", AS_METHODPR(T, PlayExclusive, (const String&, unsigned char, bool, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetAutoFade(const String& name, float fadeOutTime)
    engine->RegisterObjectMethod(className, "bool SetAutoFade(const String&in, float)", AS_METHODPR(T, SetAutoFade, (const String&, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetBlendMode(const String& name, AnimationBlendMode mode)
    engine->RegisterObjectMethod(className, "bool SetBlendMode(const String&in, AnimationBlendMode)", AS_METHODPR(T, SetBlendMode, (const String&, AnimationBlendMode), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetLayer(const String& name, unsigned char layer)
    engine->RegisterObjectMethod(className, "bool SetLayer(const String&in, uint8)", AS_METHODPR(T, SetLayer, (const String&, unsigned char), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetLooped(const String& name, bool enable)
    engine->RegisterObjectMethod(className, "bool SetLooped(const String&in, bool)", AS_METHODPR(T, SetLooped, (const String&, bool), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetRemoveOnCompletion(const String& name, bool removeOnCompletion)
    engine->RegisterObjectMethod(className, "bool SetRemoveOnCompletion(const String&in, bool)", AS_METHODPR(T, SetRemoveOnCompletion, (const String&, bool), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetSpeed(const String& name, float speed)
    engine->RegisterObjectMethod(className, "bool SetSpeed(const String&in, float)", AS_METHODPR(T, SetSpeed, (const String&, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetStartBone(const String& name, const String& startBoneName)
    engine->RegisterObjectMethod(className, "bool SetStartBone(const String&in, const String&in)", AS_METHODPR(T, SetStartBone, (const String&, const String&), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetTime(const String& name, float time)
    engine->RegisterObjectMethod(className, "bool SetTime(const String&in, float)", AS_METHODPR(T, SetTime, (const String&, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::SetWeight(const String& name, float weight)
    engine->RegisterObjectMethod(className, "bool SetWeight(const String&in, float)", AS_METHODPR(T, SetWeight, (const String&, float), bool), AS_CALL_THISCALL);

    // bool AnimationController::Stop(const String& name, float fadeOutTime = 0.0f)
    engine->RegisterObjectMethod(className, "bool Stop(const String&in, float = 0.0f)", AS_METHODPR(T, Stop, (const String&, float), bool), AS_CALL_THISCALL);

    // void AnimationController::StopAll(float fadeOutTime = 0.0f)
    engine->RegisterObjectMethod(className, "void StopAll(float = 0.0f)", AS_METHODPR(T, StopAll, (float), void), AS_CALL_THISCALL);

    // void AnimationController::StopLayer(unsigned char layer, float fadeOutTime = 0.0f)
    engine->RegisterObjectMethod(className, "void StopLayer(uint8, float = 0.0f)", AS_METHODPR(T, StopLayer, (unsigned char, float), void), AS_CALL_THISCALL);

    // virtual void AnimationController::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimationController
        REGISTER_MEMBERS_MANUAL_PART_AnimationController();
    #endif
}

// class BorderImage | File: ../UI/BorderImage.h
template <class T> void RegisterMembers_BorderImage(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_UIElement<T>(engine, className);

    // BlendMode BorderImage::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BlendMode get_blendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // const IntRect& BorderImage::GetBorder() const
    engine->RegisterObjectMethod(className, "const IntRect& GetBorder() const", AS_METHODPR(T, GetBorder, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_border() const", AS_METHODPR(T, GetBorder, () const, const IntRect&), AS_CALL_THISCALL);

    // const IntVector2& BorderImage::GetDisabledOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetDisabledOffset() const", AS_METHODPR(T, GetDisabledOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_disabledOffset() const", AS_METHODPR(T, GetDisabledOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector2& BorderImage::GetHoverOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetHoverOffset() const", AS_METHODPR(T, GetHoverOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_hoverOffset() const", AS_METHODPR(T, GetHoverOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntRect& BorderImage::GetImageBorder() const
    engine->RegisterObjectMethod(className, "const IntRect& GetImageBorder() const", AS_METHODPR(T, GetImageBorder, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_imageBorder() const", AS_METHODPR(T, GetImageBorder, () const, const IntRect&), AS_CALL_THISCALL);

    // const IntRect& BorderImage::GetImageRect() const
    engine->RegisterObjectMethod(className, "const IntRect& GetImageRect() const", AS_METHODPR(T, GetImageRect, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_imageRect() const", AS_METHODPR(T, GetImageRect, () const, const IntRect&), AS_CALL_THISCALL);

    // Material* BorderImage::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef BorderImage::GetMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetMaterialAttr() const", AS_METHODPR(T, GetMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetPosition() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_position() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);

    // Texture* BorderImage::GetTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetTexture() const", AS_METHODPR(T, GetTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_texture() const", AS_METHODPR(T, GetTexture, () const, Texture*), AS_CALL_THISCALL);

    // ResourceRef BorderImage::GetTextureAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetTextureAttr() const", AS_METHODPR(T, GetTextureAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // bool UIElement::IsSelected() const
    engine->RegisterObjectMethod(className, "bool IsSelected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_selected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);

    // bool BorderImage::IsTiled() const
    engine->RegisterObjectMethod(className, "bool IsTiled() const", AS_METHODPR(T, IsTiled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_tiled() const", AS_METHODPR(T, IsTiled, () const, bool), AS_CALL_THISCALL);

    // void BorderImage::SetBlendMode(BlendMode mode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);

    // void BorderImage::SetBorder(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetBorder(const IntRect&in)", AS_METHODPR(T, SetBorder, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_border(const IntRect&in)", AS_METHODPR(T, SetBorder, (const IntRect&), void), AS_CALL_THISCALL);

    // void BorderImage::SetDisabledOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetDisabledOffset(const IntVector2&in)", AS_METHODPR(T, SetDisabledOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_disabledOffset(const IntVector2&in)", AS_METHODPR(T, SetDisabledOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void BorderImage::SetDisabledOffset(int x, int y)
    engine->RegisterObjectMethod(className, "void SetDisabledOffset(int, int)", AS_METHODPR(T, SetDisabledOffset, (int, int), void), AS_CALL_THISCALL);

    // void BorderImage::SetFullImageRect()
    engine->RegisterObjectMethod(className, "void SetFullImageRect()", AS_METHODPR(T, SetFullImageRect, (), void), AS_CALL_THISCALL);

    // void BorderImage::SetHoverOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetHoverOffset(const IntVector2&in)", AS_METHODPR(T, SetHoverOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hoverOffset(const IntVector2&in)", AS_METHODPR(T, SetHoverOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void BorderImage::SetHoverOffset(int x, int y)
    engine->RegisterObjectMethod(className, "void SetHoverOffset(int, int)", AS_METHODPR(T, SetHoverOffset, (int, int), void), AS_CALL_THISCALL);

    // void BorderImage::SetImageBorder(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetImageBorder(const IntRect&in)", AS_METHODPR(T, SetImageBorder, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_imageBorder(const IntRect&in)", AS_METHODPR(T, SetImageBorder, (const IntRect&), void), AS_CALL_THISCALL);

    // void BorderImage::SetImageRect(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetImageRect(const IntRect&in)", AS_METHODPR(T, SetImageRect, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_imageRect(const IntRect&in)", AS_METHODPR(T, SetImageRect, (const IntRect&), void), AS_CALL_THISCALL);

    // void BorderImage::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void BorderImage::SetMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPosition(int, int)", AS_METHODPR(T, SetPosition, (int, int), void), AS_CALL_THISCALL);

    // void BorderImage::SetTexture(Texture* texture)
    engine->RegisterObjectMethod(className, "void SetTexture(Texture@+)", AS_METHODPR(T, SetTexture, (Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_texture(Texture@+)", AS_METHODPR(T, SetTexture, (Texture*), void), AS_CALL_THISCALL);

    // void BorderImage::SetTextureAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetTextureAttr(const ResourceRef&in)", AS_METHODPR(T, SetTextureAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void BorderImage::SetTiled(bool enable)
    engine->RegisterObjectMethod(className, "void SetTiled(bool)", AS_METHODPR(T, SetTiled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_tiled(bool)", AS_METHODPR(T, SetTiled, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BorderImage
        REGISTER_MEMBERS_MANUAL_PART_BorderImage();
    #endif
}

// class Camera | File: ../Graphics/Camera.h
template <class T> void RegisterMembers_Camera(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void Camera::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // float Camera::GetAspectRatio() const
    engine->RegisterObjectMethod(className, "float GetAspectRatio() const", AS_METHODPR(T, GetAspectRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_aspectRatio() const", AS_METHODPR(T, GetAspectRatio, () const, float), AS_CALL_THISCALL);

    // bool Camera::GetAutoAspectRatio() const
    engine->RegisterObjectMethod(className, "bool GetAutoAspectRatio() const", AS_METHODPR(T, GetAutoAspectRatio, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoAspectRatio() const", AS_METHODPR(T, GetAutoAspectRatio, () const, bool), AS_CALL_THISCALL);

    // const Plane& Camera::GetClipPlane() const
    engine->RegisterObjectMethod(className, "const Plane& GetClipPlane() const", AS_METHODPR(T, GetClipPlane, () const, const Plane&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Plane& get_clipPlane() const", AS_METHODPR(T, GetClipPlane, () const, const Plane&), AS_CALL_THISCALL);

    // Vector4 Camera::GetClipPlaneAttr() const
    engine->RegisterObjectMethod(className, "Vector4 GetClipPlaneAttr() const", AS_METHODPR(T, GetClipPlaneAttr, () const, Vector4), AS_CALL_THISCALL);

    // float Camera::GetDistance(const Vector3& worldPos) const
    engine->RegisterObjectMethod(className, "float GetDistance(const Vector3&in) const", AS_METHODPR(T, GetDistance, (const Vector3&) const, float), AS_CALL_THISCALL);

    // float Camera::GetDistanceSquared(const Vector3& worldPos) const
    engine->RegisterObjectMethod(className, "float GetDistanceSquared(const Vector3&in) const", AS_METHODPR(T, GetDistanceSquared, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Matrix3x4 Camera::GetEffectiveWorldTransform() const
    engine->RegisterObjectMethod(className, "Matrix3x4 GetEffectiveWorldTransform() const", AS_METHODPR(T, GetEffectiveWorldTransform, () const, Matrix3x4), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix3x4 get_effectiveWorldTransform() const", AS_METHODPR(T, GetEffectiveWorldTransform, () const, Matrix3x4), AS_CALL_THISCALL);

    // Quaternion Camera::GetFaceCameraRotation(const Vector3& position, const Quaternion& rotation, FaceCameraMode mode, float minAngle = 0.0f)
    engine->RegisterObjectMethod(className, "Quaternion GetFaceCameraRotation(const Vector3&in, const Quaternion&in, FaceCameraMode, float = 0.0f)", AS_METHODPR(T, GetFaceCameraRotation, (const Vector3&, const Quaternion&, FaceCameraMode, float), Quaternion), AS_CALL_THISCALL);

    // float Camera::GetFarClip() const
    engine->RegisterObjectMethod(className, "float GetFarClip() const", AS_METHODPR(T, GetFarClip, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_farClip() const", AS_METHODPR(T, GetFarClip, () const, float), AS_CALL_THISCALL);

    // FillMode Camera::GetFillMode() const
    engine->RegisterObjectMethod(className, "FillMode GetFillMode() const", AS_METHODPR(T, GetFillMode, () const, FillMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FillMode get_fillMode() const", AS_METHODPR(T, GetFillMode, () const, FillMode), AS_CALL_THISCALL);

    // bool Camera::GetFlipVertical() const
    engine->RegisterObjectMethod(className, "bool GetFlipVertical() const", AS_METHODPR(T, GetFlipVertical, () const, bool), AS_CALL_THISCALL);

    // float Camera::GetFov() const
    engine->RegisterObjectMethod(className, "float GetFov() const", AS_METHODPR(T, GetFov, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fov() const", AS_METHODPR(T, GetFov, () const, float), AS_CALL_THISCALL);

    // const Frustum& Camera::GetFrustum() const
    engine->RegisterObjectMethod(className, "const Frustum& GetFrustum() const", AS_METHODPR(T, GetFrustum, () const, const Frustum&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Frustum& get_frustum() const", AS_METHODPR(T, GetFrustum, () const, const Frustum&), AS_CALL_THISCALL);

    // void Camera::GetFrustumSize(Vector3& near, Vector3& far) const
    engine->RegisterObjectMethod(className, "void GetFrustumSize(Vector3&, Vector3&) const", AS_METHODPR(T, GetFrustumSize, (Vector3&, Vector3&) const, void), AS_CALL_THISCALL);

    // Matrix4 Camera::GetGPUProjection() const
    engine->RegisterObjectMethod(className, "Matrix4 GetGPUProjection() const", AS_METHODPR(T, GetGPUProjection, () const, Matrix4), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix4 get_gPUProjection() const", AS_METHODPR(T, GetGPUProjection, () const, Matrix4), AS_CALL_THISCALL);

    // float Camera::GetHalfViewSize() const
    engine->RegisterObjectMethod(className, "float GetHalfViewSize() const", AS_METHODPR(T, GetHalfViewSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_halfViewSize() const", AS_METHODPR(T, GetHalfViewSize, () const, float), AS_CALL_THISCALL);

    // float Camera::GetLodBias() const
    engine->RegisterObjectMethod(className, "float GetLodBias() const", AS_METHODPR(T, GetLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lodBias() const", AS_METHODPR(T, GetLodBias, () const, float), AS_CALL_THISCALL);

    // float Camera::GetLodDistance(float distance, float scale, float bias) const
    engine->RegisterObjectMethod(className, "float GetLodDistance(float, float, float) const", AS_METHODPR(T, GetLodDistance, (float, float, float) const, float), AS_CALL_THISCALL);

    // float Camera::GetNearClip() const
    engine->RegisterObjectMethod(className, "float GetNearClip() const", AS_METHODPR(T, GetNearClip, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_nearClip() const", AS_METHODPR(T, GetNearClip, () const, float), AS_CALL_THISCALL);

    // float Camera::GetOrthoSize() const
    engine->RegisterObjectMethod(className, "float GetOrthoSize() const", AS_METHODPR(T, GetOrthoSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_orthoSize() const", AS_METHODPR(T, GetOrthoSize, () const, float), AS_CALL_THISCALL);

    // Matrix4 Camera::GetProjection() const
    engine->RegisterObjectMethod(className, "Matrix4 GetProjection() const", AS_METHODPR(T, GetProjection, () const, Matrix4), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Matrix4 get_projection() const", AS_METHODPR(T, GetProjection, () const, Matrix4), AS_CALL_THISCALL);

    // const Vector2& Camera::GetProjectionOffset() const
    engine->RegisterObjectMethod(className, "const Vector2& GetProjectionOffset() const", AS_METHODPR(T, GetProjectionOffset, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_projectionOffset() const", AS_METHODPR(T, GetProjectionOffset, () const, const Vector2&), AS_CALL_THISCALL);

    // const Plane& Camera::GetReflectionPlane() const
    engine->RegisterObjectMethod(className, "const Plane& GetReflectionPlane() const", AS_METHODPR(T, GetReflectionPlane, () const, const Plane&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Plane& get_reflectionPlane() const", AS_METHODPR(T, GetReflectionPlane, () const, const Plane&), AS_CALL_THISCALL);

    // Vector4 Camera::GetReflectionPlaneAttr() const
    engine->RegisterObjectMethod(className, "Vector4 GetReflectionPlaneAttr() const", AS_METHODPR(T, GetReflectionPlaneAttr, () const, Vector4), AS_CALL_THISCALL);

    // bool Camera::GetReverseCulling() const
    engine->RegisterObjectMethod(className, "bool GetReverseCulling() const", AS_METHODPR(T, GetReverseCulling, () const, bool), AS_CALL_THISCALL);

    // Ray Camera::GetScreenRay(float x, float y) const
    engine->RegisterObjectMethod(className, "Ray GetScreenRay(float, float) const", AS_METHODPR(T, GetScreenRay, (float, float) const, Ray), AS_CALL_THISCALL);

    // Frustum Camera::GetSplitFrustum(float nearClip, float farClip) const
    engine->RegisterObjectMethod(className, "Frustum GetSplitFrustum(float, float) const", AS_METHODPR(T, GetSplitFrustum, (float, float) const, Frustum), AS_CALL_THISCALL);

    // bool Camera::GetUseClipping() const
    engine->RegisterObjectMethod(className, "bool GetUseClipping() const", AS_METHODPR(T, GetUseClipping, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useClipping() const", AS_METHODPR(T, GetUseClipping, () const, bool), AS_CALL_THISCALL);

    // bool Camera::GetUseReflection() const
    engine->RegisterObjectMethod(className, "bool GetUseReflection() const", AS_METHODPR(T, GetUseReflection, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useReflection() const", AS_METHODPR(T, GetUseReflection, () const, bool), AS_CALL_THISCALL);

    // const Matrix3x4& Camera::GetView() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetView() const", AS_METHODPR(T, GetView, () const, const Matrix3x4&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Matrix3x4& get_view() const", AS_METHODPR(T, GetView, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // unsigned Camera::GetViewMask() const
    engine->RegisterObjectMethod(className, "uint GetViewMask() const", AS_METHODPR(T, GetViewMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_viewMask() const", AS_METHODPR(T, GetViewMask, () const, unsigned), AS_CALL_THISCALL);

    // ViewOverrideFlags Camera::GetViewOverrideFlags() const
    engine->RegisterObjectMethod(className, "ViewOverrideFlags GetViewOverrideFlags() const", AS_METHODPR(T, GetViewOverrideFlags, () const, ViewOverrideFlags), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ViewOverrideFlags get_viewOverrideFlags() const", AS_METHODPR(T, GetViewOverrideFlags, () const, ViewOverrideFlags), AS_CALL_THISCALL);

    // Frustum Camera::GetViewSpaceFrustum() const
    engine->RegisterObjectMethod(className, "Frustum GetViewSpaceFrustum() const", AS_METHODPR(T, GetViewSpaceFrustum, () const, Frustum), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Frustum get_viewSpaceFrustum() const", AS_METHODPR(T, GetViewSpaceFrustum, () const, Frustum), AS_CALL_THISCALL);

    // Frustum Camera::GetViewSpaceSplitFrustum(float nearClip, float farClip) const
    engine->RegisterObjectMethod(className, "Frustum GetViewSpaceSplitFrustum(float, float) const", AS_METHODPR(T, GetViewSpaceSplitFrustum, (float, float) const, Frustum), AS_CALL_THISCALL);

    // float Camera::GetZoom() const
    engine->RegisterObjectMethod(className, "float GetZoom() const", AS_METHODPR(T, GetZoom, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_zoom() const", AS_METHODPR(T, GetZoom, () const, float), AS_CALL_THISCALL);

    // bool Camera::IsOrthographic() const
    engine->RegisterObjectMethod(className, "bool IsOrthographic() const", AS_METHODPR(T, IsOrthographic, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_orthographic() const", AS_METHODPR(T, IsOrthographic, () const, bool), AS_CALL_THISCALL);

    // bool Camera::IsProjectionValid() const
    engine->RegisterObjectMethod(className, "bool IsProjectionValid() const", AS_METHODPR(T, IsProjectionValid, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // Vector3 Camera::ScreenToWorldPoint(const Vector3& screenPos) const
    engine->RegisterObjectMethod(className, "Vector3 ScreenToWorldPoint(const Vector3&in) const", AS_METHODPR(T, ScreenToWorldPoint, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // void Camera::SetAspectRatio(float aspectRatio)
    engine->RegisterObjectMethod(className, "void SetAspectRatio(float)", AS_METHODPR(T, SetAspectRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_aspectRatio(float)", AS_METHODPR(T, SetAspectRatio, (float), void), AS_CALL_THISCALL);

    // void Camera::SetAspectRatioInternal(float aspectRatio)
    engine->RegisterObjectMethod(className, "void SetAspectRatioInternal(float)", AS_METHODPR(T, SetAspectRatioInternal, (float), void), AS_CALL_THISCALL);

    // void Camera::SetAutoAspectRatio(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoAspectRatio(bool)", AS_METHODPR(T, SetAutoAspectRatio, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoAspectRatio(bool)", AS_METHODPR(T, SetAutoAspectRatio, (bool), void), AS_CALL_THISCALL);

    // void Camera::SetClipPlane(const Plane& plane)
    engine->RegisterObjectMethod(className, "void SetClipPlane(const Plane&in)", AS_METHODPR(T, SetClipPlane, (const Plane&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clipPlane(const Plane&in)", AS_METHODPR(T, SetClipPlane, (const Plane&), void), AS_CALL_THISCALL);

    // void Camera::SetClipPlaneAttr(const Vector4& value)
    engine->RegisterObjectMethod(className, "void SetClipPlaneAttr(const Vector4&in)", AS_METHODPR(T, SetClipPlaneAttr, (const Vector4&), void), AS_CALL_THISCALL);

    // void Camera::SetFarClip(float farClip)
    engine->RegisterObjectMethod(className, "void SetFarClip(float)", AS_METHODPR(T, SetFarClip, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_farClip(float)", AS_METHODPR(T, SetFarClip, (float), void), AS_CALL_THISCALL);

    // void Camera::SetFillMode(FillMode mode)
    engine->RegisterObjectMethod(className, "void SetFillMode(FillMode)", AS_METHODPR(T, SetFillMode, (FillMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fillMode(FillMode)", AS_METHODPR(T, SetFillMode, (FillMode), void), AS_CALL_THISCALL);

    // void Camera::SetFlipVertical(bool enable)
    engine->RegisterObjectMethod(className, "void SetFlipVertical(bool)", AS_METHODPR(T, SetFlipVertical, (bool), void), AS_CALL_THISCALL);

    // void Camera::SetFov(float fov)
    engine->RegisterObjectMethod(className, "void SetFov(float)", AS_METHODPR(T, SetFov, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fov(float)", AS_METHODPR(T, SetFov, (float), void), AS_CALL_THISCALL);

    // void Camera::SetLodBias(float bias)
    engine->RegisterObjectMethod(className, "void SetLodBias(float)", AS_METHODPR(T, SetLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lodBias(float)", AS_METHODPR(T, SetLodBias, (float), void), AS_CALL_THISCALL);

    // void Camera::SetNearClip(float nearClip)
    engine->RegisterObjectMethod(className, "void SetNearClip(float)", AS_METHODPR(T, SetNearClip, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_nearClip(float)", AS_METHODPR(T, SetNearClip, (float), void), AS_CALL_THISCALL);

    // void Camera::SetOrthographic(bool enable)
    engine->RegisterObjectMethod(className, "void SetOrthographic(bool)", AS_METHODPR(T, SetOrthographic, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orthographic(bool)", AS_METHODPR(T, SetOrthographic, (bool), void), AS_CALL_THISCALL);

    // void Camera::SetOrthoSize(float orthoSize)
    engine->RegisterObjectMethod(className, "void SetOrthoSize(float)", AS_METHODPR(T, SetOrthoSize, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orthoSize(float)", AS_METHODPR(T, SetOrthoSize, (float), void), AS_CALL_THISCALL);

    // void Camera::SetOrthoSize(const Vector2& orthoSize)
    engine->RegisterObjectMethod(className, "void SetOrthoSize(const Vector2&in)", AS_METHODPR(T, SetOrthoSize, (const Vector2&), void), AS_CALL_THISCALL);

    // void Camera::SetOrthoSizeAttr(float orthoSize)
    engine->RegisterObjectMethod(className, "void SetOrthoSizeAttr(float)", AS_METHODPR(T, SetOrthoSizeAttr, (float), void), AS_CALL_THISCALL);

    // void Camera::SetProjection(const Matrix4& projection)
    engine->RegisterObjectMethod(className, "void SetProjection(const Matrix4&in)", AS_METHODPR(T, SetProjection, (const Matrix4&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_projection(const Matrix4&in)", AS_METHODPR(T, SetProjection, (const Matrix4&), void), AS_CALL_THISCALL);

    // void Camera::SetProjectionOffset(const Vector2& offset)
    engine->RegisterObjectMethod(className, "void SetProjectionOffset(const Vector2&in)", AS_METHODPR(T, SetProjectionOffset, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_projectionOffset(const Vector2&in)", AS_METHODPR(T, SetProjectionOffset, (const Vector2&), void), AS_CALL_THISCALL);

    // void Camera::SetReflectionPlane(const Plane& plane)
    engine->RegisterObjectMethod(className, "void SetReflectionPlane(const Plane&in)", AS_METHODPR(T, SetReflectionPlane, (const Plane&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_reflectionPlane(const Plane&in)", AS_METHODPR(T, SetReflectionPlane, (const Plane&), void), AS_CALL_THISCALL);

    // void Camera::SetReflectionPlaneAttr(const Vector4& value)
    engine->RegisterObjectMethod(className, "void SetReflectionPlaneAttr(const Vector4&in)", AS_METHODPR(T, SetReflectionPlaneAttr, (const Vector4&), void), AS_CALL_THISCALL);

    // void Camera::SetUseClipping(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseClipping(bool)", AS_METHODPR(T, SetUseClipping, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useClipping(bool)", AS_METHODPR(T, SetUseClipping, (bool), void), AS_CALL_THISCALL);

    // void Camera::SetUseReflection(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseReflection(bool)", AS_METHODPR(T, SetUseReflection, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useReflection(bool)", AS_METHODPR(T, SetUseReflection, (bool), void), AS_CALL_THISCALL);

    // void Camera::SetViewMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetViewMask(uint)", AS_METHODPR(T, SetViewMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewMask(uint)", AS_METHODPR(T, SetViewMask, (unsigned), void), AS_CALL_THISCALL);

    // void Camera::SetViewOverrideFlags(ViewOverrideFlags flags)
    engine->RegisterObjectMethod(className, "void SetViewOverrideFlags(ViewOverrideFlags)", AS_METHODPR(T, SetViewOverrideFlags, (ViewOverrideFlags), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewOverrideFlags(ViewOverrideFlags)", AS_METHODPR(T, SetViewOverrideFlags, (ViewOverrideFlags), void), AS_CALL_THISCALL);

    // void Camera::SetZoom(float zoom)
    engine->RegisterObjectMethod(className, "void SetZoom(float)", AS_METHODPR(T, SetZoom, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_zoom(float)", AS_METHODPR(T, SetZoom, (float), void), AS_CALL_THISCALL);

    // Vector2 Camera::WorldToScreenPoint(const Vector3& worldPos) const
    engine->RegisterObjectMethod(className, "Vector2 WorldToScreenPoint(const Vector3&in) const", AS_METHODPR(T, WorldToScreenPoint, (const Vector3&) const, Vector2), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Camera
        REGISTER_MEMBERS_MANUAL_PART_Camera();
    #endif
}

// class DebugRenderer | File: ../Graphics/DebugRenderer.h
template <class T> void RegisterMembers_DebugRenderer(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void DebugRenderer::AddTriangleMesh(const void* vertexData, unsigned vertexSize, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount, const Matrix3x4& transform, const Color& color, bool depthTest = true)
    // Error: type "const void*" can not automatically bind
    // void DebugRenderer::AddTriangleMesh(const void* vertexData, unsigned vertexSize, unsigned vertexStart, const void* indexData, unsigned indexSize, unsigned indexStart, unsigned indexCount, const Matrix3x4& transform, const Color& color, bool depthTest = true)
    // Error: type "const void*" can not automatically bind

    // void DebugRenderer::AddBoundingBox(const BoundingBox& box, const Color& color, bool depthTest = true, bool solid = false)
    engine->RegisterObjectMethod(className, "void AddBoundingBox(const BoundingBox&in, const Color&in, bool = true, bool = false)", AS_METHODPR(T, AddBoundingBox, (const BoundingBox&, const Color&, bool, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddBoundingBox(const BoundingBox& box, const Matrix3x4& transform, const Color& color, bool depthTest = true, bool solid = false)
    engine->RegisterObjectMethod(className, "void AddBoundingBox(const BoundingBox&in, const Matrix3x4&in, const Color&in, bool = true, bool = false)", AS_METHODPR(T, AddBoundingBox, (const BoundingBox&, const Matrix3x4&, const Color&, bool, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddCircle(const Vector3& center, const Vector3& normal, float radius, const Color& color, int steps = 64, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddCircle(const Vector3&in, const Vector3&in, float, const Color&in, int = 64, bool = true)", AS_METHODPR(T, AddCircle, (const Vector3&, const Vector3&, float, const Color&, int, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddCross(const Vector3& center, float size, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddCross(const Vector3&in, float, const Color&in, bool = true)", AS_METHODPR(T, AddCross, (const Vector3&, float, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddCylinder(const Vector3& position, float radius, float height, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddCylinder(const Vector3&in, float, float, const Color&in, bool = true)", AS_METHODPR(T, AddCylinder, (const Vector3&, float, float, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddFrustum(const Frustum& frustum, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddFrustum(const Frustum&in, const Color&in, bool = true)", AS_METHODPR(T, AddFrustum, (const Frustum&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddLine(const Vector3& start, const Vector3& end, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddLine(const Vector3&in, const Vector3&in, const Color&in, bool = true)", AS_METHODPR(T, AddLine, (const Vector3&, const Vector3&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddLine(const Vector3& start, const Vector3& end, unsigned color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddLine(const Vector3&in, const Vector3&in, uint, bool = true)", AS_METHODPR(T, AddLine, (const Vector3&, const Vector3&, unsigned, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddNode(Node* node, float scale = 1.0f, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddNode(Node@+, float = 1.0f, bool = true)", AS_METHODPR(T, AddNode, (Node*, float, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddPolygon(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddPolygon(const Vector3&in, const Vector3&in, const Vector3&in, const Vector3&in, const Color&in, bool = true)", AS_METHODPR(T, AddPolygon, (const Vector3&, const Vector3&, const Vector3&, const Vector3&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddPolygon(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Vector3& v4, unsigned color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddPolygon(const Vector3&in, const Vector3&in, const Vector3&in, const Vector3&in, uint, bool = true)", AS_METHODPR(T, AddPolygon, (const Vector3&, const Vector3&, const Vector3&, const Vector3&, unsigned, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddPolyhedron(const Polyhedron& poly, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddPolyhedron(const Polyhedron&in, const Color&in, bool = true)", AS_METHODPR(T, AddPolyhedron, (const Polyhedron&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddQuad(const Vector3& center, float width, float height, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddQuad(const Vector3&in, float, float, const Color&in, bool = true)", AS_METHODPR(T, AddQuad, (const Vector3&, float, float, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddSkeleton(const Skeleton& skeleton, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddSkeleton(const Skeleton&in, const Color&in, bool = true)", AS_METHODPR(T, AddSkeleton, (const Skeleton&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddSphere(const Sphere& sphere, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddSphere(const Sphere&in, const Color&in, bool = true)", AS_METHODPR(T, AddSphere, (const Sphere&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddSphereSector(const Sphere& sphere, const Quaternion& rotation, float angle, bool drawLines, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddSphereSector(const Sphere&in, const Quaternion&in, float, bool, const Color&in, bool = true)", AS_METHODPR(T, AddSphereSector, (const Sphere&, const Quaternion&, float, bool, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddTriangle(const Vector3& v1, const Vector3& v2, const Vector3& v3, const Color& color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddTriangle(const Vector3&in, const Vector3&in, const Vector3&in, const Color&in, bool = true)", AS_METHODPR(T, AddTriangle, (const Vector3&, const Vector3&, const Vector3&, const Color&, bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::AddTriangle(const Vector3& v1, const Vector3& v2, const Vector3& v3, unsigned color, bool depthTest = true)
    engine->RegisterObjectMethod(className, "void AddTriangle(const Vector3&in, const Vector3&in, const Vector3&in, uint, bool = true)", AS_METHODPR(T, AddTriangle, (const Vector3&, const Vector3&, const Vector3&, unsigned, bool), void), AS_CALL_THISCALL);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // const Frustum& DebugRenderer::GetFrustum() const
    engine->RegisterObjectMethod(className, "const Frustum& GetFrustum() const", AS_METHODPR(T, GetFrustum, () const, const Frustum&), AS_CALL_THISCALL);

    // bool DebugRenderer::GetLineAntiAlias() const
    engine->RegisterObjectMethod(className, "bool GetLineAntiAlias() const", AS_METHODPR(T, GetLineAntiAlias, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_lineAntiAlias() const", AS_METHODPR(T, GetLineAntiAlias, () const, bool), AS_CALL_THISCALL);

    // const Matrix4& DebugRenderer::GetProjection() const
    engine->RegisterObjectMethod(className, "const Matrix4& GetProjection() const", AS_METHODPR(T, GetProjection, () const, const Matrix4&), AS_CALL_THISCALL);

    // const Matrix3x4& DebugRenderer::GetView() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetView() const", AS_METHODPR(T, GetView, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // bool DebugRenderer::HasContent() const
    engine->RegisterObjectMethod(className, "bool HasContent() const", AS_METHODPR(T, HasContent, () const, bool), AS_CALL_THISCALL);

    // bool DebugRenderer::IsInside(const BoundingBox& box) const
    engine->RegisterObjectMethod(className, "bool IsInside(const BoundingBox&in) const", AS_METHODPR(T, IsInside, (const BoundingBox&) const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void DebugRenderer::Render()
    engine->RegisterObjectMethod(className, "void Render()", AS_METHODPR(T, Render, (), void), AS_CALL_THISCALL);

    // void DebugRenderer::SetLineAntiAlias(bool enable)
    engine->RegisterObjectMethod(className, "void SetLineAntiAlias(bool)", AS_METHODPR(T, SetLineAntiAlias, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lineAntiAlias(bool)", AS_METHODPR(T, SetLineAntiAlias, (bool), void), AS_CALL_THISCALL);

    // void DebugRenderer::SetView(Camera* camera)
    engine->RegisterObjectMethod(className, "void SetView(Camera@+)", AS_METHODPR(T, SetView, (Camera*), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DebugRenderer
        REGISTER_MEMBERS_MANUAL_PART_DebugRenderer();
    #endif
}

// const PODVector<Light*>& Drawable::GetLights() const
template <class T> CScriptArray* Drawable_constspPODVectorlesLightstargreamp_GetLights_void_template(T* _ptr)
{
    const PODVector<Light*>& result = _ptr->GetLights();
    return VectorToHandleArray(result, "Array<Light@>");
}

// const PODVector<Light*>& Drawable::GetVertexLights() const
template <class T> CScriptArray* Drawable_constspPODVectorlesLightstargreamp_GetVertexLights_void_template(T* _ptr)
{
    const PODVector<Light*>& result = _ptr->GetVertexLights();
    return VectorToHandleArray(result, "Array<Light@>");
}

// class Drawable | File: ../Graphics/Drawable.h
template <class T> void RegisterMembers_Drawable(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // const Vector<SourceBatch>& Drawable::GetBatches() const
    // Error: type "const Vector<SourceBatch>&" can not automatically bind
    // Octant* Drawable::GetOctant() const
    // Error: type "Octant" can not automatically bind bacause have @nobind mark
    // virtual void Drawable::ProcessRayQuery(const RayOctreeQuery& query, PODVector<RayQueryResult>& results)
    // Error: type "RayOctreeQuery" can not automatically bind bacause have @nobind mark
    // virtual void Drawable::Update(const FrameInfo& frame)
    // Can not be registered here bacause hidden in derived classes: ParticleEmitter2D

    // void Drawable::AddLight(Light* light)
    engine->RegisterObjectMethod(className, "void AddLight(Light@+)", AS_METHODPR(T, AddLight, (Light*), void), AS_CALL_THISCALL);

    // void Drawable::AddVertexLight(Light* light)
    engine->RegisterObjectMethod(className, "void AddVertexLight(Light@+)", AS_METHODPR(T, AddVertexLight, (Light*), void), AS_CALL_THISCALL);

    // void Drawable::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // virtual bool Drawable::DrawOcclusion(OcclusionBuffer* buffer)
    engine->RegisterObjectMethod(className, "bool DrawOcclusion(OcclusionBuffer@+)", AS_METHODPR(T, DrawOcclusion, (OcclusionBuffer*), bool), AS_CALL_THISCALL);

    // const BoundingBox& Drawable::GetBoundingBox() const
    engine->RegisterObjectMethod(className, "const BoundingBox& GetBoundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_boundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);

    // bool Drawable::GetCastShadows() const
    engine->RegisterObjectMethod(className, "bool GetCastShadows() const", AS_METHODPR(T, GetCastShadows, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_castShadows() const", AS_METHODPR(T, GetCastShadows, () const, bool), AS_CALL_THISCALL);

    // float Drawable::GetDistance() const
    engine->RegisterObjectMethod(className, "float GetDistance() const", AS_METHODPR(T, GetDistance, () const, float), AS_CALL_THISCALL);

    // unsigned char Drawable::GetDrawableFlags() const
    engine->RegisterObjectMethod(className, "uint8 GetDrawableFlags() const", AS_METHODPR(T, GetDrawableFlags, () const, unsigned char), AS_CALL_THISCALL);

    // float Drawable::GetDrawDistance() const
    engine->RegisterObjectMethod(className, "float GetDrawDistance() const", AS_METHODPR(T, GetDrawDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_drawDistance() const", AS_METHODPR(T, GetDrawDistance, () const, float), AS_CALL_THISCALL);

    // Light* Drawable::GetFirstLight() const
    engine->RegisterObjectMethod(className, "Light@+ GetFirstLight() const", AS_METHODPR(T, GetFirstLight, () const, Light*), AS_CALL_THISCALL);

    // unsigned Drawable::GetLightMask() const
    engine->RegisterObjectMethod(className, "uint GetLightMask() const", AS_METHODPR(T, GetLightMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_lightMask() const", AS_METHODPR(T, GetLightMask, () const, unsigned), AS_CALL_THISCALL);

    // const PODVector<Light*>& Drawable::GetLights() const
    engine->RegisterObjectMethod(className, "Array<Light@>@ GetLights() const", AS_FUNCTION_OBJFIRST(Drawable_constspPODVectorlesLightstargreamp_GetLights_void_template<Drawable>), AS_CALL_CDECL_OBJFIRST);

    // float Drawable::GetLodBias() const
    engine->RegisterObjectMethod(className, "float GetLodBias() const", AS_METHODPR(T, GetLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lodBias() const", AS_METHODPR(T, GetLodBias, () const, float), AS_CALL_THISCALL);

    // float Drawable::GetLodDistance() const
    engine->RegisterObjectMethod(className, "float GetLodDistance() const", AS_METHODPR(T, GetLodDistance, () const, float), AS_CALL_THISCALL);

    // virtual Geometry* Drawable::GetLodGeometry(unsigned batchIndex, unsigned level)
    engine->RegisterObjectMethod(className, "Geometry@+ GetLodGeometry(uint, uint)", AS_METHODPR(T, GetLodGeometry, (unsigned, unsigned), Geometry*), AS_CALL_THISCALL);

    // unsigned Drawable::GetMaxLights() const
    engine->RegisterObjectMethod(className, "uint GetMaxLights() const", AS_METHODPR(T, GetMaxLights, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxLights() const", AS_METHODPR(T, GetMaxLights, () const, unsigned), AS_CALL_THISCALL);

    // float Drawable::GetMaxZ() const
    engine->RegisterObjectMethod(className, "float GetMaxZ() const", AS_METHODPR(T, GetMaxZ, () const, float), AS_CALL_THISCALL);

    // float Drawable::GetMinZ() const
    engine->RegisterObjectMethod(className, "float GetMinZ() const", AS_METHODPR(T, GetMinZ, () const, float), AS_CALL_THISCALL);

    // virtual unsigned Drawable::GetNumOccluderTriangles()
    engine->RegisterObjectMethod(className, "uint GetNumOccluderTriangles()", AS_METHODPR(T, GetNumOccluderTriangles, (), unsigned), AS_CALL_THISCALL);

    // float Drawable::GetShadowDistance() const
    engine->RegisterObjectMethod(className, "float GetShadowDistance() const", AS_METHODPR(T, GetShadowDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowDistance() const", AS_METHODPR(T, GetShadowDistance, () const, float), AS_CALL_THISCALL);

    // unsigned Drawable::GetShadowMask() const
    engine->RegisterObjectMethod(className, "uint GetShadowMask() const", AS_METHODPR(T, GetShadowMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_shadowMask() const", AS_METHODPR(T, GetShadowMask, () const, unsigned), AS_CALL_THISCALL);

    // float Drawable::GetSortValue() const
    engine->RegisterObjectMethod(className, "float GetSortValue() const", AS_METHODPR(T, GetSortValue, () const, float), AS_CALL_THISCALL);

    // virtual UpdateGeometryType Drawable::GetUpdateGeometryType()
    engine->RegisterObjectMethod(className, "UpdateGeometryType GetUpdateGeometryType()", AS_METHODPR(T, GetUpdateGeometryType, (), UpdateGeometryType), AS_CALL_THISCALL);

    // const PODVector<Light*>& Drawable::GetVertexLights() const
    engine->RegisterObjectMethod(className, "Array<Light@>@ GetVertexLights() const", AS_FUNCTION_OBJFIRST(Drawable_constspPODVectorlesLightstargreamp_GetVertexLights_void_template<Drawable>), AS_CALL_CDECL_OBJFIRST);

    // unsigned Drawable::GetViewMask() const
    engine->RegisterObjectMethod(className, "uint GetViewMask() const", AS_METHODPR(T, GetViewMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_viewMask() const", AS_METHODPR(T, GetViewMask, () const, unsigned), AS_CALL_THISCALL);

    // const BoundingBox& Drawable::GetWorldBoundingBox()
    engine->RegisterObjectMethod(className, "const BoundingBox& GetWorldBoundingBox()", AS_METHODPR(T, GetWorldBoundingBox, (), const BoundingBox&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_worldBoundingBox()", AS_METHODPR(T, GetWorldBoundingBox, (), const BoundingBox&), AS_CALL_THISCALL);

    // Zone* Drawable::GetZone() const
    engine->RegisterObjectMethod(className, "Zone@+ GetZone() const", AS_METHODPR(T, GetZone, () const, Zone*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Zone@+ get_zone() const", AS_METHODPR(T, GetZone, () const, Zone*), AS_CALL_THISCALL);

    // unsigned Drawable::GetZoneMask() const
    engine->RegisterObjectMethod(className, "uint GetZoneMask() const", AS_METHODPR(T, GetZoneMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_zoneMask() const", AS_METHODPR(T, GetZoneMask, () const, unsigned), AS_CALL_THISCALL);

    // bool Drawable::HasBasePass(unsigned batchIndex) const
    engine->RegisterObjectMethod(className, "bool HasBasePass(uint) const", AS_METHODPR(T, HasBasePass, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool Drawable::IsInView() const
    engine->RegisterObjectMethod(className, "bool IsInView() const", AS_METHODPR(T, IsInView, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_inView() const", AS_METHODPR(T, IsInView, () const, bool), AS_CALL_THISCALL);

    // bool Drawable::IsInView(Camera* camera) const
    engine->RegisterObjectMethod(className, "bool IsInView(Camera@+) const", AS_METHODPR(T, IsInView, (Camera*) const, bool), AS_CALL_THISCALL);

    // bool Drawable::IsInView(const FrameInfo& frame, bool anyCamera = false) const
    engine->RegisterObjectMethod(className, "bool IsInView(const FrameInfo&in, bool = false) const", AS_METHODPR(T, IsInView, (const FrameInfo&, bool) const, bool), AS_CALL_THISCALL);

    // bool Drawable::IsOccludee() const
    engine->RegisterObjectMethod(className, "bool IsOccludee() const", AS_METHODPR(T, IsOccludee, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occludee() const", AS_METHODPR(T, IsOccludee, () const, bool), AS_CALL_THISCALL);

    // bool Drawable::IsOccluder() const
    engine->RegisterObjectMethod(className, "bool IsOccluder() const", AS_METHODPR(T, IsOccluder, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occluder() const", AS_METHODPR(T, IsOccluder, () const, bool), AS_CALL_THISCALL);

    // bool Drawable::IsZoneDirty() const
    engine->RegisterObjectMethod(className, "bool IsZoneDirty() const", AS_METHODPR(T, IsZoneDirty, () const, bool), AS_CALL_THISCALL);

    // void Drawable::LimitLights()
    engine->RegisterObjectMethod(className, "void LimitLights()", AS_METHODPR(T, LimitLights, (), void), AS_CALL_THISCALL);

    // void Drawable::LimitVertexLights(bool removeConvertedLights)
    engine->RegisterObjectMethod(className, "void LimitVertexLights(bool)", AS_METHODPR(T, LimitVertexLights, (bool), void), AS_CALL_THISCALL);

    // void Drawable::MarkForUpdate()
    engine->RegisterObjectMethod(className, "void MarkForUpdate()", AS_METHODPR(T, MarkForUpdate, (), void), AS_CALL_THISCALL);

    // void Drawable::MarkInView(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void MarkInView(const FrameInfo&in)", AS_METHODPR(T, MarkInView, (const FrameInfo&), void), AS_CALL_THISCALL);

    // void Drawable::MarkInView(unsigned frameNumber)
    engine->RegisterObjectMethod(className, "void MarkInView(uint)", AS_METHODPR(T, MarkInView, (unsigned), void), AS_CALL_THISCALL);

    // void Drawable::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Drawable::SetBasePass(unsigned batchIndex)
    engine->RegisterObjectMethod(className, "void SetBasePass(uint)", AS_METHODPR(T, SetBasePass, (unsigned), void), AS_CALL_THISCALL);

    // void Drawable::SetCastShadows(bool enable)
    engine->RegisterObjectMethod(className, "void SetCastShadows(bool)", AS_METHODPR(T, SetCastShadows, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_castShadows(bool)", AS_METHODPR(T, SetCastShadows, (bool), void), AS_CALL_THISCALL);

    // void Drawable::SetDrawDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetDrawDistance(float)", AS_METHODPR(T, SetDrawDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawDistance(float)", AS_METHODPR(T, SetDrawDistance, (float), void), AS_CALL_THISCALL);

    // void Drawable::SetLightMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetLightMask(uint)", AS_METHODPR(T, SetLightMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lightMask(uint)", AS_METHODPR(T, SetLightMask, (unsigned), void), AS_CALL_THISCALL);

    // void Drawable::SetLodBias(float bias)
    engine->RegisterObjectMethod(className, "void SetLodBias(float)", AS_METHODPR(T, SetLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lodBias(float)", AS_METHODPR(T, SetLodBias, (float), void), AS_CALL_THISCALL);

    // void Drawable::SetMaxLights(unsigned num)
    engine->RegisterObjectMethod(className, "void SetMaxLights(uint)", AS_METHODPR(T, SetMaxLights, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLights(uint)", AS_METHODPR(T, SetMaxLights, (unsigned), void), AS_CALL_THISCALL);

    // void Drawable::SetMinMaxZ(float minZ, float maxZ)
    engine->RegisterObjectMethod(className, "void SetMinMaxZ(float, float)", AS_METHODPR(T, SetMinMaxZ, (float, float), void), AS_CALL_THISCALL);

    // void Drawable::SetOccludee(bool enable)
    engine->RegisterObjectMethod(className, "void SetOccludee(bool)", AS_METHODPR(T, SetOccludee, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occludee(bool)", AS_METHODPR(T, SetOccludee, (bool), void), AS_CALL_THISCALL);

    // void Drawable::SetOccluder(bool enable)
    engine->RegisterObjectMethod(className, "void SetOccluder(bool)", AS_METHODPR(T, SetOccluder, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occluder(bool)", AS_METHODPR(T, SetOccluder, (bool), void), AS_CALL_THISCALL);

    // void Drawable::SetShadowDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetShadowDistance(float)", AS_METHODPR(T, SetShadowDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowDistance(float)", AS_METHODPR(T, SetShadowDistance, (float), void), AS_CALL_THISCALL);

    // void Drawable::SetShadowMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetShadowMask(uint)", AS_METHODPR(T, SetShadowMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowMask(uint)", AS_METHODPR(T, SetShadowMask, (unsigned), void), AS_CALL_THISCALL);

    // void Drawable::SetSortValue(float value)
    engine->RegisterObjectMethod(className, "void SetSortValue(float)", AS_METHODPR(T, SetSortValue, (float), void), AS_CALL_THISCALL);

    // void Drawable::SetViewMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetViewMask(uint)", AS_METHODPR(T, SetViewMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewMask(uint)", AS_METHODPR(T, SetViewMask, (unsigned), void), AS_CALL_THISCALL);

    // void Drawable::SetZone(Zone* zone, bool temporary = false)
    engine->RegisterObjectMethod(className, "void SetZone(Zone@+, bool = false)", AS_METHODPR(T, SetZone, (Zone*, bool), void), AS_CALL_THISCALL);

    // void Drawable::SetZoneMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetZoneMask(uint)", AS_METHODPR(T, SetZoneMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_zoneMask(uint)", AS_METHODPR(T, SetZoneMask, (unsigned), void), AS_CALL_THISCALL);

    // virtual void Drawable::UpdateBatches(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void UpdateBatches(const FrameInfo&in)", AS_METHODPR(T, UpdateBatches, (const FrameInfo&), void), AS_CALL_THISCALL);

    // virtual void Drawable::UpdateGeometry(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void UpdateGeometry(const FrameInfo&in)", AS_METHODPR(T, UpdateGeometry, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Drawable
        REGISTER_MEMBERS_MANUAL_PART_Drawable();
    #endif
}

// class LogicComponent | File: ../Scene/LogicComponent.h
template <class T> void RegisterMembers_LogicComponent(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_LogicComponent
        REGISTER_MEMBERS_MANUAL_PART_LogicComponent();
    #endif
}

// class Octree | File: ../Graphics/Octree.h
template <class T> void RegisterMembers_Octree(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);
    RegisterMembers_Octant<T>(engine, className);

    // void Octree::GetDrawables(OctreeQuery& query) const
    // Not registered because have @nobind mark
    // void Octree::Raycast(RayOctreeQuery& query) const
    // Error: type "RayOctreeQuery" can not automatically bind bacause have @nobind mark
    // void Octree::RaycastSingle(RayOctreeQuery& query) const
    // Error: type "RayOctreeQuery" can not automatically bind bacause have @nobind mark

    // void Octree::AddManualDrawable(Drawable* drawable)
    engine->RegisterObjectMethod(className, "void AddManualDrawable(Drawable@+)", AS_METHODPR(T, AddManualDrawable, (Drawable*), void), AS_CALL_THISCALL);

    // void Octree::CancelUpdate(Drawable* drawable)
    engine->RegisterObjectMethod(className, "void CancelUpdate(Drawable@+)", AS_METHODPR(T, CancelUpdate, (Drawable*), void), AS_CALL_THISCALL);

    // void Octree::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void Octree::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // unsigned Octree::GetNumLevels() const
    engine->RegisterObjectMethod(className, "uint GetNumLevels() const", AS_METHODPR(T, GetNumLevels, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numLevels() const", AS_METHODPR(T, GetNumLevels, () const, unsigned), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Octree::QueueUpdate(Drawable* drawable)
    engine->RegisterObjectMethod(className, "void QueueUpdate(Drawable@+)", AS_METHODPR(T, QueueUpdate, (Drawable*), void), AS_CALL_THISCALL);

    // void Octree::RemoveManualDrawable(Drawable* drawable)
    engine->RegisterObjectMethod(className, "void RemoveManualDrawable(Drawable@+)", AS_METHODPR(T, RemoveManualDrawable, (Drawable*), void), AS_CALL_THISCALL);

    // void Octree::SetSize(const BoundingBox& box, unsigned numLevels)
    engine->RegisterObjectMethod(className, "void SetSize(const BoundingBox&in, uint)", AS_METHODPR(T, SetSize, (const BoundingBox&, unsigned), void), AS_CALL_THISCALL);

    // void Octree::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Octree
        REGISTER_MEMBERS_MANUAL_PART_Octree();
    #endif
}

// const Vector<SharedPtr<PackageFile>>& Scene::GetRequiredPackageFiles() const
template <class T> CScriptArray* Scene_constspVectorlesSharedPtrlesPackageFilegregreamp_GetRequiredPackageFiles_void_template(T* _ptr)
{
    const Vector<SharedPtr<PackageFile>>& result = _ptr->GetRequiredPackageFiles();
    return VectorToHandleArray(result, "Array<PackageFile@>");
}

// class Scene | File: ../Scene/Scene.h
template <class T> void RegisterMembers_Scene(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Node<T>(engine, className);

    // bool Scene::GetNodesWithTag(PODVector<Node*>& dest, const String& tag) const
    // Error: type "PODVector<Node*>&" can not automatically bind

    // void Scene::AddRequiredPackageFile(PackageFile* package)
    engine->RegisterObjectMethod(className, "void AddRequiredPackageFile(PackageFile@+)", AS_METHODPR(T, AddRequiredPackageFile, (PackageFile*), void), AS_CALL_THISCALL);

    // void Scene::BeginThreadedUpdate()
    engine->RegisterObjectMethod(className, "void BeginThreadedUpdate()", AS_METHODPR(T, BeginThreadedUpdate, (), void), AS_CALL_THISCALL);

    // void Scene::Clear(bool clearReplicated = true, bool clearLocal = true)
    engine->RegisterObjectMethod(className, "void Clear(bool = true, bool = true)", AS_METHODPR(T, Clear, (bool, bool), void), AS_CALL_THISCALL);

    // void Scene::ClearRequiredPackageFiles()
    engine->RegisterObjectMethod(className, "void ClearRequiredPackageFiles()", AS_METHODPR(T, ClearRequiredPackageFiles, (), void), AS_CALL_THISCALL);

    // void Scene::ComponentAdded(Component* component)
    engine->RegisterObjectMethod(className, "void ComponentAdded(Component@+)", AS_METHODPR(T, ComponentAdded, (Component*), void), AS_CALL_THISCALL);

    // void Scene::ComponentRemoved(Component* component)
    engine->RegisterObjectMethod(className, "void ComponentRemoved(Component@+)", AS_METHODPR(T, ComponentRemoved, (Component*), void), AS_CALL_THISCALL);

    // void Scene::DelayedMarkedDirty(Component* component)
    engine->RegisterObjectMethod(className, "void DelayedMarkedDirty(Component@+)", AS_METHODPR(T, DelayedMarkedDirty, (Component*), void), AS_CALL_THISCALL);

    // void Scene::EndThreadedUpdate()
    engine->RegisterObjectMethod(className, "void EndThreadedUpdate()", AS_METHODPR(T, EndThreadedUpdate, (), void), AS_CALL_THISCALL);

    // int Scene::GetAsyncLoadingMs() const
    engine->RegisterObjectMethod(className, "int GetAsyncLoadingMs() const", AS_METHODPR(T, GetAsyncLoadingMs, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_asyncLoadingMs() const", AS_METHODPR(T, GetAsyncLoadingMs, () const, int), AS_CALL_THISCALL);

    // LoadMode Scene::GetAsyncLoadMode() const
    engine->RegisterObjectMethod(className, "LoadMode GetAsyncLoadMode() const", AS_METHODPR(T, GetAsyncLoadMode, () const, LoadMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LoadMode get_asyncLoadMode() const", AS_METHODPR(T, GetAsyncLoadMode, () const, LoadMode), AS_CALL_THISCALL);

    // float Scene::GetAsyncProgress() const
    engine->RegisterObjectMethod(className, "float GetAsyncProgress() const", AS_METHODPR(T, GetAsyncProgress, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_asyncProgress() const", AS_METHODPR(T, GetAsyncProgress, () const, float), AS_CALL_THISCALL);

    // unsigned Scene::GetChecksum() const
    engine->RegisterObjectMethod(className, "uint GetChecksum() const", AS_METHODPR(T, GetChecksum, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_checksum() const", AS_METHODPR(T, GetChecksum, () const, unsigned), AS_CALL_THISCALL);

    // Component* Scene::GetComponent(unsigned id) const
    engine->RegisterObjectMethod(className, "Component@+ GetComponent(uint) const", AS_METHODPR(T, GetComponent, (unsigned) const, Component*), AS_CALL_THISCALL);

    // float Scene::GetElapsedTime() const
    engine->RegisterObjectMethod(className, "float GetElapsedTime() const", AS_METHODPR(T, GetElapsedTime, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_elapsedTime() const", AS_METHODPR(T, GetElapsedTime, () const, float), AS_CALL_THISCALL);

    // const String& Scene::GetFileName() const
    engine->RegisterObjectMethod(className, "const String& GetFileName() const", AS_METHODPR(T, GetFileName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_fileName() const", AS_METHODPR(T, GetFileName, () const, const String&), AS_CALL_THISCALL);

    // unsigned Scene::GetFreeComponentID(CreateMode mode)
    engine->RegisterObjectMethod(className, "uint GetFreeComponentID(CreateMode)", AS_METHODPR(T, GetFreeComponentID, (CreateMode), unsigned), AS_CALL_THISCALL);

    // unsigned Scene::GetFreeNodeID(CreateMode mode)
    engine->RegisterObjectMethod(className, "uint GetFreeNodeID(CreateMode)", AS_METHODPR(T, GetFreeNodeID, (CreateMode), unsigned), AS_CALL_THISCALL);

    // Node* Scene::GetNode(unsigned id) const
    engine->RegisterObjectMethod(className, "Node@+ GetNode(uint) const", AS_METHODPR(T, GetNode, (unsigned) const, Node*), AS_CALL_THISCALL);

    // const Vector<SharedPtr<PackageFile>>& Scene::GetRequiredPackageFiles() const
    engine->RegisterObjectMethod(className, "Array<PackageFile@>@ GetRequiredPackageFiles() const", AS_FUNCTION_OBJFIRST(Scene_constspVectorlesSharedPtrlesPackageFilegregreamp_GetRequiredPackageFiles_void_template<Scene>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<PackageFile@>@ get_requiredPackageFiles() const", AS_FUNCTION_OBJFIRST(Scene_constspVectorlesSharedPtrlesPackageFilegregreamp_GetRequiredPackageFiles_void_template<Scene>), AS_CALL_CDECL_OBJFIRST);

    // float Scene::GetSmoothingConstant() const
    engine->RegisterObjectMethod(className, "float GetSmoothingConstant() const", AS_METHODPR(T, GetSmoothingConstant, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_smoothingConstant() const", AS_METHODPR(T, GetSmoothingConstant, () const, float), AS_CALL_THISCALL);

    // float Scene::GetSnapThreshold() const
    engine->RegisterObjectMethod(className, "float GetSnapThreshold() const", AS_METHODPR(T, GetSnapThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_snapThreshold() const", AS_METHODPR(T, GetSnapThreshold, () const, float), AS_CALL_THISCALL);

    // float Scene::GetTimeScale() const
    engine->RegisterObjectMethod(className, "float GetTimeScale() const", AS_METHODPR(T, GetTimeScale, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_timeScale() const", AS_METHODPR(T, GetTimeScale, () const, float), AS_CALL_THISCALL);

    // const String& Scene::GetVarName(StringHash hash) const
    engine->RegisterObjectMethod(className, "const String& GetVarName(StringHash) const", AS_METHODPR(T, GetVarName, (StringHash) const, const String&), AS_CALL_THISCALL);

    // String Scene::GetVarNamesAttr() const
    engine->RegisterObjectMethod(className, "String GetVarNamesAttr() const", AS_METHODPR(T, GetVarNamesAttr, () const, String), AS_CALL_THISCALL);

    // Node* Scene::Instantiate(Deserializer& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)
    engine->RegisterObjectMethod(className, "Node@+ Instantiate(Deserializer&, const Vector3&in, const Quaternion&in, CreateMode = REPLICATED)", AS_METHODPR(T, Instantiate, (Deserializer&, const Vector3&, const Quaternion&, CreateMode), Node*), AS_CALL_THISCALL);

    // Node* Scene::InstantiateJSON(const JSONValue& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)
    engine->RegisterObjectMethod(className, "Node@+ InstantiateJSON(const JSONValue&in, const Vector3&in, const Quaternion&in, CreateMode = REPLICATED)", AS_METHODPR(T, InstantiateJSON, (const JSONValue&, const Vector3&, const Quaternion&, CreateMode), Node*), AS_CALL_THISCALL);

    // Node* Scene::InstantiateJSON(Deserializer& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)
    engine->RegisterObjectMethod(className, "Node@+ InstantiateJSON(Deserializer&, const Vector3&in, const Quaternion&in, CreateMode = REPLICATED)", AS_METHODPR(T, InstantiateJSON, (Deserializer&, const Vector3&, const Quaternion&, CreateMode), Node*), AS_CALL_THISCALL);

    // Node* Scene::InstantiateXML(const XMLElement& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)
    engine->RegisterObjectMethod(className, "Node@+ InstantiateXML(const XMLElement&in, const Vector3&in, const Quaternion&in, CreateMode = REPLICATED)", AS_METHODPR(T, InstantiateXML, (const XMLElement&, const Vector3&, const Quaternion&, CreateMode), Node*), AS_CALL_THISCALL);

    // Node* Scene::InstantiateXML(Deserializer& source, const Vector3& position, const Quaternion& rotation, CreateMode mode = REPLICATED)
    engine->RegisterObjectMethod(className, "Node@+ InstantiateXML(Deserializer&, const Vector3&in, const Quaternion&in, CreateMode = REPLICATED)", AS_METHODPR(T, InstantiateXML, (Deserializer&, const Vector3&, const Quaternion&, CreateMode), Node*), AS_CALL_THISCALL);

    // bool Scene::IsAsyncLoading() const
    engine->RegisterObjectMethod(className, "bool IsAsyncLoading() const", AS_METHODPR(T, IsAsyncLoading, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_asyncLoading() const", AS_METHODPR(T, IsAsyncLoading, () const, bool), AS_CALL_THISCALL);

    // bool Scene::IsThreadedUpdate() const
    engine->RegisterObjectMethod(className, "bool IsThreadedUpdate() const", AS_METHODPR(T, IsThreadedUpdate, () const, bool), AS_CALL_THISCALL);

    // bool Scene::IsUpdateEnabled() const
    engine->RegisterObjectMethod(className, "bool IsUpdateEnabled() const", AS_METHODPR(T, IsUpdateEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateEnabled() const", AS_METHODPR(T, IsUpdateEnabled, () const, bool), AS_CALL_THISCALL);

    // bool Scene::LoadAsync(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES)
    engine->RegisterObjectMethod(className, "bool LoadAsync(File@+, LoadMode = LOAD_SCENE_AND_RESOURCES)", AS_METHODPR(T, LoadAsync, (File*, LoadMode), bool), AS_CALL_THISCALL);

    // bool Scene::LoadAsyncJSON(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES)
    engine->RegisterObjectMethod(className, "bool LoadAsyncJSON(File@+, LoadMode = LOAD_SCENE_AND_RESOURCES)", AS_METHODPR(T, LoadAsyncJSON, (File*, LoadMode), bool), AS_CALL_THISCALL);

    // bool Scene::LoadAsyncXML(File* file, LoadMode mode = LOAD_SCENE_AND_RESOURCES)
    engine->RegisterObjectMethod(className, "bool LoadAsyncXML(File@+, LoadMode = LOAD_SCENE_AND_RESOURCES)", AS_METHODPR(T, LoadAsyncXML, (File*, LoadMode), bool), AS_CALL_THISCALL);

    // bool Scene::LoadJSON(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadJSON(Deserializer&)", AS_METHODPR(T, LoadJSON, (Deserializer&), bool), AS_CALL_THISCALL);

    // bool Scene::LoadXML(Deserializer& source)
    engine->RegisterObjectMethod(className, "bool LoadXML(Deserializer&)", AS_METHODPR(T, LoadXML, (Deserializer&), bool), AS_CALL_THISCALL);

    // void Scene::MarkNetworkUpdate(Node* node)
    engine->RegisterObjectMethod(className, "void MarkNetworkUpdate(Node@+)", AS_METHODPR(T, MarkNetworkUpdate, (Node*), void), AS_CALL_THISCALL);

    // void Scene::MarkNetworkUpdate(Component* component)
    engine->RegisterObjectMethod(className, "void MarkNetworkUpdate(Component@+)", AS_METHODPR(T, MarkNetworkUpdate, (Component*), void), AS_CALL_THISCALL);

    // void Scene::MarkReplicationDirty(Node* node)
    engine->RegisterObjectMethod(className, "void MarkReplicationDirty(Node@+)", AS_METHODPR(T, MarkReplicationDirty, (Node*), void), AS_CALL_THISCALL);

    // void Scene::NodeAdded(Node* node)
    engine->RegisterObjectMethod(className, "void NodeAdded(Node@+)", AS_METHODPR(T, NodeAdded, (Node*), void), AS_CALL_THISCALL);

    // void Scene::NodeRemoved(Node* node)
    engine->RegisterObjectMethod(className, "void NodeRemoved(Node@+)", AS_METHODPR(T, NodeRemoved, (Node*), void), AS_CALL_THISCALL);

    // void Scene::NodeTagAdded(Node* node, const String& tag)
    engine->RegisterObjectMethod(className, "void NodeTagAdded(Node@+, const String&in)", AS_METHODPR(T, NodeTagAdded, (Node*, const String&), void), AS_CALL_THISCALL);

    // void Scene::NodeTagRemoved(Node* node, const String& tag)
    engine->RegisterObjectMethod(className, "void NodeTagRemoved(Node@+, const String&in)", AS_METHODPR(T, NodeTagRemoved, (Node*, const String&), void), AS_CALL_THISCALL);

    // void Scene::RegisterVar(const String& name)
    engine->RegisterObjectMethod(className, "void RegisterVar(const String&in)", AS_METHODPR(T, RegisterVar, (const String&), void), AS_CALL_THISCALL);

    // void Scene::SetAsyncLoadingMs(int ms)
    engine->RegisterObjectMethod(className, "void SetAsyncLoadingMs(int)", AS_METHODPR(T, SetAsyncLoadingMs, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_asyncLoadingMs(int)", AS_METHODPR(T, SetAsyncLoadingMs, (int), void), AS_CALL_THISCALL);

    // void Scene::SetElapsedTime(float time)
    engine->RegisterObjectMethod(className, "void SetElapsedTime(float)", AS_METHODPR(T, SetElapsedTime, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_elapsedTime(float)", AS_METHODPR(T, SetElapsedTime, (float), void), AS_CALL_THISCALL);

    // void Scene::SetSmoothingConstant(float constant)
    engine->RegisterObjectMethod(className, "void SetSmoothingConstant(float)", AS_METHODPR(T, SetSmoothingConstant, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_smoothingConstant(float)", AS_METHODPR(T, SetSmoothingConstant, (float), void), AS_CALL_THISCALL);

    // void Scene::SetSnapThreshold(float threshold)
    engine->RegisterObjectMethod(className, "void SetSnapThreshold(float)", AS_METHODPR(T, SetSnapThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_snapThreshold(float)", AS_METHODPR(T, SetSnapThreshold, (float), void), AS_CALL_THISCALL);

    // void Scene::SetTimeScale(float scale)
    engine->RegisterObjectMethod(className, "void SetTimeScale(float)", AS_METHODPR(T, SetTimeScale, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_timeScale(float)", AS_METHODPR(T, SetTimeScale, (float), void), AS_CALL_THISCALL);

    // void Scene::SetUpdateEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetUpdateEnabled(bool)", AS_METHODPR(T, SetUpdateEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateEnabled(bool)", AS_METHODPR(T, SetUpdateEnabled, (bool), void), AS_CALL_THISCALL);

    // void Scene::SetVarNamesAttr(const String& value)
    engine->RegisterObjectMethod(className, "void SetVarNamesAttr(const String&in)", AS_METHODPR(T, SetVarNamesAttr, (const String&), void), AS_CALL_THISCALL);

    // void Scene::StopAsyncLoading()
    engine->RegisterObjectMethod(className, "void StopAsyncLoading()", AS_METHODPR(T, StopAsyncLoading, (), void), AS_CALL_THISCALL);

    // void Scene::UnregisterAllVars()
    engine->RegisterObjectMethod(className, "void UnregisterAllVars()", AS_METHODPR(T, UnregisterAllVars, (), void), AS_CALL_THISCALL);

    // void Scene::UnregisterVar(const String& name)
    engine->RegisterObjectMethod(className, "void UnregisterVar(const String&in)", AS_METHODPR(T, UnregisterVar, (const String&), void), AS_CALL_THISCALL);

    // void Scene::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    // static bool Scene::IsReplicatedID(unsigned id)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("bool IsReplicatedID(uint)", AS_FUNCTIONPR(T::IsReplicatedID, (unsigned), bool), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Scene
        REGISTER_MEMBERS_MANUAL_PART_Scene();
    #endif
}

// class ScrollView | File: ../UI/ScrollView.h
template <class T> void RegisterMembers_ScrollView(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_UIElement<T>(engine, className);

    // bool ScrollView::GetAutoDisableChildren() const
    engine->RegisterObjectMethod(className, "bool GetAutoDisableChildren() const", AS_METHODPR(T, GetAutoDisableChildren, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoDisableChildren() const", AS_METHODPR(T, GetAutoDisableChildren, () const, bool), AS_CALL_THISCALL);

    // float ScrollView::GetAutoDisableThreshold() const
    engine->RegisterObjectMethod(className, "float GetAutoDisableThreshold() const", AS_METHODPR(T, GetAutoDisableThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_autoDisableThreshold() const", AS_METHODPR(T, GetAutoDisableThreshold, () const, float), AS_CALL_THISCALL);

    // UIElement* ScrollView::GetContentElement() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetContentElement() const", AS_METHODPR(T, GetContentElement, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_contentElement() const", AS_METHODPR(T, GetContentElement, () const, UIElement*), AS_CALL_THISCALL);

    // ScrollBar* ScrollView::GetHorizontalScrollBar() const
    engine->RegisterObjectMethod(className, "ScrollBar@+ GetHorizontalScrollBar() const", AS_METHODPR(T, GetHorizontalScrollBar, () const, ScrollBar*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ScrollBar@+ get_horizontalScrollBar() const", AS_METHODPR(T, GetHorizontalScrollBar, () const, ScrollBar*), AS_CALL_THISCALL);

    // bool ScrollView::GetHorizontalScrollBarVisible() const
    engine->RegisterObjectMethod(className, "bool GetHorizontalScrollBarVisible() const", AS_METHODPR(T, GetHorizontalScrollBarVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_horizontalScrollBarVisible() const", AS_METHODPR(T, GetHorizontalScrollBarVisible, () const, bool), AS_CALL_THISCALL);

    // float ScrollView::GetPageStep() const
    engine->RegisterObjectMethod(className, "float GetPageStep() const", AS_METHODPR(T, GetPageStep, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_pageStep() const", AS_METHODPR(T, GetPageStep, () const, float), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetPosition() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_position() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);

    // bool ScrollView::GetScrollBarsAutoVisible() const
    engine->RegisterObjectMethod(className, "bool GetScrollBarsAutoVisible() const", AS_METHODPR(T, GetScrollBarsAutoVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_scrollBarsAutoVisible() const", AS_METHODPR(T, GetScrollBarsAutoVisible, () const, bool), AS_CALL_THISCALL);

    // float ScrollView::GetScrollDeceleration() const
    engine->RegisterObjectMethod(className, "float GetScrollDeceleration() const", AS_METHODPR(T, GetScrollDeceleration, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_scrollDeceleration() const", AS_METHODPR(T, GetScrollDeceleration, () const, float), AS_CALL_THISCALL);

    // BorderImage* ScrollView::GetScrollPanel() const
    engine->RegisterObjectMethod(className, "BorderImage@+ GetScrollPanel() const", AS_METHODPR(T, GetScrollPanel, () const, BorderImage*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BorderImage@+ get_scrollPanel() const", AS_METHODPR(T, GetScrollPanel, () const, BorderImage*), AS_CALL_THISCALL);

    // float ScrollView::GetScrollSnapEpsilon() const
    engine->RegisterObjectMethod(className, "float GetScrollSnapEpsilon() const", AS_METHODPR(T, GetScrollSnapEpsilon, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_scrollSnapEpsilon() const", AS_METHODPR(T, GetScrollSnapEpsilon, () const, float), AS_CALL_THISCALL);

    // float ScrollView::GetScrollStep() const
    engine->RegisterObjectMethod(className, "float GetScrollStep() const", AS_METHODPR(T, GetScrollStep, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_scrollStep() const", AS_METHODPR(T, GetScrollStep, () const, float), AS_CALL_THISCALL);

    // ScrollBar* ScrollView::GetVerticalScrollBar() const
    engine->RegisterObjectMethod(className, "ScrollBar@+ GetVerticalScrollBar() const", AS_METHODPR(T, GetVerticalScrollBar, () const, ScrollBar*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ScrollBar@+ get_verticalScrollBar() const", AS_METHODPR(T, GetVerticalScrollBar, () const, ScrollBar*), AS_CALL_THISCALL);

    // bool ScrollView::GetVerticalScrollBarVisible() const
    engine->RegisterObjectMethod(className, "bool GetVerticalScrollBarVisible() const", AS_METHODPR(T, GetVerticalScrollBarVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_verticalScrollBarVisible() const", AS_METHODPR(T, GetVerticalScrollBarVisible, () const, bool), AS_CALL_THISCALL);

    // const IntVector2& ScrollView::GetViewPosition() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetViewPosition() const", AS_METHODPR(T, GetViewPosition, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_viewPosition() const", AS_METHODPR(T, GetViewPosition, () const, const IntVector2&), AS_CALL_THISCALL);

    // void ScrollView::SetAutoDisableChildren(bool disable)
    engine->RegisterObjectMethod(className, "void SetAutoDisableChildren(bool)", AS_METHODPR(T, SetAutoDisableChildren, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoDisableChildren(bool)", AS_METHODPR(T, SetAutoDisableChildren, (bool), void), AS_CALL_THISCALL);

    // void ScrollView::SetAutoDisableThreshold(float amount)
    engine->RegisterObjectMethod(className, "void SetAutoDisableThreshold(float)", AS_METHODPR(T, SetAutoDisableThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoDisableThreshold(float)", AS_METHODPR(T, SetAutoDisableThreshold, (float), void), AS_CALL_THISCALL);

    // void ScrollView::SetContentElement(UIElement* element)
    engine->RegisterObjectMethod(className, "void SetContentElement(UIElement@+)", AS_METHODPR(T, SetContentElement, (UIElement*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_contentElement(UIElement@+)", AS_METHODPR(T, SetContentElement, (UIElement*), void), AS_CALL_THISCALL);

    // void ScrollView::SetHorizontalScrollBarVisible(bool visible)
    engine->RegisterObjectMethod(className, "void SetHorizontalScrollBarVisible(bool)", AS_METHODPR(T, SetHorizontalScrollBarVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_horizontalScrollBarVisible(bool)", AS_METHODPR(T, SetHorizontalScrollBarVisible, (bool), void), AS_CALL_THISCALL);

    // void ScrollView::SetPageStep(float step)
    engine->RegisterObjectMethod(className, "void SetPageStep(float)", AS_METHODPR(T, SetPageStep, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pageStep(float)", AS_METHODPR(T, SetPageStep, (float), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPosition(int, int)", AS_METHODPR(T, SetPosition, (int, int), void), AS_CALL_THISCALL);

    // void ScrollView::SetScrollBarsAutoVisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetScrollBarsAutoVisible(bool)", AS_METHODPR(T, SetScrollBarsAutoVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scrollBarsAutoVisible(bool)", AS_METHODPR(T, SetScrollBarsAutoVisible, (bool), void), AS_CALL_THISCALL);

    // void ScrollView::SetScrollBarsVisible(bool horizontal, bool vertical)
    engine->RegisterObjectMethod(className, "void SetScrollBarsVisible(bool, bool)", AS_METHODPR(T, SetScrollBarsVisible, (bool, bool), void), AS_CALL_THISCALL);

    // void ScrollView::SetScrollDeceleration(float deceleration)
    engine->RegisterObjectMethod(className, "void SetScrollDeceleration(float)", AS_METHODPR(T, SetScrollDeceleration, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scrollDeceleration(float)", AS_METHODPR(T, SetScrollDeceleration, (float), void), AS_CALL_THISCALL);

    // void ScrollView::SetScrollSnapEpsilon(float snap)
    engine->RegisterObjectMethod(className, "void SetScrollSnapEpsilon(float)", AS_METHODPR(T, SetScrollSnapEpsilon, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scrollSnapEpsilon(float)", AS_METHODPR(T, SetScrollSnapEpsilon, (float), void), AS_CALL_THISCALL);

    // void ScrollView::SetScrollStep(float step)
    engine->RegisterObjectMethod(className, "void SetScrollStep(float)", AS_METHODPR(T, SetScrollStep, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scrollStep(float)", AS_METHODPR(T, SetScrollStep, (float), void), AS_CALL_THISCALL);

    // void ScrollView::SetVerticalScrollBarVisible(bool visible)
    engine->RegisterObjectMethod(className, "void SetVerticalScrollBarVisible(bool)", AS_METHODPR(T, SetVerticalScrollBarVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_verticalScrollBarVisible(bool)", AS_METHODPR(T, SetVerticalScrollBarVisible, (bool), void), AS_CALL_THISCALL);

    // void ScrollView::SetViewPosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetViewPosition(const IntVector2&in)", AS_METHODPR(T, SetViewPosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewPosition(const IntVector2&in)", AS_METHODPR(T, SetViewPosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void ScrollView::SetViewPosition(int x, int y)
    engine->RegisterObjectMethod(className, "void SetViewPosition(int, int)", AS_METHODPR(T, SetViewPosition, (int, int), void), AS_CALL_THISCALL);

    // void ScrollView::SetViewPositionAttr(const IntVector2& value)
    engine->RegisterObjectMethod(className, "void SetViewPositionAttr(const IntVector2&in)", AS_METHODPR(T, SetViewPositionAttr, (const IntVector2&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ScrollView
        REGISTER_MEMBERS_MANUAL_PART_ScrollView();
    #endif
}

// class SmoothedTransform | File: ../Scene/SmoothedTransform.h
template <class T> void RegisterMembers_SmoothedTransform(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // const Vector3& SmoothedTransform::GetTargetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetTargetPosition() const", AS_METHODPR(T, GetTargetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_targetPosition() const", AS_METHODPR(T, GetTargetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // const Quaternion& SmoothedTransform::GetTargetRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetTargetRotation() const", AS_METHODPR(T, GetTargetRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_targetRotation() const", AS_METHODPR(T, GetTargetRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // Vector3 SmoothedTransform::GetTargetWorldPosition() const
    engine->RegisterObjectMethod(className, "Vector3 GetTargetWorldPosition() const", AS_METHODPR(T, GetTargetWorldPosition, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_targetWorldPosition() const", AS_METHODPR(T, GetTargetWorldPosition, () const, Vector3), AS_CALL_THISCALL);

    // Quaternion SmoothedTransform::GetTargetWorldRotation() const
    engine->RegisterObjectMethod(className, "Quaternion GetTargetWorldRotation() const", AS_METHODPR(T, GetTargetWorldRotation, () const, Quaternion), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Quaternion get_targetWorldRotation() const", AS_METHODPR(T, GetTargetWorldRotation, () const, Quaternion), AS_CALL_THISCALL);

    // bool SmoothedTransform::IsInProgress() const
    engine->RegisterObjectMethod(className, "bool IsInProgress() const", AS_METHODPR(T, IsInProgress, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_inProgress() const", AS_METHODPR(T, IsInProgress, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void SmoothedTransform::SetTargetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetTargetPosition(const Vector3&in)", AS_METHODPR(T, SetTargetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetPosition(const Vector3&in)", AS_METHODPR(T, SetTargetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void SmoothedTransform::SetTargetRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetTargetRotation(const Quaternion&in)", AS_METHODPR(T, SetTargetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetRotation(const Quaternion&in)", AS_METHODPR(T, SetTargetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void SmoothedTransform::SetTargetWorldPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetTargetWorldPosition(const Vector3&in)", AS_METHODPR(T, SetTargetWorldPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetWorldPosition(const Vector3&in)", AS_METHODPR(T, SetTargetWorldPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void SmoothedTransform::SetTargetWorldRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetTargetWorldRotation(const Quaternion&in)", AS_METHODPR(T, SetTargetWorldRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetWorldRotation(const Quaternion&in)", AS_METHODPR(T, SetTargetWorldRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void SmoothedTransform::Update(float constant, float squaredSnapThreshold)
    engine->RegisterObjectMethod(className, "void Update(float, float)", AS_METHODPR(T, Update, (float, float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SmoothedTransform
        REGISTER_MEMBERS_MANUAL_PART_SmoothedTransform();
    #endif
}

// class SoundListener | File: ../Audio/SoundListener.h
template <class T> void RegisterMembers_SoundListener(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SoundListener
        REGISTER_MEMBERS_MANUAL_PART_SoundListener();
    #endif
}

// class SoundSource | File: ../Audio/SoundSource.h
template <class T> void RegisterMembers_SoundSource(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // volatile signed char* SoundSource::GetPlayPosition() const
    // Error: type "signed char*" can not automatically bind
    // void SoundSource::Mix(int* dest, unsigned samples, int mixRate, bool stereo, bool interpolation)
    // Error: type "int*" can not automatically bind
    // void SoundSource::SetPlayPosition(signed char* pos)
    // Error: type "signed char*" can not automatically bind

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // float SoundSource::GetAttenuation() const
    engine->RegisterObjectMethod(className, "float GetAttenuation() const", AS_METHODPR(T, GetAttenuation, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_attenuation() const", AS_METHODPR(T, GetAttenuation, () const, float), AS_CALL_THISCALL);

    // AutoRemoveMode SoundSource::GetAutoRemoveMode() const
    engine->RegisterObjectMethod(className, "AutoRemoveMode GetAutoRemoveMode() const", AS_METHODPR(T, GetAutoRemoveMode, () const, AutoRemoveMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AutoRemoveMode get_autoRemoveMode() const", AS_METHODPR(T, GetAutoRemoveMode, () const, AutoRemoveMode), AS_CALL_THISCALL);

    // float SoundSource::GetFrequency() const
    engine->RegisterObjectMethod(className, "float GetFrequency() const", AS_METHODPR(T, GetFrequency, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequency() const", AS_METHODPR(T, GetFrequency, () const, float), AS_CALL_THISCALL);

    // float SoundSource::GetGain() const
    engine->RegisterObjectMethod(className, "float GetGain() const", AS_METHODPR(T, GetGain, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_gain() const", AS_METHODPR(T, GetGain, () const, float), AS_CALL_THISCALL);

    // float SoundSource::GetPanning() const
    engine->RegisterObjectMethod(className, "float GetPanning() const", AS_METHODPR(T, GetPanning, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_panning() const", AS_METHODPR(T, GetPanning, () const, float), AS_CALL_THISCALL);

    // int SoundSource::GetPositionAttr() const
    engine->RegisterObjectMethod(className, "int GetPositionAttr() const", AS_METHODPR(T, GetPositionAttr, () const, int), AS_CALL_THISCALL);

    // Sound* SoundSource::GetSound() const
    engine->RegisterObjectMethod(className, "Sound@+ GetSound() const", AS_METHODPR(T, GetSound, () const, Sound*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Sound@+ get_sound() const", AS_METHODPR(T, GetSound, () const, Sound*), AS_CALL_THISCALL);

    // ResourceRef SoundSource::GetSoundAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetSoundAttr() const", AS_METHODPR(T, GetSoundAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // String SoundSource::GetSoundType() const
    engine->RegisterObjectMethod(className, "String GetSoundType() const", AS_METHODPR(T, GetSoundType, () const, String), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "String get_soundType() const", AS_METHODPR(T, GetSoundType, () const, String), AS_CALL_THISCALL);

    // float SoundSource::GetTimePosition() const
    engine->RegisterObjectMethod(className, "float GetTimePosition() const", AS_METHODPR(T, GetTimePosition, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_timePosition() const", AS_METHODPR(T, GetTimePosition, () const, float), AS_CALL_THISCALL);

    // bool SoundSource::IsPlaying() const
    engine->RegisterObjectMethod(className, "bool IsPlaying() const", AS_METHODPR(T, IsPlaying, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_playing() const", AS_METHODPR(T, IsPlaying, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void SoundSource::Play(Sound* sound)
    engine->RegisterObjectMethod(className, "void Play(Sound@+)", AS_METHODPR(T, Play, (Sound*), void), AS_CALL_THISCALL);

    // void SoundSource::Play(Sound* sound, float frequency)
    engine->RegisterObjectMethod(className, "void Play(Sound@+, float)", AS_METHODPR(T, Play, (Sound*, float), void), AS_CALL_THISCALL);

    // void SoundSource::Play(Sound* sound, float frequency, float gain)
    engine->RegisterObjectMethod(className, "void Play(Sound@+, float, float)", AS_METHODPR(T, Play, (Sound*, float, float), void), AS_CALL_THISCALL);

    // void SoundSource::Play(Sound* sound, float frequency, float gain, float panning)
    engine->RegisterObjectMethod(className, "void Play(Sound@+, float, float, float)", AS_METHODPR(T, Play, (Sound*, float, float, float), void), AS_CALL_THISCALL);

    // void SoundSource::Play(SoundStream* stream)
    engine->RegisterObjectMethod(className, "void Play(SoundStream@+)", AS_METHODPR(T, Play, (SoundStream*), void), AS_CALL_THISCALL);

    // void SoundSource::Seek(float seekTime)
    engine->RegisterObjectMethod(className, "void Seek(float)", AS_METHODPR(T, Seek, (float), void), AS_CALL_THISCALL);

    // void SoundSource::SetAttenuation(float attenuation)
    engine->RegisterObjectMethod(className, "void SetAttenuation(float)", AS_METHODPR(T, SetAttenuation, (float), void), AS_CALL_THISCALL);

    // void SoundSource::SetAutoRemoveMode(AutoRemoveMode mode)
    engine->RegisterObjectMethod(className, "void SetAutoRemoveMode(AutoRemoveMode)", AS_METHODPR(T, SetAutoRemoveMode, (AutoRemoveMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoRemoveMode(AutoRemoveMode)", AS_METHODPR(T, SetAutoRemoveMode, (AutoRemoveMode), void), AS_CALL_THISCALL);

    // void SoundSource::SetFrequency(float frequency)
    engine->RegisterObjectMethod(className, "void SetFrequency(float)", AS_METHODPR(T, SetFrequency, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_frequency(float)", AS_METHODPR(T, SetFrequency, (float), void), AS_CALL_THISCALL);

    // void SoundSource::SetGain(float gain)
    engine->RegisterObjectMethod(className, "void SetGain(float)", AS_METHODPR(T, SetGain, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_gain(float)", AS_METHODPR(T, SetGain, (float), void), AS_CALL_THISCALL);

    // void SoundSource::SetPanning(float panning)
    engine->RegisterObjectMethod(className, "void SetPanning(float)", AS_METHODPR(T, SetPanning, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_panning(float)", AS_METHODPR(T, SetPanning, (float), void), AS_CALL_THISCALL);

    // void SoundSource::SetPlayingAttr(bool value)
    engine->RegisterObjectMethod(className, "void SetPlayingAttr(bool)", AS_METHODPR(T, SetPlayingAttr, (bool), void), AS_CALL_THISCALL);

    // void SoundSource::SetPositionAttr(int value)
    engine->RegisterObjectMethod(className, "void SetPositionAttr(int)", AS_METHODPR(T, SetPositionAttr, (int), void), AS_CALL_THISCALL);

    // void SoundSource::SetSoundAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetSoundAttr(const ResourceRef&in)", AS_METHODPR(T, SetSoundAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void SoundSource::SetSoundType(const String& type)
    engine->RegisterObjectMethod(className, "void SetSoundType(const String&in)", AS_METHODPR(T, SetSoundType, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_soundType(const String&in)", AS_METHODPR(T, SetSoundType, (const String&), void), AS_CALL_THISCALL);

    // void SoundSource::Stop()
    engine->RegisterObjectMethod(className, "void Stop()", AS_METHODPR(T, Stop, (), void), AS_CALL_THISCALL);

    // virtual void SoundSource::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    // void SoundSource::UpdateMasterGain()
    engine->RegisterObjectMethod(className, "void UpdateMasterGain()", AS_METHODPR(T, UpdateMasterGain, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SoundSource
        REGISTER_MEMBERS_MANUAL_PART_SoundSource();
    #endif
}

// class SplinePath | File: ../Scene/SplinePath.h
template <class T> void RegisterMembers_SplinePath(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // const VariantVector& SplinePath::GetControlPointIdsAttr() const
    // Error: type "const VariantVector&" can not automatically bind
    // void SplinePath::SetControlPointIdsAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // void SplinePath::AddControlPoint(Node* point, unsigned index = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void AddControlPoint(Node@+, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, AddControlPoint, (Node*, unsigned), void), AS_CALL_THISCALL);

    // void SplinePath::ClearControlPoints()
    engine->RegisterObjectMethod(className, "void ClearControlPoints()", AS_METHODPR(T, ClearControlPoints, (), void), AS_CALL_THISCALL);

    // void SplinePath::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // unsigned SplinePath::GetControlledIdAttr() const
    engine->RegisterObjectMethod(className, "uint GetControlledIdAttr() const", AS_METHODPR(T, GetControlledIdAttr, () const, unsigned), AS_CALL_THISCALL);

    // Node* SplinePath::GetControlledNode() const
    engine->RegisterObjectMethod(className, "Node@+ GetControlledNode() const", AS_METHODPR(T, GetControlledNode, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_controlledNode() const", AS_METHODPR(T, GetControlledNode, () const, Node*), AS_CALL_THISCALL);

    // InterpolationMode SplinePath::GetInterpolationMode() const
    engine->RegisterObjectMethod(className, "InterpolationMode GetInterpolationMode() const", AS_METHODPR(T, GetInterpolationMode, () const, InterpolationMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "InterpolationMode get_interpolationMode() const", AS_METHODPR(T, GetInterpolationMode, () const, InterpolationMode), AS_CALL_THISCALL);

    // float SplinePath::GetLength() const
    engine->RegisterObjectMethod(className, "float GetLength() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);

    // Vector3 SplinePath::GetPoint(float factor) const
    engine->RegisterObjectMethod(className, "Vector3 GetPoint(float) const", AS_METHODPR(T, GetPoint, (float) const, Vector3), AS_CALL_THISCALL);

    // Vector3 SplinePath::GetPosition() const
    engine->RegisterObjectMethod(className, "Vector3 GetPosition() const", AS_METHODPR(T, GetPosition, () const, Vector3), AS_CALL_THISCALL);

    // float SplinePath::GetSpeed() const
    engine->RegisterObjectMethod(className, "float GetSpeed() const", AS_METHODPR(T, GetSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_speed() const", AS_METHODPR(T, GetSpeed, () const, float), AS_CALL_THISCALL);

    // bool SplinePath::IsFinished() const
    engine->RegisterObjectMethod(className, "bool IsFinished() const", AS_METHODPR(T, IsFinished, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_isFinished() const", AS_METHODPR(T, IsFinished, () const, bool), AS_CALL_THISCALL);

    // void SplinePath::Move(float timeStep)
    engine->RegisterObjectMethod(className, "void Move(float)", AS_METHODPR(T, Move, (float), void), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void SplinePath::RemoveControlPoint(Node* point)
    engine->RegisterObjectMethod(className, "void RemoveControlPoint(Node@+)", AS_METHODPR(T, RemoveControlPoint, (Node*), void), AS_CALL_THISCALL);

    // void SplinePath::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void SplinePath::SetControlledIdAttr(unsigned value)
    engine->RegisterObjectMethod(className, "void SetControlledIdAttr(uint)", AS_METHODPR(T, SetControlledIdAttr, (unsigned), void), AS_CALL_THISCALL);

    // void SplinePath::SetControlledNode(Node* controlled)
    engine->RegisterObjectMethod(className, "void SetControlledNode(Node@+)", AS_METHODPR(T, SetControlledNode, (Node*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_controlledNode(Node@+)", AS_METHODPR(T, SetControlledNode, (Node*), void), AS_CALL_THISCALL);

    // void SplinePath::SetInterpolationMode(InterpolationMode interpolationMode)
    engine->RegisterObjectMethod(className, "void SetInterpolationMode(InterpolationMode)", AS_METHODPR(T, SetInterpolationMode, (InterpolationMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_interpolationMode(InterpolationMode)", AS_METHODPR(T, SetInterpolationMode, (InterpolationMode), void), AS_CALL_THISCALL);

    // void SplinePath::SetPosition(float factor)
    engine->RegisterObjectMethod(className, "void SetPosition(float)", AS_METHODPR(T, SetPosition, (float), void), AS_CALL_THISCALL);

    // void SplinePath::SetSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetSpeed(float)", AS_METHODPR(T, SetSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_speed(float)", AS_METHODPR(T, SetSpeed, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SplinePath
        REGISTER_MEMBERS_MANUAL_PART_SplinePath();
    #endif
}

// class Sprite | File: ../UI/Sprite.h
template <class T> void RegisterMembers_Sprite(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_UIElement<T>(engine, className);

    // BlendMode Sprite::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BlendMode get_blendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // const IntVector2& Sprite::GetHotSpot() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetHotSpot() const", AS_METHODPR(T, GetHotSpot, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_hotSpot() const", AS_METHODPR(T, GetHotSpot, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntRect& Sprite::GetImageRect() const
    engine->RegisterObjectMethod(className, "const IntRect& GetImageRect() const", AS_METHODPR(T, GetImageRect, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_imageRect() const", AS_METHODPR(T, GetImageRect, () const, const IntRect&), AS_CALL_THISCALL);

    // const Vector2& Sprite::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_position() const", AS_METHODPR(T, GetPosition, () const, const Vector2&), AS_CALL_THISCALL);

    // float Sprite::GetRotation() const
    engine->RegisterObjectMethod(className, "float GetRotation() const", AS_METHODPR(T, GetRotation, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rotation() const", AS_METHODPR(T, GetRotation, () const, float), AS_CALL_THISCALL);

    // const Vector2& Sprite::GetScale() const
    engine->RegisterObjectMethod(className, "const Vector2& GetScale() const", AS_METHODPR(T, GetScale, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_scale() const", AS_METHODPR(T, GetScale, () const, const Vector2&), AS_CALL_THISCALL);

    // Texture* Sprite::GetTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetTexture() const", AS_METHODPR(T, GetTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_texture() const", AS_METHODPR(T, GetTexture, () const, Texture*), AS_CALL_THISCALL);

    // ResourceRef Sprite::GetTextureAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetTextureAttr() const", AS_METHODPR(T, GetTextureAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // const Matrix3x4& Sprite::GetTransform() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetTransform() const", AS_METHODPR(T, GetTransform, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // bool UIElement::IsSelected() const
    engine->RegisterObjectMethod(className, "bool IsSelected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_selected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);

    // void Sprite::SetBlendMode(BlendMode mode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);

    // void Sprite::SetFullImageRect()
    engine->RegisterObjectMethod(className, "void SetFullImageRect()", AS_METHODPR(T, SetFullImageRect, (), void), AS_CALL_THISCALL);

    // void Sprite::SetHotSpot(const IntVector2& hotSpot)
    engine->RegisterObjectMethod(className, "void SetHotSpot(const IntVector2&in)", AS_METHODPR(T, SetHotSpot, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hotSpot(const IntVector2&in)", AS_METHODPR(T, SetHotSpot, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Sprite::SetHotSpot(int x, int y)
    engine->RegisterObjectMethod(className, "void SetHotSpot(int, int)", AS_METHODPR(T, SetHotSpot, (int, int), void), AS_CALL_THISCALL);

    // void Sprite::SetImageRect(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetImageRect(const IntRect&in)", AS_METHODPR(T, SetImageRect, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_imageRect(const IntRect&in)", AS_METHODPR(T, SetImageRect, (const IntRect&), void), AS_CALL_THISCALL);

    // void Sprite::SetPosition(const Vector2& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const Vector2&in)", AS_METHODPR(T, SetPosition, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector2&in)", AS_METHODPR(T, SetPosition, (const Vector2&), void), AS_CALL_THISCALL);

    // void Sprite::SetPosition(float x, float y)
    engine->RegisterObjectMethod(className, "void SetPosition(float, float)", AS_METHODPR(T, SetPosition, (float, float), void), AS_CALL_THISCALL);

    // void Sprite::SetRotation(float angle)
    engine->RegisterObjectMethod(className, "void SetRotation(float)", AS_METHODPR(T, SetRotation, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(float)", AS_METHODPR(T, SetRotation, (float), void), AS_CALL_THISCALL);

    // void Sprite::SetScale(const Vector2& scale)
    engine->RegisterObjectMethod(className, "void SetScale(const Vector2&in)", AS_METHODPR(T, SetScale, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scale(const Vector2&in)", AS_METHODPR(T, SetScale, (const Vector2&), void), AS_CALL_THISCALL);

    // void Sprite::SetScale(float x, float y)
    engine->RegisterObjectMethod(className, "void SetScale(float, float)", AS_METHODPR(T, SetScale, (float, float), void), AS_CALL_THISCALL);

    // void Sprite::SetScale(float scale)
    engine->RegisterObjectMethod(className, "void SetScale(float)", AS_METHODPR(T, SetScale, (float), void), AS_CALL_THISCALL);

    // void Sprite::SetTexture(Texture* texture)
    engine->RegisterObjectMethod(className, "void SetTexture(Texture@+)", AS_METHODPR(T, SetTexture, (Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_texture(Texture@+)", AS_METHODPR(T, SetTexture, (Texture*), void), AS_CALL_THISCALL);

    // void Sprite::SetTextureAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetTextureAttr(const ResourceRef&in)", AS_METHODPR(T, SetTextureAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Sprite
        REGISTER_MEMBERS_MANUAL_PART_Sprite();
    #endif
}

// class Terrain | File: ../Graphics/Terrain.h
template <class T> void RegisterMembers_Terrain(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // SharedArrayPtr<float> Terrain::GetHeightData() const
    // Error: type "SharedArrayPtr<float>" can not automatically bind

    // void Terrain::ApplyHeightMap()
    engine->RegisterObjectMethod(className, "void ApplyHeightMap()", AS_METHODPR(T, ApplyHeightMap, (), void), AS_CALL_THISCALL);

    // void Terrain::CreatePatchGeometry(TerrainPatch* patch)
    engine->RegisterObjectMethod(className, "void CreatePatchGeometry(TerrainPatch@+)", AS_METHODPR(T, CreatePatchGeometry, (TerrainPatch*), void), AS_CALL_THISCALL);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // bool Terrain::GetCastShadows() const
    engine->RegisterObjectMethod(className, "bool GetCastShadows() const", AS_METHODPR(T, GetCastShadows, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_castShadows() const", AS_METHODPR(T, GetCastShadows, () const, bool), AS_CALL_THISCALL);

    // float Terrain::GetDrawDistance() const
    engine->RegisterObjectMethod(className, "float GetDrawDistance() const", AS_METHODPR(T, GetDrawDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_drawDistance() const", AS_METHODPR(T, GetDrawDistance, () const, float), AS_CALL_THISCALL);

    // Terrain* Terrain::GetEastNeighbor() const
    engine->RegisterObjectMethod(className, "Terrain@+ GetEastNeighbor() const", AS_METHODPR(T, GetEastNeighbor, () const, Terrain*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Terrain@+ get_eastNeighbor() const", AS_METHODPR(T, GetEastNeighbor, () const, Terrain*), AS_CALL_THISCALL);

    // float Terrain::GetHeight(const Vector3& worldPosition) const
    engine->RegisterObjectMethod(className, "float GetHeight(const Vector3&in) const", AS_METHODPR(T, GetHeight, (const Vector3&) const, float), AS_CALL_THISCALL);

    // Image* Terrain::GetHeightMap() const
    engine->RegisterObjectMethod(className, "Image@+ GetHeightMap() const", AS_METHODPR(T, GetHeightMap, () const, Image*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Image@+ get_heightMap() const", AS_METHODPR(T, GetHeightMap, () const, Image*), AS_CALL_THISCALL);

    // ResourceRef Terrain::GetHeightMapAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetHeightMapAttr() const", AS_METHODPR(T, GetHeightMapAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // unsigned Terrain::GetLightMask() const
    engine->RegisterObjectMethod(className, "uint GetLightMask() const", AS_METHODPR(T, GetLightMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_lightMask() const", AS_METHODPR(T, GetLightMask, () const, unsigned), AS_CALL_THISCALL);

    // float Terrain::GetLodBias() const
    engine->RegisterObjectMethod(className, "float GetLodBias() const", AS_METHODPR(T, GetLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lodBias() const", AS_METHODPR(T, GetLodBias, () const, float), AS_CALL_THISCALL);

    // Material* Terrain::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef Terrain::GetMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetMaterialAttr() const", AS_METHODPR(T, GetMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // unsigned Terrain::GetMaxLights() const
    engine->RegisterObjectMethod(className, "uint GetMaxLights() const", AS_METHODPR(T, GetMaxLights, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxLights() const", AS_METHODPR(T, GetMaxLights, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Terrain::GetMaxLodLevels() const
    engine->RegisterObjectMethod(className, "uint GetMaxLodLevels() const", AS_METHODPR(T, GetMaxLodLevels, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxLodLevels() const", AS_METHODPR(T, GetMaxLodLevels, () const, unsigned), AS_CALL_THISCALL);

    // TerrainPatch* Terrain::GetNeighborPatch(int x, int z) const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetNeighborPatch(int, int) const", AS_METHODPR(T, GetNeighborPatch, (int, int) const, TerrainPatch*), AS_CALL_THISCALL);

    // Vector3 Terrain::GetNormal(const Vector3& worldPosition) const
    engine->RegisterObjectMethod(className, "Vector3 GetNormal(const Vector3&in) const", AS_METHODPR(T, GetNormal, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // Terrain* Terrain::GetNorthNeighbor() const
    engine->RegisterObjectMethod(className, "Terrain@+ GetNorthNeighbor() const", AS_METHODPR(T, GetNorthNeighbor, () const, Terrain*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Terrain@+ get_northNeighbor() const", AS_METHODPR(T, GetNorthNeighbor, () const, Terrain*), AS_CALL_THISCALL);

    // const IntVector2& Terrain::GetNumPatches() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetNumPatches() const", AS_METHODPR(T, GetNumPatches, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_numPatches() const", AS_METHODPR(T, GetNumPatches, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector2& Terrain::GetNumVertices() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetNumVertices() const", AS_METHODPR(T, GetNumVertices, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_numVertices() const", AS_METHODPR(T, GetNumVertices, () const, const IntVector2&), AS_CALL_THISCALL);

    // unsigned Terrain::GetOcclusionLodLevel() const
    engine->RegisterObjectMethod(className, "uint GetOcclusionLodLevel() const", AS_METHODPR(T, GetOcclusionLodLevel, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_occlusionLodLevel() const", AS_METHODPR(T, GetOcclusionLodLevel, () const, unsigned), AS_CALL_THISCALL);

    // TerrainPatch* Terrain::GetPatch(unsigned index) const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetPatch(uint) const", AS_METHODPR(T, GetPatch, (unsigned) const, TerrainPatch*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TerrainPatch@+ get_patches(uint) const", AS_METHODPR(T, GetPatch, (unsigned) const, TerrainPatch*), AS_CALL_THISCALL);

    // TerrainPatch* Terrain::GetPatch(int x, int z) const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetPatch(int, int) const", AS_METHODPR(T, GetPatch, (int, int) const, TerrainPatch*), AS_CALL_THISCALL);

    // int Terrain::GetPatchSize() const
    engine->RegisterObjectMethod(className, "int GetPatchSize() const", AS_METHODPR(T, GetPatchSize, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_patchSize() const", AS_METHODPR(T, GetPatchSize, () const, int), AS_CALL_THISCALL);

    // float Terrain::GetShadowDistance() const
    engine->RegisterObjectMethod(className, "float GetShadowDistance() const", AS_METHODPR(T, GetShadowDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowDistance() const", AS_METHODPR(T, GetShadowDistance, () const, float), AS_CALL_THISCALL);

    // unsigned Terrain::GetShadowMask() const
    engine->RegisterObjectMethod(className, "uint GetShadowMask() const", AS_METHODPR(T, GetShadowMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_shadowMask() const", AS_METHODPR(T, GetShadowMask, () const, unsigned), AS_CALL_THISCALL);

    // bool Terrain::GetSmoothing() const
    engine->RegisterObjectMethod(className, "bool GetSmoothing() const", AS_METHODPR(T, GetSmoothing, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_smoothing() const", AS_METHODPR(T, GetSmoothing, () const, bool), AS_CALL_THISCALL);

    // Terrain* Terrain::GetSouthNeighbor() const
    engine->RegisterObjectMethod(className, "Terrain@+ GetSouthNeighbor() const", AS_METHODPR(T, GetSouthNeighbor, () const, Terrain*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Terrain@+ get_southNeighbor() const", AS_METHODPR(T, GetSouthNeighbor, () const, Terrain*), AS_CALL_THISCALL);

    // const Vector3& Terrain::GetSpacing() const
    engine->RegisterObjectMethod(className, "const Vector3& GetSpacing() const", AS_METHODPR(T, GetSpacing, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_spacing() const", AS_METHODPR(T, GetSpacing, () const, const Vector3&), AS_CALL_THISCALL);

    // unsigned Terrain::GetViewMask() const
    engine->RegisterObjectMethod(className, "uint GetViewMask() const", AS_METHODPR(T, GetViewMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_viewMask() const", AS_METHODPR(T, GetViewMask, () const, unsigned), AS_CALL_THISCALL);

    // Terrain* Terrain::GetWestNeighbor() const
    engine->RegisterObjectMethod(className, "Terrain@+ GetWestNeighbor() const", AS_METHODPR(T, GetWestNeighbor, () const, Terrain*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Terrain@+ get_westNeighbor() const", AS_METHODPR(T, GetWestNeighbor, () const, Terrain*), AS_CALL_THISCALL);

    // unsigned Terrain::GetZoneMask() const
    engine->RegisterObjectMethod(className, "uint GetZoneMask() const", AS_METHODPR(T, GetZoneMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_zoneMask() const", AS_METHODPR(T, GetZoneMask, () const, unsigned), AS_CALL_THISCALL);

    // Vector3 Terrain::HeightMapToWorld(const IntVector2& pixelPosition) const
    engine->RegisterObjectMethod(className, "Vector3 HeightMapToWorld(const IntVector2&in) const", AS_METHODPR(T, HeightMapToWorld, (const IntVector2&) const, Vector3), AS_CALL_THISCALL);

    // bool Terrain::IsOccludee() const
    engine->RegisterObjectMethod(className, "bool IsOccludee() const", AS_METHODPR(T, IsOccludee, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occludee() const", AS_METHODPR(T, IsOccludee, () const, bool), AS_CALL_THISCALL);

    // bool Terrain::IsOccluder() const
    engine->RegisterObjectMethod(className, "bool IsOccluder() const", AS_METHODPR(T, IsOccluder, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_occluder() const", AS_METHODPR(T, IsOccluder, () const, bool), AS_CALL_THISCALL);

    // bool Terrain::IsVisible() const
    engine->RegisterObjectMethod(className, "bool IsVisible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);

    // void Terrain::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Terrain::SetCastShadows(bool enable)
    engine->RegisterObjectMethod(className, "void SetCastShadows(bool)", AS_METHODPR(T, SetCastShadows, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_castShadows(bool)", AS_METHODPR(T, SetCastShadows, (bool), void), AS_CALL_THISCALL);

    // void Terrain::SetDrawDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetDrawDistance(float)", AS_METHODPR(T, SetDrawDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawDistance(float)", AS_METHODPR(T, SetDrawDistance, (float), void), AS_CALL_THISCALL);

    // void Terrain::SetEastNeighbor(Terrain* east)
    engine->RegisterObjectMethod(className, "void SetEastNeighbor(Terrain@+)", AS_METHODPR(T, SetEastNeighbor, (Terrain*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_eastNeighbor(Terrain@+)", AS_METHODPR(T, SetEastNeighbor, (Terrain*), void), AS_CALL_THISCALL);

    // bool Terrain::SetHeightMap(Image* image)
    engine->RegisterObjectMethod(className, "bool SetHeightMap(Image@+)", AS_METHODPR(T, SetHeightMap, (Image*), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_heightMap(Image@+)", AS_METHODPR(T, SetHeightMap, (Image*), bool), AS_CALL_THISCALL);

    // void Terrain::SetHeightMapAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetHeightMapAttr(const ResourceRef&in)", AS_METHODPR(T, SetHeightMapAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void Terrain::SetLightMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetLightMask(uint)", AS_METHODPR(T, SetLightMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lightMask(uint)", AS_METHODPR(T, SetLightMask, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetLodBias(float bias)
    engine->RegisterObjectMethod(className, "void SetLodBias(float)", AS_METHODPR(T, SetLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lodBias(float)", AS_METHODPR(T, SetLodBias, (float), void), AS_CALL_THISCALL);

    // void Terrain::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void Terrain::SetMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void Terrain::SetMaxLights(unsigned num)
    engine->RegisterObjectMethod(className, "void SetMaxLights(uint)", AS_METHODPR(T, SetMaxLights, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLights(uint)", AS_METHODPR(T, SetMaxLights, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetMaxLodLevels(unsigned levels)
    engine->RegisterObjectMethod(className, "void SetMaxLodLevels(uint)", AS_METHODPR(T, SetMaxLodLevels, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLodLevels(uint)", AS_METHODPR(T, SetMaxLodLevels, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetMaxLodLevelsAttr(unsigned value)
    engine->RegisterObjectMethod(className, "void SetMaxLodLevelsAttr(uint)", AS_METHODPR(T, SetMaxLodLevelsAttr, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetNeighbors(Terrain* north, Terrain* south, Terrain* west, Terrain* east)
    engine->RegisterObjectMethod(className, "void SetNeighbors(Terrain@+, Terrain@+, Terrain@+, Terrain@+)", AS_METHODPR(T, SetNeighbors, (Terrain*, Terrain*, Terrain*, Terrain*), void), AS_CALL_THISCALL);

    // void Terrain::SetNorthNeighbor(Terrain* north)
    engine->RegisterObjectMethod(className, "void SetNorthNeighbor(Terrain@+)", AS_METHODPR(T, SetNorthNeighbor, (Terrain*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_northNeighbor(Terrain@+)", AS_METHODPR(T, SetNorthNeighbor, (Terrain*), void), AS_CALL_THISCALL);

    // void Terrain::SetOccludee(bool enable)
    engine->RegisterObjectMethod(className, "void SetOccludee(bool)", AS_METHODPR(T, SetOccludee, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occludee(bool)", AS_METHODPR(T, SetOccludee, (bool), void), AS_CALL_THISCALL);

    // void Terrain::SetOccluder(bool enable)
    engine->RegisterObjectMethod(className, "void SetOccluder(bool)", AS_METHODPR(T, SetOccluder, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occluder(bool)", AS_METHODPR(T, SetOccluder, (bool), void), AS_CALL_THISCALL);

    // void Terrain::SetOcclusionLodLevel(unsigned level)
    engine->RegisterObjectMethod(className, "void SetOcclusionLodLevel(uint)", AS_METHODPR(T, SetOcclusionLodLevel, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occlusionLodLevel(uint)", AS_METHODPR(T, SetOcclusionLodLevel, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetOcclusionLodLevelAttr(unsigned value)
    engine->RegisterObjectMethod(className, "void SetOcclusionLodLevelAttr(uint)", AS_METHODPR(T, SetOcclusionLodLevelAttr, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetPatchSize(int size)
    engine->RegisterObjectMethod(className, "void SetPatchSize(int)", AS_METHODPR(T, SetPatchSize, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_patchSize(int)", AS_METHODPR(T, SetPatchSize, (int), void), AS_CALL_THISCALL);

    // void Terrain::SetPatchSizeAttr(int value)
    engine->RegisterObjectMethod(className, "void SetPatchSizeAttr(int)", AS_METHODPR(T, SetPatchSizeAttr, (int), void), AS_CALL_THISCALL);

    // void Terrain::SetShadowDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetShadowDistance(float)", AS_METHODPR(T, SetShadowDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowDistance(float)", AS_METHODPR(T, SetShadowDistance, (float), void), AS_CALL_THISCALL);

    // void Terrain::SetShadowMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetShadowMask(uint)", AS_METHODPR(T, SetShadowMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowMask(uint)", AS_METHODPR(T, SetShadowMask, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetSmoothing(bool enable)
    engine->RegisterObjectMethod(className, "void SetSmoothing(bool)", AS_METHODPR(T, SetSmoothing, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_smoothing(bool)", AS_METHODPR(T, SetSmoothing, (bool), void), AS_CALL_THISCALL);

    // void Terrain::SetSouthNeighbor(Terrain* south)
    engine->RegisterObjectMethod(className, "void SetSouthNeighbor(Terrain@+)", AS_METHODPR(T, SetSouthNeighbor, (Terrain*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_southNeighbor(Terrain@+)", AS_METHODPR(T, SetSouthNeighbor, (Terrain*), void), AS_CALL_THISCALL);

    // void Terrain::SetSpacing(const Vector3& spacing)
    engine->RegisterObjectMethod(className, "void SetSpacing(const Vector3&in)", AS_METHODPR(T, SetSpacing, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_spacing(const Vector3&in)", AS_METHODPR(T, SetSpacing, (const Vector3&), void), AS_CALL_THISCALL);

    // void Terrain::SetViewMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetViewMask(uint)", AS_METHODPR(T, SetViewMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_viewMask(uint)", AS_METHODPR(T, SetViewMask, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::SetWestNeighbor(Terrain* west)
    engine->RegisterObjectMethod(className, "void SetWestNeighbor(Terrain@+)", AS_METHODPR(T, SetWestNeighbor, (Terrain*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_westNeighbor(Terrain@+)", AS_METHODPR(T, SetWestNeighbor, (Terrain*), void), AS_CALL_THISCALL);

    // void Terrain::SetZoneMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetZoneMask(uint)", AS_METHODPR(T, SetZoneMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_zoneMask(uint)", AS_METHODPR(T, SetZoneMask, (unsigned), void), AS_CALL_THISCALL);

    // void Terrain::UpdatePatchLod(TerrainPatch* patch)
    engine->RegisterObjectMethod(className, "void UpdatePatchLod(TerrainPatch@+)", AS_METHODPR(T, UpdatePatchLod, (TerrainPatch*), void), AS_CALL_THISCALL);

    // IntVector2 Terrain::WorldToHeightMap(const Vector3& worldPosition) const
    engine->RegisterObjectMethod(className, "IntVector2 WorldToHeightMap(const Vector3&in) const", AS_METHODPR(T, WorldToHeightMap, (const Vector3&) const, IntVector2), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Terrain
        REGISTER_MEMBERS_MANUAL_PART_Terrain();
    #endif
}

// SharedPtr<Image> Texture2D::GetImage() const
template <class T> Image* Texture2D_SharedPtrlesImagegre_GetImage_void_template(T* _ptr)
{
    SharedPtr<Image> result = _ptr->GetImage();
    return result.Detach();
}

// class Texture2D | File: ../Graphics/Texture2D.h
template <class T> void RegisterMembers_Texture2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Texture<T>(engine, className);

    // bool Texture2D::GetData(unsigned level, void* dest) const
    // Error: type "void*" can not automatically bind
    // bool Texture2D::SetData(unsigned level, int x, int y, int width, int height, const void* data)
    // Error: type "const void*" can not automatically bind

    // bool Texture2D::GetImage(Image& image) const
    engine->RegisterObjectMethod(className, "bool GetImage(Image&) const", AS_METHODPR(T, GetImage, (Image&) const, bool), AS_CALL_THISCALL);

    // SharedPtr<Image> Texture2D::GetImage() const
    engine->RegisterObjectMethod(className, "Image@+ GetImage() const", AS_FUNCTION_OBJFIRST(Texture2D_SharedPtrlesImagegre_GetImage_void_template<Texture2D>), AS_CALL_CDECL_OBJFIRST);

    // RenderSurface* Texture2D::GetRenderSurface() const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetRenderSurface() const", AS_METHODPR(T, GetRenderSurface, () const, RenderSurface*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderSurface@+ get_renderSurface() const", AS_METHODPR(T, GetRenderSurface, () const, RenderSurface*), AS_CALL_THISCALL);

    // bool Texture2D::SetData(Image* image, bool useAlpha = false)
    engine->RegisterObjectMethod(className, "bool SetData(Image@+, bool = false)", AS_METHODPR(T, SetData, (Image*, bool), bool), AS_CALL_THISCALL);

    // bool Texture2D::SetSize(int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC, int multiSample = 1, bool autoResolve = true)
    engine->RegisterObjectMethod(className, "bool SetSize(int, int, uint, TextureUsage = TEXTURE_STATIC, int = 1, bool = true)", AS_METHODPR(T, SetSize, (int, int, unsigned, TextureUsage, int, bool), bool), AS_CALL_THISCALL);

    // static void Texture2D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Texture2D
        REGISTER_MEMBERS_MANUAL_PART_Texture2D();
    #endif
}

// class Texture2DArray | File: ../Graphics/Texture2DArray.h
template <class T> void RegisterMembers_Texture2DArray(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Texture<T>(engine, className);

    // bool Texture2DArray::GetData(unsigned layer, unsigned level, void* dest) const
    // Error: type "void*" can not automatically bind
    // bool Texture2DArray::SetData(unsigned layer, unsigned level, int x, int y, int width, int height, const void* data)
    // Error: type "const void*" can not automatically bind

    // unsigned Texture2DArray::GetLayers() const
    engine->RegisterObjectMethod(className, "uint GetLayers() const", AS_METHODPR(T, GetLayers, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_layers() const", AS_METHODPR(T, GetLayers, () const, unsigned), AS_CALL_THISCALL);

    // RenderSurface* Texture2DArray::GetRenderSurface() const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetRenderSurface() const", AS_METHODPR(T, GetRenderSurface, () const, RenderSurface*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderSurface@+ get_renderSurface() const", AS_METHODPR(T, GetRenderSurface, () const, RenderSurface*), AS_CALL_THISCALL);

    // bool Texture2DArray::SetData(unsigned layer, Deserializer& source)
    engine->RegisterObjectMethod(className, "bool SetData(uint, Deserializer&)", AS_METHODPR(T, SetData, (unsigned, Deserializer&), bool), AS_CALL_THISCALL);

    // bool Texture2DArray::SetData(unsigned layer, Image* image, bool useAlpha = false)
    engine->RegisterObjectMethod(className, "bool SetData(uint, Image@+, bool = false)", AS_METHODPR(T, SetData, (unsigned, Image*, bool), bool), AS_CALL_THISCALL);

    // void Texture2DArray::SetLayers(unsigned layers)
    engine->RegisterObjectMethod(className, "void SetLayers(uint)", AS_METHODPR(T, SetLayers, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layers(uint)", AS_METHODPR(T, SetLayers, (unsigned), void), AS_CALL_THISCALL);

    // bool Texture2DArray::SetSize(unsigned layers, int width, int height, unsigned format, TextureUsage usage = TEXTURE_STATIC)
    engine->RegisterObjectMethod(className, "bool SetSize(uint, int, int, uint, TextureUsage = TEXTURE_STATIC)", AS_METHODPR(T, SetSize, (unsigned, int, int, unsigned, TextureUsage), bool), AS_CALL_THISCALL);

    // static void Texture2DArray::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Texture2DArray
        REGISTER_MEMBERS_MANUAL_PART_Texture2DArray();
    #endif
}

// class Texture3D | File: ../Graphics/Texture3D.h
template <class T> void RegisterMembers_Texture3D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Texture<T>(engine, className);

    // bool Texture3D::GetData(unsigned level, void* dest) const
    // Error: type "void*" can not automatically bind
    // bool Texture3D::SetData(unsigned level, int x, int y, int z, int width, int height, int depth, const void* data)
    // Error: type "const void*" can not automatically bind

    // bool Texture3D::SetData(Image* image, bool useAlpha = false)
    engine->RegisterObjectMethod(className, "bool SetData(Image@+, bool = false)", AS_METHODPR(T, SetData, (Image*, bool), bool), AS_CALL_THISCALL);

    // bool Texture3D::SetSize(int width, int height, int depth, unsigned format, TextureUsage usage = TEXTURE_STATIC)
    engine->RegisterObjectMethod(className, "bool SetSize(int, int, int, uint, TextureUsage = TEXTURE_STATIC)", AS_METHODPR(T, SetSize, (int, int, int, unsigned, TextureUsage), bool), AS_CALL_THISCALL);

    // static void Texture3D::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Texture3D
        REGISTER_MEMBERS_MANUAL_PART_Texture3D();
    #endif
}

// SharedPtr<Image> TextureCube::GetImage(CubeMapFace face) const
template <class T> Image* TextureCube_SharedPtrlesImagegre_GetImage_CubeMapFace_template(T* _ptr, CubeMapFace face)
{
    SharedPtr<Image> result = _ptr->GetImage(face);
    return result.Detach();
}

// class TextureCube | File: ../Graphics/TextureCube.h
template <class T> void RegisterMembers_TextureCube(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Texture<T>(engine, className);

    // bool TextureCube::GetData(CubeMapFace face, unsigned level, void* dest) const
    // Error: type "void*" can not automatically bind
    // bool TextureCube::SetData(CubeMapFace face, unsigned level, int x, int y, int width, int height, const void* data)
    // Error: type "const void*" can not automatically bind

    // SharedPtr<Image> TextureCube::GetImage(CubeMapFace face) const
    engine->RegisterObjectMethod(className, "Image@+ GetImage(CubeMapFace) const", AS_FUNCTION_OBJFIRST(TextureCube_SharedPtrlesImagegre_GetImage_CubeMapFace_template<TextureCube>), AS_CALL_CDECL_OBJFIRST);

    // RenderSurface* TextureCube::GetRenderSurface(CubeMapFace face) const
    engine->RegisterObjectMethod(className, "RenderSurface@+ GetRenderSurface(CubeMapFace) const", AS_METHODPR(T, GetRenderSurface, (CubeMapFace) const, RenderSurface*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RenderSurface@+ get_renderSurfaces(CubeMapFace) const", AS_METHODPR(T, GetRenderSurface, (CubeMapFace) const, RenderSurface*), AS_CALL_THISCALL);

    // bool TextureCube::SetData(CubeMapFace face, Deserializer& source)
    engine->RegisterObjectMethod(className, "bool SetData(CubeMapFace, Deserializer&)", AS_METHODPR(T, SetData, (CubeMapFace, Deserializer&), bool), AS_CALL_THISCALL);

    // bool TextureCube::SetData(CubeMapFace face, Image* image, bool useAlpha = false)
    engine->RegisterObjectMethod(className, "bool SetData(CubeMapFace, Image@+, bool = false)", AS_METHODPR(T, SetData, (CubeMapFace, Image*, bool), bool), AS_CALL_THISCALL);

    // bool TextureCube::SetSize(int size, unsigned format, TextureUsage usage = TEXTURE_STATIC, int multiSample = 1)
    engine->RegisterObjectMethod(className, "bool SetSize(int, uint, TextureUsage = TEXTURE_STATIC, int = 1)", AS_METHODPR(T, SetSize, (int, unsigned, TextureUsage, int), bool), AS_CALL_THISCALL);

    // static void TextureCube::RegisterObject(Context* context)
    // Not registered because have @nobind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TextureCube
        REGISTER_MEMBERS_MANUAL_PART_TextureCube();
    #endif
}

// class ToolTip | File: ../UI/ToolTip.h
template <class T> void RegisterMembers_ToolTip(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_UIElement<T>(engine, className);

    // void ToolTip::AddAltTarget(UIElement* target)
    engine->RegisterObjectMethod(className, "void AddAltTarget(UIElement@+)", AS_METHODPR(T, AddAltTarget, (UIElement*), void), AS_CALL_THISCALL);

    // float ToolTip::GetDelay() const
    engine->RegisterObjectMethod(className, "float GetDelay() const", AS_METHODPR(T, GetDelay, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_delay() const", AS_METHODPR(T, GetDelay, () const, float), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetPosition() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_position() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);

    // bool UIElement::IsSelected() const
    engine->RegisterObjectMethod(className, "bool IsSelected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_selected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);

    // void ToolTip::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void ToolTip::SetDelay(float delay)
    engine->RegisterObjectMethod(className, "void SetDelay(float)", AS_METHODPR(T, SetDelay, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_delay(float)", AS_METHODPR(T, SetDelay, (float), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPosition(int, int)", AS_METHODPR(T, SetPosition, (int, int), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ToolTip
        REGISTER_MEMBERS_MANUAL_PART_ToolTip();
    #endif
}

// class UIComponent | File: ../UI/UIComponent.h
template <class T> void RegisterMembers_UIComponent(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // Material* UIComponent::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // UIElement* UIComponent::GetRoot() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetRoot() const", AS_METHODPR(T, GetRoot, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_root() const", AS_METHODPR(T, GetRoot, () const, UIElement*), AS_CALL_THISCALL);

    // Texture2D* UIComponent::GetTexture() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetTexture() const", AS_METHODPR(T, GetTexture, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_texture() const", AS_METHODPR(T, GetTexture, () const, Texture2D*), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void UIComponent::SetViewportIndex(unsigned index)
    engine->RegisterObjectMethod(className, "void SetViewportIndex(uint)", AS_METHODPR(T, SetViewportIndex, (unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_UIComponent
        REGISTER_MEMBERS_MANUAL_PART_UIComponent();
    #endif
}

// class UISelectable | File: ../UI/UISelectable.h
template <class T> void RegisterMembers_UISelectable(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_UIElement<T>(engine, className);

    // const Color& UISelectable::GetHoverColor() const
    engine->RegisterObjectMethod(className, "const Color& GetHoverColor() const", AS_METHODPR(T, GetHoverColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_hoverColor() const", AS_METHODPR(T, GetHoverColor, () const, const Color&), AS_CALL_THISCALL);

    // const IntVector2& UIElement::GetPosition() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_position() const", AS_METHODPR(T, GetPosition, () const, const IntVector2&), AS_CALL_THISCALL);

    // const Color& UISelectable::GetSelectionColor() const
    engine->RegisterObjectMethod(className, "const Color& GetSelectionColor() const", AS_METHODPR(T, GetSelectionColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_selectionColor() const", AS_METHODPR(T, GetSelectionColor, () const, const Color&), AS_CALL_THISCALL);

    // bool UIElement::IsSelected() const
    engine->RegisterObjectMethod(className, "bool IsSelected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_selected() const", AS_METHODPR(T, IsSelected, () const, bool), AS_CALL_THISCALL);

    // void UISelectable::SetHoverColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetHoverColor(const Color&in)", AS_METHODPR(T, SetHoverColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hoverColor(const Color&in)", AS_METHODPR(T, SetHoverColor, (const Color&), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(const IntVector2& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const IntVector2&in)", AS_METHODPR(T, SetPosition, (const IntVector2&), void), AS_CALL_THISCALL);

    // void UIElement::SetPosition(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPosition(int, int)", AS_METHODPR(T, SetPosition, (int, int), void), AS_CALL_THISCALL);

    // void UISelectable::SetSelectionColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetSelectionColor(const Color&in)", AS_METHODPR(T, SetSelectionColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_selectionColor(const Color&in)", AS_METHODPR(T, SetSelectionColor, (const Color&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_UISelectable
        REGISTER_MEMBERS_MANUAL_PART_UISelectable();
    #endif
}

// const Vector<String>& UnknownComponent::GetXMLAttributes() const
template <class T> CScriptArray* UnknownComponent_constspVectorlesStringgreamp_GetXMLAttributes_void_template(T* _ptr)
{
    const Vector<String>& result = _ptr->GetXMLAttributes();
    return VectorToArray<String>(result, "Array<String>");
}

// class UnknownComponent | File: ../Scene/UnknownComponent.h
template <class T> void RegisterMembers_UnknownComponent(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // const PODVector<unsigned char>& UnknownComponent::GetBinaryAttributes() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // bool UnknownComponent::GetUseXML() const
    engine->RegisterObjectMethod(className, "bool GetUseXML() const", AS_METHODPR(T, GetUseXML, () const, bool), AS_CALL_THISCALL);

    // const Vector<String>& UnknownComponent::GetXMLAttributes() const
    engine->RegisterObjectMethod(className, "Array<String>@ GetXMLAttributes() const", AS_FUNCTION_OBJFIRST(UnknownComponent_constspVectorlesStringgreamp_GetXMLAttributes_void_template<UnknownComponent>), AS_CALL_CDECL_OBJFIRST);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void UnknownComponent::SetType(StringHash typeHash)
    engine->RegisterObjectMethod(className, "void SetType(StringHash)", AS_METHODPR(T, SetType, (StringHash), void), AS_CALL_THISCALL);

    // void UnknownComponent::SetTypeName(const String& typeName)
    engine->RegisterObjectMethod(className, "void SetTypeName(const String&in)", AS_METHODPR(T, SetTypeName, (const String&), void), AS_CALL_THISCALL);

    // static Urho3D::StringHash UnknownComponent::GetTypeStatic()
    // Error: type "Urho3D::StringHash" can not automatically bind
    // static const Urho3D::String& UnknownComponent::GetTypeNameStatic()
    // Error: type "const Urho3D::String&" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_UnknownComponent
        REGISTER_MEMBERS_MANUAL_PART_UnknownComponent();
    #endif
}

#ifdef URHO3D_IK

// class IKConstraint | File: ../IK/IKConstraint.h
template <class T> void RegisterMembers_IKConstraint(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // const Vector2& IKConstraint::GetLengthConstraints() const
    engine->RegisterObjectMethod(className, "const Vector2& GetLengthConstraints() const", AS_METHODPR(T, GetLengthConstraints, () const, const Vector2&), AS_CALL_THISCALL);

    // float IKConstraint::GetStiffness() const
    engine->RegisterObjectMethod(className, "float GetStiffness() const", AS_METHODPR(T, GetStiffness, () const, float), AS_CALL_THISCALL);

    // float IKConstraint::GetStretchiness() const
    engine->RegisterObjectMethod(className, "float GetStretchiness() const", AS_METHODPR(T, GetStretchiness, () const, float), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void IKConstraint::SetLengthConstraints(const Vector2& lengthConstraints)
    engine->RegisterObjectMethod(className, "void SetLengthConstraints(const Vector2&in)", AS_METHODPR(T, SetLengthConstraints, (const Vector2&), void), AS_CALL_THISCALL);

    // void IKConstraint::SetStiffness(float stiffness)
    engine->RegisterObjectMethod(className, "void SetStiffness(float)", AS_METHODPR(T, SetStiffness, (float), void), AS_CALL_THISCALL);

    // void IKConstraint::SetStretchiness(float stretchiness)
    engine->RegisterObjectMethod(className, "void SetStretchiness(float)", AS_METHODPR(T, SetStretchiness, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IKConstraint
        REGISTER_MEMBERS_MANUAL_PART_IKConstraint();
    #endif
}

// class IKEffector | File: ../IK/IKEffector.h
template <class T> void RegisterMembers_IKEffector(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // bool IKEffector::GetFeature(Feature feature) const
    // Not registered because have @nobind mark
    // void IKEffector::SetFeature(Feature feature, bool enable)
    // Not registered because have @nobind mark

    // void IKEffector::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // void IKEffector::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // unsigned IKEffector::GetChainLength() const
    engine->RegisterObjectMethod(className, "uint GetChainLength() const", AS_METHODPR(T, GetChainLength, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_chainLength() const", AS_METHODPR(T, GetChainLength, () const, unsigned), AS_CALL_THISCALL);

    // bool IKEffector::GetINHERIT_PARENT_ROTATION() const
    engine->RegisterObjectMethod(className, "bool GetINHERIT_PARENT_ROTATION() const", AS_METHODPR(T, GetINHERIT_PARENT_ROTATION, () const, bool), AS_CALL_THISCALL);

    // float IKEffector::GetRotationDecay() const
    engine->RegisterObjectMethod(className, "float GetRotationDecay() const", AS_METHODPR(T, GetRotationDecay, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rotationDecay() const", AS_METHODPR(T, GetRotationDecay, () const, float), AS_CALL_THISCALL);

    // float IKEffector::GetRotationWeight() const
    engine->RegisterObjectMethod(className, "float GetRotationWeight() const", AS_METHODPR(T, GetRotationWeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rotationWeight() const", AS_METHODPR(T, GetRotationWeight, () const, float), AS_CALL_THISCALL);

    // const String& IKEffector::GetTargetName() const
    engine->RegisterObjectMethod(className, "const String& GetTargetName() const", AS_METHODPR(T, GetTargetName, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_targetName() const", AS_METHODPR(T, GetTargetName, () const, const String&), AS_CALL_THISCALL);

    // Node* IKEffector::GetTargetNode() const
    engine->RegisterObjectMethod(className, "Node@+ GetTargetNode() const", AS_METHODPR(T, GetTargetNode, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_targetNode() const", AS_METHODPR(T, GetTargetNode, () const, Node*), AS_CALL_THISCALL);

    // const Vector3& IKEffector::GetTargetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetTargetPosition() const", AS_METHODPR(T, GetTargetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_targetPosition() const", AS_METHODPR(T, GetTargetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // const Quaternion& IKEffector::GetTargetRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetTargetRotation() const", AS_METHODPR(T, GetTargetRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_targetRotation() const", AS_METHODPR(T, GetTargetRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // Vector3 IKEffector::GetTargetRotationEuler() const
    engine->RegisterObjectMethod(className, "Vector3 GetTargetRotationEuler() const", AS_METHODPR(T, GetTargetRotationEuler, () const, Vector3), AS_CALL_THISCALL);

    // float IKEffector::GetWeight() const
    engine->RegisterObjectMethod(className, "float GetWeight() const", AS_METHODPR(T, GetWeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_weight() const", AS_METHODPR(T, GetWeight, () const, float), AS_CALL_THISCALL);

    // bool IKEffector::GetWEIGHT_NLERP() const
    engine->RegisterObjectMethod(className, "bool GetWEIGHT_NLERP() const", AS_METHODPR(T, GetWEIGHT_NLERP, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void IKEffector::SetChainLength(unsigned chainLength)
    engine->RegisterObjectMethod(className, "void SetChainLength(uint)", AS_METHODPR(T, SetChainLength, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_chainLength(uint)", AS_METHODPR(T, SetChainLength, (unsigned), void), AS_CALL_THISCALL);

    // void IKEffector::SetINHERIT_PARENT_ROTATION(bool enable)
    engine->RegisterObjectMethod(className, "void SetINHERIT_PARENT_ROTATION(bool)", AS_METHODPR(T, SetINHERIT_PARENT_ROTATION, (bool), void), AS_CALL_THISCALL);

    // void IKEffector::SetRotationDecay(float decay)
    engine->RegisterObjectMethod(className, "void SetRotationDecay(float)", AS_METHODPR(T, SetRotationDecay, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotationDecay(float)", AS_METHODPR(T, SetRotationDecay, (float), void), AS_CALL_THISCALL);

    // void IKEffector::SetRotationWeight(float weight)
    engine->RegisterObjectMethod(className, "void SetRotationWeight(float)", AS_METHODPR(T, SetRotationWeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotationWeight(float)", AS_METHODPR(T, SetRotationWeight, (float), void), AS_CALL_THISCALL);

    // void IKEffector::SetTargetName(const String& nodeName)
    engine->RegisterObjectMethod(className, "void SetTargetName(const String&in)", AS_METHODPR(T, SetTargetName, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetName(const String&in)", AS_METHODPR(T, SetTargetName, (const String&), void), AS_CALL_THISCALL);

    // void IKEffector::SetTargetNode(Node* targetNode)
    engine->RegisterObjectMethod(className, "void SetTargetNode(Node@+)", AS_METHODPR(T, SetTargetNode, (Node*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetNode(Node@+)", AS_METHODPR(T, SetTargetNode, (Node*), void), AS_CALL_THISCALL);

    // void IKEffector::SetTargetPosition(const Vector3& targetPosition)
    engine->RegisterObjectMethod(className, "void SetTargetPosition(const Vector3&in)", AS_METHODPR(T, SetTargetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetPosition(const Vector3&in)", AS_METHODPR(T, SetTargetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void IKEffector::SetTargetRotation(const Quaternion& targetRotation)
    engine->RegisterObjectMethod(className, "void SetTargetRotation(const Quaternion&in)", AS_METHODPR(T, SetTargetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetRotation(const Quaternion&in)", AS_METHODPR(T, SetTargetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void IKEffector::SetTargetRotationEuler(const Vector3& targetRotation)
    engine->RegisterObjectMethod(className, "void SetTargetRotationEuler(const Vector3&in)", AS_METHODPR(T, SetTargetRotationEuler, (const Vector3&), void), AS_CALL_THISCALL);

    // void IKEffector::SetWeight(float weight)
    engine->RegisterObjectMethod(className, "void SetWeight(float)", AS_METHODPR(T, SetWeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_weight(float)", AS_METHODPR(T, SetWeight, (float), void), AS_CALL_THISCALL);

    // void IKEffector::SetWEIGHT_NLERP(bool enable)
    engine->RegisterObjectMethod(className, "void SetWEIGHT_NLERP(bool)", AS_METHODPR(T, SetWEIGHT_NLERP, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IKEffector
        REGISTER_MEMBERS_MANUAL_PART_IKEffector();
    #endif
}

// class IKSolver | File: ../IK/IKSolver.h
template <class T> void RegisterMembers_IKSolver(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // Algorithm IKSolver::GetAlgorithm() const
    // Not registered because have @manualbind mark
    // bool IKSolver::GetFeature(Feature feature) const
    // Not registered because have @nobind mark
    // void IKSolver::SetAlgorithm(Algorithm algorithm)
    // Not registered because have @manualbind mark
    // void IKSolver::SetFeature(Feature feature, bool enable)
    // Not registered because have @nobind mark

    // void IKSolver::ApplyActivePoseToScene()
    engine->RegisterObjectMethod(className, "void ApplyActivePoseToScene()", AS_METHODPR(T, ApplyActivePoseToScene, (), void), AS_CALL_THISCALL);

    // void IKSolver::ApplyOriginalPoseToActivePose()
    engine->RegisterObjectMethod(className, "void ApplyOriginalPoseToActivePose()", AS_METHODPR(T, ApplyOriginalPoseToActivePose, (), void), AS_CALL_THISCALL);

    // void IKSolver::ApplyOriginalPoseToScene()
    engine->RegisterObjectMethod(className, "void ApplyOriginalPoseToScene()", AS_METHODPR(T, ApplyOriginalPoseToScene, (), void), AS_CALL_THISCALL);

    // void IKSolver::ApplySceneToActivePose()
    engine->RegisterObjectMethod(className, "void ApplySceneToActivePose()", AS_METHODPR(T, ApplySceneToActivePose, (), void), AS_CALL_THISCALL);

    // void IKSolver::ApplySceneToOriginalPose()
    engine->RegisterObjectMethod(className, "void ApplySceneToOriginalPose()", AS_METHODPR(T, ApplySceneToOriginalPose, (), void), AS_CALL_THISCALL);

    // void IKSolver::CalculateJointRotations()
    engine->RegisterObjectMethod(className, "void CalculateJointRotations()", AS_METHODPR(T, CalculateJointRotations, (), void), AS_CALL_THISCALL);

    // void IKSolver::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // bool IKSolver::GetAUTO_SOLVE() const
    engine->RegisterObjectMethod(className, "bool GetAUTO_SOLVE() const", AS_METHODPR(T, GetAUTO_SOLVE, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_AUTO_SOLVE() const", AS_METHODPR(T, GetAUTO_SOLVE, () const, bool), AS_CALL_THISCALL);

    // bool IKSolver::GetCONSTRAINTS() const
    engine->RegisterObjectMethod(className, "bool GetCONSTRAINTS() const", AS_METHODPR(T, GetCONSTRAINTS, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_CONSTRAINTS() const", AS_METHODPR(T, GetCONSTRAINTS, () const, bool), AS_CALL_THISCALL);

    // bool IKSolver::GetJOINT_ROTATIONS() const
    engine->RegisterObjectMethod(className, "bool GetJOINT_ROTATIONS() const", AS_METHODPR(T, GetJOINT_ROTATIONS, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_JOINT_ROTATIONS() const", AS_METHODPR(T, GetJOINT_ROTATIONS, () const, bool), AS_CALL_THISCALL);

    // unsigned IKSolver::GetMaximumIterations() const
    engine->RegisterObjectMethod(className, "uint GetMaximumIterations() const", AS_METHODPR(T, GetMaximumIterations, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maximumIterations() const", AS_METHODPR(T, GetMaximumIterations, () const, unsigned), AS_CALL_THISCALL);

    // bool IKSolver::GetTARGET_ROTATIONS() const
    engine->RegisterObjectMethod(className, "bool GetTARGET_ROTATIONS() const", AS_METHODPR(T, GetTARGET_ROTATIONS, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_TARGET_ROTATIONS() const", AS_METHODPR(T, GetTARGET_ROTATIONS, () const, bool), AS_CALL_THISCALL);

    // float IKSolver::GetTolerance() const
    engine->RegisterObjectMethod(className, "float GetTolerance() const", AS_METHODPR(T, GetTolerance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_tolerance() const", AS_METHODPR(T, GetTolerance, () const, float), AS_CALL_THISCALL);

    // bool IKSolver::GetUPDATE_ACTIVE_POSE() const
    engine->RegisterObjectMethod(className, "bool GetUPDATE_ACTIVE_POSE() const", AS_METHODPR(T, GetUPDATE_ACTIVE_POSE, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_UPDATE_ACTIVE_POSE() const", AS_METHODPR(T, GetUPDATE_ACTIVE_POSE, () const, bool), AS_CALL_THISCALL);

    // bool IKSolver::GetUPDATE_ORIGINAL_POSE() const
    engine->RegisterObjectMethod(className, "bool GetUPDATE_ORIGINAL_POSE() const", AS_METHODPR(T, GetUPDATE_ORIGINAL_POSE, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_UPDATE_ORIGINAL_POSE() const", AS_METHODPR(T, GetUPDATE_ORIGINAL_POSE, () const, bool), AS_CALL_THISCALL);

    // bool IKSolver::GetUSE_ORIGINAL_POSE() const
    engine->RegisterObjectMethod(className, "bool GetUSE_ORIGINAL_POSE() const", AS_METHODPR(T, GetUSE_ORIGINAL_POSE, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_USE_ORIGINAL_POSE() const", AS_METHODPR(T, GetUSE_ORIGINAL_POSE, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void IKSolver::RebuildChainTrees()
    engine->RegisterObjectMethod(className, "void RebuildChainTrees()", AS_METHODPR(T, RebuildChainTrees, (), void), AS_CALL_THISCALL);

    // void IKSolver::RecalculateSegmentLengths()
    engine->RegisterObjectMethod(className, "void RecalculateSegmentLengths()", AS_METHODPR(T, RecalculateSegmentLengths, (), void), AS_CALL_THISCALL);

    // void IKSolver::SetAUTO_SOLVE(bool enable)
    engine->RegisterObjectMethod(className, "void SetAUTO_SOLVE(bool)", AS_METHODPR(T, SetAUTO_SOLVE, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_AUTO_SOLVE(bool)", AS_METHODPR(T, SetAUTO_SOLVE, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::SetCONSTRAINTS(bool enable)
    engine->RegisterObjectMethod(className, "void SetCONSTRAINTS(bool)", AS_METHODPR(T, SetCONSTRAINTS, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_CONSTRAINTS(bool)", AS_METHODPR(T, SetCONSTRAINTS, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::SetJOINT_ROTATIONS(bool enable)
    engine->RegisterObjectMethod(className, "void SetJOINT_ROTATIONS(bool)", AS_METHODPR(T, SetJOINT_ROTATIONS, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_JOINT_ROTATIONS(bool)", AS_METHODPR(T, SetJOINT_ROTATIONS, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::SetMaximumIterations(unsigned iterations)
    engine->RegisterObjectMethod(className, "void SetMaximumIterations(uint)", AS_METHODPR(T, SetMaximumIterations, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maximumIterations(uint)", AS_METHODPR(T, SetMaximumIterations, (unsigned), void), AS_CALL_THISCALL);

    // void IKSolver::SetTARGET_ROTATIONS(bool enable)
    engine->RegisterObjectMethod(className, "void SetTARGET_ROTATIONS(bool)", AS_METHODPR(T, SetTARGET_ROTATIONS, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_TARGET_ROTATIONS(bool)", AS_METHODPR(T, SetTARGET_ROTATIONS, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::SetTolerance(float tolerance)
    engine->RegisterObjectMethod(className, "void SetTolerance(float)", AS_METHODPR(T, SetTolerance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_tolerance(float)", AS_METHODPR(T, SetTolerance, (float), void), AS_CALL_THISCALL);

    // void IKSolver::SetUPDATE_ACTIVE_POSE(bool enable)
    engine->RegisterObjectMethod(className, "void SetUPDATE_ACTIVE_POSE(bool)", AS_METHODPR(T, SetUPDATE_ACTIVE_POSE, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_UPDATE_ACTIVE_POSE(bool)", AS_METHODPR(T, SetUPDATE_ACTIVE_POSE, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::SetUPDATE_ORIGINAL_POSE(bool enable)
    engine->RegisterObjectMethod(className, "void SetUPDATE_ORIGINAL_POSE(bool)", AS_METHODPR(T, SetUPDATE_ORIGINAL_POSE, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_UPDATE_ORIGINAL_POSE(bool)", AS_METHODPR(T, SetUPDATE_ORIGINAL_POSE, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::SetUSE_ORIGINAL_POSE(bool enable)
    engine->RegisterObjectMethod(className, "void SetUSE_ORIGINAL_POSE(bool)", AS_METHODPR(T, SetUSE_ORIGINAL_POSE, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_USE_ORIGINAL_POSE(bool)", AS_METHODPR(T, SetUSE_ORIGINAL_POSE, (bool), void), AS_CALL_THISCALL);

    // void IKSolver::Solve()
    engine->RegisterObjectMethod(className, "void Solve()", AS_METHODPR(T, Solve, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_IKSolver
        REGISTER_MEMBERS_MANUAL_PART_IKSolver();
    #endif
}

#endif // def URHO3D_IK

#ifdef URHO3D_NAVIGATION

// class CrowdAgent | File: ../Navigation/CrowdAgent.h
template <class T> void RegisterMembers_CrowdAgent(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void CrowdAgent::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // void CrowdAgent::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // Vector3 CrowdAgent::GetActualVelocity() const
    engine->RegisterObjectMethod(className, "Vector3 GetActualVelocity() const", AS_METHODPR(T, GetActualVelocity, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_actualVelocity() const", AS_METHODPR(T, GetActualVelocity, () const, Vector3), AS_CALL_THISCALL);

    // int CrowdAgent::GetAgentCrowdId() const
    engine->RegisterObjectMethod(className, "int GetAgentCrowdId() const", AS_METHODPR(T, GetAgentCrowdId, () const, int), AS_CALL_THISCALL);

    // CrowdAgentState CrowdAgent::GetAgentState() const
    engine->RegisterObjectMethod(className, "CrowdAgentState GetAgentState() const", AS_METHODPR(T, GetAgentState, () const, CrowdAgentState), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CrowdAgentState get_agentState() const", AS_METHODPR(T, GetAgentState, () const, CrowdAgentState), AS_CALL_THISCALL);

    // Vector3 CrowdAgent::GetDesiredVelocity() const
    engine->RegisterObjectMethod(className, "Vector3 GetDesiredVelocity() const", AS_METHODPR(T, GetDesiredVelocity, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_desiredVelocity() const", AS_METHODPR(T, GetDesiredVelocity, () const, Vector3), AS_CALL_THISCALL);

    // float CrowdAgent::GetHeight() const
    engine->RegisterObjectMethod(className, "float GetHeight() const", AS_METHODPR(T, GetHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_height() const", AS_METHODPR(T, GetHeight, () const, float), AS_CALL_THISCALL);

    // float CrowdAgent::GetMaxAccel() const
    engine->RegisterObjectMethod(className, "float GetMaxAccel() const", AS_METHODPR(T, GetMaxAccel, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxAccel() const", AS_METHODPR(T, GetMaxAccel, () const, float), AS_CALL_THISCALL);

    // float CrowdAgent::GetMaxSpeed() const
    engine->RegisterObjectMethod(className, "float GetMaxSpeed() const", AS_METHODPR(T, GetMaxSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxSpeed() const", AS_METHODPR(T, GetMaxSpeed, () const, float), AS_CALL_THISCALL);

    // NavigationPushiness CrowdAgent::GetNavigationPushiness() const
    engine->RegisterObjectMethod(className, "NavigationPushiness GetNavigationPushiness() const", AS_METHODPR(T, GetNavigationPushiness, () const, NavigationPushiness), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "NavigationPushiness get_navigationPushiness() const", AS_METHODPR(T, GetNavigationPushiness, () const, NavigationPushiness), AS_CALL_THISCALL);

    // NavigationQuality CrowdAgent::GetNavigationQuality() const
    engine->RegisterObjectMethod(className, "NavigationQuality GetNavigationQuality() const", AS_METHODPR(T, GetNavigationQuality, () const, NavigationQuality), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "NavigationQuality get_navigationQuality() const", AS_METHODPR(T, GetNavigationQuality, () const, NavigationQuality), AS_CALL_THISCALL);

    // unsigned CrowdAgent::GetObstacleAvoidanceType() const
    engine->RegisterObjectMethod(className, "uint GetObstacleAvoidanceType() const", AS_METHODPR(T, GetObstacleAvoidanceType, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_obstacleAvoidanceType() const", AS_METHODPR(T, GetObstacleAvoidanceType, () const, unsigned), AS_CALL_THISCALL);

    // Vector3 CrowdAgent::GetPosition() const
    engine->RegisterObjectMethod(className, "Vector3 GetPosition() const", AS_METHODPR(T, GetPosition, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_position() const", AS_METHODPR(T, GetPosition, () const, Vector3), AS_CALL_THISCALL);

    // unsigned CrowdAgent::GetQueryFilterType() const
    engine->RegisterObjectMethod(className, "uint GetQueryFilterType() const", AS_METHODPR(T, GetQueryFilterType, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_queryFilterType() const", AS_METHODPR(T, GetQueryFilterType, () const, unsigned), AS_CALL_THISCALL);

    // float CrowdAgent::GetRadius() const
    engine->RegisterObjectMethod(className, "float GetRadius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_radius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);

    // CrowdAgentRequestedTarget CrowdAgent::GetRequestedTargetType() const
    engine->RegisterObjectMethod(className, "CrowdAgentRequestedTarget GetRequestedTargetType() const", AS_METHODPR(T, GetRequestedTargetType, () const, CrowdAgentRequestedTarget), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CrowdAgentRequestedTarget get_requestedTargetType() const", AS_METHODPR(T, GetRequestedTargetType, () const, CrowdAgentRequestedTarget), AS_CALL_THISCALL);

    // const Vector3& CrowdAgent::GetTargetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetTargetPosition() const", AS_METHODPR(T, GetTargetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_targetPosition() const", AS_METHODPR(T, GetTargetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // CrowdAgentTargetState CrowdAgent::GetTargetState() const
    engine->RegisterObjectMethod(className, "CrowdAgentTargetState GetTargetState() const", AS_METHODPR(T, GetTargetState, () const, CrowdAgentTargetState), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CrowdAgentTargetState get_targetState() const", AS_METHODPR(T, GetTargetState, () const, CrowdAgentTargetState), AS_CALL_THISCALL);

    // const Vector3& CrowdAgent::GetTargetVelocity() const
    engine->RegisterObjectMethod(className, "const Vector3& GetTargetVelocity() const", AS_METHODPR(T, GetTargetVelocity, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_targetVelocity() const", AS_METHODPR(T, GetTargetVelocity, () const, const Vector3&), AS_CALL_THISCALL);

    // bool CrowdAgent::GetUpdateNodePosition() const
    engine->RegisterObjectMethod(className, "bool GetUpdateNodePosition() const", AS_METHODPR(T, GetUpdateNodePosition, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateNodePosition() const", AS_METHODPR(T, GetUpdateNodePosition, () const, bool), AS_CALL_THISCALL);

    // bool CrowdAgent::HasArrived() const
    engine->RegisterObjectMethod(className, "bool HasArrived() const", AS_METHODPR(T, HasArrived, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_arrived() const", AS_METHODPR(T, HasArrived, () const, bool), AS_CALL_THISCALL);

    // bool CrowdAgent::HasRequestedTarget() const
    engine->RegisterObjectMethod(className, "bool HasRequestedTarget() const", AS_METHODPR(T, HasRequestedTarget, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_requestedTarget() const", AS_METHODPR(T, HasRequestedTarget, () const, bool), AS_CALL_THISCALL);

    // bool CrowdAgent::IsInCrowd() const
    engine->RegisterObjectMethod(className, "bool IsInCrowd() const", AS_METHODPR(T, IsInCrowd, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_inCrowd() const", AS_METHODPR(T, IsInCrowd, () const, bool), AS_CALL_THISCALL);

    // void CrowdAgent::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void CrowdAgent::ResetTarget()
    engine->RegisterObjectMethod(className, "void ResetTarget()", AS_METHODPR(T, ResetTarget, (), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetHeight(float height)
    engine->RegisterObjectMethod(className, "void SetHeight(float)", AS_METHODPR(T, SetHeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_height(float)", AS_METHODPR(T, SetHeight, (float), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetMaxAccel(float maxAccel)
    engine->RegisterObjectMethod(className, "void SetMaxAccel(float)", AS_METHODPR(T, SetMaxAccel, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxAccel(float)", AS_METHODPR(T, SetMaxAccel, (float), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetMaxSpeed(float maxSpeed)
    engine->RegisterObjectMethod(className, "void SetMaxSpeed(float)", AS_METHODPR(T, SetMaxSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxSpeed(float)", AS_METHODPR(T, SetMaxSpeed, (float), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetNavigationPushiness(NavigationPushiness val)
    engine->RegisterObjectMethod(className, "void SetNavigationPushiness(NavigationPushiness)", AS_METHODPR(T, SetNavigationPushiness, (NavigationPushiness), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_navigationPushiness(NavigationPushiness)", AS_METHODPR(T, SetNavigationPushiness, (NavigationPushiness), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetNavigationQuality(NavigationQuality val)
    engine->RegisterObjectMethod(className, "void SetNavigationQuality(NavigationQuality)", AS_METHODPR(T, SetNavigationQuality, (NavigationQuality), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_navigationQuality(NavigationQuality)", AS_METHODPR(T, SetNavigationQuality, (NavigationQuality), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetObstacleAvoidanceType(unsigned obstacleAvoidanceType)
    engine->RegisterObjectMethod(className, "void SetObstacleAvoidanceType(uint)", AS_METHODPR(T, SetObstacleAvoidanceType, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_obstacleAvoidanceType(uint)", AS_METHODPR(T, SetObstacleAvoidanceType, (unsigned), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetQueryFilterType(unsigned queryFilterType)
    engine->RegisterObjectMethod(className, "void SetQueryFilterType(uint)", AS_METHODPR(T, SetQueryFilterType, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_queryFilterType(uint)", AS_METHODPR(T, SetQueryFilterType, (unsigned), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetRadius(float radius)
    engine->RegisterObjectMethod(className, "void SetRadius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_radius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetTargetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetTargetPosition(const Vector3&in)", AS_METHODPR(T, SetTargetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetPosition(const Vector3&in)", AS_METHODPR(T, SetTargetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetTargetVelocity(const Vector3& velocity)
    engine->RegisterObjectMethod(className, "void SetTargetVelocity(const Vector3&in)", AS_METHODPR(T, SetTargetVelocity, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_targetVelocity(const Vector3&in)", AS_METHODPR(T, SetTargetVelocity, (const Vector3&), void), AS_CALL_THISCALL);

    // void CrowdAgent::SetUpdateNodePosition(bool unodepos)
    engine->RegisterObjectMethod(className, "void SetUpdateNodePosition(bool)", AS_METHODPR(T, SetUpdateNodePosition, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateNodePosition(bool)", AS_METHODPR(T, SetUpdateNodePosition, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CrowdAgent
        REGISTER_MEMBERS_MANUAL_PART_CrowdAgent();
    #endif
}

// PODVector<CrowdAgent*> CrowdManager::GetAgents(Node* node = nullptr, bool inCrowdFilter = true) const
template <class T> CScriptArray* CrowdManager_PODVectorlesCrowdAgentstargre_GetAgents_Nodestar_bool_template(T* _ptr, Node* node, bool inCrowdFilter)
{
    PODVector<CrowdAgent*> result = _ptr->GetAgents(node, inCrowdFilter);
    return VectorToHandleArray(result, "Array<CrowdAgent@>");
}

// class CrowdManager | File: ../Navigation/CrowdManager.h
template <class T> void RegisterMembers_CrowdManager(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // Vector3 CrowdManager::FindNearestPoint(const Vector3& point, int queryFilterType, dtPolyRef* nearestRef = nullptr)
    // Error: type "dtPolyRef*" can not automatically bind
    // void CrowdManager::FindPath(PODVector<Vector3>& dest, const Vector3& start, const Vector3& end, int queryFilterType)
    // Error: type "PODVector<Vector3>&" can not automatically bind
    // float CrowdManager::GetDistanceToWall(const Vector3& point, float radius, int queryFilterType, Vector3* hitPos = nullptr, Vector3* hitNormal = nullptr)
    // Error: type "Vector3*" can not automatically bind
    // VariantVector CrowdManager::GetObstacleAvoidanceTypesAttr() const
    // Error: type "VariantVector" can not automatically bind
    // VariantVector CrowdManager::GetQueryFilterTypesAttr() const
    // Error: type "VariantVector" can not automatically bind
    // Vector3 CrowdManager::GetRandomPoint(int queryFilterType, dtPolyRef* randomRef = nullptr)
    // Error: type "dtPolyRef*" can not automatically bind
    // Vector3 CrowdManager::GetRandomPointInCircle(const Vector3& center, float radius, int queryFilterType, dtPolyRef* randomRef = nullptr)
    // Error: type "dtPolyRef*" can not automatically bind
    // Vector3 CrowdManager::Raycast(const Vector3& start, const Vector3& end, int queryFilterType, Vector3* hitNormal = nullptr)
    // Error: type "Vector3*" can not automatically bind
    // void CrowdManager::SetObstacleAvoidanceTypesAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind
    // void CrowdManager::SetQueryFilterTypesAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // void CrowdManager::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void CrowdManager::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // PODVector<CrowdAgent*> CrowdManager::GetAgents(Node* node = nullptr, bool inCrowdFilter = true) const
    engine->RegisterObjectMethod(className, "Array<CrowdAgent@>@ GetAgents(Node@+ = null, bool = true) const", AS_FUNCTION_OBJFIRST(CrowdManager_PODVectorlesCrowdAgentstargre_GetAgents_Nodestar_bool_template<CrowdManager>), AS_CALL_CDECL_OBJFIRST);

    // float CrowdManager::GetAreaCost(unsigned queryFilterType, unsigned areaID) const
    engine->RegisterObjectMethod(className, "float GetAreaCost(uint, uint) const", AS_METHODPR(T, GetAreaCost, (unsigned, unsigned) const, float), AS_CALL_THISCALL);

    // unsigned short CrowdManager::GetExcludeFlags(unsigned queryFilterType) const
    engine->RegisterObjectMethod(className, "uint16 GetExcludeFlags(uint) const", AS_METHODPR(T, GetExcludeFlags, (unsigned) const, unsigned short), AS_CALL_THISCALL);

    // unsigned short CrowdManager::GetIncludeFlags(unsigned queryFilterType) const
    engine->RegisterObjectMethod(className, "uint16 GetIncludeFlags(uint) const", AS_METHODPR(T, GetIncludeFlags, (unsigned) const, unsigned short), AS_CALL_THISCALL);

    // float CrowdManager::GetMaxAgentRadius() const
    engine->RegisterObjectMethod(className, "float GetMaxAgentRadius() const", AS_METHODPR(T, GetMaxAgentRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxAgentRadius() const", AS_METHODPR(T, GetMaxAgentRadius, () const, float), AS_CALL_THISCALL);

    // unsigned CrowdManager::GetMaxAgents() const
    engine->RegisterObjectMethod(className, "uint GetMaxAgents() const", AS_METHODPR(T, GetMaxAgents, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxAgents() const", AS_METHODPR(T, GetMaxAgents, () const, unsigned), AS_CALL_THISCALL);

    // NavigationMesh* CrowdManager::GetNavigationMesh() const
    engine->RegisterObjectMethod(className, "NavigationMesh@+ GetNavigationMesh() const", AS_METHODPR(T, GetNavigationMesh, () const, NavigationMesh*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "NavigationMesh@+ get_navMesh() const", AS_METHODPR(T, GetNavigationMesh, () const, NavigationMesh*), AS_CALL_THISCALL);

    // unsigned CrowdManager::GetNumAreas(unsigned queryFilterType) const
    engine->RegisterObjectMethod(className, "uint GetNumAreas(uint) const", AS_METHODPR(T, GetNumAreas, (unsigned) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAreas(uint) const", AS_METHODPR(T, GetNumAreas, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // unsigned CrowdManager::GetNumObstacleAvoidanceTypes() const
    engine->RegisterObjectMethod(className, "uint GetNumObstacleAvoidanceTypes() const", AS_METHODPR(T, GetNumObstacleAvoidanceTypes, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numObstacleAvoidanceTypes() const", AS_METHODPR(T, GetNumObstacleAvoidanceTypes, () const, unsigned), AS_CALL_THISCALL);

    // unsigned CrowdManager::GetNumQueryFilterTypes() const
    engine->RegisterObjectMethod(className, "uint GetNumQueryFilterTypes() const", AS_METHODPR(T, GetNumQueryFilterTypes, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numQueryFilterTypes() const", AS_METHODPR(T, GetNumQueryFilterTypes, () const, unsigned), AS_CALL_THISCALL);

    // const CrowdObstacleAvoidanceParams& CrowdManager::GetObstacleAvoidanceParams(unsigned obstacleAvoidanceType) const
    engine->RegisterObjectMethod(className, "const CrowdObstacleAvoidanceParams& GetObstacleAvoidanceParams(uint) const", AS_METHODPR(T, GetObstacleAvoidanceParams, (unsigned) const, const CrowdObstacleAvoidanceParams&), AS_CALL_THISCALL);

    // Vector3 CrowdManager::MoveAlongSurface(const Vector3& start, const Vector3& end, int queryFilterType, int maxVisited = 3)
    engine->RegisterObjectMethod(className, "Vector3 MoveAlongSurface(const Vector3&in, const Vector3&in, int, int = 3)", AS_METHODPR(T, MoveAlongSurface, (const Vector3&, const Vector3&, int, int), Vector3), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void CrowdManager::ResetCrowdTarget(Node* node = nullptr)
    engine->RegisterObjectMethod(className, "void ResetCrowdTarget(Node@+ = null)", AS_METHODPR(T, ResetCrowdTarget, (Node*), void), AS_CALL_THISCALL);

    // void CrowdManager::SetAreaCost(unsigned queryFilterType, unsigned areaID, float cost)
    engine->RegisterObjectMethod(className, "void SetAreaCost(uint, uint, float)", AS_METHODPR(T, SetAreaCost, (unsigned, unsigned, float), void), AS_CALL_THISCALL);

    // void CrowdManager::SetCrowdTarget(const Vector3& position, Node* node = nullptr)
    engine->RegisterObjectMethod(className, "void SetCrowdTarget(const Vector3&in, Node@+ = null)", AS_METHODPR(T, SetCrowdTarget, (const Vector3&, Node*), void), AS_CALL_THISCALL);

    // void CrowdManager::SetCrowdVelocity(const Vector3& velocity, Node* node = nullptr)
    engine->RegisterObjectMethod(className, "void SetCrowdVelocity(const Vector3&in, Node@+ = null)", AS_METHODPR(T, SetCrowdVelocity, (const Vector3&, Node*), void), AS_CALL_THISCALL);

    // void CrowdManager::SetExcludeFlags(unsigned queryFilterType, unsigned short flags)
    engine->RegisterObjectMethod(className, "void SetExcludeFlags(uint, uint16)", AS_METHODPR(T, SetExcludeFlags, (unsigned, unsigned short), void), AS_CALL_THISCALL);

    // void CrowdManager::SetIncludeFlags(unsigned queryFilterType, unsigned short flags)
    engine->RegisterObjectMethod(className, "void SetIncludeFlags(uint, uint16)", AS_METHODPR(T, SetIncludeFlags, (unsigned, unsigned short), void), AS_CALL_THISCALL);

    // void CrowdManager::SetMaxAgentRadius(float maxAgentRadius)
    engine->RegisterObjectMethod(className, "void SetMaxAgentRadius(float)", AS_METHODPR(T, SetMaxAgentRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxAgentRadius(float)", AS_METHODPR(T, SetMaxAgentRadius, (float), void), AS_CALL_THISCALL);

    // void CrowdManager::SetMaxAgents(unsigned maxAgents)
    engine->RegisterObjectMethod(className, "void SetMaxAgents(uint)", AS_METHODPR(T, SetMaxAgents, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxAgents(uint)", AS_METHODPR(T, SetMaxAgents, (unsigned), void), AS_CALL_THISCALL);

    // void CrowdManager::SetNavigationMesh(NavigationMesh* navMesh)
    engine->RegisterObjectMethod(className, "void SetNavigationMesh(NavigationMesh@+)", AS_METHODPR(T, SetNavigationMesh, (NavigationMesh*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_navMesh(NavigationMesh@+)", AS_METHODPR(T, SetNavigationMesh, (NavigationMesh*), void), AS_CALL_THISCALL);

    // void CrowdManager::SetObstacleAvoidanceParams(unsigned obstacleAvoidanceType, const CrowdObstacleAvoidanceParams& params)
    engine->RegisterObjectMethod(className, "void SetObstacleAvoidanceParams(uint, const CrowdObstacleAvoidanceParams&in)", AS_METHODPR(T, SetObstacleAvoidanceParams, (unsigned, const CrowdObstacleAvoidanceParams&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CrowdManager
        REGISTER_MEMBERS_MANUAL_PART_CrowdManager();
    #endif
}

// class NavArea | File: ../Navigation/NavArea.h
template <class T> void RegisterMembers_NavArea(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void NavArea::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // unsigned NavArea::GetAreaID() const
    engine->RegisterObjectMethod(className, "uint GetAreaID() const", AS_METHODPR(T, GetAreaID, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_areaID() const", AS_METHODPR(T, GetAreaID, () const, unsigned), AS_CALL_THISCALL);

    // BoundingBox NavArea::GetBoundingBox() const
    engine->RegisterObjectMethod(className, "BoundingBox GetBoundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BoundingBox get_boundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);

    // BoundingBox NavArea::GetWorldBoundingBox() const
    engine->RegisterObjectMethod(className, "BoundingBox GetWorldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BoundingBox get_worldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void NavArea::SetAreaID(unsigned newID)
    engine->RegisterObjectMethod(className, "void SetAreaID(uint)", AS_METHODPR(T, SetAreaID, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_areaID(uint)", AS_METHODPR(T, SetAreaID, (unsigned), void), AS_CALL_THISCALL);

    // void NavArea::SetBoundingBox(const BoundingBox& bnds)
    engine->RegisterObjectMethod(className, "void SetBoundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_boundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NavArea
        REGISTER_MEMBERS_MANUAL_PART_NavArea();
    #endif
}

// class Navigable | File: ../Navigation/Navigable.h
template <class T> void RegisterMembers_Navigable(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // bool Navigable::IsRecursive() const
    engine->RegisterObjectMethod(className, "bool IsRecursive() const", AS_METHODPR(T, IsRecursive, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_recursive() const", AS_METHODPR(T, IsRecursive, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Navigable::SetRecursive(bool enable)
    engine->RegisterObjectMethod(className, "void SetRecursive(bool)", AS_METHODPR(T, SetRecursive, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_recursive(bool)", AS_METHODPR(T, SetRecursive, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Navigable
        REGISTER_MEMBERS_MANUAL_PART_Navigable();
    #endif
}

// class NavigationMesh | File: ../Navigation/NavigationMesh.h
template <class T> void RegisterMembers_NavigationMesh(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // virtual bool NavigationMesh::AddTile(const PODVector<unsigned char>& tileData)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // Vector3 NavigationMesh::FindNearestPoint(const Vector3& point, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr, dtPolyRef* nearestRef = nullptr)
    // Error: type "const dtQueryFilter*" can not automatically bind
    // void NavigationMesh::FindPath(PODVector<Vector3>& dest, const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr)
    // Error: type "PODVector<Vector3>&" can not automatically bind
    // void NavigationMesh::FindPath(PODVector<NavigationPathPoint>& dest, const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr)
    // Error: type "PODVector<NavigationPathPoint>&" can not automatically bind
    // float NavigationMesh::GetDistanceToWall(const Vector3& point, float radius, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr, Vector3* hitPos = nullptr, Vector3* hitNormal = nullptr)
    // Error: type "const dtQueryFilter*" can not automatically bind
    // virtual PODVector<unsigned char> NavigationMesh::GetNavigationDataAttr() const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // Vector3 NavigationMesh::GetRandomPoint(const dtQueryFilter* filter = nullptr, dtPolyRef* randomRef = nullptr)
    // Error: type "const dtQueryFilter*" can not automatically bind
    // Vector3 NavigationMesh::GetRandomPointInCircle(const Vector3& center, float radius, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr, dtPolyRef* randomRef = nullptr)
    // Error: type "const dtQueryFilter*" can not automatically bind
    // virtual PODVector<unsigned char> NavigationMesh::GetTileData(const IntVector2& tile) const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // Vector3 NavigationMesh::MoveAlongSurface(const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE, int maxVisited = 3, const dtQueryFilter* filter = nullptr)
    // Error: type "const dtQueryFilter*" can not automatically bind
    // Vector3 NavigationMesh::Raycast(const Vector3& start, const Vector3& end, const Vector3& extents = Vector3::ONE, const dtQueryFilter* filter = nullptr, Vector3* hitNormal = nullptr)
    // Error: type "const dtQueryFilter*" can not automatically bind
    // virtual void NavigationMesh::SetNavigationDataAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // virtual bool NavigationMesh::Allocate(const BoundingBox& boundingBox, unsigned maxTiles)
    engine->RegisterObjectMethod(className, "bool Allocate(const BoundingBox&in, uint)", AS_METHODPR(T, Allocate, (const BoundingBox&, unsigned), bool), AS_CALL_THISCALL);

    // virtual bool NavigationMesh::Build()
    engine->RegisterObjectMethod(className, "bool Build()", AS_METHODPR(T, Build, (), bool), AS_CALL_THISCALL);

    // virtual bool NavigationMesh::Build(const BoundingBox& boundingBox)
    engine->RegisterObjectMethod(className, "bool Build(const BoundingBox&in)", AS_METHODPR(T, Build, (const BoundingBox&), bool), AS_CALL_THISCALL);

    // virtual bool NavigationMesh::Build(const IntVector2& from, const IntVector2& to)
    engine->RegisterObjectMethod(className, "bool Build(const IntVector2&in, const IntVector2&in)", AS_METHODPR(T, Build, (const IntVector2&, const IntVector2&), bool), AS_CALL_THISCALL);

    // void NavigationMesh::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void NavigationMesh::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // float NavigationMesh::GetAgentHeight() const
    engine->RegisterObjectMethod(className, "float GetAgentHeight() const", AS_METHODPR(T, GetAgentHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_agentHeight() const", AS_METHODPR(T, GetAgentHeight, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetAgentMaxClimb() const
    engine->RegisterObjectMethod(className, "float GetAgentMaxClimb() const", AS_METHODPR(T, GetAgentMaxClimb, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_agentMaxClimb() const", AS_METHODPR(T, GetAgentMaxClimb, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetAgentMaxSlope() const
    engine->RegisterObjectMethod(className, "float GetAgentMaxSlope() const", AS_METHODPR(T, GetAgentMaxSlope, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_agentMaxSlope() const", AS_METHODPR(T, GetAgentMaxSlope, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetAgentRadius() const
    engine->RegisterObjectMethod(className, "float GetAgentRadius() const", AS_METHODPR(T, GetAgentRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_agentRadius() const", AS_METHODPR(T, GetAgentRadius, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetAreaCost(unsigned areaID) const
    engine->RegisterObjectMethod(className, "float GetAreaCost(uint) const", AS_METHODPR(T, GetAreaCost, (unsigned) const, float), AS_CALL_THISCALL);

    // const BoundingBox& NavigationMesh::GetBoundingBox() const
    engine->RegisterObjectMethod(className, "const BoundingBox& GetBoundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BoundingBox& get_boundingBox() const", AS_METHODPR(T, GetBoundingBox, () const, const BoundingBox&), AS_CALL_THISCALL);

    // float NavigationMesh::GetCellHeight() const
    engine->RegisterObjectMethod(className, "float GetCellHeight() const", AS_METHODPR(T, GetCellHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_cellHeight() const", AS_METHODPR(T, GetCellHeight, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetCellSize() const
    engine->RegisterObjectMethod(className, "float GetCellSize() const", AS_METHODPR(T, GetCellSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_cellSize() const", AS_METHODPR(T, GetCellSize, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetDetailSampleDistance() const
    engine->RegisterObjectMethod(className, "float GetDetailSampleDistance() const", AS_METHODPR(T, GetDetailSampleDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_detailSampleDistance() const", AS_METHODPR(T, GetDetailSampleDistance, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetDetailSampleMaxError() const
    engine->RegisterObjectMethod(className, "float GetDetailSampleMaxError() const", AS_METHODPR(T, GetDetailSampleMaxError, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_detailSampleMaxError() const", AS_METHODPR(T, GetDetailSampleMaxError, () const, float), AS_CALL_THISCALL);

    // bool NavigationMesh::GetDrawNavAreas() const
    engine->RegisterObjectMethod(className, "bool GetDrawNavAreas() const", AS_METHODPR(T, GetDrawNavAreas, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawNavAreas() const", AS_METHODPR(T, GetDrawNavAreas, () const, bool), AS_CALL_THISCALL);

    // bool NavigationMesh::GetDrawOffMeshConnections() const
    engine->RegisterObjectMethod(className, "bool GetDrawOffMeshConnections() const", AS_METHODPR(T, GetDrawOffMeshConnections, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawOffMeshConnections() const", AS_METHODPR(T, GetDrawOffMeshConnections, () const, bool), AS_CALL_THISCALL);

    // float NavigationMesh::GetEdgeMaxError() const
    engine->RegisterObjectMethod(className, "float GetEdgeMaxError() const", AS_METHODPR(T, GetEdgeMaxError, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_edgeMaxError() const", AS_METHODPR(T, GetEdgeMaxError, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetEdgeMaxLength() const
    engine->RegisterObjectMethod(className, "float GetEdgeMaxLength() const", AS_METHODPR(T, GetEdgeMaxLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_edgeMaxLength() const", AS_METHODPR(T, GetEdgeMaxLength, () const, float), AS_CALL_THISCALL);

    // String NavigationMesh::GetMeshName() const
    engine->RegisterObjectMethod(className, "String GetMeshName() const", AS_METHODPR(T, GetMeshName, () const, String), AS_CALL_THISCALL);

    // IntVector2 NavigationMesh::GetNumTiles() const
    engine->RegisterObjectMethod(className, "IntVector2 GetNumTiles() const", AS_METHODPR(T, GetNumTiles, () const, IntVector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector2 get_numTiles() const", AS_METHODPR(T, GetNumTiles, () const, IntVector2), AS_CALL_THISCALL);

    // const Vector3& NavigationMesh::GetPadding() const
    engine->RegisterObjectMethod(className, "const Vector3& GetPadding() const", AS_METHODPR(T, GetPadding, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_padding() const", AS_METHODPR(T, GetPadding, () const, const Vector3&), AS_CALL_THISCALL);

    // NavmeshPartitionType NavigationMesh::GetPartitionType() const
    engine->RegisterObjectMethod(className, "NavmeshPartitionType GetPartitionType() const", AS_METHODPR(T, GetPartitionType, () const, NavmeshPartitionType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "NavmeshPartitionType get_partitionType() const", AS_METHODPR(T, GetPartitionType, () const, NavmeshPartitionType), AS_CALL_THISCALL);

    // float NavigationMesh::GetRegionMergeSize() const
    engine->RegisterObjectMethod(className, "float GetRegionMergeSize() const", AS_METHODPR(T, GetRegionMergeSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_regionMergeSize() const", AS_METHODPR(T, GetRegionMergeSize, () const, float), AS_CALL_THISCALL);

    // float NavigationMesh::GetRegionMinSize() const
    engine->RegisterObjectMethod(className, "float GetRegionMinSize() const", AS_METHODPR(T, GetRegionMinSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_regionMinSize() const", AS_METHODPR(T, GetRegionMinSize, () const, float), AS_CALL_THISCALL);

    // BoundingBox NavigationMesh::GetTileBoundingBox(const IntVector2& tile) const
    engine->RegisterObjectMethod(className, "BoundingBox GetTileBoundingBox(const IntVector2&in) const", AS_METHODPR(T, GetTileBoundingBox, (const IntVector2&) const, BoundingBox), AS_CALL_THISCALL);

    // IntVector2 NavigationMesh::GetTileIndex(const Vector3& position) const
    engine->RegisterObjectMethod(className, "IntVector2 GetTileIndex(const Vector3&in) const", AS_METHODPR(T, GetTileIndex, (const Vector3&) const, IntVector2), AS_CALL_THISCALL);

    // int NavigationMesh::GetTileSize() const
    engine->RegisterObjectMethod(className, "int GetTileSize() const", AS_METHODPR(T, GetTileSize, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_tileSize() const", AS_METHODPR(T, GetTileSize, () const, int), AS_CALL_THISCALL);

    // BoundingBox NavigationMesh::GetWorldBoundingBox() const
    engine->RegisterObjectMethod(className, "BoundingBox GetWorldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BoundingBox get_worldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);

    // bool NavigationMesh::HasTile(const IntVector2& tile) const
    engine->RegisterObjectMethod(className, "bool HasTile(const IntVector2&in) const", AS_METHODPR(T, HasTile, (const IntVector2&) const, bool), AS_CALL_THISCALL);

    // bool NavigationMesh::IsInitialized() const
    engine->RegisterObjectMethod(className, "bool IsInitialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_initialized() const", AS_METHODPR(T, IsInitialized, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // virtual void NavigationMesh::RemoveAllTiles()
    engine->RegisterObjectMethod(className, "void RemoveAllTiles()", AS_METHODPR(T, RemoveAllTiles, (), void), AS_CALL_THISCALL);

    // virtual void NavigationMesh::RemoveTile(const IntVector2& tile)
    engine->RegisterObjectMethod(className, "void RemoveTile(const IntVector2&in)", AS_METHODPR(T, RemoveTile, (const IntVector2&), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetAgentHeight(float height)
    engine->RegisterObjectMethod(className, "void SetAgentHeight(float)", AS_METHODPR(T, SetAgentHeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_agentHeight(float)", AS_METHODPR(T, SetAgentHeight, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetAgentMaxClimb(float maxClimb)
    engine->RegisterObjectMethod(className, "void SetAgentMaxClimb(float)", AS_METHODPR(T, SetAgentMaxClimb, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_agentMaxClimb(float)", AS_METHODPR(T, SetAgentMaxClimb, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetAgentMaxSlope(float maxSlope)
    engine->RegisterObjectMethod(className, "void SetAgentMaxSlope(float)", AS_METHODPR(T, SetAgentMaxSlope, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_agentMaxSlope(float)", AS_METHODPR(T, SetAgentMaxSlope, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetAgentRadius(float radius)
    engine->RegisterObjectMethod(className, "void SetAgentRadius(float)", AS_METHODPR(T, SetAgentRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_agentRadius(float)", AS_METHODPR(T, SetAgentRadius, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetAreaCost(unsigned areaID, float cost)
    engine->RegisterObjectMethod(className, "void SetAreaCost(uint, float)", AS_METHODPR(T, SetAreaCost, (unsigned, float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetCellHeight(float height)
    engine->RegisterObjectMethod(className, "void SetCellHeight(float)", AS_METHODPR(T, SetCellHeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cellHeight(float)", AS_METHODPR(T, SetCellHeight, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetCellSize(float size)
    engine->RegisterObjectMethod(className, "void SetCellSize(float)", AS_METHODPR(T, SetCellSize, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cellSize(float)", AS_METHODPR(T, SetCellSize, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetDetailSampleDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetDetailSampleDistance(float)", AS_METHODPR(T, SetDetailSampleDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_detailSampleDistance(float)", AS_METHODPR(T, SetDetailSampleDistance, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetDetailSampleMaxError(float error)
    engine->RegisterObjectMethod(className, "void SetDetailSampleMaxError(float)", AS_METHODPR(T, SetDetailSampleMaxError, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_detailSampleMaxError(float)", AS_METHODPR(T, SetDetailSampleMaxError, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetDrawNavAreas(bool enable)
    engine->RegisterObjectMethod(className, "void SetDrawNavAreas(bool)", AS_METHODPR(T, SetDrawNavAreas, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawNavAreas(bool)", AS_METHODPR(T, SetDrawNavAreas, (bool), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetDrawOffMeshConnections(bool enable)
    engine->RegisterObjectMethod(className, "void SetDrawOffMeshConnections(bool)", AS_METHODPR(T, SetDrawOffMeshConnections, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawOffMeshConnections(bool)", AS_METHODPR(T, SetDrawOffMeshConnections, (bool), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetEdgeMaxError(float error)
    engine->RegisterObjectMethod(className, "void SetEdgeMaxError(float)", AS_METHODPR(T, SetEdgeMaxError, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_edgeMaxError(float)", AS_METHODPR(T, SetEdgeMaxError, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetEdgeMaxLength(float length)
    engine->RegisterObjectMethod(className, "void SetEdgeMaxLength(float)", AS_METHODPR(T, SetEdgeMaxLength, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_edgeMaxLength(float)", AS_METHODPR(T, SetEdgeMaxLength, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetMeshName(const String& newName)
    engine->RegisterObjectMethod(className, "void SetMeshName(const String&in)", AS_METHODPR(T, SetMeshName, (const String&), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetPadding(const Vector3& padding)
    engine->RegisterObjectMethod(className, "void SetPadding(const Vector3&in)", AS_METHODPR(T, SetPadding, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_padding(const Vector3&in)", AS_METHODPR(T, SetPadding, (const Vector3&), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetPartitionType(NavmeshPartitionType partitionType)
    engine->RegisterObjectMethod(className, "void SetPartitionType(NavmeshPartitionType)", AS_METHODPR(T, SetPartitionType, (NavmeshPartitionType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_partitionType(NavmeshPartitionType)", AS_METHODPR(T, SetPartitionType, (NavmeshPartitionType), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetRegionMergeSize(float size)
    engine->RegisterObjectMethod(className, "void SetRegionMergeSize(float)", AS_METHODPR(T, SetRegionMergeSize, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_regionMergeSize(float)", AS_METHODPR(T, SetRegionMergeSize, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetRegionMinSize(float size)
    engine->RegisterObjectMethod(className, "void SetRegionMinSize(float)", AS_METHODPR(T, SetRegionMinSize, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_regionMinSize(float)", AS_METHODPR(T, SetRegionMinSize, (float), void), AS_CALL_THISCALL);

    // void NavigationMesh::SetTileSize(int size)
    engine->RegisterObjectMethod(className, "void SetTileSize(int)", AS_METHODPR(T, SetTileSize, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_tileSize(int)", AS_METHODPR(T, SetTileSize, (int), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NavigationMesh
        REGISTER_MEMBERS_MANUAL_PART_NavigationMesh();
    #endif
}

// class Obstacle | File: ../Navigation/Obstacle.h
template <class T> void RegisterMembers_Obstacle(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void Obstacle::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void Obstacle::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // float Obstacle::GetHeight() const
    engine->RegisterObjectMethod(className, "float GetHeight() const", AS_METHODPR(T, GetHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_height() const", AS_METHODPR(T, GetHeight, () const, float), AS_CALL_THISCALL);

    // unsigned Obstacle::GetObstacleID() const
    engine->RegisterObjectMethod(className, "uint GetObstacleID() const", AS_METHODPR(T, GetObstacleID, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_obstacleId() const", AS_METHODPR(T, GetObstacleID, () const, unsigned), AS_CALL_THISCALL);

    // float Obstacle::GetRadius() const
    engine->RegisterObjectMethod(className, "float GetRadius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_radius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);

    // void Obstacle::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Obstacle::SetHeight(float newHeight)
    engine->RegisterObjectMethod(className, "void SetHeight(float)", AS_METHODPR(T, SetHeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_height(float)", AS_METHODPR(T, SetHeight, (float), void), AS_CALL_THISCALL);

    // void Obstacle::SetRadius(float newRadius)
    engine->RegisterObjectMethod(className, "void SetRadius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_radius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Obstacle
        REGISTER_MEMBERS_MANUAL_PART_Obstacle();
    #endif
}

// class OffMeshConnection | File: ../Navigation/OffMeshConnection.h
template <class T> void RegisterMembers_OffMeshConnection(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void OffMeshConnection::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // unsigned OffMeshConnection::GetAreaID() const
    engine->RegisterObjectMethod(className, "uint GetAreaID() const", AS_METHODPR(T, GetAreaID, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_areaID() const", AS_METHODPR(T, GetAreaID, () const, unsigned), AS_CALL_THISCALL);

    // Node* OffMeshConnection::GetEndPoint() const
    engine->RegisterObjectMethod(className, "Node@+ GetEndPoint() const", AS_METHODPR(T, GetEndPoint, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_endPoint() const", AS_METHODPR(T, GetEndPoint, () const, Node*), AS_CALL_THISCALL);

    // unsigned OffMeshConnection::GetMask() const
    engine->RegisterObjectMethod(className, "uint GetMask() const", AS_METHODPR(T, GetMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_mask() const", AS_METHODPR(T, GetMask, () const, unsigned), AS_CALL_THISCALL);

    // float OffMeshConnection::GetRadius() const
    engine->RegisterObjectMethod(className, "float GetRadius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_radius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);

    // bool OffMeshConnection::IsBidirectional() const
    engine->RegisterObjectMethod(className, "bool IsBidirectional() const", AS_METHODPR(T, IsBidirectional, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_bidirectional() const", AS_METHODPR(T, IsBidirectional, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void OffMeshConnection::SetAreaID(unsigned newAreaID)
    engine->RegisterObjectMethod(className, "void SetAreaID(uint)", AS_METHODPR(T, SetAreaID, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_areaID(uint)", AS_METHODPR(T, SetAreaID, (unsigned), void), AS_CALL_THISCALL);

    // void OffMeshConnection::SetBidirectional(bool enabled)
    engine->RegisterObjectMethod(className, "void SetBidirectional(bool)", AS_METHODPR(T, SetBidirectional, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bidirectional(bool)", AS_METHODPR(T, SetBidirectional, (bool), void), AS_CALL_THISCALL);

    // void OffMeshConnection::SetEndPoint(Node* node)
    engine->RegisterObjectMethod(className, "void SetEndPoint(Node@+)", AS_METHODPR(T, SetEndPoint, (Node*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_endPoint(Node@+)", AS_METHODPR(T, SetEndPoint, (Node*), void), AS_CALL_THISCALL);

    // void OffMeshConnection::SetMask(unsigned newMask)
    engine->RegisterObjectMethod(className, "void SetMask(uint)", AS_METHODPR(T, SetMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mask(uint)", AS_METHODPR(T, SetMask, (unsigned), void), AS_CALL_THISCALL);

    // void OffMeshConnection::SetRadius(float radius)
    engine->RegisterObjectMethod(className, "void SetRadius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_radius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_OffMeshConnection
        REGISTER_MEMBERS_MANUAL_PART_OffMeshConnection();
    #endif
}

#endif // def URHO3D_NAVIGATION

#ifdef URHO3D_NETWORK

// class NetworkPriority | File: ../Network/NetworkPriority.h
template <class T> void RegisterMembers_NetworkPriority(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // bool NetworkPriority::CheckUpdate(float distance, float& accumulator)
    engine->RegisterObjectMethod(className, "bool CheckUpdate(float, float&)", AS_METHODPR(T, CheckUpdate, (float, float&), bool), AS_CALL_THISCALL);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // bool NetworkPriority::GetAlwaysUpdateOwner() const
    engine->RegisterObjectMethod(className, "bool GetAlwaysUpdateOwner() const", AS_METHODPR(T, GetAlwaysUpdateOwner, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_alwaysUpdateOwner() const", AS_METHODPR(T, GetAlwaysUpdateOwner, () const, bool), AS_CALL_THISCALL);

    // float NetworkPriority::GetBasePriority() const
    engine->RegisterObjectMethod(className, "float GetBasePriority() const", AS_METHODPR(T, GetBasePriority, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_basePriority() const", AS_METHODPR(T, GetBasePriority, () const, float), AS_CALL_THISCALL);

    // float NetworkPriority::GetDistanceFactor() const
    engine->RegisterObjectMethod(className, "float GetDistanceFactor() const", AS_METHODPR(T, GetDistanceFactor, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_distanceFactor() const", AS_METHODPR(T, GetDistanceFactor, () const, float), AS_CALL_THISCALL);

    // float NetworkPriority::GetMinPriority() const
    engine->RegisterObjectMethod(className, "float GetMinPriority() const", AS_METHODPR(T, GetMinPriority, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minPriority() const", AS_METHODPR(T, GetMinPriority, () const, float), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void NetworkPriority::SetAlwaysUpdateOwner(bool enable)
    engine->RegisterObjectMethod(className, "void SetAlwaysUpdateOwner(bool)", AS_METHODPR(T, SetAlwaysUpdateOwner, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_alwaysUpdateOwner(bool)", AS_METHODPR(T, SetAlwaysUpdateOwner, (bool), void), AS_CALL_THISCALL);

    // void NetworkPriority::SetBasePriority(float priority)
    engine->RegisterObjectMethod(className, "void SetBasePriority(float)", AS_METHODPR(T, SetBasePriority, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_basePriority(float)", AS_METHODPR(T, SetBasePriority, (float), void), AS_CALL_THISCALL);

    // void NetworkPriority::SetDistanceFactor(float factor)
    engine->RegisterObjectMethod(className, "void SetDistanceFactor(float)", AS_METHODPR(T, SetDistanceFactor, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_distanceFactor(float)", AS_METHODPR(T, SetDistanceFactor, (float), void), AS_CALL_THISCALL);

    // void NetworkPriority::SetMinPriority(float priority)
    engine->RegisterObjectMethod(className, "void SetMinPriority(float)", AS_METHODPR(T, SetMinPriority, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minPriority(float)", AS_METHODPR(T, SetMinPriority, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_NetworkPriority
        REGISTER_MEMBERS_MANUAL_PART_NetworkPriority();
    #endif
}

#endif // def URHO3D_NETWORK

#ifdef URHO3D_PHYSICS

// class CollisionShape | File: ../Physics/CollisionShape.h
template <class T> void RegisterMembers_CollisionShape(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // btCollisionShape* CollisionShape::GetCollisionShape() const
    // Error: type "btCollisionShape*" can not automatically bind

    // void CollisionShape::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // CollisionGeometryData* CollisionShape::GetGeometryData() const
    engine->RegisterObjectMethod(className, "CollisionGeometryData@+ GetGeometryData() const", AS_METHODPR(T, GetGeometryData, () const, CollisionGeometryData*), AS_CALL_THISCALL);

    // unsigned CollisionShape::GetLodLevel() const
    engine->RegisterObjectMethod(className, "uint GetLodLevel() const", AS_METHODPR(T, GetLodLevel, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_lodLevel() const", AS_METHODPR(T, GetLodLevel, () const, unsigned), AS_CALL_THISCALL);

    // float CollisionShape::GetMargin() const
    engine->RegisterObjectMethod(className, "float GetMargin() const", AS_METHODPR(T, GetMargin, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_margin() const", AS_METHODPR(T, GetMargin, () const, float), AS_CALL_THISCALL);

    // Model* CollisionShape::GetModel() const
    engine->RegisterObjectMethod(className, "Model@+ GetModel() const", AS_METHODPR(T, GetModel, () const, Model*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Model@+ get_model() const", AS_METHODPR(T, GetModel, () const, Model*), AS_CALL_THISCALL);

    // ResourceRef CollisionShape::GetModelAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetModelAttr() const", AS_METHODPR(T, GetModelAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // PhysicsWorld* CollisionShape::GetPhysicsWorld() const
    engine->RegisterObjectMethod(className, "PhysicsWorld@+ GetPhysicsWorld() const", AS_METHODPR(T, GetPhysicsWorld, () const, PhysicsWorld*), AS_CALL_THISCALL);

    // const Vector3& CollisionShape::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_position() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // const Quaternion& CollisionShape::GetRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetRotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_rotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // ShapeType CollisionShape::GetShapeType() const
    engine->RegisterObjectMethod(className, "ShapeType GetShapeType() const", AS_METHODPR(T, GetShapeType, () const, ShapeType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ShapeType get_shapeType() const", AS_METHODPR(T, GetShapeType, () const, ShapeType), AS_CALL_THISCALL);

    // const Vector3& CollisionShape::GetSize() const
    engine->RegisterObjectMethod(className, "const Vector3& GetSize() const", AS_METHODPR(T, GetSize, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_size() const", AS_METHODPR(T, GetSize, () const, const Vector3&), AS_CALL_THISCALL);

    // BoundingBox CollisionShape::GetWorldBoundingBox() const
    engine->RegisterObjectMethod(className, "BoundingBox GetWorldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BoundingBox get_worldBoundingBox() const", AS_METHODPR(T, GetWorldBoundingBox, () const, BoundingBox), AS_CALL_THISCALL);

    // void CollisionShape::NotifyRigidBody(bool updateMass = true)
    engine->RegisterObjectMethod(className, "void NotifyRigidBody(bool = true)", AS_METHODPR(T, NotifyRigidBody, (bool), void), AS_CALL_THISCALL);

    // void CollisionShape::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void CollisionShape::ReleaseShape()
    engine->RegisterObjectMethod(className, "void ReleaseShape()", AS_METHODPR(T, ReleaseShape, (), void), AS_CALL_THISCALL);

    // void CollisionShape::SetBox(const Vector3& size, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetBox(const Vector3&in, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetBox, (const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetCapsule(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetCapsule(float, float, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetCapsule, (float, float, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetCone(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetCone(float, float, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetCone, (float, float, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetConvexHull(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetConvexHull(Model@+, uint = 0, const Vector3&in = Vector3::ONE, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetConvexHull, (Model*, unsigned, const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetCustomConvexHull(CustomGeometry* custom, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetCustomConvexHull(CustomGeometry@+, const Vector3&in = Vector3::ONE, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetCustomConvexHull, (CustomGeometry*, const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetCustomGImpactMesh(CustomGeometry* custom, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetCustomGImpactMesh(CustomGeometry@+, const Vector3&in = Vector3::ONE, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetCustomGImpactMesh, (CustomGeometry*, const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetCustomTriangleMesh(CustomGeometry* custom, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetCustomTriangleMesh(CustomGeometry@+, const Vector3&in = Vector3::ONE, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetCustomTriangleMesh, (CustomGeometry*, const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetCylinder(float diameter, float height, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetCylinder(float, float, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetCylinder, (float, float, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetGImpactMesh(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetGImpactMesh(Model@+, uint = 0, const Vector3&in = Vector3::ONE, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetGImpactMesh, (Model*, unsigned, const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetLodLevel(unsigned lodLevel)
    engine->RegisterObjectMethod(className, "void SetLodLevel(uint)", AS_METHODPR(T, SetLodLevel, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lodLevel(uint)", AS_METHODPR(T, SetLodLevel, (unsigned), void), AS_CALL_THISCALL);

    // void CollisionShape::SetMargin(float margin)
    engine->RegisterObjectMethod(className, "void SetMargin(float)", AS_METHODPR(T, SetMargin, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_margin(float)", AS_METHODPR(T, SetMargin, (float), void), AS_CALL_THISCALL);

    // void CollisionShape::SetModel(Model* model)
    engine->RegisterObjectMethod(className, "void SetModel(Model@+)", AS_METHODPR(T, SetModel, (Model*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_model(Model@+)", AS_METHODPR(T, SetModel, (Model*), void), AS_CALL_THISCALL);

    // void CollisionShape::SetModelAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetModelAttr(const ResourceRef&in)", AS_METHODPR(T, SetModelAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetShapeType(ShapeType type)
    engine->RegisterObjectMethod(className, "void SetShapeType(ShapeType)", AS_METHODPR(T, SetShapeType, (ShapeType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shapeType(ShapeType)", AS_METHODPR(T, SetShapeType, (ShapeType), void), AS_CALL_THISCALL);

    // void CollisionShape::SetSize(const Vector3& size)
    engine->RegisterObjectMethod(className, "void SetSize(const Vector3&in)", AS_METHODPR(T, SetSize, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_size(const Vector3&in)", AS_METHODPR(T, SetSize, (const Vector3&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetSphere(float diameter, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetSphere(float, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetSphere, (float, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetStaticPlane(const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetStaticPlane(const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetStaticPlane, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetTerrain(unsigned lodLevel = 0)
    engine->RegisterObjectMethod(className, "void SetTerrain(uint = 0)", AS_METHODPR(T, SetTerrain, (unsigned), void), AS_CALL_THISCALL);

    // void CollisionShape::SetTransform(const Vector3& position, const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in)", AS_METHODPR(T, SetTransform, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void CollisionShape::SetTriangleMesh(Model* model, unsigned lodLevel = 0, const Vector3& scale = Vector3::ONE, const Vector3& position = Vector3::ZERO, const Quaternion& rotation = Quaternion::IDENTITY)
    engine->RegisterObjectMethod(className, "void SetTriangleMesh(Model@+, uint = 0, const Vector3&in = Vector3::ONE, const Vector3&in = Vector3::ZERO, const Quaternion&in = Quaternion::IDENTITY)", AS_METHODPR(T, SetTriangleMesh, (Model*, unsigned, const Vector3&, const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionShape
        REGISTER_MEMBERS_MANUAL_PART_CollisionShape();
    #endif
}

// class Constraint | File: ../Physics/Constraint.h
template <class T> void RegisterMembers_Constraint(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // btTypedConstraint* Constraint::GetConstraint() const
    // Error: type "btTypedConstraint*" can not automatically bind

    // void Constraint::ApplyFrames()
    engine->RegisterObjectMethod(className, "void ApplyFrames()", AS_METHODPR(T, ApplyFrames, (), void), AS_CALL_THISCALL);

    // void Constraint::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // float Constraint::GetCFM() const
    engine->RegisterObjectMethod(className, "float GetCFM() const", AS_METHODPR(T, GetCFM, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_cfm() const", AS_METHODPR(T, GetCFM, () const, float), AS_CALL_THISCALL);

    // ConstraintType Constraint::GetConstraintType() const
    engine->RegisterObjectMethod(className, "ConstraintType GetConstraintType() const", AS_METHODPR(T, GetConstraintType, () const, ConstraintType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ConstraintType get_constraintType() const", AS_METHODPR(T, GetConstraintType, () const, ConstraintType), AS_CALL_THISCALL);

    // bool Constraint::GetDisableCollision() const
    engine->RegisterObjectMethod(className, "bool GetDisableCollision() const", AS_METHODPR(T, GetDisableCollision, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_disableCollision() const", AS_METHODPR(T, GetDisableCollision, () const, bool), AS_CALL_THISCALL);

    // float Constraint::GetERP() const
    engine->RegisterObjectMethod(className, "float GetERP() const", AS_METHODPR(T, GetERP, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_erp() const", AS_METHODPR(T, GetERP, () const, float), AS_CALL_THISCALL);

    // const Vector2& Constraint::GetHighLimit() const
    engine->RegisterObjectMethod(className, "const Vector2& GetHighLimit() const", AS_METHODPR(T, GetHighLimit, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_highLimit() const", AS_METHODPR(T, GetHighLimit, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& Constraint::GetLowLimit() const
    engine->RegisterObjectMethod(className, "const Vector2& GetLowLimit() const", AS_METHODPR(T, GetLowLimit, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_lowLimit() const", AS_METHODPR(T, GetLowLimit, () const, const Vector2&), AS_CALL_THISCALL);

    // RigidBody* Constraint::GetOtherBody() const
    engine->RegisterObjectMethod(className, "RigidBody@+ GetOtherBody() const", AS_METHODPR(T, GetOtherBody, () const, RigidBody*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RigidBody@+ get_otherBody() const", AS_METHODPR(T, GetOtherBody, () const, RigidBody*), AS_CALL_THISCALL);

    // const Vector3& Constraint::GetOtherPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetOtherPosition() const", AS_METHODPR(T, GetOtherPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_otherPosition() const", AS_METHODPR(T, GetOtherPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // const Quaternion& Constraint::GetOtherRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetOtherRotation() const", AS_METHODPR(T, GetOtherRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_otherRotation() const", AS_METHODPR(T, GetOtherRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // RigidBody* Constraint::GetOwnBody() const
    engine->RegisterObjectMethod(className, "RigidBody@+ GetOwnBody() const", AS_METHODPR(T, GetOwnBody, () const, RigidBody*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RigidBody@+ get_ownBody() const", AS_METHODPR(T, GetOwnBody, () const, RigidBody*), AS_CALL_THISCALL);

    // PhysicsWorld* Constraint::GetPhysicsWorld() const
    engine->RegisterObjectMethod(className, "PhysicsWorld@+ GetPhysicsWorld() const", AS_METHODPR(T, GetPhysicsWorld, () const, PhysicsWorld*), AS_CALL_THISCALL);

    // const Vector3& Constraint::GetPosition() const
    engine->RegisterObjectMethod(className, "const Vector3& GetPosition() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_position() const", AS_METHODPR(T, GetPosition, () const, const Vector3&), AS_CALL_THISCALL);

    // const Quaternion& Constraint::GetRotation() const
    engine->RegisterObjectMethod(className, "const Quaternion& GetRotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Quaternion& get_rotation() const", AS_METHODPR(T, GetRotation, () const, const Quaternion&), AS_CALL_THISCALL);

    // Vector3 Constraint::GetWorldPosition() const
    engine->RegisterObjectMethod(className, "Vector3 GetWorldPosition() const", AS_METHODPR(T, GetWorldPosition, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_worldPosition() const", AS_METHODPR(T, GetWorldPosition, () const, Vector3), AS_CALL_THISCALL);

    // void Constraint::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Constraint::ReleaseConstraint()
    engine->RegisterObjectMethod(className, "void ReleaseConstraint()", AS_METHODPR(T, ReleaseConstraint, (), void), AS_CALL_THISCALL);

    // void Constraint::SetAxis(const Vector3& axis)
    engine->RegisterObjectMethod(className, "void SetAxis(const Vector3&in)", AS_METHODPR(T, SetAxis, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_axis(const Vector3&in)", AS_METHODPR(T, SetAxis, (const Vector3&), void), AS_CALL_THISCALL);

    // void Constraint::SetCFM(float cfm)
    engine->RegisterObjectMethod(className, "void SetCFM(float)", AS_METHODPR(T, SetCFM, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cfm(float)", AS_METHODPR(T, SetCFM, (float), void), AS_CALL_THISCALL);

    // void Constraint::SetConstraintType(ConstraintType type)
    engine->RegisterObjectMethod(className, "void SetConstraintType(ConstraintType)", AS_METHODPR(T, SetConstraintType, (ConstraintType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_constraintType(ConstraintType)", AS_METHODPR(T, SetConstraintType, (ConstraintType), void), AS_CALL_THISCALL);

    // void Constraint::SetDisableCollision(bool disable)
    engine->RegisterObjectMethod(className, "void SetDisableCollision(bool)", AS_METHODPR(T, SetDisableCollision, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_disableCollision(bool)", AS_METHODPR(T, SetDisableCollision, (bool), void), AS_CALL_THISCALL);

    // void Constraint::SetERP(float erp)
    engine->RegisterObjectMethod(className, "void SetERP(float)", AS_METHODPR(T, SetERP, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_erp(float)", AS_METHODPR(T, SetERP, (float), void), AS_CALL_THISCALL);

    // void Constraint::SetHighLimit(const Vector2& limit)
    engine->RegisterObjectMethod(className, "void SetHighLimit(const Vector2&in)", AS_METHODPR(T, SetHighLimit, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_highLimit(const Vector2&in)", AS_METHODPR(T, SetHighLimit, (const Vector2&), void), AS_CALL_THISCALL);

    // void Constraint::SetLowLimit(const Vector2& limit)
    engine->RegisterObjectMethod(className, "void SetLowLimit(const Vector2&in)", AS_METHODPR(T, SetLowLimit, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lowLimit(const Vector2&in)", AS_METHODPR(T, SetLowLimit, (const Vector2&), void), AS_CALL_THISCALL);

    // void Constraint::SetOtherAxis(const Vector3& axis)
    engine->RegisterObjectMethod(className, "void SetOtherAxis(const Vector3&in)", AS_METHODPR(T, SetOtherAxis, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherAxis(const Vector3&in)", AS_METHODPR(T, SetOtherAxis, (const Vector3&), void), AS_CALL_THISCALL);

    // void Constraint::SetOtherBody(RigidBody* body)
    engine->RegisterObjectMethod(className, "void SetOtherBody(RigidBody@+)", AS_METHODPR(T, SetOtherBody, (RigidBody*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherBody(RigidBody@+)", AS_METHODPR(T, SetOtherBody, (RigidBody*), void), AS_CALL_THISCALL);

    // void Constraint::SetOtherPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetOtherPosition(const Vector3&in)", AS_METHODPR(T, SetOtherPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherPosition(const Vector3&in)", AS_METHODPR(T, SetOtherPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void Constraint::SetOtherRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetOtherRotation(const Quaternion&in)", AS_METHODPR(T, SetOtherRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherRotation(const Quaternion&in)", AS_METHODPR(T, SetOtherRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void Constraint::SetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void Constraint::SetRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void Constraint::SetWorldPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetWorldPosition(const Vector3&in)", AS_METHODPR(T, SetWorldPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_worldPosition(const Vector3&in)", AS_METHODPR(T, SetWorldPosition, (const Vector3&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Constraint
        REGISTER_MEMBERS_MANUAL_PART_Constraint();
    #endif
}

// class PhysicsWorld | File: ../Physics/PhysicsWorld.h
template <class T> void RegisterMembers_PhysicsWorld(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void PhysicsWorld::ConvexCast(PhysicsRaycastResult& result, btCollisionShape* shape, const Vector3& startPos, const Quaternion& startRot, const Vector3& endPos, const Quaternion& endRot, unsigned collisionMask = M_MAX_UNSIGNED)
    // Error: type "btCollisionShape*" can not automatically bind
    // void PhysicsWorld::draw3dText(const btVector3& location, const char* textString) override
    // Error: type "const btVector3&" can not automatically bind
    // void PhysicsWorld::drawContactPoint(const btVector3& pointOnB, const btVector3& normalOnB, btScalar distance, int lifeTime, const btVector3& color) override
    // Error: type "const btVector3&" can not automatically bind
    // void PhysicsWorld::drawLine(const btVector3& from, const btVector3& to, const btVector3& color) override
    // Error: type "const btVector3&" can not automatically bind
    // void PhysicsWorld::GetCollidingBodies(PODVector<RigidBody*>& result, const RigidBody* body)
    // Error: type "PODVector<RigidBody*>&" can not automatically bind
    // CollisionGeometryDataCache& PhysicsWorld::GetConvexCache()
    // Error: type "CollisionGeometryDataCache&" can not automatically bind
    // CollisionGeometryDataCache& PhysicsWorld::GetGImpactTrimeshCache()
    // Error: type "CollisionGeometryDataCache&" can not automatically bind
    // void PhysicsWorld::GetRigidBodies(PODVector<RigidBody*>& result, const Sphere& sphere, unsigned collisionMask = M_MAX_UNSIGNED)
    // Error: type "PODVector<RigidBody*>&" can not automatically bind
    // void PhysicsWorld::GetRigidBodies(PODVector<RigidBody*>& result, const BoundingBox& box, unsigned collisionMask = M_MAX_UNSIGNED)
    // Error: type "PODVector<RigidBody*>&" can not automatically bind
    // void PhysicsWorld::GetRigidBodies(PODVector<RigidBody*>& result, const RigidBody* body)
    // Error: type "PODVector<RigidBody*>&" can not automatically bind
    // CollisionGeometryDataCache& PhysicsWorld::GetTriMeshCache()
    // Error: type "CollisionGeometryDataCache&" can not automatically bind
    // btDiscreteDynamicsWorld* PhysicsWorld::GetWorld()
    // Error: type "btDiscreteDynamicsWorld*" can not automatically bind
    // bool PhysicsWorld::isVisible(const btVector3& aabbMin, const btVector3& aabbMax) override
    // Error: type "const btVector3&" can not automatically bind
    // void PhysicsWorld::Raycast(PODVector<PhysicsRaycastResult>& result, const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)
    // Error: type "PODVector<PhysicsRaycastResult>&" can not automatically bind
    // void PhysicsWorld::reportErrorWarning(const char* warningString) override
    // Error: type "const char*" can not automatically bind

    // void PhysicsWorld::AddCollisionShape(CollisionShape* shape)
    engine->RegisterObjectMethod(className, "void AddCollisionShape(CollisionShape@+)", AS_METHODPR(T, AddCollisionShape, (CollisionShape*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::AddConstraint(Constraint* constraint)
    engine->RegisterObjectMethod(className, "void AddConstraint(Constraint@+)", AS_METHODPR(T, AddConstraint, (Constraint*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::AddDelayedWorldTransform(const DelayedWorldTransform& transform)
    engine->RegisterObjectMethod(className, "void AddDelayedWorldTransform(const DelayedWorldTransform&in)", AS_METHODPR(T, AddDelayedWorldTransform, (const DelayedWorldTransform&), void), AS_CALL_THISCALL);

    // void PhysicsWorld::AddRigidBody(RigidBody* body)
    engine->RegisterObjectMethod(className, "void AddRigidBody(RigidBody@+)", AS_METHODPR(T, AddRigidBody, (RigidBody*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::CleanupGeometryCache()
    engine->RegisterObjectMethod(className, "void CleanupGeometryCache()", AS_METHODPR(T, CleanupGeometryCache, (), void), AS_CALL_THISCALL);

    // void PhysicsWorld::ConvexCast(PhysicsRaycastResult& result, CollisionShape* shape, const Vector3& startPos, const Quaternion& startRot, const Vector3& endPos, const Quaternion& endRot, unsigned collisionMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void ConvexCast(PhysicsRaycastResult&, CollisionShape@+, const Vector3&in, const Quaternion&in, const Vector3&in, const Quaternion&in, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, ConvexCast, (PhysicsRaycastResult&, CollisionShape*, const Vector3&, const Quaternion&, const Vector3&, const Quaternion&, unsigned), void), AS_CALL_THISCALL);

    // void PhysicsWorld::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::DrawDebugGeometry(bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(bool)", AS_METHODPR(T, DrawDebugGeometry, (bool), void), AS_CALL_THISCALL);

    // int PhysicsWorld::getDebugMode() const override
    engine->RegisterObjectMethod(className, "int getDebugMode() const", AS_METHODPR(T, getDebugMode, () const, int), AS_CALL_THISCALL);

    // int PhysicsWorld::GetFps() const
    engine->RegisterObjectMethod(className, "int GetFps() const", AS_METHODPR(T, GetFps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_fps() const", AS_METHODPR(T, GetFps, () const, int), AS_CALL_THISCALL);

    // Vector3 PhysicsWorld::GetGravity() const
    engine->RegisterObjectMethod(className, "Vector3 GetGravity() const", AS_METHODPR(T, GetGravity, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_gravity() const", AS_METHODPR(T, GetGravity, () const, Vector3), AS_CALL_THISCALL);

    // bool PhysicsWorld::GetInternalEdge() const
    engine->RegisterObjectMethod(className, "bool GetInternalEdge() const", AS_METHODPR(T, GetInternalEdge, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_internalEdge() const", AS_METHODPR(T, GetInternalEdge, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld::GetInterpolation() const
    engine->RegisterObjectMethod(className, "bool GetInterpolation() const", AS_METHODPR(T, GetInterpolation, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_interpolation() const", AS_METHODPR(T, GetInterpolation, () const, bool), AS_CALL_THISCALL);

    // float PhysicsWorld::GetMaxNetworkAngularVelocity() const
    engine->RegisterObjectMethod(className, "float GetMaxNetworkAngularVelocity() const", AS_METHODPR(T, GetMaxNetworkAngularVelocity, () const, float), AS_CALL_THISCALL);

    // int PhysicsWorld::GetMaxSubSteps() const
    engine->RegisterObjectMethod(className, "int GetMaxSubSteps() const", AS_METHODPR(T, GetMaxSubSteps, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maxSubSteps() const", AS_METHODPR(T, GetMaxSubSteps, () const, int), AS_CALL_THISCALL);

    // int PhysicsWorld::GetNumIterations() const
    engine->RegisterObjectMethod(className, "int GetNumIterations() const", AS_METHODPR(T, GetNumIterations, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_numIterations() const", AS_METHODPR(T, GetNumIterations, () const, int), AS_CALL_THISCALL);

    // bool PhysicsWorld::GetSplitImpulse() const
    engine->RegisterObjectMethod(className, "bool GetSplitImpulse() const", AS_METHODPR(T, GetSplitImpulse, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_splitImpulse() const", AS_METHODPR(T, GetSplitImpulse, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld::IsApplyingTransforms() const
    engine->RegisterObjectMethod(className, "bool IsApplyingTransforms() const", AS_METHODPR(T, IsApplyingTransforms, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld::IsSimulating() const
    engine->RegisterObjectMethod(className, "bool IsSimulating() const", AS_METHODPR(T, IsSimulating, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld::IsUpdateEnabled() const
    engine->RegisterObjectMethod(className, "bool IsUpdateEnabled() const", AS_METHODPR(T, IsUpdateEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateEnabled() const", AS_METHODPR(T, IsUpdateEnabled, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void PhysicsWorld::RaycastSingle(PhysicsRaycastResult& result, const Ray& ray, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void RaycastSingle(PhysicsRaycastResult&, const Ray&in, float, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, RaycastSingle, (PhysicsRaycastResult&, const Ray&, float, unsigned), void), AS_CALL_THISCALL);

    // void PhysicsWorld::RaycastSingleSegmented(PhysicsRaycastResult& result, const Ray& ray, float maxDistance, float segmentDistance, unsigned collisionMask = M_MAX_UNSIGNED, float overlapDistance = 0.1f)
    engine->RegisterObjectMethod(className, "void RaycastSingleSegmented(PhysicsRaycastResult&, const Ray&in, float, float, uint = M_MAX_UNSIGNED, float = 0.1f)", AS_METHODPR(T, RaycastSingleSegmented, (PhysicsRaycastResult&, const Ray&, float, float, unsigned, float), void), AS_CALL_THISCALL);

    // void PhysicsWorld::RemoveCachedGeometry(Model* model)
    engine->RegisterObjectMethod(className, "void RemoveCachedGeometry(Model@+)", AS_METHODPR(T, RemoveCachedGeometry, (Model*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::RemoveCollisionShape(CollisionShape* shape)
    engine->RegisterObjectMethod(className, "void RemoveCollisionShape(CollisionShape@+)", AS_METHODPR(T, RemoveCollisionShape, (CollisionShape*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::RemoveConstraint(Constraint* constraint)
    engine->RegisterObjectMethod(className, "void RemoveConstraint(Constraint@+)", AS_METHODPR(T, RemoveConstraint, (Constraint*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::RemoveRigidBody(RigidBody* body)
    engine->RegisterObjectMethod(className, "void RemoveRigidBody(RigidBody@+)", AS_METHODPR(T, RemoveRigidBody, (RigidBody*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetApplyingTransforms(bool enable)
    engine->RegisterObjectMethod(className, "void SetApplyingTransforms(bool)", AS_METHODPR(T, SetApplyingTransforms, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetDebugDepthTest(bool enable)
    engine->RegisterObjectMethod(className, "void SetDebugDepthTest(bool)", AS_METHODPR(T, SetDebugDepthTest, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::setDebugMode(int debugMode) override
    engine->RegisterObjectMethod(className, "void setDebugMode(int)", AS_METHODPR(T, setDebugMode, (int), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetDebugRenderer(DebugRenderer* debug)
    engine->RegisterObjectMethod(className, "void SetDebugRenderer(DebugRenderer@+)", AS_METHODPR(T, SetDebugRenderer, (DebugRenderer*), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetFps(int fps)
    engine->RegisterObjectMethod(className, "void SetFps(int)", AS_METHODPR(T, SetFps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fps(int)", AS_METHODPR(T, SetFps, (int), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetGravity(const Vector3& gravity)
    engine->RegisterObjectMethod(className, "void SetGravity(const Vector3&in)", AS_METHODPR(T, SetGravity, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_gravity(const Vector3&in)", AS_METHODPR(T, SetGravity, (const Vector3&), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetInternalEdge(bool enable)
    engine->RegisterObjectMethod(className, "void SetInternalEdge(bool)", AS_METHODPR(T, SetInternalEdge, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_internalEdge(bool)", AS_METHODPR(T, SetInternalEdge, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetInterpolation(bool enable)
    engine->RegisterObjectMethod(className, "void SetInterpolation(bool)", AS_METHODPR(T, SetInterpolation, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_interpolation(bool)", AS_METHODPR(T, SetInterpolation, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetMaxNetworkAngularVelocity(float velocity)
    engine->RegisterObjectMethod(className, "void SetMaxNetworkAngularVelocity(float)", AS_METHODPR(T, SetMaxNetworkAngularVelocity, (float), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetMaxSubSteps(int num)
    engine->RegisterObjectMethod(className, "void SetMaxSubSteps(int)", AS_METHODPR(T, SetMaxSubSteps, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxSubSteps(int)", AS_METHODPR(T, SetMaxSubSteps, (int), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetNumIterations(int num)
    engine->RegisterObjectMethod(className, "void SetNumIterations(int)", AS_METHODPR(T, SetNumIterations, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numIterations(int)", AS_METHODPR(T, SetNumIterations, (int), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetSplitImpulse(bool enable)
    engine->RegisterObjectMethod(className, "void SetSplitImpulse(bool)", AS_METHODPR(T, SetSplitImpulse, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_splitImpulse(bool)", AS_METHODPR(T, SetSplitImpulse, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SetUpdateEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetUpdateEnabled(bool)", AS_METHODPR(T, SetUpdateEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateEnabled(bool)", AS_METHODPR(T, SetUpdateEnabled, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld::SphereCast(PhysicsRaycastResult& result, const Ray& ray, float radius, float maxDistance, unsigned collisionMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void SphereCast(PhysicsRaycastResult&, const Ray&in, float, float, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, SphereCast, (PhysicsRaycastResult&, const Ray&, float, float, unsigned), void), AS_CALL_THISCALL);

    // void PhysicsWorld::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    // void PhysicsWorld::UpdateCollisions()
    engine->RegisterObjectMethod(className, "void UpdateCollisions()", AS_METHODPR(T, UpdateCollisions, (), void), AS_CALL_THISCALL);

    // static struct PhysicsWorldConfig PhysicsWorld::config
    // Error: type "struct PhysicsWorldConfig" can not automatically bind

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PhysicsWorld
        REGISTER_MEMBERS_MANUAL_PART_PhysicsWorld();
    #endif
}

// class RigidBody | File: ../Physics/RigidBody.h
template <class T> void RegisterMembers_RigidBody(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // btRigidBody* RigidBody::GetBody() const
    // Error: type "btRigidBody*" can not automatically bind
    // void RigidBody::GetCollidingBodies(PODVector<RigidBody*>& result) const
    // Error: type "PODVector<RigidBody*>&" can not automatically bind
    // btCompoundShape* RigidBody::GetCompoundShape() const
    // Error: type "btCompoundShape*" can not automatically bind
    // const PODVector<unsigned char>& RigidBody::GetNetAngularVelocityAttr() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void RigidBody::getWorldTransform(btTransform& worldTrans) const override
    // Not registered because have @nobind mark
    // void RigidBody::SetNetAngularVelocityAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void RigidBody::setWorldTransform(const btTransform& worldTrans) override
    // Not registered because have @nobind mark

    // void RigidBody::Activate()
    engine->RegisterObjectMethod(className, "void Activate()", AS_METHODPR(T, Activate, (), void), AS_CALL_THISCALL);

    // void RigidBody::AddConstraint(Constraint* constraint)
    engine->RegisterObjectMethod(className, "void AddConstraint(Constraint@+)", AS_METHODPR(T, AddConstraint, (Constraint*), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyForce(const Vector3& force)
    engine->RegisterObjectMethod(className, "void ApplyForce(const Vector3&in)", AS_METHODPR(T, ApplyForce, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyForce(const Vector3& force, const Vector3& position)
    engine->RegisterObjectMethod(className, "void ApplyForce(const Vector3&in, const Vector3&in)", AS_METHODPR(T, ApplyForce, (const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyImpulse(const Vector3& impulse)
    engine->RegisterObjectMethod(className, "void ApplyImpulse(const Vector3&in)", AS_METHODPR(T, ApplyImpulse, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyImpulse(const Vector3& impulse, const Vector3& position)
    engine->RegisterObjectMethod(className, "void ApplyImpulse(const Vector3&in, const Vector3&in)", AS_METHODPR(T, ApplyImpulse, (const Vector3&, const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyTorque(const Vector3& torque)
    engine->RegisterObjectMethod(className, "void ApplyTorque(const Vector3&in)", AS_METHODPR(T, ApplyTorque, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyTorqueImpulse(const Vector3& torque)
    engine->RegisterObjectMethod(className, "void ApplyTorqueImpulse(const Vector3&in)", AS_METHODPR(T, ApplyTorqueImpulse, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::ApplyWorldTransform(const Vector3& newWorldPosition, const Quaternion& newWorldRotation)
    engine->RegisterObjectMethod(className, "void ApplyWorldTransform(const Vector3&in, const Quaternion&in)", AS_METHODPR(T, ApplyWorldTransform, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void RigidBody::DisableMassUpdate()
    engine->RegisterObjectMethod(className, "void DisableMassUpdate()", AS_METHODPR(T, DisableMassUpdate, (), void), AS_CALL_THISCALL);

    // void RigidBody::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void RigidBody::EnableMassUpdate()
    engine->RegisterObjectMethod(className, "void EnableMassUpdate()", AS_METHODPR(T, EnableMassUpdate, (), void), AS_CALL_THISCALL);

    // float RigidBody::GetAngularDamping() const
    engine->RegisterObjectMethod(className, "float GetAngularDamping() const", AS_METHODPR(T, GetAngularDamping, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_angularDamping() const", AS_METHODPR(T, GetAngularDamping, () const, float), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetAngularFactor() const
    engine->RegisterObjectMethod(className, "Vector3 GetAngularFactor() const", AS_METHODPR(T, GetAngularFactor, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_angularFactor() const", AS_METHODPR(T, GetAngularFactor, () const, Vector3), AS_CALL_THISCALL);

    // float RigidBody::GetAngularRestThreshold() const
    engine->RegisterObjectMethod(className, "float GetAngularRestThreshold() const", AS_METHODPR(T, GetAngularRestThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_angularRestThreshold() const", AS_METHODPR(T, GetAngularRestThreshold, () const, float), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetAngularVelocity() const
    engine->RegisterObjectMethod(className, "Vector3 GetAngularVelocity() const", AS_METHODPR(T, GetAngularVelocity, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_angularVelocity() const", AS_METHODPR(T, GetAngularVelocity, () const, Vector3), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetAnisotropicFriction() const
    engine->RegisterObjectMethod(className, "Vector3 GetAnisotropicFriction() const", AS_METHODPR(T, GetAnisotropicFriction, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_anisotropicFriction() const", AS_METHODPR(T, GetAnisotropicFriction, () const, Vector3), AS_CALL_THISCALL);

    // float RigidBody::GetCcdMotionThreshold() const
    engine->RegisterObjectMethod(className, "float GetCcdMotionThreshold() const", AS_METHODPR(T, GetCcdMotionThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_ccdMotionThreshold() const", AS_METHODPR(T, GetCcdMotionThreshold, () const, float), AS_CALL_THISCALL);

    // float RigidBody::GetCcdRadius() const
    engine->RegisterObjectMethod(className, "float GetCcdRadius() const", AS_METHODPR(T, GetCcdRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_ccdRadius() const", AS_METHODPR(T, GetCcdRadius, () const, float), AS_CALL_THISCALL);

    // const Vector3& RigidBody::GetCenterOfMass() const
    engine->RegisterObjectMethod(className, "const Vector3& GetCenterOfMass() const", AS_METHODPR(T, GetCenterOfMass, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_centerOfMass() const", AS_METHODPR(T, GetCenterOfMass, () const, const Vector3&), AS_CALL_THISCALL);

    // CollisionEventMode RigidBody::GetCollisionEventMode() const
    engine->RegisterObjectMethod(className, "CollisionEventMode GetCollisionEventMode() const", AS_METHODPR(T, GetCollisionEventMode, () const, CollisionEventMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "CollisionEventMode get_collisionEventMode() const", AS_METHODPR(T, GetCollisionEventMode, () const, CollisionEventMode), AS_CALL_THISCALL);

    // unsigned RigidBody::GetCollisionLayer() const
    engine->RegisterObjectMethod(className, "uint GetCollisionLayer() const", AS_METHODPR(T, GetCollisionLayer, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_collisionLayer() const", AS_METHODPR(T, GetCollisionLayer, () const, unsigned), AS_CALL_THISCALL);

    // unsigned RigidBody::GetCollisionMask() const
    engine->RegisterObjectMethod(className, "uint GetCollisionMask() const", AS_METHODPR(T, GetCollisionMask, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_collisionMask() const", AS_METHODPR(T, GetCollisionMask, () const, unsigned), AS_CALL_THISCALL);

    // float RigidBody::GetContactProcessingThreshold() const
    engine->RegisterObjectMethod(className, "float GetContactProcessingThreshold() const", AS_METHODPR(T, GetContactProcessingThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_contactProcessingThreshold() const", AS_METHODPR(T, GetContactProcessingThreshold, () const, float), AS_CALL_THISCALL);

    // float RigidBody::GetFriction() const
    engine->RegisterObjectMethod(className, "float GetFriction() const", AS_METHODPR(T, GetFriction, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_friction() const", AS_METHODPR(T, GetFriction, () const, float), AS_CALL_THISCALL);

    // const Vector3& RigidBody::GetGravityOverride() const
    engine->RegisterObjectMethod(className, "const Vector3& GetGravityOverride() const", AS_METHODPR(T, GetGravityOverride, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_gravityOverride() const", AS_METHODPR(T, GetGravityOverride, () const, const Vector3&), AS_CALL_THISCALL);

    // float RigidBody::GetLinearDamping() const
    engine->RegisterObjectMethod(className, "float GetLinearDamping() const", AS_METHODPR(T, GetLinearDamping, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_linearDamping() const", AS_METHODPR(T, GetLinearDamping, () const, float), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetLinearFactor() const
    engine->RegisterObjectMethod(className, "Vector3 GetLinearFactor() const", AS_METHODPR(T, GetLinearFactor, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_linearFactor() const", AS_METHODPR(T, GetLinearFactor, () const, Vector3), AS_CALL_THISCALL);

    // float RigidBody::GetLinearRestThreshold() const
    engine->RegisterObjectMethod(className, "float GetLinearRestThreshold() const", AS_METHODPR(T, GetLinearRestThreshold, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_linearRestThreshold() const", AS_METHODPR(T, GetLinearRestThreshold, () const, float), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetLinearVelocity() const
    engine->RegisterObjectMethod(className, "Vector3 GetLinearVelocity() const", AS_METHODPR(T, GetLinearVelocity, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_linearVelocity() const", AS_METHODPR(T, GetLinearVelocity, () const, Vector3), AS_CALL_THISCALL);

    // float RigidBody::GetMass() const
    engine->RegisterObjectMethod(className, "float GetMass() const", AS_METHODPR(T, GetMass, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mass() const", AS_METHODPR(T, GetMass, () const, float), AS_CALL_THISCALL);

    // PhysicsWorld* RigidBody::GetPhysicsWorld() const
    engine->RegisterObjectMethod(className, "PhysicsWorld@+ GetPhysicsWorld() const", AS_METHODPR(T, GetPhysicsWorld, () const, PhysicsWorld*), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetPosition() const
    engine->RegisterObjectMethod(className, "Vector3 GetPosition() const", AS_METHODPR(T, GetPosition, () const, Vector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector3 get_position() const", AS_METHODPR(T, GetPosition, () const, Vector3), AS_CALL_THISCALL);

    // float RigidBody::GetRestitution() const
    engine->RegisterObjectMethod(className, "float GetRestitution() const", AS_METHODPR(T, GetRestitution, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_restitution() const", AS_METHODPR(T, GetRestitution, () const, float), AS_CALL_THISCALL);

    // float RigidBody::GetRollingFriction() const
    engine->RegisterObjectMethod(className, "float GetRollingFriction() const", AS_METHODPR(T, GetRollingFriction, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rollingFriction() const", AS_METHODPR(T, GetRollingFriction, () const, float), AS_CALL_THISCALL);

    // Quaternion RigidBody::GetRotation() const
    engine->RegisterObjectMethod(className, "Quaternion GetRotation() const", AS_METHODPR(T, GetRotation, () const, Quaternion), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Quaternion get_rotation() const", AS_METHODPR(T, GetRotation, () const, Quaternion), AS_CALL_THISCALL);

    // bool RigidBody::GetUseGravity() const
    engine->RegisterObjectMethod(className, "bool GetUseGravity() const", AS_METHODPR(T, GetUseGravity, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useGravity() const", AS_METHODPR(T, GetUseGravity, () const, bool), AS_CALL_THISCALL);

    // Vector3 RigidBody::GetVelocityAtPoint(const Vector3& position) const
    engine->RegisterObjectMethod(className, "Vector3 GetVelocityAtPoint(const Vector3&in) const", AS_METHODPR(T, GetVelocityAtPoint, (const Vector3&) const, Vector3), AS_CALL_THISCALL);

    // bool RigidBody::IsActive() const
    engine->RegisterObjectMethod(className, "bool IsActive() const", AS_METHODPR(T, IsActive, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_active() const", AS_METHODPR(T, IsActive, () const, bool), AS_CALL_THISCALL);

    // bool RigidBody::IsKinematic() const
    engine->RegisterObjectMethod(className, "bool IsKinematic() const", AS_METHODPR(T, IsKinematic, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_kinematic() const", AS_METHODPR(T, IsKinematic, () const, bool), AS_CALL_THISCALL);

    // bool RigidBody::IsTrigger() const
    engine->RegisterObjectMethod(className, "bool IsTrigger() const", AS_METHODPR(T, IsTrigger, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_trigger() const", AS_METHODPR(T, IsTrigger, () const, bool), AS_CALL_THISCALL);

    // void RigidBody::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void RigidBody::ReAddBodyToWorld()
    engine->RegisterObjectMethod(className, "void ReAddBodyToWorld()", AS_METHODPR(T, ReAddBodyToWorld, (), void), AS_CALL_THISCALL);

    // void RigidBody::ReleaseBody()
    engine->RegisterObjectMethod(className, "void ReleaseBody()", AS_METHODPR(T, ReleaseBody, (), void), AS_CALL_THISCALL);

    // void RigidBody::RemoveConstraint(Constraint* constraint)
    engine->RegisterObjectMethod(className, "void RemoveConstraint(Constraint@+)", AS_METHODPR(T, RemoveConstraint, (Constraint*), void), AS_CALL_THISCALL);

    // void RigidBody::ResetForces()
    engine->RegisterObjectMethod(className, "void ResetForces()", AS_METHODPR(T, ResetForces, (), void), AS_CALL_THISCALL);

    // void RigidBody::SetAngularDamping(float damping)
    engine->RegisterObjectMethod(className, "void SetAngularDamping(float)", AS_METHODPR(T, SetAngularDamping, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angularDamping(float)", AS_METHODPR(T, SetAngularDamping, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetAngularFactor(const Vector3& factor)
    engine->RegisterObjectMethod(className, "void SetAngularFactor(const Vector3&in)", AS_METHODPR(T, SetAngularFactor, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angularFactor(const Vector3&in)", AS_METHODPR(T, SetAngularFactor, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetAngularRestThreshold(float threshold)
    engine->RegisterObjectMethod(className, "void SetAngularRestThreshold(float)", AS_METHODPR(T, SetAngularRestThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angularRestThreshold(float)", AS_METHODPR(T, SetAngularRestThreshold, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetAngularVelocity(const Vector3& velocity)
    engine->RegisterObjectMethod(className, "void SetAngularVelocity(const Vector3&in)", AS_METHODPR(T, SetAngularVelocity, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angularVelocity(const Vector3&in)", AS_METHODPR(T, SetAngularVelocity, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetAnisotropicFriction(const Vector3& friction)
    engine->RegisterObjectMethod(className, "void SetAnisotropicFriction(const Vector3&in)", AS_METHODPR(T, SetAnisotropicFriction, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anisotropicFriction(const Vector3&in)", AS_METHODPR(T, SetAnisotropicFriction, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetCcdMotionThreshold(float threshold)
    engine->RegisterObjectMethod(className, "void SetCcdMotionThreshold(float)", AS_METHODPR(T, SetCcdMotionThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ccdMotionThreshold(float)", AS_METHODPR(T, SetCcdMotionThreshold, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetCcdRadius(float radius)
    engine->RegisterObjectMethod(className, "void SetCcdRadius(float)", AS_METHODPR(T, SetCcdRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ccdRadius(float)", AS_METHODPR(T, SetCcdRadius, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetCollisionEventMode(CollisionEventMode mode)
    engine->RegisterObjectMethod(className, "void SetCollisionEventMode(CollisionEventMode)", AS_METHODPR(T, SetCollisionEventMode, (CollisionEventMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_collisionEventMode(CollisionEventMode)", AS_METHODPR(T, SetCollisionEventMode, (CollisionEventMode), void), AS_CALL_THISCALL);

    // void RigidBody::SetCollisionLayer(unsigned layer)
    engine->RegisterObjectMethod(className, "void SetCollisionLayer(uint)", AS_METHODPR(T, SetCollisionLayer, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_collisionLayer(uint)", AS_METHODPR(T, SetCollisionLayer, (unsigned), void), AS_CALL_THISCALL);

    // void RigidBody::SetCollisionLayerAndMask(unsigned layer, unsigned mask)
    engine->RegisterObjectMethod(className, "void SetCollisionLayerAndMask(uint, uint)", AS_METHODPR(T, SetCollisionLayerAndMask, (unsigned, unsigned), void), AS_CALL_THISCALL);

    // void RigidBody::SetCollisionMask(unsigned mask)
    engine->RegisterObjectMethod(className, "void SetCollisionMask(uint)", AS_METHODPR(T, SetCollisionMask, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_collisionMask(uint)", AS_METHODPR(T, SetCollisionMask, (unsigned), void), AS_CALL_THISCALL);

    // void RigidBody::SetContactProcessingThreshold(float threshold)
    engine->RegisterObjectMethod(className, "void SetContactProcessingThreshold(float)", AS_METHODPR(T, SetContactProcessingThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_contactProcessingThreshold(float)", AS_METHODPR(T, SetContactProcessingThreshold, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetFriction(float friction)
    engine->RegisterObjectMethod(className, "void SetFriction(float)", AS_METHODPR(T, SetFriction, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_friction(float)", AS_METHODPR(T, SetFriction, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetGravityOverride(const Vector3& gravity)
    engine->RegisterObjectMethod(className, "void SetGravityOverride(const Vector3&in)", AS_METHODPR(T, SetGravityOverride, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_gravityOverride(const Vector3&in)", AS_METHODPR(T, SetGravityOverride, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetKinematic(bool enable)
    engine->RegisterObjectMethod(className, "void SetKinematic(bool)", AS_METHODPR(T, SetKinematic, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_kinematic(bool)", AS_METHODPR(T, SetKinematic, (bool), void), AS_CALL_THISCALL);

    // void RigidBody::SetLinearDamping(float damping)
    engine->RegisterObjectMethod(className, "void SetLinearDamping(float)", AS_METHODPR(T, SetLinearDamping, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearDamping(float)", AS_METHODPR(T, SetLinearDamping, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetLinearFactor(const Vector3& factor)
    engine->RegisterObjectMethod(className, "void SetLinearFactor(const Vector3&in)", AS_METHODPR(T, SetLinearFactor, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearFactor(const Vector3&in)", AS_METHODPR(T, SetLinearFactor, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetLinearRestThreshold(float threshold)
    engine->RegisterObjectMethod(className, "void SetLinearRestThreshold(float)", AS_METHODPR(T, SetLinearRestThreshold, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearRestThreshold(float)", AS_METHODPR(T, SetLinearRestThreshold, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetLinearVelocity(const Vector3& velocity)
    engine->RegisterObjectMethod(className, "void SetLinearVelocity(const Vector3&in)", AS_METHODPR(T, SetLinearVelocity, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearVelocity(const Vector3&in)", AS_METHODPR(T, SetLinearVelocity, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetMass(float mass)
    engine->RegisterObjectMethod(className, "void SetMass(float)", AS_METHODPR(T, SetMass, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mass(float)", AS_METHODPR(T, SetMass, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetPosition(const Vector3& position)
    engine->RegisterObjectMethod(className, "void SetPosition(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_position(const Vector3&in)", AS_METHODPR(T, SetPosition, (const Vector3&), void), AS_CALL_THISCALL);

    // void RigidBody::SetRestitution(float restitution)
    engine->RegisterObjectMethod(className, "void SetRestitution(float)", AS_METHODPR(T, SetRestitution, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_restitution(float)", AS_METHODPR(T, SetRestitution, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetRollingFriction(float friction)
    engine->RegisterObjectMethod(className, "void SetRollingFriction(float)", AS_METHODPR(T, SetRollingFriction, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rollingFriction(float)", AS_METHODPR(T, SetRollingFriction, (float), void), AS_CALL_THISCALL);

    // void RigidBody::SetRotation(const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetRotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rotation(const Quaternion&in)", AS_METHODPR(T, SetRotation, (const Quaternion&), void), AS_CALL_THISCALL);

    // void RigidBody::SetTransform(const Vector3& position, const Quaternion& rotation)
    engine->RegisterObjectMethod(className, "void SetTransform(const Vector3&in, const Quaternion&in)", AS_METHODPR(T, SetTransform, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void RigidBody::SetTrigger(bool enable)
    engine->RegisterObjectMethod(className, "void SetTrigger(bool)", AS_METHODPR(T, SetTrigger, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_trigger(bool)", AS_METHODPR(T, SetTrigger, (bool), void), AS_CALL_THISCALL);

    // void RigidBody::SetUseGravity(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseGravity(bool)", AS_METHODPR(T, SetUseGravity, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useGravity(bool)", AS_METHODPR(T, SetUseGravity, (bool), void), AS_CALL_THISCALL);

    // void RigidBody::UpdateGravity()
    engine->RegisterObjectMethod(className, "void UpdateGravity()", AS_METHODPR(T, UpdateGravity, (), void), AS_CALL_THISCALL);

    // void RigidBody::UpdateMass()
    engine->RegisterObjectMethod(className, "void UpdateMass()", AS_METHODPR(T, UpdateMass, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RigidBody
        REGISTER_MEMBERS_MANUAL_PART_RigidBody();
    #endif
}

#endif // def URHO3D_PHYSICS

#ifdef URHO3D_URHO2D

// class CollisionShape2D | File: ../Urho2D/CollisionShape2D.h
template <class T> void RegisterMembers_CollisionShape2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // b2Fixture* CollisionShape2D::GetFixture() const
    // Error: type "b2Fixture*" can not automatically bind

    // void CollisionShape2D::CreateFixture()
    engine->RegisterObjectMethod(className, "void CreateFixture()", AS_METHODPR(T, CreateFixture, (), void), AS_CALL_THISCALL);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // int CollisionShape2D::GetCategoryBits() const
    engine->RegisterObjectMethod(className, "int GetCategoryBits() const", AS_METHODPR(T, GetCategoryBits, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_categoryBits() const", AS_METHODPR(T, GetCategoryBits, () const, int), AS_CALL_THISCALL);

    // float CollisionShape2D::GetDensity() const
    engine->RegisterObjectMethod(className, "float GetDensity() const", AS_METHODPR(T, GetDensity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_density() const", AS_METHODPR(T, GetDensity, () const, float), AS_CALL_THISCALL);

    // float CollisionShape2D::GetFriction() const
    engine->RegisterObjectMethod(className, "float GetFriction() const", AS_METHODPR(T, GetFriction, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_friction() const", AS_METHODPR(T, GetFriction, () const, float), AS_CALL_THISCALL);

    // int CollisionShape2D::GetGroupIndex() const
    engine->RegisterObjectMethod(className, "int GetGroupIndex() const", AS_METHODPR(T, GetGroupIndex, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_groupIndex() const", AS_METHODPR(T, GetGroupIndex, () const, int), AS_CALL_THISCALL);

    // float CollisionShape2D::GetInertia() const
    engine->RegisterObjectMethod(className, "float GetInertia() const", AS_METHODPR(T, GetInertia, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_inertia() const", AS_METHODPR(T, GetInertia, () const, float), AS_CALL_THISCALL);

    // int CollisionShape2D::GetMaskBits() const
    engine->RegisterObjectMethod(className, "int GetMaskBits() const", AS_METHODPR(T, GetMaskBits, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_maskBits() const", AS_METHODPR(T, GetMaskBits, () const, int), AS_CALL_THISCALL);

    // float CollisionShape2D::GetMass() const
    engine->RegisterObjectMethod(className, "float GetMass() const", AS_METHODPR(T, GetMass, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mass() const", AS_METHODPR(T, GetMass, () const, float), AS_CALL_THISCALL);

    // Vector2 CollisionShape2D::GetMassCenter() const
    engine->RegisterObjectMethod(className, "Vector2 GetMassCenter() const", AS_METHODPR(T, GetMassCenter, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_massCenter() const", AS_METHODPR(T, GetMassCenter, () const, Vector2), AS_CALL_THISCALL);

    // float CollisionShape2D::GetRestitution() const
    engine->RegisterObjectMethod(className, "float GetRestitution() const", AS_METHODPR(T, GetRestitution, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_restitution() const", AS_METHODPR(T, GetRestitution, () const, float), AS_CALL_THISCALL);

    // bool CollisionShape2D::IsTrigger() const
    engine->RegisterObjectMethod(className, "bool IsTrigger() const", AS_METHODPR(T, IsTrigger, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_trigger() const", AS_METHODPR(T, IsTrigger, () const, bool), AS_CALL_THISCALL);

    // void CollisionShape2D::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void CollisionShape2D::ReleaseFixture()
    engine->RegisterObjectMethod(className, "void ReleaseFixture()", AS_METHODPR(T, ReleaseFixture, (), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetCategoryBits(int categoryBits)
    engine->RegisterObjectMethod(className, "void SetCategoryBits(int)", AS_METHODPR(T, SetCategoryBits, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_categoryBits(int)", AS_METHODPR(T, SetCategoryBits, (int), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetDensity(float density)
    engine->RegisterObjectMethod(className, "void SetDensity(float)", AS_METHODPR(T, SetDensity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_density(float)", AS_METHODPR(T, SetDensity, (float), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetFriction(float friction)
    engine->RegisterObjectMethod(className, "void SetFriction(float)", AS_METHODPR(T, SetFriction, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_friction(float)", AS_METHODPR(T, SetFriction, (float), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetGroupIndex(int groupIndex)
    engine->RegisterObjectMethod(className, "void SetGroupIndex(int)", AS_METHODPR(T, SetGroupIndex, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_groupIndex(int)", AS_METHODPR(T, SetGroupIndex, (int), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetMaskBits(int maskBits)
    engine->RegisterObjectMethod(className, "void SetMaskBits(int)", AS_METHODPR(T, SetMaskBits, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maskBits(int)", AS_METHODPR(T, SetMaskBits, (int), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetRestitution(float restitution)
    engine->RegisterObjectMethod(className, "void SetRestitution(float)", AS_METHODPR(T, SetRestitution, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_restitution(float)", AS_METHODPR(T, SetRestitution, (float), void), AS_CALL_THISCALL);

    // void CollisionShape2D::SetTrigger(bool trigger)
    engine->RegisterObjectMethod(className, "void SetTrigger(bool)", AS_METHODPR(T, SetTrigger, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_trigger(bool)", AS_METHODPR(T, SetTrigger, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionShape2D
        REGISTER_MEMBERS_MANUAL_PART_CollisionShape2D();
    #endif
}

// class Constraint2D | File: ../Urho2D/Constraint2D.h
template <class T> void RegisterMembers_Constraint2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // b2Joint* Constraint2D::GetJoint() const
    // Error: type "b2Joint*" can not automatically bind

    // void Constraint2D::CreateJoint()
    engine->RegisterObjectMethod(className, "void CreateJoint()", AS_METHODPR(T, CreateJoint, (), void), AS_CALL_THISCALL);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // Constraint2D* Constraint2D::GetAttachedConstraint() const
    engine->RegisterObjectMethod(className, "Constraint2D@+ GetAttachedConstraint() const", AS_METHODPR(T, GetAttachedConstraint, () const, Constraint2D*), AS_CALL_THISCALL);

    // bool Constraint2D::GetCollideConnected() const
    engine->RegisterObjectMethod(className, "bool GetCollideConnected() const", AS_METHODPR(T, GetCollideConnected, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_collideConnected() const", AS_METHODPR(T, GetCollideConnected, () const, bool), AS_CALL_THISCALL);

    // RigidBody2D* Constraint2D::GetOtherBody() const
    engine->RegisterObjectMethod(className, "RigidBody2D@+ GetOtherBody() const", AS_METHODPR(T, GetOtherBody, () const, RigidBody2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RigidBody2D@+ get_otherBody() const", AS_METHODPR(T, GetOtherBody, () const, RigidBody2D*), AS_CALL_THISCALL);

    // RigidBody2D* Constraint2D::GetOwnerBody() const
    engine->RegisterObjectMethod(className, "RigidBody2D@+ GetOwnerBody() const", AS_METHODPR(T, GetOwnerBody, () const, RigidBody2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "RigidBody2D@+ get_ownerBody() const", AS_METHODPR(T, GetOwnerBody, () const, RigidBody2D*), AS_CALL_THISCALL);

    // void Constraint2D::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void Constraint2D::ReleaseJoint()
    engine->RegisterObjectMethod(className, "void ReleaseJoint()", AS_METHODPR(T, ReleaseJoint, (), void), AS_CALL_THISCALL);

    // void Constraint2D::SetAttachedConstraint(Constraint2D* constraint)
    engine->RegisterObjectMethod(className, "void SetAttachedConstraint(Constraint2D@+)", AS_METHODPR(T, SetAttachedConstraint, (Constraint2D*), void), AS_CALL_THISCALL);

    // void Constraint2D::SetCollideConnected(bool collideConnected)
    engine->RegisterObjectMethod(className, "void SetCollideConnected(bool)", AS_METHODPR(T, SetCollideConnected, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_collideConnected(bool)", AS_METHODPR(T, SetCollideConnected, (bool), void), AS_CALL_THISCALL);

    // void Constraint2D::SetOtherBody(RigidBody2D* body)
    engine->RegisterObjectMethod(className, "void SetOtherBody(RigidBody2D@+)", AS_METHODPR(T, SetOtherBody, (RigidBody2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherBody(RigidBody2D@+)", AS_METHODPR(T, SetOtherBody, (RigidBody2D*), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Constraint2D
        REGISTER_MEMBERS_MANUAL_PART_Constraint2D();
    #endif
}

// class PhysicsWorld2D | File: ../Urho2D/PhysicsWorld2D.h
template <class T> void RegisterMembers_PhysicsWorld2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void PhysicsWorld2D::BeginContact(b2Contact* contact) override
    // Error: type "b2Contact*" can not automatically bind
    // void PhysicsWorld2D::DrawCircle(const b2Vec2& center, float32 radius, const b2Color& color) override
    // Error: type "const b2Vec2&" can not automatically bind
    // void PhysicsWorld2D::DrawPoint(const b2Vec2& p, float32 size, const b2Color& color) override
    // Error: type "const b2Vec2&" can not automatically bind
    // void PhysicsWorld2D::DrawPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) override
    // Error: type "const b2Vec2*" can not automatically bind
    // void PhysicsWorld2D::DrawSegment(const b2Vec2& p1, const b2Vec2& p2, const b2Color& color) override
    // Error: type "const b2Vec2&" can not automatically bind
    // void PhysicsWorld2D::DrawSolidCircle(const b2Vec2& center, float32 radius, const b2Vec2& axis, const b2Color& color) override
    // Error: type "const b2Vec2&" can not automatically bind
    // void PhysicsWorld2D::DrawSolidPolygon(const b2Vec2* vertices, int32 vertexCount, const b2Color& color) override
    // Error: type "const b2Vec2*" can not automatically bind
    // void PhysicsWorld2D::DrawTransform(const b2Transform& xf) override
    // Error: type "const b2Transform&" can not automatically bind
    // void PhysicsWorld2D::EndContact(b2Contact* contact) override
    // Error: type "b2Contact*" can not automatically bind
    // void PhysicsWorld2D::GetRigidBodies(PODVector<RigidBody2D*>& results, const Rect& aabb, unsigned collisionMask = M_MAX_UNSIGNED)
    // Error: type "PODVector<RigidBody2D*>&" can not automatically bind
    // b2World* PhysicsWorld2D::GetWorld()
    // Error: type "b2World*" can not automatically bind
    // void PhysicsWorld2D::PreSolve(b2Contact* contact, const b2Manifold* oldManifold) override
    // Error: type "b2Contact*" can not automatically bind
    // void PhysicsWorld2D::Raycast(PODVector<PhysicsRaycastResult2D>& results, const Vector2& startPoint, const Vector2& endPoint, unsigned collisionMask = M_MAX_UNSIGNED)
    // Error: type "PODVector<PhysicsRaycastResult2D>&" can not automatically bind

    // void PhysicsWorld2D::AddDelayedWorldTransform(const DelayedWorldTransform2D& transform)
    engine->RegisterObjectMethod(className, "void AddDelayedWorldTransform(const DelayedWorldTransform2D&in)", AS_METHODPR(T, AddDelayedWorldTransform, (const DelayedWorldTransform2D&), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::AddRigidBody(RigidBody2D* rigidBody)
    engine->RegisterObjectMethod(className, "void AddRigidBody(RigidBody2D@+)", AS_METHODPR(T, AddRigidBody, (RigidBody2D*), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::DrawDebugGeometry()
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry()", AS_METHODPR(T, DrawDebugGeometry, (), void), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetAllowSleeping() const
    engine->RegisterObjectMethod(className, "bool GetAllowSleeping() const", AS_METHODPR(T, GetAllowSleeping, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_allowSleeping() const", AS_METHODPR(T, GetAllowSleeping, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetAutoClearForces() const
    engine->RegisterObjectMethod(className, "bool GetAutoClearForces() const", AS_METHODPR(T, GetAutoClearForces, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoClearForces() const", AS_METHODPR(T, GetAutoClearForces, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetContinuousPhysics() const
    engine->RegisterObjectMethod(className, "bool GetContinuousPhysics() const", AS_METHODPR(T, GetContinuousPhysics, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_continuousPhysics() const", AS_METHODPR(T, GetContinuousPhysics, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetDrawAabb() const
    engine->RegisterObjectMethod(className, "bool GetDrawAabb() const", AS_METHODPR(T, GetDrawAabb, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawAabb() const", AS_METHODPR(T, GetDrawAabb, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetDrawCenterOfMass() const
    engine->RegisterObjectMethod(className, "bool GetDrawCenterOfMass() const", AS_METHODPR(T, GetDrawCenterOfMass, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawCenterOfMass() const", AS_METHODPR(T, GetDrawCenterOfMass, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetDrawJoint() const
    engine->RegisterObjectMethod(className, "bool GetDrawJoint() const", AS_METHODPR(T, GetDrawJoint, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawJoint() const", AS_METHODPR(T, GetDrawJoint, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetDrawPair() const
    engine->RegisterObjectMethod(className, "bool GetDrawPair() const", AS_METHODPR(T, GetDrawPair, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawPair() const", AS_METHODPR(T, GetDrawPair, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetDrawShape() const
    engine->RegisterObjectMethod(className, "bool GetDrawShape() const", AS_METHODPR(T, GetDrawShape, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawShape() const", AS_METHODPR(T, GetDrawShape, () const, bool), AS_CALL_THISCALL);

    // const Vector2& PhysicsWorld2D::GetGravity() const
    engine->RegisterObjectMethod(className, "const Vector2& GetGravity() const", AS_METHODPR(T, GetGravity, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_gravity() const", AS_METHODPR(T, GetGravity, () const, const Vector2&), AS_CALL_THISCALL);

    // int PhysicsWorld2D::GetPositionIterations() const
    engine->RegisterObjectMethod(className, "int GetPositionIterations() const", AS_METHODPR(T, GetPositionIterations, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_positionIterations() const", AS_METHODPR(T, GetPositionIterations, () const, int), AS_CALL_THISCALL);

    // RigidBody2D* PhysicsWorld2D::GetRigidBody(const Vector2& point, unsigned collisionMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "RigidBody2D@+ GetRigidBody(const Vector2&in, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, GetRigidBody, (const Vector2&, unsigned), RigidBody2D*), AS_CALL_THISCALL);

    // RigidBody2D* PhysicsWorld2D::GetRigidBody(int screenX, int screenY, unsigned collisionMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "RigidBody2D@+ GetRigidBody(int, int, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, GetRigidBody, (int, int, unsigned), RigidBody2D*), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetSubStepping() const
    engine->RegisterObjectMethod(className, "bool GetSubStepping() const", AS_METHODPR(T, GetSubStepping, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_subStepping() const", AS_METHODPR(T, GetSubStepping, () const, bool), AS_CALL_THISCALL);

    // int PhysicsWorld2D::GetVelocityIterations() const
    engine->RegisterObjectMethod(className, "int GetVelocityIterations() const", AS_METHODPR(T, GetVelocityIterations, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_velocityIterations() const", AS_METHODPR(T, GetVelocityIterations, () const, int), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::GetWarmStarting() const
    engine->RegisterObjectMethod(className, "bool GetWarmStarting() const", AS_METHODPR(T, GetWarmStarting, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_warmStarting() const", AS_METHODPR(T, GetWarmStarting, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::IsApplyingTransforms() const
    engine->RegisterObjectMethod(className, "bool IsApplyingTransforms() const", AS_METHODPR(T, IsApplyingTransforms, () const, bool), AS_CALL_THISCALL);

    // bool PhysicsWorld2D::IsUpdateEnabled() const
    engine->RegisterObjectMethod(className, "bool IsUpdateEnabled() const", AS_METHODPR(T, IsUpdateEnabled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateEnabled() const", AS_METHODPR(T, IsUpdateEnabled, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::RaycastSingle(PhysicsRaycastResult2D& result, const Vector2& startPoint, const Vector2& endPoint, unsigned collisionMask = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void RaycastSingle(PhysicsRaycastResult2D&, const Vector2&in, const Vector2&in, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, RaycastSingle, (PhysicsRaycastResult2D&, const Vector2&, const Vector2&, unsigned), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::RemoveRigidBody(RigidBody2D* rigidBody)
    engine->RegisterObjectMethod(className, "void RemoveRigidBody(RigidBody2D@+)", AS_METHODPR(T, RemoveRigidBody, (RigidBody2D*), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetAllowSleeping(bool enable)
    engine->RegisterObjectMethod(className, "void SetAllowSleeping(bool)", AS_METHODPR(T, SetAllowSleeping, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_allowSleeping(bool)", AS_METHODPR(T, SetAllowSleeping, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetApplyingTransforms(bool enable)
    engine->RegisterObjectMethod(className, "void SetApplyingTransforms(bool)", AS_METHODPR(T, SetApplyingTransforms, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetAutoClearForces(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoClearForces(bool)", AS_METHODPR(T, SetAutoClearForces, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoClearForces(bool)", AS_METHODPR(T, SetAutoClearForces, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetContinuousPhysics(bool enable)
    engine->RegisterObjectMethod(className, "void SetContinuousPhysics(bool)", AS_METHODPR(T, SetContinuousPhysics, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_continuousPhysics(bool)", AS_METHODPR(T, SetContinuousPhysics, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetDrawAabb(bool drawAabb)
    engine->RegisterObjectMethod(className, "void SetDrawAabb(bool)", AS_METHODPR(T, SetDrawAabb, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawAabb(bool)", AS_METHODPR(T, SetDrawAabb, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetDrawCenterOfMass(bool drawCenterOfMass)
    engine->RegisterObjectMethod(className, "void SetDrawCenterOfMass(bool)", AS_METHODPR(T, SetDrawCenterOfMass, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawCenterOfMass(bool)", AS_METHODPR(T, SetDrawCenterOfMass, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetDrawJoint(bool drawJoint)
    engine->RegisterObjectMethod(className, "void SetDrawJoint(bool)", AS_METHODPR(T, SetDrawJoint, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawJoint(bool)", AS_METHODPR(T, SetDrawJoint, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetDrawPair(bool drawPair)
    engine->RegisterObjectMethod(className, "void SetDrawPair(bool)", AS_METHODPR(T, SetDrawPair, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawPair(bool)", AS_METHODPR(T, SetDrawPair, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetDrawShape(bool drawShape)
    engine->RegisterObjectMethod(className, "void SetDrawShape(bool)", AS_METHODPR(T, SetDrawShape, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawShape(bool)", AS_METHODPR(T, SetDrawShape, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetGravity(const Vector2& gravity)
    engine->RegisterObjectMethod(className, "void SetGravity(const Vector2&in)", AS_METHODPR(T, SetGravity, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_gravity(const Vector2&in)", AS_METHODPR(T, SetGravity, (const Vector2&), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetPositionIterations(int positionIterations)
    engine->RegisterObjectMethod(className, "void SetPositionIterations(int)", AS_METHODPR(T, SetPositionIterations, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_positionIterations(int)", AS_METHODPR(T, SetPositionIterations, (int), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetSubStepping(bool enable)
    engine->RegisterObjectMethod(className, "void SetSubStepping(bool)", AS_METHODPR(T, SetSubStepping, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_subStepping(bool)", AS_METHODPR(T, SetSubStepping, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetUpdateEnabled(bool enable)
    engine->RegisterObjectMethod(className, "void SetUpdateEnabled(bool)", AS_METHODPR(T, SetUpdateEnabled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateEnabled(bool)", AS_METHODPR(T, SetUpdateEnabled, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetVelocityIterations(int velocityIterations)
    engine->RegisterObjectMethod(className, "void SetVelocityIterations(int)", AS_METHODPR(T, SetVelocityIterations, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_velocityIterations(int)", AS_METHODPR(T, SetVelocityIterations, (int), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::SetWarmStarting(bool enable)
    engine->RegisterObjectMethod(className, "void SetWarmStarting(bool)", AS_METHODPR(T, SetWarmStarting, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_warmStarting(bool)", AS_METHODPR(T, SetWarmStarting, (bool), void), AS_CALL_THISCALL);

    // void PhysicsWorld2D::Update(float timeStep)
    engine->RegisterObjectMethod(className, "void Update(float)", AS_METHODPR(T, Update, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_PhysicsWorld2D
        REGISTER_MEMBERS_MANUAL_PART_PhysicsWorld2D();
    #endif
}

// class RigidBody2D | File: ../Urho2D/RigidBody2D.h
template <class T> void RegisterMembers_RigidBody2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // b2Body* RigidBody2D::GetBody() const
    // Error: type "b2Body*" can not automatically bind

    // void RigidBody2D::AddCollisionShape2D(CollisionShape2D* collisionShape)
    engine->RegisterObjectMethod(className, "void AddCollisionShape2D(CollisionShape2D@+)", AS_METHODPR(T, AddCollisionShape2D, (CollisionShape2D*), void), AS_CALL_THISCALL);

    // void RigidBody2D::AddConstraint2D(Constraint2D* constraint)
    engine->RegisterObjectMethod(className, "void AddConstraint2D(Constraint2D@+)", AS_METHODPR(T, AddConstraint2D, (Constraint2D*), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyAngularImpulse(float impulse, bool wake)
    engine->RegisterObjectMethod(className, "void ApplyAngularImpulse(float, bool)", AS_METHODPR(T, ApplyAngularImpulse, (float, bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyForce(const Vector2& force, const Vector2& point, bool wake)
    engine->RegisterObjectMethod(className, "void ApplyForce(const Vector2&in, const Vector2&in, bool)", AS_METHODPR(T, ApplyForce, (const Vector2&, const Vector2&, bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyForceToCenter(const Vector2& force, bool wake)
    engine->RegisterObjectMethod(className, "void ApplyForceToCenter(const Vector2&in, bool)", AS_METHODPR(T, ApplyForceToCenter, (const Vector2&, bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyLinearImpulse(const Vector2& impulse, const Vector2& point, bool wake)
    engine->RegisterObjectMethod(className, "void ApplyLinearImpulse(const Vector2&in, const Vector2&in, bool)", AS_METHODPR(T, ApplyLinearImpulse, (const Vector2&, const Vector2&, bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyLinearImpulseToCenter(const Vector2& impulse, bool wake)
    engine->RegisterObjectMethod(className, "void ApplyLinearImpulseToCenter(const Vector2&in, bool)", AS_METHODPR(T, ApplyLinearImpulseToCenter, (const Vector2&, bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyTorque(float torque, bool wake)
    engine->RegisterObjectMethod(className, "void ApplyTorque(float, bool)", AS_METHODPR(T, ApplyTorque, (float, bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyWorldTransform()
    engine->RegisterObjectMethod(className, "void ApplyWorldTransform()", AS_METHODPR(T, ApplyWorldTransform, (), void), AS_CALL_THISCALL);

    // void RigidBody2D::ApplyWorldTransform(const Vector3& newWorldPosition, const Quaternion& newWorldRotation)
    engine->RegisterObjectMethod(className, "void ApplyWorldTransform(const Vector3&in, const Quaternion&in)", AS_METHODPR(T, ApplyWorldTransform, (const Vector3&, const Quaternion&), void), AS_CALL_THISCALL);

    // void RigidBody2D::CreateBody()
    engine->RegisterObjectMethod(className, "void CreateBody()", AS_METHODPR(T, CreateBody, (), void), AS_CALL_THISCALL);

    // virtual void Component::DrawDebugGeometry(DebugRenderer* debug, bool depthTest)
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // float RigidBody2D::GetAngularDamping() const
    engine->RegisterObjectMethod(className, "float GetAngularDamping() const", AS_METHODPR(T, GetAngularDamping, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_angularDamping() const", AS_METHODPR(T, GetAngularDamping, () const, float), AS_CALL_THISCALL);

    // float RigidBody2D::GetAngularVelocity() const
    engine->RegisterObjectMethod(className, "float GetAngularVelocity() const", AS_METHODPR(T, GetAngularVelocity, () const, float), AS_CALL_THISCALL);

    // BodyType2D RigidBody2D::GetBodyType() const
    engine->RegisterObjectMethod(className, "BodyType2D GetBodyType() const", AS_METHODPR(T, GetBodyType, () const, BodyType2D), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BodyType2D get_bodyType() const", AS_METHODPR(T, GetBodyType, () const, BodyType2D), AS_CALL_THISCALL);

    // float RigidBody2D::GetGravityScale() const
    engine->RegisterObjectMethod(className, "float GetGravityScale() const", AS_METHODPR(T, GetGravityScale, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_gravityScale() const", AS_METHODPR(T, GetGravityScale, () const, float), AS_CALL_THISCALL);

    // float RigidBody2D::GetInertia() const
    engine->RegisterObjectMethod(className, "float GetInertia() const", AS_METHODPR(T, GetInertia, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_inertia() const", AS_METHODPR(T, GetInertia, () const, float), AS_CALL_THISCALL);

    // float RigidBody2D::GetLinearDamping() const
    engine->RegisterObjectMethod(className, "float GetLinearDamping() const", AS_METHODPR(T, GetLinearDamping, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_linearDamping() const", AS_METHODPR(T, GetLinearDamping, () const, float), AS_CALL_THISCALL);

    // Vector2 RigidBody2D::GetLinearVelocity() const
    engine->RegisterObjectMethod(className, "Vector2 GetLinearVelocity() const", AS_METHODPR(T, GetLinearVelocity, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_linearVelocity() const", AS_METHODPR(T, GetLinearVelocity, () const, Vector2), AS_CALL_THISCALL);

    // float RigidBody2D::GetMass() const
    engine->RegisterObjectMethod(className, "float GetMass() const", AS_METHODPR(T, GetMass, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_mass() const", AS_METHODPR(T, GetMass, () const, float), AS_CALL_THISCALL);

    // Vector2 RigidBody2D::GetMassCenter() const
    engine->RegisterObjectMethod(className, "Vector2 GetMassCenter() const", AS_METHODPR(T, GetMassCenter, () const, Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_massCenter() const", AS_METHODPR(T, GetMassCenter, () const, Vector2), AS_CALL_THISCALL);

    // bool RigidBody2D::GetUseFixtureMass() const
    engine->RegisterObjectMethod(className, "bool GetUseFixtureMass() const", AS_METHODPR(T, GetUseFixtureMass, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useFixtureMass() const", AS_METHODPR(T, GetUseFixtureMass, () const, bool), AS_CALL_THISCALL);

    // bool RigidBody2D::IsAllowSleep() const
    engine->RegisterObjectMethod(className, "bool IsAllowSleep() const", AS_METHODPR(T, IsAllowSleep, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_allowSleep() const", AS_METHODPR(T, IsAllowSleep, () const, bool), AS_CALL_THISCALL);

    // bool RigidBody2D::IsAwake() const
    engine->RegisterObjectMethod(className, "bool IsAwake() const", AS_METHODPR(T, IsAwake, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_awake() const", AS_METHODPR(T, IsAwake, () const, bool), AS_CALL_THISCALL);

    // bool RigidBody2D::IsBullet() const
    engine->RegisterObjectMethod(className, "bool IsBullet() const", AS_METHODPR(T, IsBullet, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_bullet() const", AS_METHODPR(T, IsBullet, () const, bool), AS_CALL_THISCALL);

    // bool RigidBody2D::IsFixedRotation() const
    engine->RegisterObjectMethod(className, "bool IsFixedRotation() const", AS_METHODPR(T, IsFixedRotation, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedRotation() const", AS_METHODPR(T, IsFixedRotation, () const, bool), AS_CALL_THISCALL);

    // void RigidBody2D::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void RigidBody2D::ReleaseBody()
    engine->RegisterObjectMethod(className, "void ReleaseBody()", AS_METHODPR(T, ReleaseBody, (), void), AS_CALL_THISCALL);

    // void RigidBody2D::RemoveCollisionShape2D(CollisionShape2D* collisionShape)
    engine->RegisterObjectMethod(className, "void RemoveCollisionShape2D(CollisionShape2D@+)", AS_METHODPR(T, RemoveCollisionShape2D, (CollisionShape2D*), void), AS_CALL_THISCALL);

    // void RigidBody2D::RemoveConstraint2D(Constraint2D* constraint)
    engine->RegisterObjectMethod(className, "void RemoveConstraint2D(Constraint2D@+)", AS_METHODPR(T, RemoveConstraint2D, (Constraint2D*), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetAllowSleep(bool allowSleep)
    engine->RegisterObjectMethod(className, "void SetAllowSleep(bool)", AS_METHODPR(T, SetAllowSleep, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_allowSleep(bool)", AS_METHODPR(T, SetAllowSleep, (bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetAngularDamping(float angularDamping)
    engine->RegisterObjectMethod(className, "void SetAngularDamping(float)", AS_METHODPR(T, SetAngularDamping, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angularDamping(float)", AS_METHODPR(T, SetAngularDamping, (float), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetAngularVelocity(float angularVelocity)
    engine->RegisterObjectMethod(className, "void SetAngularVelocity(float)", AS_METHODPR(T, SetAngularVelocity, (float), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetAwake(bool awake)
    engine->RegisterObjectMethod(className, "void SetAwake(bool)", AS_METHODPR(T, SetAwake, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_awake(bool)", AS_METHODPR(T, SetAwake, (bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetBodyType(BodyType2D type)
    engine->RegisterObjectMethod(className, "void SetBodyType(BodyType2D)", AS_METHODPR(T, SetBodyType, (BodyType2D), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bodyType(BodyType2D)", AS_METHODPR(T, SetBodyType, (BodyType2D), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetBullet(bool bullet)
    engine->RegisterObjectMethod(className, "void SetBullet(bool)", AS_METHODPR(T, SetBullet, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_bullet(bool)", AS_METHODPR(T, SetBullet, (bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetFixedRotation(bool fixedRotation)
    engine->RegisterObjectMethod(className, "void SetFixedRotation(bool)", AS_METHODPR(T, SetFixedRotation, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedRotation(bool)", AS_METHODPR(T, SetFixedRotation, (bool), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetGravityScale(float gravityScale)
    engine->RegisterObjectMethod(className, "void SetGravityScale(float)", AS_METHODPR(T, SetGravityScale, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_gravityScale(float)", AS_METHODPR(T, SetGravityScale, (float), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetInertia(float inertia)
    engine->RegisterObjectMethod(className, "void SetInertia(float)", AS_METHODPR(T, SetInertia, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_inertia(float)", AS_METHODPR(T, SetInertia, (float), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetLinearDamping(float linearDamping)
    engine->RegisterObjectMethod(className, "void SetLinearDamping(float)", AS_METHODPR(T, SetLinearDamping, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearDamping(float)", AS_METHODPR(T, SetLinearDamping, (float), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetLinearVelocity(const Vector2& linearVelocity)
    engine->RegisterObjectMethod(className, "void SetLinearVelocity(const Vector2&in)", AS_METHODPR(T, SetLinearVelocity, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearVelocity(const Vector2&in)", AS_METHODPR(T, SetLinearVelocity, (const Vector2&), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetMass(float mass)
    engine->RegisterObjectMethod(className, "void SetMass(float)", AS_METHODPR(T, SetMass, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_mass(float)", AS_METHODPR(T, SetMass, (float), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetMassCenter(const Vector2& center)
    engine->RegisterObjectMethod(className, "void SetMassCenter(const Vector2&in)", AS_METHODPR(T, SetMassCenter, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_massCenter(const Vector2&in)", AS_METHODPR(T, SetMassCenter, (const Vector2&), void), AS_CALL_THISCALL);

    // void RigidBody2D::SetUseFixtureMass(bool useFixtureMass)
    engine->RegisterObjectMethod(className, "void SetUseFixtureMass(bool)", AS_METHODPR(T, SetUseFixtureMass, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useFixtureMass(bool)", AS_METHODPR(T, SetUseFixtureMass, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RigidBody2D
        REGISTER_MEMBERS_MANUAL_PART_RigidBody2D();
    #endif
}

// Vector<SharedPtr<TileMapObject2D>> TileMap2D::GetTileCollisionShapes(unsigned gid) const
template <class T> CScriptArray* TileMap2D_VectorlesSharedPtrlesTileMapObject2Dgregre_GetTileCollisionShapes_unsigned_template(T* _ptr, unsigned gid)
{
    Vector<SharedPtr<TileMapObject2D>> result = _ptr->GetTileCollisionShapes(gid);
    return VectorToHandleArray(result, "Array<TileMapObject2D@>");
}

// class TileMap2D | File: ../Urho2D/TileMap2D.h
template <class T> void RegisterMembers_TileMap2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void TileMap2D::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // void TileMap2D::DrawDebugGeometry()
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry()", AS_METHODPR(T, DrawDebugGeometry, (), void), AS_CALL_THISCALL);

    // const TileMapInfo2D& TileMap2D::GetInfo() const
    engine->RegisterObjectMethod(className, "const TileMapInfo2D& GetInfo() const", AS_METHODPR(T, GetInfo, () const, const TileMapInfo2D&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const TileMapInfo2D& get_info() const", AS_METHODPR(T, GetInfo, () const, const TileMapInfo2D&), AS_CALL_THISCALL);

    // TileMapLayer2D* TileMap2D::GetLayer(unsigned index) const
    engine->RegisterObjectMethod(className, "TileMapLayer2D@+ GetLayer(uint) const", AS_METHODPR(T, GetLayer, (unsigned) const, TileMapLayer2D*), AS_CALL_THISCALL);

    // unsigned TileMap2D::GetNumLayers() const
    engine->RegisterObjectMethod(className, "uint GetNumLayers() const", AS_METHODPR(T, GetNumLayers, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numLayers() const", AS_METHODPR(T, GetNumLayers, () const, unsigned), AS_CALL_THISCALL);

    // Vector<SharedPtr<TileMapObject2D>> TileMap2D::GetTileCollisionShapes(unsigned gid) const
    engine->RegisterObjectMethod(className, "Array<TileMapObject2D@>@ GetTileCollisionShapes(uint) const", AS_FUNCTION_OBJFIRST(TileMap2D_VectorlesSharedPtrlesTileMapObject2Dgregre_GetTileCollisionShapes_unsigned_template<TileMap2D>), AS_CALL_CDECL_OBJFIRST);

    // TmxFile2D* TileMap2D::GetTmxFile() const
    engine->RegisterObjectMethod(className, "TmxFile2D@+ GetTmxFile() const", AS_METHODPR(T, GetTmxFile, () const, TmxFile2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TmxFile2D@+ get_tmxFile() const", AS_METHODPR(T, GetTmxFile, () const, TmxFile2D*), AS_CALL_THISCALL);

    // ResourceRef TileMap2D::GetTmxFileAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetTmxFileAttr() const", AS_METHODPR(T, GetTmxFileAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // bool TileMap2D::PositionToTileIndex(int& x, int& y, const Vector2& position) const
    engine->RegisterObjectMethod(className, "bool PositionToTileIndex(int&, int&, const Vector2&in) const", AS_METHODPR(T, PositionToTileIndex, (int&, int&, const Vector2&) const, bool), AS_CALL_THISCALL);

    // void TileMap2D::SetTmxFile(TmxFile2D* tmxFile)
    engine->RegisterObjectMethod(className, "void SetTmxFile(TmxFile2D@+)", AS_METHODPR(T, SetTmxFile, (TmxFile2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_tmxFile(TmxFile2D@+)", AS_METHODPR(T, SetTmxFile, (TmxFile2D*), void), AS_CALL_THISCALL);

    // void TileMap2D::SetTmxFileAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetTmxFileAttr(const ResourceRef&in)", AS_METHODPR(T, SetTmxFileAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // Vector2 TileMap2D::TileIndexToPosition(int x, int y) const
    engine->RegisterObjectMethod(className, "Vector2 TileIndexToPosition(int, int) const", AS_METHODPR(T, TileIndexToPosition, (int, int) const, Vector2), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TileMap2D
        REGISTER_MEMBERS_MANUAL_PART_TileMap2D();
    #endif
}

// class TileMapLayer2D | File: ../Urho2D/TileMapLayer2D.h
template <class T> void RegisterMembers_TileMapLayer2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Component<T>(engine, className);

    // void TileMapLayer2D::DrawDebugGeometry(DebugRenderer* debug, bool depthTest) override
    engine->RegisterObjectMethod(className, "void DrawDebugGeometry(DebugRenderer@+, bool)", AS_METHODPR(T, DrawDebugGeometry, (DebugRenderer*, bool), void), AS_CALL_THISCALL);

    // int TileMapLayer2D::GetDrawOrder() const
    engine->RegisterObjectMethod(className, "int GetDrawOrder() const", AS_METHODPR(T, GetDrawOrder, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_drawOrder() const", AS_METHODPR(T, GetDrawOrder, () const, int), AS_CALL_THISCALL);

    // int TileMapLayer2D::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // Node* TileMapLayer2D::GetImageNode() const
    engine->RegisterObjectMethod(className, "Node@+ GetImageNode() const", AS_METHODPR(T, GetImageNode, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_imageNode() const", AS_METHODPR(T, GetImageNode, () const, Node*), AS_CALL_THISCALL);

    // TileMapLayerType2D TileMapLayer2D::GetLayerType() const
    engine->RegisterObjectMethod(className, "TileMapLayerType2D GetLayerType() const", AS_METHODPR(T, GetLayerType, () const, TileMapLayerType2D), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TileMapLayerType2D get_layerType() const", AS_METHODPR(T, GetLayerType, () const, TileMapLayerType2D), AS_CALL_THISCALL);

    // unsigned TileMapLayer2D::GetNumObjects() const
    engine->RegisterObjectMethod(className, "uint GetNumObjects() const", AS_METHODPR(T, GetNumObjects, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numObjects() const", AS_METHODPR(T, GetNumObjects, () const, unsigned), AS_CALL_THISCALL);

    // TileMapObject2D* TileMapLayer2D::GetObject(unsigned index) const
    engine->RegisterObjectMethod(className, "TileMapObject2D@+ GetObject(uint) const", AS_METHODPR(T, GetObject, (unsigned) const, TileMapObject2D*), AS_CALL_THISCALL);

    // Node* TileMapLayer2D::GetObjectNode(unsigned index) const
    engine->RegisterObjectMethod(className, "Node@+ GetObjectNode(uint) const", AS_METHODPR(T, GetObjectNode, (unsigned) const, Node*), AS_CALL_THISCALL);

    // const String& TileMapLayer2D::GetProperty(const String& name) const
    engine->RegisterObjectMethod(className, "const String& GetProperty(const String&in) const", AS_METHODPR(T, GetProperty, (const String&) const, const String&), AS_CALL_THISCALL);

    // Tile2D* TileMapLayer2D::GetTile(int x, int y) const
    engine->RegisterObjectMethod(className, "Tile2D@+ GetTile(int, int) const", AS_METHODPR(T, GetTile, (int, int) const, Tile2D*), AS_CALL_THISCALL);

    // TileMap2D* TileMapLayer2D::GetTileMap() const
    engine->RegisterObjectMethod(className, "TileMap2D@+ GetTileMap() const", AS_METHODPR(T, GetTileMap, () const, TileMap2D*), AS_CALL_THISCALL);

    // Node* TileMapLayer2D::GetTileNode(int x, int y) const
    engine->RegisterObjectMethod(className, "Node@+ GetTileNode(int, int) const", AS_METHODPR(T, GetTileNode, (int, int) const, Node*), AS_CALL_THISCALL);

    // const TmxLayer2D* TileMapLayer2D::GetTmxLayer() const
    engine->RegisterObjectMethod(className, "TmxLayer2D@+ GetTmxLayer() const", AS_METHODPR(T, GetTmxLayer, () const, const TmxLayer2D*), AS_CALL_THISCALL);

    // int TileMapLayer2D::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool TileMapLayer2D::HasProperty(const String& name) const
    engine->RegisterObjectMethod(className, "bool HasProperty(const String&in) const", AS_METHODPR(T, HasProperty, (const String&) const, bool), AS_CALL_THISCALL);

    // void TileMapLayer2D::Initialize(TileMap2D* tileMap, const TmxLayer2D* tmxLayer)
    engine->RegisterObjectMethod(className, "void Initialize(TileMap2D@+, TmxLayer2D@+)", AS_METHODPR(T, Initialize, (TileMap2D*, const TmxLayer2D*), void), AS_CALL_THISCALL);

    // bool TileMapLayer2D::IsVisible() const
    engine->RegisterObjectMethod(className, "bool IsVisible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_visible() const", AS_METHODPR(T, IsVisible, () const, bool), AS_CALL_THISCALL);

    // virtual void Component::OnSetEnabled()
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void TileMapLayer2D::SetDrawOrder(int drawOrder)
    engine->RegisterObjectMethod(className, "void SetDrawOrder(int)", AS_METHODPR(T, SetDrawOrder, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawOrder(int)", AS_METHODPR(T, SetDrawOrder, (int), void), AS_CALL_THISCALL);

    // void TileMapLayer2D::SetVisible(bool visible)
    engine->RegisterObjectMethod(className, "void SetVisible(bool)", AS_METHODPR(T, SetVisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_visible(bool)", AS_METHODPR(T, SetVisible, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TileMapLayer2D
        REGISTER_MEMBERS_MANUAL_PART_TileMapLayer2D();
    #endif
}

#endif // def URHO3D_URHO2D

// class BillboardSet | File: ../Graphics/BillboardSet.h
template <class T> void RegisterMembers_BillboardSet(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // PODVector<Billboard>& BillboardSet::GetBillboards()
    // Error: type "PODVector<Billboard>&" can not automatically bind
    // VariantVector BillboardSet::GetBillboardsAttr() const
    // Error: type "VariantVector" can not automatically bind
    // const PODVector<unsigned char>& BillboardSet::GetNetBillboardsAttr() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void BillboardSet::SetBillboardsAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind
    // void BillboardSet::SetNetBillboardsAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // void BillboardSet::Commit()
    engine->RegisterObjectMethod(className, "void Commit()", AS_METHODPR(T, Commit, (), void), AS_CALL_THISCALL);

    // float BillboardSet::GetAnimationLodBias() const
    engine->RegisterObjectMethod(className, "float GetAnimationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_animationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);

    // Billboard* BillboardSet::GetBillboard(unsigned index)
    engine->RegisterObjectMethod(className, "Billboard@+ GetBillboard(uint)", AS_METHODPR(T, GetBillboard, (unsigned), Billboard*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Billboard@+ get_billboards(uint)", AS_METHODPR(T, GetBillboard, (unsigned), Billboard*), AS_CALL_THISCALL);

    // FaceCameraMode BillboardSet::GetFaceCameraMode() const
    engine->RegisterObjectMethod(className, "FaceCameraMode GetFaceCameraMode() const", AS_METHODPR(T, GetFaceCameraMode, () const, FaceCameraMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FaceCameraMode get_faceCameraMode() const", AS_METHODPR(T, GetFaceCameraMode, () const, FaceCameraMode), AS_CALL_THISCALL);

    // Material* BillboardSet::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef BillboardSet::GetMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetMaterialAttr() const", AS_METHODPR(T, GetMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // float BillboardSet::GetMinAngle() const
    engine->RegisterObjectMethod(className, "float GetMinAngle() const", AS_METHODPR(T, GetMinAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_minAngle() const", AS_METHODPR(T, GetMinAngle, () const, float), AS_CALL_THISCALL);

    // unsigned BillboardSet::GetNumBillboards() const
    engine->RegisterObjectMethod(className, "uint GetNumBillboards() const", AS_METHODPR(T, GetNumBillboards, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numBillboards() const", AS_METHODPR(T, GetNumBillboards, () const, unsigned), AS_CALL_THISCALL);

    // bool BillboardSet::IsFixedScreenSize() const
    engine->RegisterObjectMethod(className, "bool IsFixedScreenSize() const", AS_METHODPR(T, IsFixedScreenSize, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedScreenSize() const", AS_METHODPR(T, IsFixedScreenSize, () const, bool), AS_CALL_THISCALL);

    // bool BillboardSet::IsRelative() const
    engine->RegisterObjectMethod(className, "bool IsRelative() const", AS_METHODPR(T, IsRelative, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_relative() const", AS_METHODPR(T, IsRelative, () const, bool), AS_CALL_THISCALL);

    // bool BillboardSet::IsScaled() const
    engine->RegisterObjectMethod(className, "bool IsScaled() const", AS_METHODPR(T, IsScaled, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_scaled() const", AS_METHODPR(T, IsScaled, () const, bool), AS_CALL_THISCALL);

    // bool BillboardSet::IsSorted() const
    engine->RegisterObjectMethod(className, "bool IsSorted() const", AS_METHODPR(T, IsSorted, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sorted() const", AS_METHODPR(T, IsSorted, () const, bool), AS_CALL_THISCALL);

    // void BillboardSet::SetAnimationLodBias(float bias)
    engine->RegisterObjectMethod(className, "void SetAnimationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);

    // void BillboardSet::SetFaceCameraMode(FaceCameraMode mode)
    engine->RegisterObjectMethod(className, "void SetFaceCameraMode(FaceCameraMode)", AS_METHODPR(T, SetFaceCameraMode, (FaceCameraMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_faceCameraMode(FaceCameraMode)", AS_METHODPR(T, SetFaceCameraMode, (FaceCameraMode), void), AS_CALL_THISCALL);

    // void BillboardSet::SetFixedScreenSize(bool enable)
    engine->RegisterObjectMethod(className, "void SetFixedScreenSize(bool)", AS_METHODPR(T, SetFixedScreenSize, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedScreenSize(bool)", AS_METHODPR(T, SetFixedScreenSize, (bool), void), AS_CALL_THISCALL);

    // void BillboardSet::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void BillboardSet::SetMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void BillboardSet::SetMinAngle(float angle)
    engine->RegisterObjectMethod(className, "void SetMinAngle(float)", AS_METHODPR(T, SetMinAngle, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_minAngle(float)", AS_METHODPR(T, SetMinAngle, (float), void), AS_CALL_THISCALL);

    // void BillboardSet::SetNumBillboards(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumBillboards(uint)", AS_METHODPR(T, SetNumBillboards, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numBillboards(uint)", AS_METHODPR(T, SetNumBillboards, (unsigned), void), AS_CALL_THISCALL);

    // void BillboardSet::SetRelative(bool enable)
    engine->RegisterObjectMethod(className, "void SetRelative(bool)", AS_METHODPR(T, SetRelative, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_relative(bool)", AS_METHODPR(T, SetRelative, (bool), void), AS_CALL_THISCALL);

    // void BillboardSet::SetScaled(bool enable)
    engine->RegisterObjectMethod(className, "void SetScaled(bool)", AS_METHODPR(T, SetScaled, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scaled(bool)", AS_METHODPR(T, SetScaled, (bool), void), AS_CALL_THISCALL);

    // void BillboardSet::SetSorted(bool enable)
    engine->RegisterObjectMethod(className, "void SetSorted(bool)", AS_METHODPR(T, SetSorted, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sorted(bool)", AS_METHODPR(T, SetSorted, (bool), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_BillboardSet
        REGISTER_MEMBERS_MANUAL_PART_BillboardSet();
    #endif
}

// class Button | File: ../UI/Button.h
template <class T> void RegisterMembers_Button(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // const IntVector2& Button::GetPressedChildOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPressedChildOffset() const", AS_METHODPR(T, GetPressedChildOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_pressedChildOffset() const", AS_METHODPR(T, GetPressedChildOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // const IntVector2& Button::GetPressedOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPressedOffset() const", AS_METHODPR(T, GetPressedOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_pressedOffset() const", AS_METHODPR(T, GetPressedOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // float Button::GetRepeatDelay() const
    engine->RegisterObjectMethod(className, "float GetRepeatDelay() const", AS_METHODPR(T, GetRepeatDelay, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_repeatDelay() const", AS_METHODPR(T, GetRepeatDelay, () const, float), AS_CALL_THISCALL);

    // float Button::GetRepeatRate() const
    engine->RegisterObjectMethod(className, "float GetRepeatRate() const", AS_METHODPR(T, GetRepeatRate, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_repeatRate() const", AS_METHODPR(T, GetRepeatRate, () const, float), AS_CALL_THISCALL);

    // bool Button::IsPressed() const
    engine->RegisterObjectMethod(className, "bool IsPressed() const", AS_METHODPR(T, IsPressed, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_pressed() const", AS_METHODPR(T, IsPressed, () const, bool), AS_CALL_THISCALL);

    // void Button::SetPressedChildOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetPressedChildOffset(const IntVector2&in)", AS_METHODPR(T, SetPressedChildOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pressedChildOffset(const IntVector2&in)", AS_METHODPR(T, SetPressedChildOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Button::SetPressedChildOffset(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPressedChildOffset(int, int)", AS_METHODPR(T, SetPressedChildOffset, (int, int), void), AS_CALL_THISCALL);

    // void Button::SetPressedOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetPressedOffset(const IntVector2&in)", AS_METHODPR(T, SetPressedOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_pressedOffset(const IntVector2&in)", AS_METHODPR(T, SetPressedOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Button::SetPressedOffset(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPressedOffset(int, int)", AS_METHODPR(T, SetPressedOffset, (int, int), void), AS_CALL_THISCALL);

    // void Button::SetRepeat(float delay, float rate)
    engine->RegisterObjectMethod(className, "void SetRepeat(float, float)", AS_METHODPR(T, SetRepeat, (float, float), void), AS_CALL_THISCALL);

    // void Button::SetRepeatDelay(float delay)
    engine->RegisterObjectMethod(className, "void SetRepeatDelay(float)", AS_METHODPR(T, SetRepeatDelay, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_repeatDelay(float)", AS_METHODPR(T, SetRepeatDelay, (float), void), AS_CALL_THISCALL);

    // void Button::SetRepeatRate(float rate)
    engine->RegisterObjectMethod(className, "void SetRepeatRate(float)", AS_METHODPR(T, SetRepeatRate, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_repeatRate(float)", AS_METHODPR(T, SetRepeatRate, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Button
        REGISTER_MEMBERS_MANUAL_PART_Button();
    #endif
}

// class CheckBox | File: ../UI/CheckBox.h
template <class T> void RegisterMembers_CheckBox(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // const IntVector2& CheckBox::GetCheckedOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetCheckedOffset() const", AS_METHODPR(T, GetCheckedOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_checkedOffset() const", AS_METHODPR(T, GetCheckedOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // bool CheckBox::IsChecked() const
    engine->RegisterObjectMethod(className, "bool IsChecked() const", AS_METHODPR(T, IsChecked, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_checked() const", AS_METHODPR(T, IsChecked, () const, bool), AS_CALL_THISCALL);

    // void CheckBox::SetChecked(bool enable)
    engine->RegisterObjectMethod(className, "void SetChecked(bool)", AS_METHODPR(T, SetChecked, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_checked(bool)", AS_METHODPR(T, SetChecked, (bool), void), AS_CALL_THISCALL);

    // void CheckBox::SetCheckedOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetCheckedOffset(const IntVector2&in)", AS_METHODPR(T, SetCheckedOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_checkedOffset(const IntVector2&in)", AS_METHODPR(T, SetCheckedOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void CheckBox::SetCheckedOffset(int x, int y)
    engine->RegisterObjectMethod(className, "void SetCheckedOffset(int, int)", AS_METHODPR(T, SetCheckedOffset, (int, int), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CheckBox
        REGISTER_MEMBERS_MANUAL_PART_CheckBox();
    #endif
}

// class Cursor | File: ../UI/Cursor.h
template <class T> void RegisterMembers_Cursor(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // VariantVector Cursor::GetShapesAttr() const
    // Error: type "VariantVector" can not automatically bind
    // void Cursor::SetShapesAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // void Cursor::ApplyOSCursorShape()
    engine->RegisterObjectMethod(className, "void ApplyOSCursorShape()", AS_METHODPR(T, ApplyOSCursorShape, (), void), AS_CALL_THISCALL);

    // void Cursor::DefineShape(const String& shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot)
    engine->RegisterObjectMethod(className, "void DefineShape(const String&in, Image@+, const IntRect&in, const IntVector2&in)", AS_METHODPR(T, DefineShape, (const String&, Image*, const IntRect&, const IntVector2&), void), AS_CALL_THISCALL);

    // void Cursor::DefineShape(CursorShape shape, Image* image, const IntRect& imageRect, const IntVector2& hotSpot)
    engine->RegisterObjectMethod(className, "void DefineShape(CursorShape, Image@+, const IntRect&in, const IntVector2&in)", AS_METHODPR(T, DefineShape, (CursorShape, Image*, const IntRect&, const IntVector2&), void), AS_CALL_THISCALL);

    // const String& Cursor::GetShape() const
    engine->RegisterObjectMethod(className, "const String& GetShape() const", AS_METHODPR(T, GetShape, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_shape() const", AS_METHODPR(T, GetShape, () const, const String&), AS_CALL_THISCALL);

    // bool Cursor::GetUseSystemShapes() const
    engine->RegisterObjectMethod(className, "bool GetUseSystemShapes() const", AS_METHODPR(T, GetUseSystemShapes, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useSystemShapes() const", AS_METHODPR(T, GetUseSystemShapes, () const, bool), AS_CALL_THISCALL);

    // void Cursor::SetShape(const String& shape)
    engine->RegisterObjectMethod(className, "void SetShape(const String&in)", AS_METHODPR(T, SetShape, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shape(const String&in)", AS_METHODPR(T, SetShape, (const String&), void), AS_CALL_THISCALL);

    // void Cursor::SetShape(CursorShape shape)
    engine->RegisterObjectMethod(className, "void SetShape(CursorShape)", AS_METHODPR(T, SetShape, (CursorShape), void), AS_CALL_THISCALL);

    // void Cursor::SetUseSystemShapes(bool enable)
    engine->RegisterObjectMethod(className, "void SetUseSystemShapes(bool)", AS_METHODPR(T, SetUseSystemShapes, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useSystemShapes(bool)", AS_METHODPR(T, SetUseSystemShapes, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Cursor
        REGISTER_MEMBERS_MANUAL_PART_Cursor();
    #endif
}

// class CustomGeometry | File: ../Graphics/CustomGeometry.h
template <class T> void RegisterMembers_CustomGeometry(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // PODVector<unsigned char> CustomGeometry::GetGeometryDataAttr() const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // Vector<PODVector<CustomGeometryVertex>>& CustomGeometry::GetVertices()
    // Error: type "Vector<PODVector<CustomGeometryVertex>>&" can not automatically bind
    // void CustomGeometry::SetGeometryDataAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // void CustomGeometry::BeginGeometry(unsigned index, PrimitiveType type)
    engine->RegisterObjectMethod(className, "void BeginGeometry(uint, PrimitiveType)", AS_METHODPR(T, BeginGeometry, (unsigned, PrimitiveType), void), AS_CALL_THISCALL);

    // void CustomGeometry::Clear()
    engine->RegisterObjectMethod(className, "void Clear()", AS_METHODPR(T, Clear, (), void), AS_CALL_THISCALL);

    // void CustomGeometry::Commit()
    engine->RegisterObjectMethod(className, "void Commit()", AS_METHODPR(T, Commit, (), void), AS_CALL_THISCALL);

    // void CustomGeometry::DefineColor(const Color& color)
    engine->RegisterObjectMethod(className, "void DefineColor(const Color&in)", AS_METHODPR(T, DefineColor, (const Color&), void), AS_CALL_THISCALL);

    // void CustomGeometry::DefineGeometry(unsigned index, PrimitiveType type, unsigned numVertices, bool hasNormals, bool hasColors, bool hasTexCoords, bool hasTangents)
    engine->RegisterObjectMethod(className, "void DefineGeometry(uint, PrimitiveType, uint, bool, bool, bool, bool)", AS_METHODPR(T, DefineGeometry, (unsigned, PrimitiveType, unsigned, bool, bool, bool, bool), void), AS_CALL_THISCALL);

    // void CustomGeometry::DefineNormal(const Vector3& normal)
    engine->RegisterObjectMethod(className, "void DefineNormal(const Vector3&in)", AS_METHODPR(T, DefineNormal, (const Vector3&), void), AS_CALL_THISCALL);

    // void CustomGeometry::DefineTangent(const Vector4& tangent)
    engine->RegisterObjectMethod(className, "void DefineTangent(const Vector4&in)", AS_METHODPR(T, DefineTangent, (const Vector4&), void), AS_CALL_THISCALL);

    // void CustomGeometry::DefineTexCoord(const Vector2& texCoord)
    engine->RegisterObjectMethod(className, "void DefineTexCoord(const Vector2&in)", AS_METHODPR(T, DefineTexCoord, (const Vector2&), void), AS_CALL_THISCALL);

    // void CustomGeometry::DefineVertex(const Vector3& position)
    engine->RegisterObjectMethod(className, "void DefineVertex(const Vector3&in)", AS_METHODPR(T, DefineVertex, (const Vector3&), void), AS_CALL_THISCALL);

    // Material* CustomGeometry::GetMaterial(unsigned index = 0) const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial(uint = 0) const", AS_METHODPR(T, GetMaterial, (unsigned) const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_materials(uint = 0) const", AS_METHODPR(T, GetMaterial, (unsigned) const, Material*), AS_CALL_THISCALL);

    // const ResourceRefList& CustomGeometry::GetMaterialsAttr() const
    engine->RegisterObjectMethod(className, "const ResourceRefList& GetMaterialsAttr() const", AS_METHODPR(T, GetMaterialsAttr, () const, const ResourceRefList&), AS_CALL_THISCALL);

    // unsigned CustomGeometry::GetNumGeometries() const
    engine->RegisterObjectMethod(className, "uint GetNumGeometries() const", AS_METHODPR(T, GetNumGeometries, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numGeometries() const", AS_METHODPR(T, GetNumGeometries, () const, unsigned), AS_CALL_THISCALL);

    // unsigned CustomGeometry::GetNumVertices(unsigned index) const
    engine->RegisterObjectMethod(className, "uint GetNumVertices(uint) const", AS_METHODPR(T, GetNumVertices, (unsigned) const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numVertices(uint) const", AS_METHODPR(T, GetNumVertices, (unsigned) const, unsigned), AS_CALL_THISCALL);

    // CustomGeometryVertex* CustomGeometry::GetVertex(unsigned geometryIndex, unsigned vertexNum)
    engine->RegisterObjectMethod(className, "CustomGeometryVertex@+ GetVertex(uint, uint)", AS_METHODPR(T, GetVertex, (unsigned, unsigned), CustomGeometryVertex*), AS_CALL_THISCALL);

    // bool CustomGeometry::IsDynamic() const
    engine->RegisterObjectMethod(className, "bool IsDynamic() const", AS_METHODPR(T, IsDynamic, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_dynamic() const", AS_METHODPR(T, IsDynamic, () const, bool), AS_CALL_THISCALL);

    // void CustomGeometry::SetDynamic(bool enable)
    engine->RegisterObjectMethod(className, "void SetDynamic(bool)", AS_METHODPR(T, SetDynamic, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dynamic(bool)", AS_METHODPR(T, SetDynamic, (bool), void), AS_CALL_THISCALL);

    // void CustomGeometry::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // bool CustomGeometry::SetMaterial(unsigned index, Material* material)
    engine->RegisterObjectMethod(className, "bool SetMaterial(uint, Material@+)", AS_METHODPR(T, SetMaterial, (unsigned, Material*), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_materials(uint, Material@+)", AS_METHODPR(T, SetMaterial, (unsigned, Material*), bool), AS_CALL_THISCALL);

    // void CustomGeometry::SetMaterialsAttr(const ResourceRefList& value)
    engine->RegisterObjectMethod(className, "void SetMaterialsAttr(const ResourceRefList&in)", AS_METHODPR(T, SetMaterialsAttr, (const ResourceRefList&), void), AS_CALL_THISCALL);

    // void CustomGeometry::SetNumGeometries(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumGeometries(uint)", AS_METHODPR(T, SetNumGeometries, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numGeometries(uint)", AS_METHODPR(T, SetNumGeometries, (unsigned), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CustomGeometry
        REGISTER_MEMBERS_MANUAL_PART_CustomGeometry();
    #endif
}

// class DecalSet | File: ../Graphics/DecalSet.h
template <class T> void RegisterMembers_DecalSet(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // PODVector<unsigned char> DecalSet::GetDecalsAttr() const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // void DecalSet::SetDecalsAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // bool DecalSet::AddDecal(Drawable* target, const Vector3& worldPosition, const Quaternion& worldRotation, float size, float aspectRatio, float depth, const Vector2& topLeftUV, const Vector2& bottomRightUV, float timeToLive = 0.0f, float normalCutoff = 0.1f, unsigned subGeometry = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "bool AddDecal(Drawable@+, const Vector3&in, const Quaternion&in, float, float, float, const Vector2&in, const Vector2&in, float = 0.0f, float = 0.1f, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, AddDecal, (Drawable*, const Vector3&, const Quaternion&, float, float, float, const Vector2&, const Vector2&, float, float, unsigned), bool), AS_CALL_THISCALL);

    // Material* DecalSet::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef DecalSet::GetMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetMaterialAttr() const", AS_METHODPR(T, GetMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // unsigned DecalSet::GetMaxIndices() const
    engine->RegisterObjectMethod(className, "uint GetMaxIndices() const", AS_METHODPR(T, GetMaxIndices, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxIndices() const", AS_METHODPR(T, GetMaxIndices, () const, unsigned), AS_CALL_THISCALL);

    // unsigned DecalSet::GetMaxVertices() const
    engine->RegisterObjectMethod(className, "uint GetMaxVertices() const", AS_METHODPR(T, GetMaxVertices, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxVertices() const", AS_METHODPR(T, GetMaxVertices, () const, unsigned), AS_CALL_THISCALL);

    // unsigned DecalSet::GetNumDecals() const
    engine->RegisterObjectMethod(className, "uint GetNumDecals() const", AS_METHODPR(T, GetNumDecals, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numDecals() const", AS_METHODPR(T, GetNumDecals, () const, unsigned), AS_CALL_THISCALL);

    // unsigned DecalSet::GetNumIndices() const
    engine->RegisterObjectMethod(className, "uint GetNumIndices() const", AS_METHODPR(T, GetNumIndices, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numIndices() const", AS_METHODPR(T, GetNumIndices, () const, unsigned), AS_CALL_THISCALL);

    // unsigned DecalSet::GetNumVertices() const
    engine->RegisterObjectMethod(className, "uint GetNumVertices() const", AS_METHODPR(T, GetNumVertices, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numVertices() const", AS_METHODPR(T, GetNumVertices, () const, unsigned), AS_CALL_THISCALL);

    // bool DecalSet::GetOptimizeBufferSize() const
    engine->RegisterObjectMethod(className, "bool GetOptimizeBufferSize() const", AS_METHODPR(T, GetOptimizeBufferSize, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_optimizeBufferSize() const", AS_METHODPR(T, GetOptimizeBufferSize, () const, bool), AS_CALL_THISCALL);

    // void DecalSet::RemoveAllDecals()
    engine->RegisterObjectMethod(className, "void RemoveAllDecals()", AS_METHODPR(T, RemoveAllDecals, (), void), AS_CALL_THISCALL);

    // void DecalSet::RemoveDecals(unsigned num)
    engine->RegisterObjectMethod(className, "void RemoveDecals(uint)", AS_METHODPR(T, RemoveDecals, (unsigned), void), AS_CALL_THISCALL);

    // void DecalSet::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void DecalSet::SetMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void DecalSet::SetMaxIndices(unsigned num)
    engine->RegisterObjectMethod(className, "void SetMaxIndices(uint)", AS_METHODPR(T, SetMaxIndices, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxIndices(uint)", AS_METHODPR(T, SetMaxIndices, (unsigned), void), AS_CALL_THISCALL);

    // void DecalSet::SetMaxVertices(unsigned num)
    engine->RegisterObjectMethod(className, "void SetMaxVertices(uint)", AS_METHODPR(T, SetMaxVertices, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxVertices(uint)", AS_METHODPR(T, SetMaxVertices, (unsigned), void), AS_CALL_THISCALL);

    // void DecalSet::SetOptimizeBufferSize(bool enable)
    engine->RegisterObjectMethod(className, "void SetOptimizeBufferSize(bool)", AS_METHODPR(T, SetOptimizeBufferSize, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_optimizeBufferSize(bool)", AS_METHODPR(T, SetOptimizeBufferSize, (bool), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DecalSet
        REGISTER_MEMBERS_MANUAL_PART_DecalSet();
    #endif
}

// class Light | File: ../Graphics/Light.h
template <class T> void RegisterMembers_Light(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // LightBatchQueue* Light::GetLightQueue() const
    // Error: type "LightBatchQueue*" can not automatically bind
    // void Light::SetLightQueue(LightBatchQueue* queue)
    // Error: type "LightBatchQueue*" can not automatically bind

    // float Light::GetAspectRatio() const
    engine->RegisterObjectMethod(className, "float GetAspectRatio() const", AS_METHODPR(T, GetAspectRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_aspectRatio() const", AS_METHODPR(T, GetAspectRatio, () const, float), AS_CALL_THISCALL);

    // float Light::GetBrightness() const
    engine->RegisterObjectMethod(className, "float GetBrightness() const", AS_METHODPR(T, GetBrightness, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_brightness() const", AS_METHODPR(T, GetBrightness, () const, float), AS_CALL_THISCALL);

    // const Color& Light::GetColor() const
    engine->RegisterObjectMethod(className, "const Color& GetColor() const", AS_METHODPR(T, GetColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_color() const", AS_METHODPR(T, GetColor, () const, const Color&), AS_CALL_THISCALL);

    // Color Light::GetColorFromTemperature() const
    engine->RegisterObjectMethod(className, "Color GetColorFromTemperature() const", AS_METHODPR(T, GetColorFromTemperature, () const, Color), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Color get_colorFromTemperature() const", AS_METHODPR(T, GetColorFromTemperature, () const, Color), AS_CALL_THISCALL);

    // Color Light::GetEffectiveColor() const
    engine->RegisterObjectMethod(className, "Color GetEffectiveColor() const", AS_METHODPR(T, GetEffectiveColor, () const, Color), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Color get_effectiveColor() const", AS_METHODPR(T, GetEffectiveColor, () const, Color), AS_CALL_THISCALL);

    // float Light::GetEffectiveSpecularIntensity() const
    engine->RegisterObjectMethod(className, "float GetEffectiveSpecularIntensity() const", AS_METHODPR(T, GetEffectiveSpecularIntensity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_effectiveSpecularIntensity() const", AS_METHODPR(T, GetEffectiveSpecularIntensity, () const, float), AS_CALL_THISCALL);

    // float Light::GetFadeDistance() const
    engine->RegisterObjectMethod(className, "float GetFadeDistance() const", AS_METHODPR(T, GetFadeDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fadeDistance() const", AS_METHODPR(T, GetFadeDistance, () const, float), AS_CALL_THISCALL);

    // float Light::GetFov() const
    engine->RegisterObjectMethod(className, "float GetFov() const", AS_METHODPR(T, GetFov, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fov() const", AS_METHODPR(T, GetFov, () const, float), AS_CALL_THISCALL);

    // Frustum Light::GetFrustum() const
    engine->RegisterObjectMethod(className, "Frustum GetFrustum() const", AS_METHODPR(T, GetFrustum, () const, Frustum), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Frustum get_frustum() const", AS_METHODPR(T, GetFrustum, () const, Frustum), AS_CALL_THISCALL);

    // float Light::GetIntensityDivisor(float attenuation = 1.0f) const
    engine->RegisterObjectMethod(className, "float GetIntensityDivisor(float = 1.0f) const", AS_METHODPR(T, GetIntensityDivisor, (float) const, float), AS_CALL_THISCALL);

    // float Light::GetLength() const
    engine->RegisterObjectMethod(className, "float GetLength() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);

    // LightType Light::GetLightType() const
    engine->RegisterObjectMethod(className, "LightType GetLightType() const", AS_METHODPR(T, GetLightType, () const, LightType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LightType get_lightType() const", AS_METHODPR(T, GetLightType, () const, LightType), AS_CALL_THISCALL);

    // int Light::GetNumShadowSplits() const
    engine->RegisterObjectMethod(className, "int GetNumShadowSplits() const", AS_METHODPR(T, GetNumShadowSplits, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_numShadowSplits() const", AS_METHODPR(T, GetNumShadowSplits, () const, int), AS_CALL_THISCALL);

    // bool Light::GetPerVertex() const
    engine->RegisterObjectMethod(className, "bool GetPerVertex() const", AS_METHODPR(T, GetPerVertex, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_perVertex() const", AS_METHODPR(T, GetPerVertex, () const, bool), AS_CALL_THISCALL);

    // float Light::GetRadius() const
    engine->RegisterObjectMethod(className, "float GetRadius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_radius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);

    // Texture* Light::GetRampTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetRampTexture() const", AS_METHODPR(T, GetRampTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_rampTexture() const", AS_METHODPR(T, GetRampTexture, () const, Texture*), AS_CALL_THISCALL);

    // ResourceRef Light::GetRampTextureAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetRampTextureAttr() const", AS_METHODPR(T, GetRampTextureAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // float Light::GetRange() const
    engine->RegisterObjectMethod(className, "float GetRange() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_range() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);

    // const BiasParameters& Light::GetShadowBias() const
    engine->RegisterObjectMethod(className, "const BiasParameters& GetShadowBias() const", AS_METHODPR(T, GetShadowBias, () const, const BiasParameters&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const BiasParameters& get_shadowBias() const", AS_METHODPR(T, GetShadowBias, () const, const BiasParameters&), AS_CALL_THISCALL);

    // const CascadeParameters& Light::GetShadowCascade() const
    engine->RegisterObjectMethod(className, "const CascadeParameters& GetShadowCascade() const", AS_METHODPR(T, GetShadowCascade, () const, const CascadeParameters&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const CascadeParameters& get_shadowCascade() const", AS_METHODPR(T, GetShadowCascade, () const, const CascadeParameters&), AS_CALL_THISCALL);

    // float Light::GetShadowFadeDistance() const
    engine->RegisterObjectMethod(className, "float GetShadowFadeDistance() const", AS_METHODPR(T, GetShadowFadeDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowFadeDistance() const", AS_METHODPR(T, GetShadowFadeDistance, () const, float), AS_CALL_THISCALL);

    // const FocusParameters& Light::GetShadowFocus() const
    engine->RegisterObjectMethod(className, "const FocusParameters& GetShadowFocus() const", AS_METHODPR(T, GetShadowFocus, () const, const FocusParameters&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const FocusParameters& get_shadowFocus() const", AS_METHODPR(T, GetShadowFocus, () const, const FocusParameters&), AS_CALL_THISCALL);

    // float Light::GetShadowIntensity() const
    engine->RegisterObjectMethod(className, "float GetShadowIntensity() const", AS_METHODPR(T, GetShadowIntensity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowIntensity() const", AS_METHODPR(T, GetShadowIntensity, () const, float), AS_CALL_THISCALL);

    // float Light::GetShadowMaxExtrusion() const
    engine->RegisterObjectMethod(className, "float GetShadowMaxExtrusion() const", AS_METHODPR(T, GetShadowMaxExtrusion, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowMaxExtrusion() const", AS_METHODPR(T, GetShadowMaxExtrusion, () const, float), AS_CALL_THISCALL);

    // float Light::GetShadowNearFarRatio() const
    engine->RegisterObjectMethod(className, "float GetShadowNearFarRatio() const", AS_METHODPR(T, GetShadowNearFarRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowNearFarRatio() const", AS_METHODPR(T, GetShadowNearFarRatio, () const, float), AS_CALL_THISCALL);

    // float Light::GetShadowResolution() const
    engine->RegisterObjectMethod(className, "float GetShadowResolution() const", AS_METHODPR(T, GetShadowResolution, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_shadowResolution() const", AS_METHODPR(T, GetShadowResolution, () const, float), AS_CALL_THISCALL);

    // Texture* Light::GetShapeTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetShapeTexture() const", AS_METHODPR(T, GetShapeTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_shapeTexture() const", AS_METHODPR(T, GetShapeTexture, () const, Texture*), AS_CALL_THISCALL);

    // ResourceRef Light::GetShapeTextureAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetShapeTextureAttr() const", AS_METHODPR(T, GetShapeTextureAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // float Light::GetSpecularIntensity() const
    engine->RegisterObjectMethod(className, "float GetSpecularIntensity() const", AS_METHODPR(T, GetSpecularIntensity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_specularIntensity() const", AS_METHODPR(T, GetSpecularIntensity, () const, float), AS_CALL_THISCALL);

    // float Light::GetTemperature() const
    engine->RegisterObjectMethod(className, "float GetTemperature() const", AS_METHODPR(T, GetTemperature, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_temperature() const", AS_METHODPR(T, GetTemperature, () const, float), AS_CALL_THISCALL);

    // bool Light::GetUsePhysicalValues() const
    engine->RegisterObjectMethod(className, "bool GetUsePhysicalValues() const", AS_METHODPR(T, GetUsePhysicalValues, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_usePhysicalValues() const", AS_METHODPR(T, GetUsePhysicalValues, () const, bool), AS_CALL_THISCALL);

    // Frustum Light::GetViewSpaceFrustum(const Matrix3x4& view) const
    engine->RegisterObjectMethod(className, "Frustum GetViewSpaceFrustum(const Matrix3x4&in) const", AS_METHODPR(T, GetViewSpaceFrustum, (const Matrix3x4&) const, Frustum), AS_CALL_THISCALL);

    // const Matrix3x4& Light::GetVolumeTransform(Camera* camera)
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetVolumeTransform(Camera@+)", AS_METHODPR(T, GetVolumeTransform, (Camera*), const Matrix3x4&), AS_CALL_THISCALL);

    // bool Light::IsNegative() const
    engine->RegisterObjectMethod(className, "bool IsNegative() const", AS_METHODPR(T, IsNegative, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_negative() const", AS_METHODPR(T, IsNegative, () const, bool), AS_CALL_THISCALL);

    // void Light::SetAspectRatio(float aspectRatio)
    engine->RegisterObjectMethod(className, "void SetAspectRatio(float)", AS_METHODPR(T, SetAspectRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_aspectRatio(float)", AS_METHODPR(T, SetAspectRatio, (float), void), AS_CALL_THISCALL);

    // void Light::SetBrightness(float brightness)
    engine->RegisterObjectMethod(className, "void SetBrightness(float)", AS_METHODPR(T, SetBrightness, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_brightness(float)", AS_METHODPR(T, SetBrightness, (float), void), AS_CALL_THISCALL);

    // void Light::SetColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetColor(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_color(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);

    // void Light::SetFadeDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetFadeDistance(float)", AS_METHODPR(T, SetFadeDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fadeDistance(float)", AS_METHODPR(T, SetFadeDistance, (float), void), AS_CALL_THISCALL);

    // void Light::SetFov(float fov)
    engine->RegisterObjectMethod(className, "void SetFov(float)", AS_METHODPR(T, SetFov, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fov(float)", AS_METHODPR(T, SetFov, (float), void), AS_CALL_THISCALL);

    // void Light::SetIntensitySortValue(float distance)
    engine->RegisterObjectMethod(className, "void SetIntensitySortValue(float)", AS_METHODPR(T, SetIntensitySortValue, (float), void), AS_CALL_THISCALL);

    // void Light::SetIntensitySortValue(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void SetIntensitySortValue(const BoundingBox&in)", AS_METHODPR(T, SetIntensitySortValue, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void Light::SetLength(float length)
    engine->RegisterObjectMethod(className, "void SetLength(float)", AS_METHODPR(T, SetLength, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_length(float)", AS_METHODPR(T, SetLength, (float), void), AS_CALL_THISCALL);

    // void Light::SetLightType(LightType type)
    engine->RegisterObjectMethod(className, "void SetLightType(LightType)", AS_METHODPR(T, SetLightType, (LightType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lightType(LightType)", AS_METHODPR(T, SetLightType, (LightType), void), AS_CALL_THISCALL);

    // void Light::SetPerVertex(bool enable)
    engine->RegisterObjectMethod(className, "void SetPerVertex(bool)", AS_METHODPR(T, SetPerVertex, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_perVertex(bool)", AS_METHODPR(T, SetPerVertex, (bool), void), AS_CALL_THISCALL);

    // void Light::SetRadius(float radius)
    engine->RegisterObjectMethod(className, "void SetRadius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_radius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);

    // void Light::SetRampTexture(Texture* texture)
    engine->RegisterObjectMethod(className, "void SetRampTexture(Texture@+)", AS_METHODPR(T, SetRampTexture, (Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rampTexture(Texture@+)", AS_METHODPR(T, SetRampTexture, (Texture*), void), AS_CALL_THISCALL);

    // void Light::SetRampTextureAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetRampTextureAttr(const ResourceRef&in)", AS_METHODPR(T, SetRampTextureAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void Light::SetRange(float range)
    engine->RegisterObjectMethod(className, "void SetRange(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_range(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);

    // void Light::SetShadowBias(const BiasParameters& parameters)
    engine->RegisterObjectMethod(className, "void SetShadowBias(const BiasParameters&in)", AS_METHODPR(T, SetShadowBias, (const BiasParameters&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowBias(const BiasParameters&in)", AS_METHODPR(T, SetShadowBias, (const BiasParameters&), void), AS_CALL_THISCALL);

    // void Light::SetShadowCascade(const CascadeParameters& parameters)
    engine->RegisterObjectMethod(className, "void SetShadowCascade(const CascadeParameters&in)", AS_METHODPR(T, SetShadowCascade, (const CascadeParameters&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowCascade(const CascadeParameters&in)", AS_METHODPR(T, SetShadowCascade, (const CascadeParameters&), void), AS_CALL_THISCALL);

    // void Light::SetShadowFadeDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetShadowFadeDistance(float)", AS_METHODPR(T, SetShadowFadeDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowFadeDistance(float)", AS_METHODPR(T, SetShadowFadeDistance, (float), void), AS_CALL_THISCALL);

    // void Light::SetShadowFocus(const FocusParameters& parameters)
    engine->RegisterObjectMethod(className, "void SetShadowFocus(const FocusParameters&in)", AS_METHODPR(T, SetShadowFocus, (const FocusParameters&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowFocus(const FocusParameters&in)", AS_METHODPR(T, SetShadowFocus, (const FocusParameters&), void), AS_CALL_THISCALL);

    // void Light::SetShadowIntensity(float intensity)
    engine->RegisterObjectMethod(className, "void SetShadowIntensity(float)", AS_METHODPR(T, SetShadowIntensity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowIntensity(float)", AS_METHODPR(T, SetShadowIntensity, (float), void), AS_CALL_THISCALL);

    // void Light::SetShadowMaxExtrusion(float extrusion)
    engine->RegisterObjectMethod(className, "void SetShadowMaxExtrusion(float)", AS_METHODPR(T, SetShadowMaxExtrusion, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowMaxExtrusion(float)", AS_METHODPR(T, SetShadowMaxExtrusion, (float), void), AS_CALL_THISCALL);

    // void Light::SetShadowNearFarRatio(float nearFarRatio)
    engine->RegisterObjectMethod(className, "void SetShadowNearFarRatio(float)", AS_METHODPR(T, SetShadowNearFarRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowNearFarRatio(float)", AS_METHODPR(T, SetShadowNearFarRatio, (float), void), AS_CALL_THISCALL);

    // void Light::SetShadowResolution(float resolution)
    engine->RegisterObjectMethod(className, "void SetShadowResolution(float)", AS_METHODPR(T, SetShadowResolution, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shadowResolution(float)", AS_METHODPR(T, SetShadowResolution, (float), void), AS_CALL_THISCALL);

    // void Light::SetShapeTexture(Texture* texture)
    engine->RegisterObjectMethod(className, "void SetShapeTexture(Texture@+)", AS_METHODPR(T, SetShapeTexture, (Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_shapeTexture(Texture@+)", AS_METHODPR(T, SetShapeTexture, (Texture*), void), AS_CALL_THISCALL);

    // void Light::SetShapeTextureAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetShapeTextureAttr(const ResourceRef&in)", AS_METHODPR(T, SetShapeTextureAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void Light::SetSpecularIntensity(float intensity)
    engine->RegisterObjectMethod(className, "void SetSpecularIntensity(float)", AS_METHODPR(T, SetSpecularIntensity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_specularIntensity(float)", AS_METHODPR(T, SetSpecularIntensity, (float), void), AS_CALL_THISCALL);

    // void Light::SetTemperature(float temperature)
    engine->RegisterObjectMethod(className, "void SetTemperature(float)", AS_METHODPR(T, SetTemperature, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_temperature(float)", AS_METHODPR(T, SetTemperature, (float), void), AS_CALL_THISCALL);

    // void Light::SetUsePhysicalValues(bool enable)
    engine->RegisterObjectMethod(className, "void SetUsePhysicalValues(bool)", AS_METHODPR(T, SetUsePhysicalValues, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_usePhysicalValues(bool)", AS_METHODPR(T, SetUsePhysicalValues, (bool), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    // static Matrix3x4 Light::GetFullscreenQuadTransform(Camera* camera)
    engine->SetDefaultNamespace(className);engine->RegisterGlobalFunction("Matrix3x4 GetFullscreenQuadTransform(Camera@+)", AS_FUNCTIONPR(T::GetFullscreenQuadTransform, (Camera*), Matrix3x4), AS_CALL_CDECL);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Light
        REGISTER_MEMBERS_MANUAL_PART_Light();
    #endif
}

// class LineEdit | File: ../UI/LineEdit.h
template <class T> void RegisterMembers_LineEdit(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // BorderImage* LineEdit::GetCursor() const
    engine->RegisterObjectMethod(className, "BorderImage@+ GetCursor() const", AS_METHODPR(T, GetCursor, () const, BorderImage*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BorderImage@+ get_cursor() const", AS_METHODPR(T, GetCursor, () const, BorderImage*), AS_CALL_THISCALL);

    // float LineEdit::GetCursorBlinkRate() const
    engine->RegisterObjectMethod(className, "float GetCursorBlinkRate() const", AS_METHODPR(T, GetCursorBlinkRate, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_cursorBlinkRate() const", AS_METHODPR(T, GetCursorBlinkRate, () const, float), AS_CALL_THISCALL);

    // unsigned LineEdit::GetCursorPosition() const
    engine->RegisterObjectMethod(className, "uint GetCursorPosition() const", AS_METHODPR(T, GetCursorPosition, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_cursorPosition() const", AS_METHODPR(T, GetCursorPosition, () const, unsigned), AS_CALL_THISCALL);

    // unsigned LineEdit::GetEchoCharacter() const
    engine->RegisterObjectMethod(className, "uint GetEchoCharacter() const", AS_METHODPR(T, GetEchoCharacter, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_echoCharacter() const", AS_METHODPR(T, GetEchoCharacter, () const, unsigned), AS_CALL_THISCALL);

    // unsigned LineEdit::GetMaxLength() const
    engine->RegisterObjectMethod(className, "uint GetMaxLength() const", AS_METHODPR(T, GetMaxLength, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxLength() const", AS_METHODPR(T, GetMaxLength, () const, unsigned), AS_CALL_THISCALL);

    // const String& LineEdit::GetText() const
    engine->RegisterObjectMethod(className, "const String& GetText() const", AS_METHODPR(T, GetText, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_text() const", AS_METHODPR(T, GetText, () const, const String&), AS_CALL_THISCALL);

    // Text* LineEdit::GetTextElement() const
    engine->RegisterObjectMethod(className, "Text@+ GetTextElement() const", AS_METHODPR(T, GetTextElement, () const, Text*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Text@+ get_textElement() const", AS_METHODPR(T, GetTextElement, () const, Text*), AS_CALL_THISCALL);

    // bool LineEdit::IsCursorMovable() const
    engine->RegisterObjectMethod(className, "bool IsCursorMovable() const", AS_METHODPR(T, IsCursorMovable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_cursorMovable() const", AS_METHODPR(T, IsCursorMovable, () const, bool), AS_CALL_THISCALL);

    // bool LineEdit::IsTextCopyable() const
    engine->RegisterObjectMethod(className, "bool IsTextCopyable() const", AS_METHODPR(T, IsTextCopyable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_textCopyable() const", AS_METHODPR(T, IsTextCopyable, () const, bool), AS_CALL_THISCALL);

    // bool LineEdit::IsTextSelectable() const
    engine->RegisterObjectMethod(className, "bool IsTextSelectable() const", AS_METHODPR(T, IsTextSelectable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_textSelectable() const", AS_METHODPR(T, IsTextSelectable, () const, bool), AS_CALL_THISCALL);

    // void LineEdit::SetCursorBlinkRate(float rate)
    engine->RegisterObjectMethod(className, "void SetCursorBlinkRate(float)", AS_METHODPR(T, SetCursorBlinkRate, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cursorBlinkRate(float)", AS_METHODPR(T, SetCursorBlinkRate, (float), void), AS_CALL_THISCALL);

    // void LineEdit::SetCursorMovable(bool enable)
    engine->RegisterObjectMethod(className, "void SetCursorMovable(bool)", AS_METHODPR(T, SetCursorMovable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cursorMovable(bool)", AS_METHODPR(T, SetCursorMovable, (bool), void), AS_CALL_THISCALL);

    // void LineEdit::SetCursorPosition(unsigned position)
    engine->RegisterObjectMethod(className, "void SetCursorPosition(uint)", AS_METHODPR(T, SetCursorPosition, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_cursorPosition(uint)", AS_METHODPR(T, SetCursorPosition, (unsigned), void), AS_CALL_THISCALL);

    // void LineEdit::SetEchoCharacter(unsigned c)
    engine->RegisterObjectMethod(className, "void SetEchoCharacter(uint)", AS_METHODPR(T, SetEchoCharacter, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_echoCharacter(uint)", AS_METHODPR(T, SetEchoCharacter, (unsigned), void), AS_CALL_THISCALL);

    // void LineEdit::SetMaxLength(unsigned length)
    engine->RegisterObjectMethod(className, "void SetMaxLength(uint)", AS_METHODPR(T, SetMaxLength, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLength(uint)", AS_METHODPR(T, SetMaxLength, (unsigned), void), AS_CALL_THISCALL);

    // void LineEdit::SetText(const String& text)
    engine->RegisterObjectMethod(className, "void SetText(const String&in)", AS_METHODPR(T, SetText, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_text(const String&in)", AS_METHODPR(T, SetText, (const String&), void), AS_CALL_THISCALL);

    // void LineEdit::SetTextCopyable(bool enable)
    engine->RegisterObjectMethod(className, "void SetTextCopyable(bool)", AS_METHODPR(T, SetTextCopyable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textCopyable(bool)", AS_METHODPR(T, SetTextCopyable, (bool), void), AS_CALL_THISCALL);

    // void LineEdit::SetTextSelectable(bool enable)
    engine->RegisterObjectMethod(className, "void SetTextSelectable(bool)", AS_METHODPR(T, SetTextSelectable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textSelectable(bool)", AS_METHODPR(T, SetTextSelectable, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_LineEdit
        REGISTER_MEMBERS_MANUAL_PART_LineEdit();
    #endif
}

// PODVector<UIElement*> ListView::GetItems() const
template <class T> CScriptArray* ListView_PODVectorlesUIElementstargre_GetItems_void_template(T* _ptr)
{
    PODVector<UIElement*> result = _ptr->GetItems();
    return VectorToHandleArray(result, "Array<UIElement@>");
}

// PODVector<UIElement*> ListView::GetSelectedItems() const
template <class T> CScriptArray* ListView_PODVectorlesUIElementstargre_GetSelectedItems_void_template(T* _ptr)
{
    PODVector<UIElement*> result = _ptr->GetSelectedItems();
    return VectorToHandleArray(result, "Array<UIElement@>");
}

// const PODVector<unsigned>& ListView::GetSelections() const
template <class T> CScriptArray* ListView_constspPODVectorlesunsignedgreamp_GetSelections_void_template(T* _ptr)
{
    const PODVector<unsigned>& result = _ptr->GetSelections();
    return VectorToArray(result, "Array<uint>");
}

// void ListView::SetSelections(const PODVector<unsigned>& indices)
template <class T> void ListView_void_SetSelections_constspPODVectorlesunsignedgreamp_template(T* _ptr, CScriptArray* indices_conv)
{
    PODVector<unsigned> indices = ArrayToPODVector<unsigned>(indices_conv);
    _ptr->SetSelections(indices);
}

// class ListView | File: ../UI/ListView.h
template <class T> void RegisterMembers_ListView(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_ScrollView<T>(engine, className);

    // void ListView::AddItem(UIElement* item)
    engine->RegisterObjectMethod(className, "void AddItem(UIElement@+)", AS_METHODPR(T, AddItem, (UIElement*), void), AS_CALL_THISCALL);

    // void ListView::AddSelection(unsigned index)
    engine->RegisterObjectMethod(className, "void AddSelection(uint)", AS_METHODPR(T, AddSelection, (unsigned), void), AS_CALL_THISCALL);

    // void ListView::ChangeSelection(int delta, bool additive = false)
    engine->RegisterObjectMethod(className, "void ChangeSelection(int, bool = false)", AS_METHODPR(T, ChangeSelection, (int, bool), void), AS_CALL_THISCALL);

    // void ListView::ClearSelection()
    engine->RegisterObjectMethod(className, "void ClearSelection()", AS_METHODPR(T, ClearSelection, (), void), AS_CALL_THISCALL);

    // void ListView::CopySelectedItemsToClipboard() const
    engine->RegisterObjectMethod(className, "void CopySelectedItemsToClipboard() const", AS_METHODPR(T, CopySelectedItemsToClipboard, () const, void), AS_CALL_THISCALL);

    // void ListView::DisableInternalLayoutUpdate()
    engine->RegisterObjectMethod(className, "void DisableInternalLayoutUpdate()", AS_METHODPR(T, DisableInternalLayoutUpdate, (), void), AS_CALL_THISCALL);

    // void ListView::EnableInternalLayoutUpdate()
    engine->RegisterObjectMethod(className, "void EnableInternalLayoutUpdate()", AS_METHODPR(T, EnableInternalLayoutUpdate, (), void), AS_CALL_THISCALL);

    // void ListView::EnsureItemVisibility(unsigned index)
    engine->RegisterObjectMethod(className, "void EnsureItemVisibility(uint)", AS_METHODPR(T, EnsureItemVisibility, (unsigned), void), AS_CALL_THISCALL);

    // void ListView::EnsureItemVisibility(UIElement* item)
    engine->RegisterObjectMethod(className, "void EnsureItemVisibility(UIElement@+)", AS_METHODPR(T, EnsureItemVisibility, (UIElement*), void), AS_CALL_THISCALL);

    // void ListView::Expand(unsigned index, bool enable, bool recursive = false)
    engine->RegisterObjectMethod(className, "void Expand(uint, bool, bool = false)", AS_METHODPR(T, Expand, (unsigned, bool, bool), void), AS_CALL_THISCALL);

    // unsigned ListView::FindItem(UIElement* item) const
    engine->RegisterObjectMethod(className, "uint FindItem(UIElement@+) const", AS_METHODPR(T, FindItem, (UIElement*) const, unsigned), AS_CALL_THISCALL);

    // int ListView::GetBaseIndent() const
    engine->RegisterObjectMethod(className, "int GetBaseIndent() const", AS_METHODPR(T, GetBaseIndent, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_baseIndent() const", AS_METHODPR(T, GetBaseIndent, () const, int), AS_CALL_THISCALL);

    // bool ListView::GetClearSelectionOnDefocus() const
    engine->RegisterObjectMethod(className, "bool GetClearSelectionOnDefocus() const", AS_METHODPR(T, GetClearSelectionOnDefocus, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_clearSelectionOnDefocus() const", AS_METHODPR(T, GetClearSelectionOnDefocus, () const, bool), AS_CALL_THISCALL);

    // bool ListView::GetHierarchyMode() const
    engine->RegisterObjectMethod(className, "bool GetHierarchyMode() const", AS_METHODPR(T, GetHierarchyMode, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_hierarchyMode() const", AS_METHODPR(T, GetHierarchyMode, () const, bool), AS_CALL_THISCALL);

    // HighlightMode ListView::GetHighlightMode() const
    engine->RegisterObjectMethod(className, "HighlightMode GetHighlightMode() const", AS_METHODPR(T, GetHighlightMode, () const, HighlightMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "HighlightMode get_highlightMode() const", AS_METHODPR(T, GetHighlightMode, () const, HighlightMode), AS_CALL_THISCALL);

    // UIElement* ListView::GetItem(unsigned index) const
    engine->RegisterObjectMethod(className, "UIElement@+ GetItem(uint) const", AS_METHODPR(T, GetItem, (unsigned) const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_items(uint) const", AS_METHODPR(T, GetItem, (unsigned) const, UIElement*), AS_CALL_THISCALL);

    // PODVector<UIElement*> ListView::GetItems() const
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetItems() const", AS_FUNCTION_OBJFIRST(ListView_PODVectorlesUIElementstargre_GetItems_void_template<ListView>), AS_CALL_CDECL_OBJFIRST);

    // bool ListView::GetMultiselect() const
    engine->RegisterObjectMethod(className, "bool GetMultiselect() const", AS_METHODPR(T, GetMultiselect, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_multiselect() const", AS_METHODPR(T, GetMultiselect, () const, bool), AS_CALL_THISCALL);

    // unsigned ListView::GetNumItems() const
    engine->RegisterObjectMethod(className, "uint GetNumItems() const", AS_METHODPR(T, GetNumItems, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numItems() const", AS_METHODPR(T, GetNumItems, () const, unsigned), AS_CALL_THISCALL);

    // UIElement* ListView::GetSelectedItem() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetSelectedItem() const", AS_METHODPR(T, GetSelectedItem, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_selectedItem() const", AS_METHODPR(T, GetSelectedItem, () const, UIElement*), AS_CALL_THISCALL);

    // PODVector<UIElement*> ListView::GetSelectedItems() const
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetSelectedItems() const", AS_FUNCTION_OBJFIRST(ListView_PODVectorlesUIElementstargre_GetSelectedItems_void_template<ListView>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ get_selectedItems() const", AS_FUNCTION_OBJFIRST(ListView_PODVectorlesUIElementstargre_GetSelectedItems_void_template<ListView>), AS_CALL_CDECL_OBJFIRST);

    // unsigned ListView::GetSelection() const
    engine->RegisterObjectMethod(className, "uint GetSelection() const", AS_METHODPR(T, GetSelection, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_selection() const", AS_METHODPR(T, GetSelection, () const, unsigned), AS_CALL_THISCALL);

    // const PODVector<unsigned>& ListView::GetSelections() const
    engine->RegisterObjectMethod(className, "Array<uint>@ GetSelections() const", AS_FUNCTION_OBJFIRST(ListView_constspPODVectorlesunsignedgreamp_GetSelections_void_template<ListView>), AS_CALL_CDECL_OBJFIRST);
    engine->RegisterObjectMethod(className, "Array<uint>@ get_selections() const", AS_FUNCTION_OBJFIRST(ListView_constspPODVectorlesunsignedgreamp_GetSelections_void_template<ListView>), AS_CALL_CDECL_OBJFIRST);

    // bool ListView::GetSelectOnClickEnd() const
    engine->RegisterObjectMethod(className, "bool GetSelectOnClickEnd() const", AS_METHODPR(T, GetSelectOnClickEnd, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_selectOnClickEnd() const", AS_METHODPR(T, GetSelectOnClickEnd, () const, bool), AS_CALL_THISCALL);

    // void ListView::InsertItem(unsigned index, UIElement* item, UIElement* parentItem = nullptr)
    engine->RegisterObjectMethod(className, "void InsertItem(uint, UIElement@+, UIElement@+ = null)", AS_METHODPR(T, InsertItem, (unsigned, UIElement*, UIElement*), void), AS_CALL_THISCALL);

    // bool ListView::IsExpanded(unsigned index) const
    engine->RegisterObjectMethod(className, "bool IsExpanded(uint) const", AS_METHODPR(T, IsExpanded, (unsigned) const, bool), AS_CALL_THISCALL);

    // bool ListView::IsSelected(unsigned index) const
    engine->RegisterObjectMethod(className, "bool IsSelected(uint) const", AS_METHODPR(T, IsSelected, (unsigned) const, bool), AS_CALL_THISCALL);

    // void ListView::RemoveAllItems()
    engine->RegisterObjectMethod(className, "void RemoveAllItems()", AS_METHODPR(T, RemoveAllItems, (), void), AS_CALL_THISCALL);

    // void ListView::RemoveItem(UIElement* item, unsigned index = 0)
    engine->RegisterObjectMethod(className, "void RemoveItem(UIElement@+, uint = 0)", AS_METHODPR(T, RemoveItem, (UIElement*, unsigned), void), AS_CALL_THISCALL);

    // void ListView::RemoveItem(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveItem(uint)", AS_METHODPR(T, RemoveItem, (unsigned), void), AS_CALL_THISCALL);

    // void ListView::RemoveSelection(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveSelection(uint)", AS_METHODPR(T, RemoveSelection, (unsigned), void), AS_CALL_THISCALL);

    // void ListView::SetBaseIndent(int baseIndent)
    engine->RegisterObjectMethod(className, "void SetBaseIndent(int)", AS_METHODPR(T, SetBaseIndent, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_baseIndent(int)", AS_METHODPR(T, SetBaseIndent, (int), void), AS_CALL_THISCALL);

    // void ListView::SetClearSelectionOnDefocus(bool enable)
    engine->RegisterObjectMethod(className, "void SetClearSelectionOnDefocus(bool)", AS_METHODPR(T, SetClearSelectionOnDefocus, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_clearSelectionOnDefocus(bool)", AS_METHODPR(T, SetClearSelectionOnDefocus, (bool), void), AS_CALL_THISCALL);

    // void ListView::SetHierarchyMode(bool enable)
    engine->RegisterObjectMethod(className, "void SetHierarchyMode(bool)", AS_METHODPR(T, SetHierarchyMode, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hierarchyMode(bool)", AS_METHODPR(T, SetHierarchyMode, (bool), void), AS_CALL_THISCALL);

    // void ListView::SetHighlightMode(HighlightMode mode)
    engine->RegisterObjectMethod(className, "void SetHighlightMode(HighlightMode)", AS_METHODPR(T, SetHighlightMode, (HighlightMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_highlightMode(HighlightMode)", AS_METHODPR(T, SetHighlightMode, (HighlightMode), void), AS_CALL_THISCALL);

    // void ListView::SetMultiselect(bool enable)
    engine->RegisterObjectMethod(className, "void SetMultiselect(bool)", AS_METHODPR(T, SetMultiselect, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_multiselect(bool)", AS_METHODPR(T, SetMultiselect, (bool), void), AS_CALL_THISCALL);

    // void ListView::SetSelection(unsigned index)
    engine->RegisterObjectMethod(className, "void SetSelection(uint)", AS_METHODPR(T, SetSelection, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_selection(uint)", AS_METHODPR(T, SetSelection, (unsigned), void), AS_CALL_THISCALL);

    // void ListView::SetSelections(const PODVector<unsigned>& indices)
    engine->RegisterObjectMethod(className, "void SetSelections(Array<uint>@+)", AS_FUNCTION_OBJFIRST(ListView_void_SetSelections_constspPODVectorlesunsignedgreamp_template<ListView>), AS_CALL_CDECL_OBJFIRST);

    // void ListView::SetSelectOnClickEnd(bool enable)
    engine->RegisterObjectMethod(className, "void SetSelectOnClickEnd(bool)", AS_METHODPR(T, SetSelectOnClickEnd, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_selectOnClickEnd(bool)", AS_METHODPR(T, SetSelectOnClickEnd, (bool), void), AS_CALL_THISCALL);

    // void ListView::ToggleExpand(unsigned index, bool recursive = false)
    engine->RegisterObjectMethod(className, "void ToggleExpand(uint, bool = false)", AS_METHODPR(T, ToggleExpand, (unsigned, bool), void), AS_CALL_THISCALL);

    // void ListView::ToggleSelection(unsigned index)
    engine->RegisterObjectMethod(className, "void ToggleSelection(uint)", AS_METHODPR(T, ToggleSelection, (unsigned), void), AS_CALL_THISCALL);

    // void ListView::UpdateInternalLayout()
    engine->RegisterObjectMethod(className, "void UpdateInternalLayout()", AS_METHODPR(T, UpdateInternalLayout, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ListView
        REGISTER_MEMBERS_MANUAL_PART_ListView();
    #endif
}

// class ProgressBar | File: ../UI/ProgressBar.h
template <class T> void RegisterMembers_ProgressBar(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // void ProgressBar::ChangeValue(float delta)
    engine->RegisterObjectMethod(className, "void ChangeValue(float)", AS_METHODPR(T, ChangeValue, (float), void), AS_CALL_THISCALL);

    // BorderImage* ProgressBar::GetKnob() const
    engine->RegisterObjectMethod(className, "BorderImage@+ GetKnob() const", AS_METHODPR(T, GetKnob, () const, BorderImage*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BorderImage@+ get_knob() const", AS_METHODPR(T, GetKnob, () const, BorderImage*), AS_CALL_THISCALL);

    // const String& ProgressBar::GetLoadingPercentStyle() const
    engine->RegisterObjectMethod(className, "const String& GetLoadingPercentStyle() const", AS_METHODPR(T, GetLoadingPercentStyle, () const, const String&), AS_CALL_THISCALL);

    // Orientation ProgressBar::GetOrientation() const
    engine->RegisterObjectMethod(className, "Orientation GetOrientation() const", AS_METHODPR(T, GetOrientation, () const, Orientation), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Orientation get_orientation() const", AS_METHODPR(T, GetOrientation, () const, Orientation), AS_CALL_THISCALL);

    // float ProgressBar::GetRange() const
    engine->RegisterObjectMethod(className, "float GetRange() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_range() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);

    // bool ProgressBar::GetShowPercentText() const
    engine->RegisterObjectMethod(className, "bool GetShowPercentText() const", AS_METHODPR(T, GetShowPercentText, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_showPercentText() const", AS_METHODPR(T, GetShowPercentText, () const, bool), AS_CALL_THISCALL);

    // float ProgressBar::GetValue() const
    engine->RegisterObjectMethod(className, "float GetValue() const", AS_METHODPR(T, GetValue, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_value() const", AS_METHODPR(T, GetValue, () const, float), AS_CALL_THISCALL);

    // void ProgressBar::SetLoadingPercentStyle(const String& style)
    engine->RegisterObjectMethod(className, "void SetLoadingPercentStyle(const String&in)", AS_METHODPR(T, SetLoadingPercentStyle, (const String&), void), AS_CALL_THISCALL);

    // void ProgressBar::SetOrientation(Orientation orientation)
    engine->RegisterObjectMethod(className, "void SetOrientation(Orientation)", AS_METHODPR(T, SetOrientation, (Orientation), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orientation(Orientation)", AS_METHODPR(T, SetOrientation, (Orientation), void), AS_CALL_THISCALL);

    // void ProgressBar::SetRange(float range)
    engine->RegisterObjectMethod(className, "void SetRange(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_range(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);

    // void ProgressBar::SetShowPercentText(bool enable)
    engine->RegisterObjectMethod(className, "void SetShowPercentText(bool)", AS_METHODPR(T, SetShowPercentText, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_showPercentText(bool)", AS_METHODPR(T, SetShowPercentText, (bool), void), AS_CALL_THISCALL);

    // void ProgressBar::SetValue(float value)
    engine->RegisterObjectMethod(className, "void SetValue(float)", AS_METHODPR(T, SetValue, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_value(float)", AS_METHODPR(T, SetValue, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ProgressBar
        REGISTER_MEMBERS_MANUAL_PART_ProgressBar();
    #endif
}

// class RibbonTrail | File: ../Graphics/RibbonTrail.h
template <class T> void RegisterMembers_RibbonTrail(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // void RibbonTrail::Commit()
    engine->RegisterObjectMethod(className, "void Commit()", AS_METHODPR(T, Commit, (), void), AS_CALL_THISCALL);

    // float RibbonTrail::GetAnimationLodBias() const
    engine->RegisterObjectMethod(className, "float GetAnimationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_animationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);

    // const Vector3& RibbonTrail::GetBaseVelocity() const
    engine->RegisterObjectMethod(className, "const Vector3& GetBaseVelocity() const", AS_METHODPR(T, GetBaseVelocity, () const, const Vector3&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector3& get_baseVelocity() const", AS_METHODPR(T, GetBaseVelocity, () const, const Vector3&), AS_CALL_THISCALL);

    // const Color& RibbonTrail::GetEndColor() const
    engine->RegisterObjectMethod(className, "const Color& GetEndColor() const", AS_METHODPR(T, GetEndColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_endColor() const", AS_METHODPR(T, GetEndColor, () const, const Color&), AS_CALL_THISCALL);

    // float RibbonTrail::GetEndScale() const
    engine->RegisterObjectMethod(className, "float GetEndScale() const", AS_METHODPR(T, GetEndScale, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_endScale() const", AS_METHODPR(T, GetEndScale, () const, float), AS_CALL_THISCALL);

    // float RibbonTrail::GetLifetime() const
    engine->RegisterObjectMethod(className, "float GetLifetime() const", AS_METHODPR(T, GetLifetime, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lifetime() const", AS_METHODPR(T, GetLifetime, () const, float), AS_CALL_THISCALL);

    // Material* RibbonTrail::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef RibbonTrail::GetMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetMaterialAttr() const", AS_METHODPR(T, GetMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // const Color& RibbonTrail::GetStartColor() const
    engine->RegisterObjectMethod(className, "const Color& GetStartColor() const", AS_METHODPR(T, GetStartColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_startColor() const", AS_METHODPR(T, GetStartColor, () const, const Color&), AS_CALL_THISCALL);

    // float RibbonTrail::GetStartScale() const
    engine->RegisterObjectMethod(className, "float GetStartScale() const", AS_METHODPR(T, GetStartScale, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_startScale() const", AS_METHODPR(T, GetStartScale, () const, float), AS_CALL_THISCALL);

    // unsigned RibbonTrail::GetTailColumn() const
    engine->RegisterObjectMethod(className, "uint GetTailColumn() const", AS_METHODPR(T, GetTailColumn, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_tailColumn() const", AS_METHODPR(T, GetTailColumn, () const, unsigned), AS_CALL_THISCALL);

    // TrailType RibbonTrail::GetTrailType() const
    engine->RegisterObjectMethod(className, "TrailType GetTrailType() const", AS_METHODPR(T, GetTrailType, () const, TrailType), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TrailType get_trailType() const", AS_METHODPR(T, GetTrailType, () const, TrailType), AS_CALL_THISCALL);

    // bool RibbonTrail::GetUpdateInvisible() const
    engine->RegisterObjectMethod(className, "bool GetUpdateInvisible() const", AS_METHODPR(T, GetUpdateInvisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateInvisible() const", AS_METHODPR(T, GetUpdateInvisible, () const, bool), AS_CALL_THISCALL);

    // float RibbonTrail::GetVertexDistance() const
    engine->RegisterObjectMethod(className, "float GetVertexDistance() const", AS_METHODPR(T, GetVertexDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_vertexDistance() const", AS_METHODPR(T, GetVertexDistance, () const, float), AS_CALL_THISCALL);

    // float RibbonTrail::GetWidth() const
    engine->RegisterObjectMethod(className, "float GetWidth() const", AS_METHODPR(T, GetWidth, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_width() const", AS_METHODPR(T, GetWidth, () const, float), AS_CALL_THISCALL);

    // bool RibbonTrail::IsEmitting() const
    engine->RegisterObjectMethod(className, "bool IsEmitting() const", AS_METHODPR(T, IsEmitting, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_emitting() const", AS_METHODPR(T, IsEmitting, () const, bool), AS_CALL_THISCALL);

    // bool RibbonTrail::IsSorted() const
    engine->RegisterObjectMethod(className, "bool IsSorted() const", AS_METHODPR(T, IsSorted, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_sorted() const", AS_METHODPR(T, IsSorted, () const, bool), AS_CALL_THISCALL);

    // void RibbonTrail::SetAnimationLodBias(float bias)
    engine->RegisterObjectMethod(className, "void SetAnimationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetBaseVelocity(const Vector3& baseVelocity)
    engine->RegisterObjectMethod(className, "void SetBaseVelocity(const Vector3&in)", AS_METHODPR(T, SetBaseVelocity, (const Vector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_baseVelocity(const Vector3&in)", AS_METHODPR(T, SetBaseVelocity, (const Vector3&), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetEmitting(bool emitting)
    engine->RegisterObjectMethod(className, "void SetEmitting(bool)", AS_METHODPR(T, SetEmitting, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_emitting(bool)", AS_METHODPR(T, SetEmitting, (bool), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetEndColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetEndColor(const Color&in)", AS_METHODPR(T, SetEndColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_endColor(const Color&in)", AS_METHODPR(T, SetEndColor, (const Color&), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetEndScale(float endScale)
    engine->RegisterObjectMethod(className, "void SetEndScale(float)", AS_METHODPR(T, SetEndScale, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_endScale(float)", AS_METHODPR(T, SetEndScale, (float), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetLifetime(float time)
    engine->RegisterObjectMethod(className, "void SetLifetime(float)", AS_METHODPR(T, SetLifetime, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lifetime(float)", AS_METHODPR(T, SetLifetime, (float), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetSorted(bool enable)
    engine->RegisterObjectMethod(className, "void SetSorted(bool)", AS_METHODPR(T, SetSorted, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sorted(bool)", AS_METHODPR(T, SetSorted, (bool), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetStartColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetStartColor(const Color&in)", AS_METHODPR(T, SetStartColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_startColor(const Color&in)", AS_METHODPR(T, SetStartColor, (const Color&), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetStartScale(float startScale)
    engine->RegisterObjectMethod(className, "void SetStartScale(float)", AS_METHODPR(T, SetStartScale, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_startScale(float)", AS_METHODPR(T, SetStartScale, (float), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetTailColumn(unsigned tailColumn)
    engine->RegisterObjectMethod(className, "void SetTailColumn(uint)", AS_METHODPR(T, SetTailColumn, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_tailColumn(uint)", AS_METHODPR(T, SetTailColumn, (unsigned), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetTrailType(TrailType type)
    engine->RegisterObjectMethod(className, "void SetTrailType(TrailType)", AS_METHODPR(T, SetTrailType, (TrailType), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_trailType(TrailType)", AS_METHODPR(T, SetTrailType, (TrailType), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetUpdateInvisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetUpdateInvisible(bool)", AS_METHODPR(T, SetUpdateInvisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateInvisible(bool)", AS_METHODPR(T, SetUpdateInvisible, (bool), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetVertexDistance(float length)
    engine->RegisterObjectMethod(className, "void SetVertexDistance(float)", AS_METHODPR(T, SetVertexDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexDistance(float)", AS_METHODPR(T, SetVertexDistance, (float), void), AS_CALL_THISCALL);

    // void RibbonTrail::SetWidth(float width)
    engine->RegisterObjectMethod(className, "void SetWidth(float)", AS_METHODPR(T, SetWidth, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_width(float)", AS_METHODPR(T, SetWidth, (float), void), AS_CALL_THISCALL);

    // void RibbonTrail::Update(const FrameInfo& frame) override
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RibbonTrail
        REGISTER_MEMBERS_MANUAL_PART_RibbonTrail();
    #endif
}

// class ScrollBar | File: ../UI/ScrollBar.h
template <class T> void RegisterMembers_ScrollBar(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // void ScrollBar::ChangeValue(float delta)
    engine->RegisterObjectMethod(className, "void ChangeValue(float)", AS_METHODPR(T, ChangeValue, (float), void), AS_CALL_THISCALL);

    // Button* ScrollBar::GetBackButton() const
    engine->RegisterObjectMethod(className, "Button@+ GetBackButton() const", AS_METHODPR(T, GetBackButton, () const, Button*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Button@+ get_backButton() const", AS_METHODPR(T, GetBackButton, () const, Button*), AS_CALL_THISCALL);

    // float ScrollBar::GetEffectiveScrollStep() const
    engine->RegisterObjectMethod(className, "float GetEffectiveScrollStep() const", AS_METHODPR(T, GetEffectiveScrollStep, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_effectiveScrollStep() const", AS_METHODPR(T, GetEffectiveScrollStep, () const, float), AS_CALL_THISCALL);

    // Button* ScrollBar::GetForwardButton() const
    engine->RegisterObjectMethod(className, "Button@+ GetForwardButton() const", AS_METHODPR(T, GetForwardButton, () const, Button*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Button@+ get_forwardButton() const", AS_METHODPR(T, GetForwardButton, () const, Button*), AS_CALL_THISCALL);

    // Orientation ScrollBar::GetOrientation() const
    engine->RegisterObjectMethod(className, "Orientation GetOrientation() const", AS_METHODPR(T, GetOrientation, () const, Orientation), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Orientation get_orientation() const", AS_METHODPR(T, GetOrientation, () const, Orientation), AS_CALL_THISCALL);

    // float ScrollBar::GetRange() const
    engine->RegisterObjectMethod(className, "float GetRange() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_range() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);

    // float ScrollBar::GetScrollStep() const
    engine->RegisterObjectMethod(className, "float GetScrollStep() const", AS_METHODPR(T, GetScrollStep, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_scrollStep() const", AS_METHODPR(T, GetScrollStep, () const, float), AS_CALL_THISCALL);

    // Slider* ScrollBar::GetSlider() const
    engine->RegisterObjectMethod(className, "Slider@+ GetSlider() const", AS_METHODPR(T, GetSlider, () const, Slider*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Slider@+ get_slider() const", AS_METHODPR(T, GetSlider, () const, Slider*), AS_CALL_THISCALL);

    // float ScrollBar::GetStepFactor() const
    engine->RegisterObjectMethod(className, "float GetStepFactor() const", AS_METHODPR(T, GetStepFactor, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_stepFactor() const", AS_METHODPR(T, GetStepFactor, () const, float), AS_CALL_THISCALL);

    // float ScrollBar::GetValue() const
    engine->RegisterObjectMethod(className, "float GetValue() const", AS_METHODPR(T, GetValue, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_value() const", AS_METHODPR(T, GetValue, () const, float), AS_CALL_THISCALL);

    // void ScrollBar::SetOrientation(Orientation orientation)
    engine->RegisterObjectMethod(className, "void SetOrientation(Orientation)", AS_METHODPR(T, SetOrientation, (Orientation), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orientation(Orientation)", AS_METHODPR(T, SetOrientation, (Orientation), void), AS_CALL_THISCALL);

    // void ScrollBar::SetRange(float range)
    engine->RegisterObjectMethod(className, "void SetRange(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_range(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);

    // void ScrollBar::SetScrollStep(float step)
    engine->RegisterObjectMethod(className, "void SetScrollStep(float)", AS_METHODPR(T, SetScrollStep, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_scrollStep(float)", AS_METHODPR(T, SetScrollStep, (float), void), AS_CALL_THISCALL);

    // void ScrollBar::SetStepFactor(float factor)
    engine->RegisterObjectMethod(className, "void SetStepFactor(float)", AS_METHODPR(T, SetStepFactor, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_stepFactor(float)", AS_METHODPR(T, SetStepFactor, (float), void), AS_CALL_THISCALL);

    // void ScrollBar::SetValue(float value)
    engine->RegisterObjectMethod(className, "void SetValue(float)", AS_METHODPR(T, SetValue, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_value(float)", AS_METHODPR(T, SetValue, (float), void), AS_CALL_THISCALL);

    // void ScrollBar::StepBack()
    engine->RegisterObjectMethod(className, "void StepBack()", AS_METHODPR(T, StepBack, (), void), AS_CALL_THISCALL);

    // void ScrollBar::StepForward()
    engine->RegisterObjectMethod(className, "void StepForward()", AS_METHODPR(T, StepForward, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ScrollBar
        REGISTER_MEMBERS_MANUAL_PART_ScrollBar();
    #endif
}

// class Slider | File: ../UI/Slider.h
template <class T> void RegisterMembers_Slider(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // void Slider::ChangeValue(float delta)
    engine->RegisterObjectMethod(className, "void ChangeValue(float)", AS_METHODPR(T, ChangeValue, (float), void), AS_CALL_THISCALL);

    // BorderImage* Slider::GetKnob() const
    engine->RegisterObjectMethod(className, "BorderImage@+ GetKnob() const", AS_METHODPR(T, GetKnob, () const, BorderImage*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BorderImage@+ get_knob() const", AS_METHODPR(T, GetKnob, () const, BorderImage*), AS_CALL_THISCALL);

    // Orientation Slider::GetOrientation() const
    engine->RegisterObjectMethod(className, "Orientation GetOrientation() const", AS_METHODPR(T, GetOrientation, () const, Orientation), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Orientation get_orientation() const", AS_METHODPR(T, GetOrientation, () const, Orientation), AS_CALL_THISCALL);

    // float Slider::GetRange() const
    engine->RegisterObjectMethod(className, "float GetRange() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_range() const", AS_METHODPR(T, GetRange, () const, float), AS_CALL_THISCALL);

    // float Slider::GetRepeatRate() const
    engine->RegisterObjectMethod(className, "float GetRepeatRate() const", AS_METHODPR(T, GetRepeatRate, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_repeatRate() const", AS_METHODPR(T, GetRepeatRate, () const, float), AS_CALL_THISCALL);

    // float Slider::GetValue() const
    engine->RegisterObjectMethod(className, "float GetValue() const", AS_METHODPR(T, GetValue, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_value() const", AS_METHODPR(T, GetValue, () const, float), AS_CALL_THISCALL);

    // void Slider::SetOrientation(Orientation orientation)
    engine->RegisterObjectMethod(className, "void SetOrientation(Orientation)", AS_METHODPR(T, SetOrientation, (Orientation), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orientation(Orientation)", AS_METHODPR(T, SetOrientation, (Orientation), void), AS_CALL_THISCALL);

    // void Slider::SetRange(float range)
    engine->RegisterObjectMethod(className, "void SetRange(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_range(float)", AS_METHODPR(T, SetRange, (float), void), AS_CALL_THISCALL);

    // void Slider::SetRepeatRate(float rate)
    engine->RegisterObjectMethod(className, "void SetRepeatRate(float)", AS_METHODPR(T, SetRepeatRate, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_repeatRate(float)", AS_METHODPR(T, SetRepeatRate, (float), void), AS_CALL_THISCALL);

    // void Slider::SetValue(float value)
    engine->RegisterObjectMethod(className, "void SetValue(float)", AS_METHODPR(T, SetValue, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_value(float)", AS_METHODPR(T, SetValue, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Slider
        REGISTER_MEMBERS_MANUAL_PART_Slider();
    #endif
}

// class SoundSource3D | File: ../Audio/SoundSource3D.h
template <class T> void RegisterMembers_SoundSource3D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_SoundSource<T>(engine, className);

    // void SoundSource3D::CalculateAttenuation()
    engine->RegisterObjectMethod(className, "void CalculateAttenuation()", AS_METHODPR(T, CalculateAttenuation, (), void), AS_CALL_THISCALL);

    // float SoundSource3D::GetFarDistance() const
    engine->RegisterObjectMethod(className, "float GetFarDistance() const", AS_METHODPR(T, GetFarDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_farDistance() const", AS_METHODPR(T, GetFarDistance, () const, float), AS_CALL_THISCALL);

    // float SoundSource3D::GetInnerAngle() const
    engine->RegisterObjectMethod(className, "float GetInnerAngle() const", AS_METHODPR(T, GetInnerAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_innerAngle() const", AS_METHODPR(T, GetInnerAngle, () const, float), AS_CALL_THISCALL);

    // float SoundSource3D::GetNearDistance() const
    engine->RegisterObjectMethod(className, "float GetNearDistance() const", AS_METHODPR(T, GetNearDistance, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_nearDistance() const", AS_METHODPR(T, GetNearDistance, () const, float), AS_CALL_THISCALL);

    // float SoundSource3D::GetOuterAngle() const
    engine->RegisterObjectMethod(className, "float GetOuterAngle() const", AS_METHODPR(T, GetOuterAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_outerAngle() const", AS_METHODPR(T, GetOuterAngle, () const, float), AS_CALL_THISCALL);

    // float SoundSource3D::RollAngleoffFactor() const
    engine->RegisterObjectMethod(className, "float RollAngleoffFactor() const", AS_METHODPR(T, RollAngleoffFactor, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rolloffFactor() const", AS_METHODPR(T, RollAngleoffFactor, () const, float), AS_CALL_THISCALL);

    // void SoundSource3D::SetAngleAttenuation(float innerAngle, float outerAngle)
    engine->RegisterObjectMethod(className, "void SetAngleAttenuation(float, float)", AS_METHODPR(T, SetAngleAttenuation, (float, float), void), AS_CALL_THISCALL);

    // void SoundSource3D::SetDistanceAttenuation(float nearDistance, float farDistance, float rolloffFactor)
    engine->RegisterObjectMethod(className, "void SetDistanceAttenuation(float, float, float)", AS_METHODPR(T, SetDistanceAttenuation, (float, float, float), void), AS_CALL_THISCALL);

    // void SoundSource3D::SetFarDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetFarDistance(float)", AS_METHODPR(T, SetFarDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_farDistance(float)", AS_METHODPR(T, SetFarDistance, (float), void), AS_CALL_THISCALL);

    // void SoundSource3D::SetInnerAngle(float angle)
    engine->RegisterObjectMethod(className, "void SetInnerAngle(float)", AS_METHODPR(T, SetInnerAngle, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_innerAngle(float)", AS_METHODPR(T, SetInnerAngle, (float), void), AS_CALL_THISCALL);

    // void SoundSource3D::SetNearDistance(float distance)
    engine->RegisterObjectMethod(className, "void SetNearDistance(float)", AS_METHODPR(T, SetNearDistance, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_nearDistance(float)", AS_METHODPR(T, SetNearDistance, (float), void), AS_CALL_THISCALL);

    // void SoundSource3D::SetOuterAngle(float angle)
    engine->RegisterObjectMethod(className, "void SetOuterAngle(float)", AS_METHODPR(T, SetOuterAngle, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_outerAngle(float)", AS_METHODPR(T, SetOuterAngle, (float), void), AS_CALL_THISCALL);

    // void SoundSource3D::SetRolloffFactor(float factor)
    engine->RegisterObjectMethod(className, "void SetRolloffFactor(float)", AS_METHODPR(T, SetRolloffFactor, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rolloffFactor(float)", AS_METHODPR(T, SetRolloffFactor, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_SoundSource3D
        REGISTER_MEMBERS_MANUAL_PART_SoundSource3D();
    #endif
}

// class StaticModel | File: ../Graphics/StaticModel.h
template <class T> void RegisterMembers_StaticModel(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // virtual void StaticModel::SetModel(Model* model)
    // Can not be registered here bacause hidden in derived classes: AnimatedModel

    // void StaticModel::ApplyMaterialList(const String& fileName = String::EMPTY)
    engine->RegisterObjectMethod(className, "void ApplyMaterialList(const String&in = String::EMPTY)", AS_METHODPR(T, ApplyMaterialList, (const String&), void), AS_CALL_THISCALL);

    // virtual Material* StaticModel::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // virtual Material* StaticModel::GetMaterial(unsigned index) const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial(uint) const", AS_METHODPR(T, GetMaterial, (unsigned) const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_materials(uint) const", AS_METHODPR(T, GetMaterial, (unsigned) const, Material*), AS_CALL_THISCALL);

    // const ResourceRefList& StaticModel::GetMaterialsAttr() const
    engine->RegisterObjectMethod(className, "const ResourceRefList& GetMaterialsAttr() const", AS_METHODPR(T, GetMaterialsAttr, () const, const ResourceRefList&), AS_CALL_THISCALL);

    // Model* StaticModel::GetModel() const
    engine->RegisterObjectMethod(className, "Model@+ GetModel() const", AS_METHODPR(T, GetModel, () const, Model*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Model@+ get_model() const", AS_METHODPR(T, GetModel, () const, Model*), AS_CALL_THISCALL);

    // ResourceRef StaticModel::GetModelAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetModelAttr() const", AS_METHODPR(T, GetModelAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // unsigned StaticModel::GetNumGeometries() const
    engine->RegisterObjectMethod(className, "uint GetNumGeometries() const", AS_METHODPR(T, GetNumGeometries, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numGeometries() const", AS_METHODPR(T, GetNumGeometries, () const, unsigned), AS_CALL_THISCALL);

    // unsigned StaticModel::GetOcclusionLodLevel() const
    engine->RegisterObjectMethod(className, "uint GetOcclusionLodLevel() const", AS_METHODPR(T, GetOcclusionLodLevel, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_occlusionLodLevel() const", AS_METHODPR(T, GetOcclusionLodLevel, () const, unsigned), AS_CALL_THISCALL);

    // bool StaticModel::IsInside(const Vector3& point) const
    engine->RegisterObjectMethod(className, "bool IsInside(const Vector3&in) const", AS_METHODPR(T, IsInside, (const Vector3&) const, bool), AS_CALL_THISCALL);

    // bool StaticModel::IsInsideLocal(const Vector3& point) const
    engine->RegisterObjectMethod(className, "bool IsInsideLocal(const Vector3&in) const", AS_METHODPR(T, IsInsideLocal, (const Vector3&) const, bool), AS_CALL_THISCALL);

    // virtual void StaticModel::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // virtual bool StaticModel::SetMaterial(unsigned index, Material* material)
    engine->RegisterObjectMethod(className, "bool SetMaterial(uint, Material@+)", AS_METHODPR(T, SetMaterial, (unsigned, Material*), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_materials(uint, Material@+)", AS_METHODPR(T, SetMaterial, (unsigned, Material*), bool), AS_CALL_THISCALL);

    // void StaticModel::SetMaterialsAttr(const ResourceRefList& value)
    engine->RegisterObjectMethod(className, "void SetMaterialsAttr(const ResourceRefList&in)", AS_METHODPR(T, SetMaterialsAttr, (const ResourceRefList&), void), AS_CALL_THISCALL);

    // void StaticModel::SetModelAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetModelAttr(const ResourceRef&in)", AS_METHODPR(T, SetModelAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void StaticModel::SetOcclusionLodLevel(unsigned level)
    engine->RegisterObjectMethod(className, "void SetOcclusionLodLevel(uint)", AS_METHODPR(T, SetOcclusionLodLevel, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_occlusionLodLevel(uint)", AS_METHODPR(T, SetOcclusionLodLevel, (unsigned), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StaticModel
        REGISTER_MEMBERS_MANUAL_PART_StaticModel();
    #endif
}

// class TerrainPatch | File: ../Graphics/TerrainPatch.h
template <class T> void RegisterMembers_TerrainPatch(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // PODVector<float>& TerrainPatch::GetLodErrors()
    // Error: type "PODVector<float>&" can not automatically bind

    // const IntVector2& TerrainPatch::GetCoordinates() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetCoordinates() const", AS_METHODPR(T, GetCoordinates, () const, const IntVector2&), AS_CALL_THISCALL);

    // TerrainPatch* TerrainPatch::GetEastPatch() const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetEastPatch() const", AS_METHODPR(T, GetEastPatch, () const, TerrainPatch*), AS_CALL_THISCALL);

    // Geometry* TerrainPatch::GetGeometry() const
    engine->RegisterObjectMethod(className, "Geometry@+ GetGeometry() const", AS_METHODPR(T, GetGeometry, () const, Geometry*), AS_CALL_THISCALL);

    // unsigned TerrainPatch::GetLodLevel() const
    engine->RegisterObjectMethod(className, "uint GetLodLevel() const", AS_METHODPR(T, GetLodLevel, () const, unsigned), AS_CALL_THISCALL);

    // Geometry* TerrainPatch::GetMaxLodGeometry() const
    engine->RegisterObjectMethod(className, "Geometry@+ GetMaxLodGeometry() const", AS_METHODPR(T, GetMaxLodGeometry, () const, Geometry*), AS_CALL_THISCALL);

    // TerrainPatch* TerrainPatch::GetNorthPatch() const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetNorthPatch() const", AS_METHODPR(T, GetNorthPatch, () const, TerrainPatch*), AS_CALL_THISCALL);

    // Geometry* TerrainPatch::GetOcclusionGeometry() const
    engine->RegisterObjectMethod(className, "Geometry@+ GetOcclusionGeometry() const", AS_METHODPR(T, GetOcclusionGeometry, () const, Geometry*), AS_CALL_THISCALL);

    // Terrain* TerrainPatch::GetOwner() const
    engine->RegisterObjectMethod(className, "Terrain@+ GetOwner() const", AS_METHODPR(T, GetOwner, () const, Terrain*), AS_CALL_THISCALL);

    // TerrainPatch* TerrainPatch::GetSouthPatch() const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetSouthPatch() const", AS_METHODPR(T, GetSouthPatch, () const, TerrainPatch*), AS_CALL_THISCALL);

    // VertexBuffer* TerrainPatch::GetVertexBuffer() const
    engine->RegisterObjectMethod(className, "VertexBuffer@+ GetVertexBuffer() const", AS_METHODPR(T, GetVertexBuffer, () const, VertexBuffer*), AS_CALL_THISCALL);

    // TerrainPatch* TerrainPatch::GetWestPatch() const
    engine->RegisterObjectMethod(className, "TerrainPatch@+ GetWestPatch() const", AS_METHODPR(T, GetWestPatch, () const, TerrainPatch*), AS_CALL_THISCALL);

    // void TerrainPatch::ResetLod()
    engine->RegisterObjectMethod(className, "void ResetLod()", AS_METHODPR(T, ResetLod, (), void), AS_CALL_THISCALL);

    // void TerrainPatch::SetBoundingBox(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void SetBoundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void TerrainPatch::SetCoordinates(const IntVector2& coordinates)
    engine->RegisterObjectMethod(className, "void SetCoordinates(const IntVector2&in)", AS_METHODPR(T, SetCoordinates, (const IntVector2&), void), AS_CALL_THISCALL);

    // void TerrainPatch::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void TerrainPatch::SetNeighbors(TerrainPatch* north, TerrainPatch* south, TerrainPatch* west, TerrainPatch* east)
    engine->RegisterObjectMethod(className, "void SetNeighbors(TerrainPatch@+, TerrainPatch@+, TerrainPatch@+, TerrainPatch@+)", AS_METHODPR(T, SetNeighbors, (TerrainPatch*, TerrainPatch*, TerrainPatch*, TerrainPatch*), void), AS_CALL_THISCALL);

    // void TerrainPatch::SetOwner(Terrain* terrain)
    engine->RegisterObjectMethod(className, "void SetOwner(Terrain@+)", AS_METHODPR(T, SetOwner, (Terrain*), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_TerrainPatch
        REGISTER_MEMBERS_MANUAL_PART_TerrainPatch();
    #endif
}

// class Text | File: ../UI/Text.h
template <class T> void RegisterMembers_Text(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_UISelectable<T>(engine, className);

    // void Text::ClearSelection()
    engine->RegisterObjectMethod(className, "void ClearSelection()", AS_METHODPR(T, ClearSelection, (), void), AS_CALL_THISCALL);

    // bool Text::GetAutoLocalizable() const
    engine->RegisterObjectMethod(className, "bool GetAutoLocalizable() const", AS_METHODPR(T, GetAutoLocalizable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoLocalizable() const", AS_METHODPR(T, GetAutoLocalizable, () const, bool), AS_CALL_THISCALL);

    // Vector2 Text::GetCharPosition(unsigned index)
    engine->RegisterObjectMethod(className, "Vector2 GetCharPosition(uint)", AS_METHODPR(T, GetCharPosition, (unsigned), Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_charPositions(uint)", AS_METHODPR(T, GetCharPosition, (unsigned), Vector2), AS_CALL_THISCALL);

    // Vector2 Text::GetCharSize(unsigned index)
    engine->RegisterObjectMethod(className, "Vector2 GetCharSize(uint)", AS_METHODPR(T, GetCharSize, (unsigned), Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_charSizes(uint)", AS_METHODPR(T, GetCharSize, (unsigned), Vector2), AS_CALL_THISCALL);

    // const Color& Text::GetEffectColor() const
    engine->RegisterObjectMethod(className, "const Color& GetEffectColor() const", AS_METHODPR(T, GetEffectColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_effectColor() const", AS_METHODPR(T, GetEffectColor, () const, const Color&), AS_CALL_THISCALL);

    // float Text::GetEffectDepthBias() const
    engine->RegisterObjectMethod(className, "float GetEffectDepthBias() const", AS_METHODPR(T, GetEffectDepthBias, () const, float), AS_CALL_THISCALL);

    // bool Text::GetEffectRoundStroke() const
    engine->RegisterObjectMethod(className, "bool GetEffectRoundStroke() const", AS_METHODPR(T, GetEffectRoundStroke, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_effectRoundStroke() const", AS_METHODPR(T, GetEffectRoundStroke, () const, bool), AS_CALL_THISCALL);

    // const IntVector2& Text::GetEffectShadowOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetEffectShadowOffset() const", AS_METHODPR(T, GetEffectShadowOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_effectShadowOffset() const", AS_METHODPR(T, GetEffectShadowOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // int Text::GetEffectStrokeThickness() const
    engine->RegisterObjectMethod(className, "int GetEffectStrokeThickness() const", AS_METHODPR(T, GetEffectStrokeThickness, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_effectStrokeThickness() const", AS_METHODPR(T, GetEffectStrokeThickness, () const, int), AS_CALL_THISCALL);

    // Font* Text::GetFont() const
    engine->RegisterObjectMethod(className, "Font@+ GetFont() const", AS_METHODPR(T, GetFont, () const, Font*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Font@+ get_font() const", AS_METHODPR(T, GetFont, () const, Font*), AS_CALL_THISCALL);

    // ResourceRef Text::GetFontAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetFontAttr() const", AS_METHODPR(T, GetFontAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // float Text::GetFontSize() const
    engine->RegisterObjectMethod(className, "float GetFontSize() const", AS_METHODPR(T, GetFontSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fontSize() const", AS_METHODPR(T, GetFontSize, () const, float), AS_CALL_THISCALL);

    // unsigned Text::GetNumChars() const
    engine->RegisterObjectMethod(className, "uint GetNumChars() const", AS_METHODPR(T, GetNumChars, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numChars() const", AS_METHODPR(T, GetNumChars, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Text::GetNumRows() const
    engine->RegisterObjectMethod(className, "uint GetNumRows() const", AS_METHODPR(T, GetNumRows, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numRows() const", AS_METHODPR(T, GetNumRows, () const, unsigned), AS_CALL_THISCALL);

    // float Text::GetRowHeight() const
    engine->RegisterObjectMethod(className, "float GetRowHeight() const", AS_METHODPR(T, GetRowHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rowHeight() const", AS_METHODPR(T, GetRowHeight, () const, float), AS_CALL_THISCALL);

    // float Text::GetRowSpacing() const
    engine->RegisterObjectMethod(className, "float GetRowSpacing() const", AS_METHODPR(T, GetRowSpacing, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rowSpacing() const", AS_METHODPR(T, GetRowSpacing, () const, float), AS_CALL_THISCALL);

    // float Text::GetRowWidth(unsigned index) const
    engine->RegisterObjectMethod(className, "float GetRowWidth(uint) const", AS_METHODPR(T, GetRowWidth, (unsigned) const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rowWidths(uint) const", AS_METHODPR(T, GetRowWidth, (unsigned) const, float), AS_CALL_THISCALL);

    // unsigned Text::GetSelectionLength() const
    engine->RegisterObjectMethod(className, "uint GetSelectionLength() const", AS_METHODPR(T, GetSelectionLength, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_selectionLength() const", AS_METHODPR(T, GetSelectionLength, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Text::GetSelectionStart() const
    engine->RegisterObjectMethod(className, "uint GetSelectionStart() const", AS_METHODPR(T, GetSelectionStart, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_selectionStart() const", AS_METHODPR(T, GetSelectionStart, () const, unsigned), AS_CALL_THISCALL);

    // const String& Text::GetText() const
    engine->RegisterObjectMethod(className, "const String& GetText() const", AS_METHODPR(T, GetText, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_text() const", AS_METHODPR(T, GetText, () const, const String&), AS_CALL_THISCALL);

    // HorizontalAlignment Text::GetTextAlignment() const
    engine->RegisterObjectMethod(className, "HorizontalAlignment GetTextAlignment() const", AS_METHODPR(T, GetTextAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "HorizontalAlignment get_textAlignment() const", AS_METHODPR(T, GetTextAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);

    // String Text::GetTextAttr() const
    engine->RegisterObjectMethod(className, "String GetTextAttr() const", AS_METHODPR(T, GetTextAttr, () const, String), AS_CALL_THISCALL);

    // TextEffect Text::GetTextEffect() const
    engine->RegisterObjectMethod(className, "TextEffect GetTextEffect() const", AS_METHODPR(T, GetTextEffect, () const, TextEffect), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextEffect get_textEffect() const", AS_METHODPR(T, GetTextEffect, () const, TextEffect), AS_CALL_THISCALL);

    // bool Text::GetWordwrap() const
    engine->RegisterObjectMethod(className, "bool GetWordwrap() const", AS_METHODPR(T, GetWordwrap, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_wordwrap() const", AS_METHODPR(T, GetWordwrap, () const, bool), AS_CALL_THISCALL);

    // void Text::SetAutoLocalizable(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoLocalizable(bool)", AS_METHODPR(T, SetAutoLocalizable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoLocalizable(bool)", AS_METHODPR(T, SetAutoLocalizable, (bool), void), AS_CALL_THISCALL);

    // void Text::SetEffectColor(const Color& effectColor)
    engine->RegisterObjectMethod(className, "void SetEffectColor(const Color&in)", AS_METHODPR(T, SetEffectColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectColor(const Color&in)", AS_METHODPR(T, SetEffectColor, (const Color&), void), AS_CALL_THISCALL);

    // void Text::SetEffectDepthBias(float bias)
    engine->RegisterObjectMethod(className, "void SetEffectDepthBias(float)", AS_METHODPR(T, SetEffectDepthBias, (float), void), AS_CALL_THISCALL);

    // void Text::SetEffectRoundStroke(bool roundStroke)
    engine->RegisterObjectMethod(className, "void SetEffectRoundStroke(bool)", AS_METHODPR(T, SetEffectRoundStroke, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectRoundStroke(bool)", AS_METHODPR(T, SetEffectRoundStroke, (bool), void), AS_CALL_THISCALL);

    // void Text::SetEffectShadowOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetEffectShadowOffset(const IntVector2&in)", AS_METHODPR(T, SetEffectShadowOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectShadowOffset(const IntVector2&in)", AS_METHODPR(T, SetEffectShadowOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Text::SetEffectStrokeThickness(int thickness)
    engine->RegisterObjectMethod(className, "void SetEffectStrokeThickness(int)", AS_METHODPR(T, SetEffectStrokeThickness, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectStrokeThickness(int)", AS_METHODPR(T, SetEffectStrokeThickness, (int), void), AS_CALL_THISCALL);

    // bool Text::SetFont(const String& fontName, float size = DEFAULT_FONT_SIZE)
    engine->RegisterObjectMethod(className, "bool SetFont(const String&in, float = DEFAULT_FONT_SIZE)", AS_METHODPR(T, SetFont, (const String&, float), bool), AS_CALL_THISCALL);

    // bool Text::SetFont(Font* font, float size = DEFAULT_FONT_SIZE)
    engine->RegisterObjectMethod(className, "bool SetFont(Font@+, float = DEFAULT_FONT_SIZE)", AS_METHODPR(T, SetFont, (Font*, float), bool), AS_CALL_THISCALL);

    // void Text::SetFontAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetFontAttr(const ResourceRef&in)", AS_METHODPR(T, SetFontAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // bool Text::SetFontSize(float size)
    engine->RegisterObjectMethod(className, "bool SetFontSize(float)", AS_METHODPR(T, SetFontSize, (float), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_fontSize(float)", AS_METHODPR(T, SetFontSize, (float), bool), AS_CALL_THISCALL);

    // void Text::SetRowSpacing(float spacing)
    engine->RegisterObjectMethod(className, "void SetRowSpacing(float)", AS_METHODPR(T, SetRowSpacing, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rowSpacing(float)", AS_METHODPR(T, SetRowSpacing, (float), void), AS_CALL_THISCALL);

    // void Text::SetSelection(unsigned start, unsigned length = M_MAX_UNSIGNED)
    engine->RegisterObjectMethod(className, "void SetSelection(uint, uint = M_MAX_UNSIGNED)", AS_METHODPR(T, SetSelection, (unsigned, unsigned), void), AS_CALL_THISCALL);

    // void Text::SetText(const String& text)
    engine->RegisterObjectMethod(className, "void SetText(const String&in)", AS_METHODPR(T, SetText, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_text(const String&in)", AS_METHODPR(T, SetText, (const String&), void), AS_CALL_THISCALL);

    // void Text::SetTextAlignment(HorizontalAlignment align)
    engine->RegisterObjectMethod(className, "void SetTextAlignment(HorizontalAlignment)", AS_METHODPR(T, SetTextAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textAlignment(HorizontalAlignment)", AS_METHODPR(T, SetTextAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);

    // void Text::SetTextAttr(const String& value)
    engine->RegisterObjectMethod(className, "void SetTextAttr(const String&in)", AS_METHODPR(T, SetTextAttr, (const String&), void), AS_CALL_THISCALL);

    // void Text::SetTextEffect(TextEffect textEffect)
    engine->RegisterObjectMethod(className, "void SetTextEffect(TextEffect)", AS_METHODPR(T, SetTextEffect, (TextEffect), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textEffect(TextEffect)", AS_METHODPR(T, SetTextEffect, (TextEffect), void), AS_CALL_THISCALL);

    // void Text::SetWordwrap(bool enable)
    engine->RegisterObjectMethod(className, "void SetWordwrap(bool)", AS_METHODPR(T, SetWordwrap, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_wordwrap(bool)", AS_METHODPR(T, SetWordwrap, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Text
        REGISTER_MEMBERS_MANUAL_PART_Text();
    #endif
}

// class Text3D | File: ../UI/Text3D.h
template <class T> void RegisterMembers_Text3D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // Vector2 Text3D::GetCharPosition(unsigned index)
    engine->RegisterObjectMethod(className, "Vector2 GetCharPosition(uint)", AS_METHODPR(T, GetCharPosition, (unsigned), Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_charPositions(uint)", AS_METHODPR(T, GetCharPosition, (unsigned), Vector2), AS_CALL_THISCALL);

    // Vector2 Text3D::GetCharSize(unsigned index)
    engine->RegisterObjectMethod(className, "Vector2 GetCharSize(uint)", AS_METHODPR(T, GetCharSize, (unsigned), Vector2), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Vector2 get_charSizes(uint)", AS_METHODPR(T, GetCharSize, (unsigned), Vector2), AS_CALL_THISCALL);

    // const Color& Text3D::GetColor(Corner corner) const
    engine->RegisterObjectMethod(className, "const Color& GetColor(Corner) const", AS_METHODPR(T, GetColor, (Corner) const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_colors(Corner) const", AS_METHODPR(T, GetColor, (Corner) const, const Color&), AS_CALL_THISCALL);

    // const Color& Text3D::GetColorAttr() const
    engine->RegisterObjectMethod(className, "const Color& GetColorAttr() const", AS_METHODPR(T, GetColorAttr, () const, const Color&), AS_CALL_THISCALL);

    // const Color& Text3D::GetEffectColor() const
    engine->RegisterObjectMethod(className, "const Color& GetEffectColor() const", AS_METHODPR(T, GetEffectColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_effectColor() const", AS_METHODPR(T, GetEffectColor, () const, const Color&), AS_CALL_THISCALL);

    // float Text3D::GetEffectDepthBias() const
    engine->RegisterObjectMethod(className, "float GetEffectDepthBias() const", AS_METHODPR(T, GetEffectDepthBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_effectDepthBias() const", AS_METHODPR(T, GetEffectDepthBias, () const, float), AS_CALL_THISCALL);

    // bool Text3D::GetEffectRoundStroke() const
    engine->RegisterObjectMethod(className, "bool GetEffectRoundStroke() const", AS_METHODPR(T, GetEffectRoundStroke, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_effectRoundStroke() const", AS_METHODPR(T, GetEffectRoundStroke, () const, bool), AS_CALL_THISCALL);

    // const IntVector2& Text3D::GetEffectShadowOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetEffectShadowOffset() const", AS_METHODPR(T, GetEffectShadowOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_effectShadowOffset() const", AS_METHODPR(T, GetEffectShadowOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // int Text3D::GetEffectStrokeThickness() const
    engine->RegisterObjectMethod(className, "int GetEffectStrokeThickness() const", AS_METHODPR(T, GetEffectStrokeThickness, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_effectStrokeThickness() const", AS_METHODPR(T, GetEffectStrokeThickness, () const, int), AS_CALL_THISCALL);

    // FaceCameraMode Text3D::GetFaceCameraMode() const
    engine->RegisterObjectMethod(className, "FaceCameraMode GetFaceCameraMode() const", AS_METHODPR(T, GetFaceCameraMode, () const, FaceCameraMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "FaceCameraMode get_faceCameraMode() const", AS_METHODPR(T, GetFaceCameraMode, () const, FaceCameraMode), AS_CALL_THISCALL);

    // Font* Text3D::GetFont() const
    engine->RegisterObjectMethod(className, "Font@+ GetFont() const", AS_METHODPR(T, GetFont, () const, Font*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Font@+ get_font() const", AS_METHODPR(T, GetFont, () const, Font*), AS_CALL_THISCALL);

    // ResourceRef Text3D::GetFontAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetFontAttr() const", AS_METHODPR(T, GetFontAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // float Text3D::GetFontSize() const
    engine->RegisterObjectMethod(className, "float GetFontSize() const", AS_METHODPR(T, GetFontSize, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fontSize() const", AS_METHODPR(T, GetFontSize, () const, float), AS_CALL_THISCALL);

    // int Text3D::GetHeight() const
    engine->RegisterObjectMethod(className, "int GetHeight() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_height() const", AS_METHODPR(T, GetHeight, () const, int), AS_CALL_THISCALL);

    // HorizontalAlignment Text3D::GetHorizontalAlignment() const
    engine->RegisterObjectMethod(className, "HorizontalAlignment GetHorizontalAlignment() const", AS_METHODPR(T, GetHorizontalAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "HorizontalAlignment get_horizontalAlignment() const", AS_METHODPR(T, GetHorizontalAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);

    // Material* Text3D::GetMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_material() const", AS_METHODPR(T, GetMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef Text3D::GetMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetMaterialAttr() const", AS_METHODPR(T, GetMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // unsigned Text3D::GetNumChars() const
    engine->RegisterObjectMethod(className, "uint GetNumChars() const", AS_METHODPR(T, GetNumChars, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numChars() const", AS_METHODPR(T, GetNumChars, () const, unsigned), AS_CALL_THISCALL);

    // unsigned Text3D::GetNumRows() const
    engine->RegisterObjectMethod(className, "uint GetNumRows() const", AS_METHODPR(T, GetNumRows, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numRows() const", AS_METHODPR(T, GetNumRows, () const, unsigned), AS_CALL_THISCALL);

    // float Text3D::GetOpacity() const
    engine->RegisterObjectMethod(className, "float GetOpacity() const", AS_METHODPR(T, GetOpacity, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_opacity() const", AS_METHODPR(T, GetOpacity, () const, float), AS_CALL_THISCALL);

    // int Text3D::GetRowHeight() const
    engine->RegisterObjectMethod(className, "int GetRowHeight() const", AS_METHODPR(T, GetRowHeight, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_rowHeight() const", AS_METHODPR(T, GetRowHeight, () const, int), AS_CALL_THISCALL);

    // float Text3D::GetRowSpacing() const
    engine->RegisterObjectMethod(className, "float GetRowSpacing() const", AS_METHODPR(T, GetRowSpacing, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_rowSpacing() const", AS_METHODPR(T, GetRowSpacing, () const, float), AS_CALL_THISCALL);

    // int Text3D::GetRowWidth(unsigned index) const
    engine->RegisterObjectMethod(className, "int GetRowWidth(uint) const", AS_METHODPR(T, GetRowWidth, (unsigned) const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_rowWidths(uint) const", AS_METHODPR(T, GetRowWidth, (unsigned) const, int), AS_CALL_THISCALL);

    // const String& Text3D::GetText() const
    engine->RegisterObjectMethod(className, "const String& GetText() const", AS_METHODPR(T, GetText, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_text() const", AS_METHODPR(T, GetText, () const, const String&), AS_CALL_THISCALL);

    // HorizontalAlignment Text3D::GetTextAlignment() const
    engine->RegisterObjectMethod(className, "HorizontalAlignment GetTextAlignment() const", AS_METHODPR(T, GetTextAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "HorizontalAlignment get_textAlignment() const", AS_METHODPR(T, GetTextAlignment, () const, HorizontalAlignment), AS_CALL_THISCALL);

    // String Text3D::GetTextAttr() const
    engine->RegisterObjectMethod(className, "String GetTextAttr() const", AS_METHODPR(T, GetTextAttr, () const, String), AS_CALL_THISCALL);

    // TextEffect Text3D::GetTextEffect() const
    engine->RegisterObjectMethod(className, "TextEffect GetTextEffect() const", AS_METHODPR(T, GetTextEffect, () const, TextEffect), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "TextEffect get_textEffect() const", AS_METHODPR(T, GetTextEffect, () const, TextEffect), AS_CALL_THISCALL);

    // VerticalAlignment Text3D::GetVerticalAlignment() const
    engine->RegisterObjectMethod(className, "VerticalAlignment GetVerticalAlignment() const", AS_METHODPR(T, GetVerticalAlignment, () const, VerticalAlignment), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "VerticalAlignment get_verticalAlignment() const", AS_METHODPR(T, GetVerticalAlignment, () const, VerticalAlignment), AS_CALL_THISCALL);

    // int Text3D::GetWidth() const
    engine->RegisterObjectMethod(className, "int GetWidth() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_width() const", AS_METHODPR(T, GetWidth, () const, int), AS_CALL_THISCALL);

    // bool Text3D::GetWordwrap() const
    engine->RegisterObjectMethod(className, "bool GetWordwrap() const", AS_METHODPR(T, GetWordwrap, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_wordwrap() const", AS_METHODPR(T, GetWordwrap, () const, bool), AS_CALL_THISCALL);

    // bool Text3D::IsFixedScreenSize() const
    engine->RegisterObjectMethod(className, "bool IsFixedScreenSize() const", AS_METHODPR(T, IsFixedScreenSize, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedScreenSize() const", AS_METHODPR(T, IsFixedScreenSize, () const, bool), AS_CALL_THISCALL);

    // void Text3D::SetAlignment(HorizontalAlignment hAlign, VerticalAlignment vAlign)
    engine->RegisterObjectMethod(className, "void SetAlignment(HorizontalAlignment, VerticalAlignment)", AS_METHODPR(T, SetAlignment, (HorizontalAlignment, VerticalAlignment), void), AS_CALL_THISCALL);

    // void Text3D::SetColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetColor(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_color(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);

    // void Text3D::SetColor(Corner corner, const Color& color)
    engine->RegisterObjectMethod(className, "void SetColor(Corner, const Color&in)", AS_METHODPR(T, SetColor, (Corner, const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_colors(Corner, const Color&in)", AS_METHODPR(T, SetColor, (Corner, const Color&), void), AS_CALL_THISCALL);

    // void Text3D::SetEffectColor(const Color& effectColor)
    engine->RegisterObjectMethod(className, "void SetEffectColor(const Color&in)", AS_METHODPR(T, SetEffectColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectColor(const Color&in)", AS_METHODPR(T, SetEffectColor, (const Color&), void), AS_CALL_THISCALL);

    // void Text3D::SetEffectDepthBias(float bias)
    engine->RegisterObjectMethod(className, "void SetEffectDepthBias(float)", AS_METHODPR(T, SetEffectDepthBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectDepthBias(float)", AS_METHODPR(T, SetEffectDepthBias, (float), void), AS_CALL_THISCALL);

    // void Text3D::SetEffectRoundStroke(bool roundStroke)
    engine->RegisterObjectMethod(className, "void SetEffectRoundStroke(bool)", AS_METHODPR(T, SetEffectRoundStroke, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectRoundStroke(bool)", AS_METHODPR(T, SetEffectRoundStroke, (bool), void), AS_CALL_THISCALL);

    // void Text3D::SetEffectShadowOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetEffectShadowOffset(const IntVector2&in)", AS_METHODPR(T, SetEffectShadowOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectShadowOffset(const IntVector2&in)", AS_METHODPR(T, SetEffectShadowOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Text3D::SetEffectStrokeThickness(int thickness)
    engine->RegisterObjectMethod(className, "void SetEffectStrokeThickness(int)", AS_METHODPR(T, SetEffectStrokeThickness, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effectStrokeThickness(int)", AS_METHODPR(T, SetEffectStrokeThickness, (int), void), AS_CALL_THISCALL);

    // void Text3D::SetFaceCameraMode(FaceCameraMode mode)
    engine->RegisterObjectMethod(className, "void SetFaceCameraMode(FaceCameraMode)", AS_METHODPR(T, SetFaceCameraMode, (FaceCameraMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_faceCameraMode(FaceCameraMode)", AS_METHODPR(T, SetFaceCameraMode, (FaceCameraMode), void), AS_CALL_THISCALL);

    // void Text3D::SetFixedScreenSize(bool enable)
    engine->RegisterObjectMethod(className, "void SetFixedScreenSize(bool)", AS_METHODPR(T, SetFixedScreenSize, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedScreenSize(bool)", AS_METHODPR(T, SetFixedScreenSize, (bool), void), AS_CALL_THISCALL);

    // bool Text3D::SetFont(const String& fontName, float size = DEFAULT_FONT_SIZE)
    engine->RegisterObjectMethod(className, "bool SetFont(const String&in, float = DEFAULT_FONT_SIZE)", AS_METHODPR(T, SetFont, (const String&, float), bool), AS_CALL_THISCALL);

    // bool Text3D::SetFont(Font* font, float size = DEFAULT_FONT_SIZE)
    engine->RegisterObjectMethod(className, "bool SetFont(Font@+, float = DEFAULT_FONT_SIZE)", AS_METHODPR(T, SetFont, (Font*, float), bool), AS_CALL_THISCALL);

    // void Text3D::SetFontAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetFontAttr(const ResourceRef&in)", AS_METHODPR(T, SetFontAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // bool Text3D::SetFontSize(float size)
    engine->RegisterObjectMethod(className, "bool SetFontSize(float)", AS_METHODPR(T, SetFontSize, (float), bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool set_fontSize(float)", AS_METHODPR(T, SetFontSize, (float), bool), AS_CALL_THISCALL);

    // void Text3D::SetHorizontalAlignment(HorizontalAlignment align)
    engine->RegisterObjectMethod(className, "void SetHorizontalAlignment(HorizontalAlignment)", AS_METHODPR(T, SetHorizontalAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_horizontalAlignment(HorizontalAlignment)", AS_METHODPR(T, SetHorizontalAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);

    // void Text3D::SetMaterial(Material* material)
    engine->RegisterObjectMethod(className, "void SetMaterial(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_material(Material@+)", AS_METHODPR(T, SetMaterial, (Material*), void), AS_CALL_THISCALL);

    // void Text3D::SetMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void Text3D::SetOpacity(float opacity)
    engine->RegisterObjectMethod(className, "void SetOpacity(float)", AS_METHODPR(T, SetOpacity, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_opacity(float)", AS_METHODPR(T, SetOpacity, (float), void), AS_CALL_THISCALL);

    // void Text3D::SetRowSpacing(float spacing)
    engine->RegisterObjectMethod(className, "void SetRowSpacing(float)", AS_METHODPR(T, SetRowSpacing, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_rowSpacing(float)", AS_METHODPR(T, SetRowSpacing, (float), void), AS_CALL_THISCALL);

    // void Text3D::SetText(const String& text)
    engine->RegisterObjectMethod(className, "void SetText(const String&in)", AS_METHODPR(T, SetText, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_text(const String&in)", AS_METHODPR(T, SetText, (const String&), void), AS_CALL_THISCALL);

    // void Text3D::SetTextAlignment(HorizontalAlignment align)
    engine->RegisterObjectMethod(className, "void SetTextAlignment(HorizontalAlignment)", AS_METHODPR(T, SetTextAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textAlignment(HorizontalAlignment)", AS_METHODPR(T, SetTextAlignment, (HorizontalAlignment), void), AS_CALL_THISCALL);

    // void Text3D::SetTextAttr(const String& value)
    engine->RegisterObjectMethod(className, "void SetTextAttr(const String&in)", AS_METHODPR(T, SetTextAttr, (const String&), void), AS_CALL_THISCALL);

    // void Text3D::SetTextEffect(TextEffect textEffect)
    engine->RegisterObjectMethod(className, "void SetTextEffect(TextEffect)", AS_METHODPR(T, SetTextEffect, (TextEffect), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textEffect(TextEffect)", AS_METHODPR(T, SetTextEffect, (TextEffect), void), AS_CALL_THISCALL);

    // void Text3D::SetVerticalAlignment(VerticalAlignment align)
    engine->RegisterObjectMethod(className, "void SetVerticalAlignment(VerticalAlignment)", AS_METHODPR(T, SetVerticalAlignment, (VerticalAlignment), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_verticalAlignment(VerticalAlignment)", AS_METHODPR(T, SetVerticalAlignment, (VerticalAlignment), void), AS_CALL_THISCALL);

    // void Text3D::SetWidth(int width)
    engine->RegisterObjectMethod(className, "void SetWidth(int)", AS_METHODPR(T, SetWidth, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_width(int)", AS_METHODPR(T, SetWidth, (int), void), AS_CALL_THISCALL);

    // void Text3D::SetWordwrap(bool enable)
    engine->RegisterObjectMethod(className, "void SetWordwrap(bool)", AS_METHODPR(T, SetWordwrap, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_wordwrap(bool)", AS_METHODPR(T, SetWordwrap, (bool), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Text3D
        REGISTER_MEMBERS_MANUAL_PART_Text3D();
    #endif
}

// class Window | File: ../UI/Window.h
template <class T> void RegisterMembers_Window(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BorderImage<T>(engine, className);

    // bool Window::GetFixedHeightResizing() const
    engine->RegisterObjectMethod(className, "bool GetFixedHeightResizing() const", AS_METHODPR(T, GetFixedHeightResizing, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedHeightResizing() const", AS_METHODPR(T, GetFixedHeightResizing, () const, bool), AS_CALL_THISCALL);

    // bool Window::GetFixedWidthResizing() const
    engine->RegisterObjectMethod(className, "bool GetFixedWidthResizing() const", AS_METHODPR(T, GetFixedWidthResizing, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_fixedWidthResizing() const", AS_METHODPR(T, GetFixedWidthResizing, () const, bool), AS_CALL_THISCALL);

    // bool Window::GetModalAutoDismiss() const
    engine->RegisterObjectMethod(className, "bool GetModalAutoDismiss() const", AS_METHODPR(T, GetModalAutoDismiss, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_modalAutoDismiss() const", AS_METHODPR(T, GetModalAutoDismiss, () const, bool), AS_CALL_THISCALL);

    // const Color& Window::GetModalFrameColor() const
    engine->RegisterObjectMethod(className, "const Color& GetModalFrameColor() const", AS_METHODPR(T, GetModalFrameColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_modalFrameColor() const", AS_METHODPR(T, GetModalFrameColor, () const, const Color&), AS_CALL_THISCALL);

    // const IntVector2& Window::GetModalFrameSize() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetModalFrameSize() const", AS_METHODPR(T, GetModalFrameSize, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_modalFrameSize() const", AS_METHODPR(T, GetModalFrameSize, () const, const IntVector2&), AS_CALL_THISCALL);

    // const Color& Window::GetModalShadeColor() const
    engine->RegisterObjectMethod(className, "const Color& GetModalShadeColor() const", AS_METHODPR(T, GetModalShadeColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_modalShadeColor() const", AS_METHODPR(T, GetModalShadeColor, () const, const Color&), AS_CALL_THISCALL);

    // const IntRect& Window::GetResizeBorder() const
    engine->RegisterObjectMethod(className, "const IntRect& GetResizeBorder() const", AS_METHODPR(T, GetResizeBorder, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_resizeBorder() const", AS_METHODPR(T, GetResizeBorder, () const, const IntRect&), AS_CALL_THISCALL);

    // bool Window::IsModal() const
    engine->RegisterObjectMethod(className, "bool IsModal() const", AS_METHODPR(T, IsModal, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_modal() const", AS_METHODPR(T, IsModal, () const, bool), AS_CALL_THISCALL);

    // bool Window::IsMovable() const
    engine->RegisterObjectMethod(className, "bool IsMovable() const", AS_METHODPR(T, IsMovable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_movable() const", AS_METHODPR(T, IsMovable, () const, bool), AS_CALL_THISCALL);

    // bool Window::IsResizable() const
    engine->RegisterObjectMethod(className, "bool IsResizable() const", AS_METHODPR(T, IsResizable, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resizable() const", AS_METHODPR(T, IsResizable, () const, bool), AS_CALL_THISCALL);

    // void Window::SetFixedHeightResizing(bool enable)
    engine->RegisterObjectMethod(className, "void SetFixedHeightResizing(bool)", AS_METHODPR(T, SetFixedHeightResizing, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedHeightResizing(bool)", AS_METHODPR(T, SetFixedHeightResizing, (bool), void), AS_CALL_THISCALL);

    // void Window::SetFixedWidthResizing(bool enable)
    engine->RegisterObjectMethod(className, "void SetFixedWidthResizing(bool)", AS_METHODPR(T, SetFixedWidthResizing, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fixedWidthResizing(bool)", AS_METHODPR(T, SetFixedWidthResizing, (bool), void), AS_CALL_THISCALL);

    // void Window::SetModal(bool modal)
    engine->RegisterObjectMethod(className, "void SetModal(bool)", AS_METHODPR(T, SetModal, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modal(bool)", AS_METHODPR(T, SetModal, (bool), void), AS_CALL_THISCALL);

    // void Window::SetModalAutoDismiss(bool enable)
    engine->RegisterObjectMethod(className, "void SetModalAutoDismiss(bool)", AS_METHODPR(T, SetModalAutoDismiss, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalAutoDismiss(bool)", AS_METHODPR(T, SetModalAutoDismiss, (bool), void), AS_CALL_THISCALL);

    // void Window::SetModalFrameColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetModalFrameColor(const Color&in)", AS_METHODPR(T, SetModalFrameColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalFrameColor(const Color&in)", AS_METHODPR(T, SetModalFrameColor, (const Color&), void), AS_CALL_THISCALL);

    // void Window::SetModalFrameSize(const IntVector2& size)
    engine->RegisterObjectMethod(className, "void SetModalFrameSize(const IntVector2&in)", AS_METHODPR(T, SetModalFrameSize, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalFrameSize(const IntVector2&in)", AS_METHODPR(T, SetModalFrameSize, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Window::SetModalShadeColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetModalShadeColor(const Color&in)", AS_METHODPR(T, SetModalShadeColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_modalShadeColor(const Color&in)", AS_METHODPR(T, SetModalShadeColor, (const Color&), void), AS_CALL_THISCALL);

    // void Window::SetMovable(bool enable)
    engine->RegisterObjectMethod(className, "void SetMovable(bool)", AS_METHODPR(T, SetMovable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_movable(bool)", AS_METHODPR(T, SetMovable, (bool), void), AS_CALL_THISCALL);

    // void Window::SetResizable(bool enable)
    engine->RegisterObjectMethod(className, "void SetResizable(bool)", AS_METHODPR(T, SetResizable, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_resizable(bool)", AS_METHODPR(T, SetResizable, (bool), void), AS_CALL_THISCALL);

    // void Window::SetResizeBorder(const IntRect& rect)
    engine->RegisterObjectMethod(className, "void SetResizeBorder(const IntRect&in)", AS_METHODPR(T, SetResizeBorder, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_resizeBorder(const IntRect&in)", AS_METHODPR(T, SetResizeBorder, (const IntRect&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Window
        REGISTER_MEMBERS_MANUAL_PART_Window();
    #endif
}

// class Zone | File: ../Graphics/Zone.h
template <class T> void RegisterMembers_Zone(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // const Color& Zone::GetAmbientColor() const
    engine->RegisterObjectMethod(className, "const Color& GetAmbientColor() const", AS_METHODPR(T, GetAmbientColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_ambientColor() const", AS_METHODPR(T, GetAmbientColor, () const, const Color&), AS_CALL_THISCALL);

    // const Color& Zone::GetAmbientEndColor()
    engine->RegisterObjectMethod(className, "const Color& GetAmbientEndColor()", AS_METHODPR(T, GetAmbientEndColor, (), const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_ambientEndColor()", AS_METHODPR(T, GetAmbientEndColor, (), const Color&), AS_CALL_THISCALL);

    // bool Zone::GetAmbientGradient() const
    engine->RegisterObjectMethod(className, "bool GetAmbientGradient() const", AS_METHODPR(T, GetAmbientGradient, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_ambientGradient() const", AS_METHODPR(T, GetAmbientGradient, () const, bool), AS_CALL_THISCALL);

    // const Color& Zone::GetAmbientStartColor()
    engine->RegisterObjectMethod(className, "const Color& GetAmbientStartColor()", AS_METHODPR(T, GetAmbientStartColor, (), const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_ambientStartColor()", AS_METHODPR(T, GetAmbientStartColor, (), const Color&), AS_CALL_THISCALL);

    // const Color& Zone::GetFogColor() const
    engine->RegisterObjectMethod(className, "const Color& GetFogColor() const", AS_METHODPR(T, GetFogColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_fogColor() const", AS_METHODPR(T, GetFogColor, () const, const Color&), AS_CALL_THISCALL);

    // float Zone::GetFogEnd() const
    engine->RegisterObjectMethod(className, "float GetFogEnd() const", AS_METHODPR(T, GetFogEnd, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fogEnd() const", AS_METHODPR(T, GetFogEnd, () const, float), AS_CALL_THISCALL);

    // float Zone::GetFogHeight() const
    engine->RegisterObjectMethod(className, "float GetFogHeight() const", AS_METHODPR(T, GetFogHeight, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fogHeight() const", AS_METHODPR(T, GetFogHeight, () const, float), AS_CALL_THISCALL);

    // float Zone::GetFogHeightScale() const
    engine->RegisterObjectMethod(className, "float GetFogHeightScale() const", AS_METHODPR(T, GetFogHeightScale, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fogHeightScale() const", AS_METHODPR(T, GetFogHeightScale, () const, float), AS_CALL_THISCALL);

    // float Zone::GetFogStart() const
    engine->RegisterObjectMethod(className, "float GetFogStart() const", AS_METHODPR(T, GetFogStart, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_fogStart() const", AS_METHODPR(T, GetFogStart, () const, float), AS_CALL_THISCALL);

    // bool Zone::GetHeightFog() const
    engine->RegisterObjectMethod(className, "bool GetHeightFog() const", AS_METHODPR(T, GetHeightFog, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_heightFog() const", AS_METHODPR(T, GetHeightFog, () const, bool), AS_CALL_THISCALL);

    // const Matrix3x4& Zone::GetInverseWorldTransform() const
    engine->RegisterObjectMethod(className, "const Matrix3x4& GetInverseWorldTransform() const", AS_METHODPR(T, GetInverseWorldTransform, () const, const Matrix3x4&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Matrix3x4& get_inverseWorldTransform() const", AS_METHODPR(T, GetInverseWorldTransform, () const, const Matrix3x4&), AS_CALL_THISCALL);

    // bool Zone::GetOverride() const
    engine->RegisterObjectMethod(className, "bool GetOverride() const", AS_METHODPR(T, GetOverride, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_override() const", AS_METHODPR(T, GetOverride, () const, bool), AS_CALL_THISCALL);

    // int Zone::GetPriority() const
    engine->RegisterObjectMethod(className, "int GetPriority() const", AS_METHODPR(T, GetPriority, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_priority() const", AS_METHODPR(T, GetPriority, () const, int), AS_CALL_THISCALL);

    // Texture* Zone::GetZoneTexture() const
    engine->RegisterObjectMethod(className, "Texture@+ GetZoneTexture() const", AS_METHODPR(T, GetZoneTexture, () const, Texture*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture@+ get_zoneTexture() const", AS_METHODPR(T, GetZoneTexture, () const, Texture*), AS_CALL_THISCALL);

    // ResourceRef Zone::GetZoneTextureAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetZoneTextureAttr() const", AS_METHODPR(T, GetZoneTextureAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // bool Zone::IsInside(const Vector3& point) const
    engine->RegisterObjectMethod(className, "bool IsInside(const Vector3&in) const", AS_METHODPR(T, IsInside, (const Vector3&) const, bool), AS_CALL_THISCALL);

    // void Zone::SetAmbientColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetAmbientColor(const Color&in)", AS_METHODPR(T, SetAmbientColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ambientColor(const Color&in)", AS_METHODPR(T, SetAmbientColor, (const Color&), void), AS_CALL_THISCALL);

    // void Zone::SetAmbientGradient(bool enable)
    engine->RegisterObjectMethod(className, "void SetAmbientGradient(bool)", AS_METHODPR(T, SetAmbientGradient, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ambientGradient(bool)", AS_METHODPR(T, SetAmbientGradient, (bool), void), AS_CALL_THISCALL);

    // void Zone::SetBoundingBox(const BoundingBox& box)
    engine->RegisterObjectMethod(className, "void SetBoundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_boundingBox(const BoundingBox&in)", AS_METHODPR(T, SetBoundingBox, (const BoundingBox&), void), AS_CALL_THISCALL);

    // void Zone::SetFogColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetFogColor(const Color&in)", AS_METHODPR(T, SetFogColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fogColor(const Color&in)", AS_METHODPR(T, SetFogColor, (const Color&), void), AS_CALL_THISCALL);

    // void Zone::SetFogEnd(float end)
    engine->RegisterObjectMethod(className, "void SetFogEnd(float)", AS_METHODPR(T, SetFogEnd, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fogEnd(float)", AS_METHODPR(T, SetFogEnd, (float), void), AS_CALL_THISCALL);

    // void Zone::SetFogHeight(float height)
    engine->RegisterObjectMethod(className, "void SetFogHeight(float)", AS_METHODPR(T, SetFogHeight, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fogHeight(float)", AS_METHODPR(T, SetFogHeight, (float), void), AS_CALL_THISCALL);

    // void Zone::SetFogHeightScale(float scale)
    engine->RegisterObjectMethod(className, "void SetFogHeightScale(float)", AS_METHODPR(T, SetFogHeightScale, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fogHeightScale(float)", AS_METHODPR(T, SetFogHeightScale, (float), void), AS_CALL_THISCALL);

    // void Zone::SetFogStart(float start)
    engine->RegisterObjectMethod(className, "void SetFogStart(float)", AS_METHODPR(T, SetFogStart, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_fogStart(float)", AS_METHODPR(T, SetFogStart, (float), void), AS_CALL_THISCALL);

    // void Zone::SetHeightFog(bool enable)
    engine->RegisterObjectMethod(className, "void SetHeightFog(bool)", AS_METHODPR(T, SetHeightFog, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_heightFog(bool)", AS_METHODPR(T, SetHeightFog, (bool), void), AS_CALL_THISCALL);

    // void Zone::SetOverride(bool enable)
    engine->RegisterObjectMethod(className, "void SetOverride(bool)", AS_METHODPR(T, SetOverride, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_override(bool)", AS_METHODPR(T, SetOverride, (bool), void), AS_CALL_THISCALL);

    // void Zone::SetPriority(int priority)
    engine->RegisterObjectMethod(className, "void SetPriority(int)", AS_METHODPR(T, SetPriority, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_priority(int)", AS_METHODPR(T, SetPriority, (int), void), AS_CALL_THISCALL);

    // void Zone::SetZoneTexture(Texture* texture)
    engine->RegisterObjectMethod(className, "void SetZoneTexture(Texture@+)", AS_METHODPR(T, SetZoneTexture, (Texture*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_zoneTexture(Texture@+)", AS_METHODPR(T, SetZoneTexture, (Texture*), void), AS_CALL_THISCALL);

    // void Zone::SetZoneTextureAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetZoneTextureAttr(const ResourceRef&in)", AS_METHODPR(T, SetZoneTextureAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Zone
        REGISTER_MEMBERS_MANUAL_PART_Zone();
    #endif
}

#ifdef URHO3D_NAVIGATION

// class DynamicNavigationMesh | File: ../Navigation/DynamicNavigationMesh.h
template <class T> void RegisterMembers_DynamicNavigationMesh(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_NavigationMesh<T>(engine, className);

    // bool DynamicNavigationMesh::GetDrawObstacles() const
    engine->RegisterObjectMethod(className, "bool GetDrawObstacles() const", AS_METHODPR(T, GetDrawObstacles, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_drawObstacles() const", AS_METHODPR(T, GetDrawObstacles, () const, bool), AS_CALL_THISCALL);

    // unsigned DynamicNavigationMesh::GetMaxLayers() const
    engine->RegisterObjectMethod(className, "uint GetMaxLayers() const", AS_METHODPR(T, GetMaxLayers, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxLayers() const", AS_METHODPR(T, GetMaxLayers, () const, unsigned), AS_CALL_THISCALL);

    // unsigned DynamicNavigationMesh::GetMaxObstacles() const
    engine->RegisterObjectMethod(className, "uint GetMaxObstacles() const", AS_METHODPR(T, GetMaxObstacles, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_maxObstacles() const", AS_METHODPR(T, GetMaxObstacles, () const, unsigned), AS_CALL_THISCALL);

    // bool DynamicNavigationMesh::IsObstacleInTile(Obstacle* obstacle, const IntVector2& tile) const
    engine->RegisterObjectMethod(className, "bool IsObstacleInTile(Obstacle@+, const IntVector2&in) const", AS_METHODPR(T, IsObstacleInTile, (Obstacle*, const IntVector2&) const, bool), AS_CALL_THISCALL);

    // void DynamicNavigationMesh::SetDrawObstacles(bool enable)
    engine->RegisterObjectMethod(className, "void SetDrawObstacles(bool)", AS_METHODPR(T, SetDrawObstacles, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawObstacles(bool)", AS_METHODPR(T, SetDrawObstacles, (bool), void), AS_CALL_THISCALL);

    // void DynamicNavigationMesh::SetMaxLayers(unsigned maxLayers)
    engine->RegisterObjectMethod(className, "void SetMaxLayers(uint)", AS_METHODPR(T, SetMaxLayers, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLayers(uint)", AS_METHODPR(T, SetMaxLayers, (unsigned), void), AS_CALL_THISCALL);

    // void DynamicNavigationMesh::SetMaxObstacles(unsigned maxObstacles)
    engine->RegisterObjectMethod(className, "void SetMaxObstacles(uint)", AS_METHODPR(T, SetMaxObstacles, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxObstacles(uint)", AS_METHODPR(T, SetMaxObstacles, (unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DynamicNavigationMesh
        REGISTER_MEMBERS_MANUAL_PART_DynamicNavigationMesh();
    #endif
}

#endif // def URHO3D_NAVIGATION

#ifdef URHO3D_PHYSICS

// class RaycastVehicle | File: ../Physics/RaycastVehicle.h
template <class T> void RegisterMembers_RaycastVehicle(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_LogicComponent<T>(engine, className);

    // VariantVector RaycastVehicle::GetWheelDataAttr() const
    // Error: type "VariantVector" can not automatically bind
    // void RaycastVehicle::SetWheelDataAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // void RaycastVehicle::AddWheel(Node* wheelNode, Vector3 wheelDirection, Vector3 wheelAxle, float restLength, float wheelRadius, bool frontWheel)
    engine->RegisterObjectMethod(className, "void AddWheel(Node@+, Vector3, Vector3, float, float, bool)", AS_METHODPR(T, AddWheel, (Node*, Vector3, Vector3, float, float, bool), void), AS_CALL_THISCALL);

    // void RaycastVehicle::FixedPostUpdate(float timeStep) override
    engine->RegisterObjectMethod(className, "void FixedPostUpdate(float)", AS_METHODPR(T, FixedPostUpdate, (float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::FixedUpdate(float timeStep) override
    engine->RegisterObjectMethod(className, "void FixedUpdate(float)", AS_METHODPR(T, FixedUpdate, (float), void), AS_CALL_THISCALL);

    // float RaycastVehicle::GetBrake(int wheel) const
    engine->RegisterObjectMethod(className, "float GetBrake(int) const", AS_METHODPR(T, GetBrake, (int) const, float), AS_CALL_THISCALL);

    // Vector3 RaycastVehicle::GetContactNormal(int wheel) const
    engine->RegisterObjectMethod(className, "Vector3 GetContactNormal(int) const", AS_METHODPR(T, GetContactNormal, (int) const, Vector3), AS_CALL_THISCALL);

    // Vector3 RaycastVehicle::GetContactPosition(int wheel) const
    engine->RegisterObjectMethod(className, "Vector3 GetContactPosition(int) const", AS_METHODPR(T, GetContactPosition, (int) const, Vector3), AS_CALL_THISCALL);

    // IntVector3 RaycastVehicle::GetCoordinateSystem() const
    engine->RegisterObjectMethod(className, "IntVector3 GetCoordinateSystem() const", AS_METHODPR(T, GetCoordinateSystem, () const, IntVector3), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "IntVector3 get_coordinateSystem() const", AS_METHODPR(T, GetCoordinateSystem, () const, IntVector3), AS_CALL_THISCALL);

    // float RaycastVehicle::GetEngineForce(int wheel) const
    engine->RegisterObjectMethod(className, "float GetEngineForce(int) const", AS_METHODPR(T, GetEngineForce, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetInAirRPM() const
    engine->RegisterObjectMethod(className, "float GetInAirRPM() const", AS_METHODPR(T, GetInAirRPM, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_inAirRPM() const", AS_METHODPR(T, GetInAirRPM, () const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetMaxSideSlipSpeed() const
    engine->RegisterObjectMethod(className, "float GetMaxSideSlipSpeed() const", AS_METHODPR(T, GetMaxSideSlipSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxSideSlipSpeed() const", AS_METHODPR(T, GetMaxSideSlipSpeed, () const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetMaxSuspensionTravel(int wheel)
    engine->RegisterObjectMethod(className, "float GetMaxSuspensionTravel(int)", AS_METHODPR(T, GetMaxSuspensionTravel, (int), float), AS_CALL_THISCALL);

    // int RaycastVehicle::GetNumWheels() const
    engine->RegisterObjectMethod(className, "int GetNumWheels() const", AS_METHODPR(T, GetNumWheels, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_numWheels() const", AS_METHODPR(T, GetNumWheels, () const, int), AS_CALL_THISCALL);

    // float RaycastVehicle::GetSteeringValue(int wheel) const
    engine->RegisterObjectMethod(className, "float GetSteeringValue(int) const", AS_METHODPR(T, GetSteeringValue, (int) const, float), AS_CALL_THISCALL);

    // Vector3 RaycastVehicle::GetWheelAxle(int wheel) const
    engine->RegisterObjectMethod(className, "Vector3 GetWheelAxle(int) const", AS_METHODPR(T, GetWheelAxle, (int) const, Vector3), AS_CALL_THISCALL);

    // Vector3 RaycastVehicle::GetWheelConnectionPoint(int wheel) const
    engine->RegisterObjectMethod(className, "Vector3 GetWheelConnectionPoint(int) const", AS_METHODPR(T, GetWheelConnectionPoint, (int) const, Vector3), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelDampingCompression(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelDampingCompression(int) const", AS_METHODPR(T, GetWheelDampingCompression, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelDampingRelaxation(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelDampingRelaxation(int) const", AS_METHODPR(T, GetWheelDampingRelaxation, (int) const, float), AS_CALL_THISCALL);

    // Vector3 RaycastVehicle::GetWheelDirection(int wheel) const
    engine->RegisterObjectMethod(className, "Vector3 GetWheelDirection(int) const", AS_METHODPR(T, GetWheelDirection, (int) const, Vector3), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelFrictionSlip(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelFrictionSlip(int) const", AS_METHODPR(T, GetWheelFrictionSlip, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelMaxSuspensionForce(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelMaxSuspensionForce(int) const", AS_METHODPR(T, GetWheelMaxSuspensionForce, (int) const, float), AS_CALL_THISCALL);

    // Node* RaycastVehicle::GetWheelNode(int wheel) const
    engine->RegisterObjectMethod(className, "Node@+ GetWheelNode(int) const", AS_METHODPR(T, GetWheelNode, (int) const, Node*), AS_CALL_THISCALL);

    // Vector3 RaycastVehicle::GetWheelPosition(int wheel)
    engine->RegisterObjectMethod(className, "Vector3 GetWheelPosition(int)", AS_METHODPR(T, GetWheelPosition, (int), Vector3), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelRadius(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelRadius(int) const", AS_METHODPR(T, GetWheelRadius, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelRestLength(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelRestLength(int) const", AS_METHODPR(T, GetWheelRestLength, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelRollInfluence(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelRollInfluence(int) const", AS_METHODPR(T, GetWheelRollInfluence, (int) const, float), AS_CALL_THISCALL);

    // Quaternion RaycastVehicle::GetWheelRotation(int wheel)
    engine->RegisterObjectMethod(className, "Quaternion GetWheelRotation(int)", AS_METHODPR(T, GetWheelRotation, (int), Quaternion), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelSideSlipSpeed(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelSideSlipSpeed(int) const", AS_METHODPR(T, GetWheelSideSlipSpeed, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelSkidInfo(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelSkidInfo(int) const", AS_METHODPR(T, GetWheelSkidInfo, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelSkidInfoCumulative(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelSkidInfoCumulative(int) const", AS_METHODPR(T, GetWheelSkidInfoCumulative, (int) const, float), AS_CALL_THISCALL);

    // float RaycastVehicle::GetWheelSuspensionStiffness(int wheel) const
    engine->RegisterObjectMethod(className, "float GetWheelSuspensionStiffness(int) const", AS_METHODPR(T, GetWheelSuspensionStiffness, (int) const, float), AS_CALL_THISCALL);

    // void RaycastVehicle::Init()
    engine->RegisterObjectMethod(className, "void Init()", AS_METHODPR(T, Init, (), void), AS_CALL_THISCALL);

    // bool RaycastVehicle::IsFrontWheel(int wheel) const
    engine->RegisterObjectMethod(className, "bool IsFrontWheel(int) const", AS_METHODPR(T, IsFrontWheel, (int) const, bool), AS_CALL_THISCALL);

    // void RaycastVehicle::OnSetEnabled() override
    engine->RegisterObjectMethod(className, "void OnSetEnabled()", AS_METHODPR(T, OnSetEnabled, (), void), AS_CALL_THISCALL);

    // void RaycastVehicle::PostUpdate(float timeStep) override
    engine->RegisterObjectMethod(className, "void PostUpdate(float)", AS_METHODPR(T, PostUpdate, (float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::ResetSuspension()
    engine->RegisterObjectMethod(className, "void ResetSuspension()", AS_METHODPR(T, ResetSuspension, (), void), AS_CALL_THISCALL);

    // void RaycastVehicle::ResetWheels()
    engine->RegisterObjectMethod(className, "void ResetWheels()", AS_METHODPR(T, ResetWheels, (), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetBrake(int wheel, float force)
    engine->RegisterObjectMethod(className, "void SetBrake(int, float)", AS_METHODPR(T, SetBrake, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetCoordinateSystem(const IntVector3& coordinateSystem = RIGHT_FORWARD_UP)
    engine->RegisterObjectMethod(className, "void SetCoordinateSystem(const IntVector3&in = RIGHT_FORWARD_UP)", AS_METHODPR(T, SetCoordinateSystem, (const IntVector3&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_coordinateSystem(const IntVector3&in = RIGHT_FORWARD_UP)", AS_METHODPR(T, SetCoordinateSystem, (const IntVector3&), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetEngineForce(int wheel, float force)
    engine->RegisterObjectMethod(className, "void SetEngineForce(int, float)", AS_METHODPR(T, SetEngineForce, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetInAirRPM(float rpm)
    engine->RegisterObjectMethod(className, "void SetInAirRPM(float)", AS_METHODPR(T, SetInAirRPM, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_inAirRPM(float)", AS_METHODPR(T, SetInAirRPM, (float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetMaxSideSlipSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetMaxSideSlipSpeed(float)", AS_METHODPR(T, SetMaxSideSlipSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxSideSlipSpeed(float)", AS_METHODPR(T, SetMaxSideSlipSpeed, (float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetMaxSuspensionTravel(int wheel, float maxSuspensionTravel)
    engine->RegisterObjectMethod(className, "void SetMaxSuspensionTravel(int, float)", AS_METHODPR(T, SetMaxSuspensionTravel, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetSteeringValue(int wheel, float steeringValue)
    engine->RegisterObjectMethod(className, "void SetSteeringValue(int, float)", AS_METHODPR(T, SetSteeringValue, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelAxle(int wheel, Vector3 axle)
    engine->RegisterObjectMethod(className, "void SetWheelAxle(int, Vector3)", AS_METHODPR(T, SetWheelAxle, (int, Vector3), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelDampingCompression(int wheel, float compression)
    engine->RegisterObjectMethod(className, "void SetWheelDampingCompression(int, float)", AS_METHODPR(T, SetWheelDampingCompression, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelDampingRelaxation(int wheel, float damping)
    engine->RegisterObjectMethod(className, "void SetWheelDampingRelaxation(int, float)", AS_METHODPR(T, SetWheelDampingRelaxation, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelDirection(int wheel, Vector3 direction)
    engine->RegisterObjectMethod(className, "void SetWheelDirection(int, Vector3)", AS_METHODPR(T, SetWheelDirection, (int, Vector3), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelFrictionSlip(int wheel, float slip)
    engine->RegisterObjectMethod(className, "void SetWheelFrictionSlip(int, float)", AS_METHODPR(T, SetWheelFrictionSlip, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelMaxSuspensionForce(int wheel, float force)
    engine->RegisterObjectMethod(className, "void SetWheelMaxSuspensionForce(int, float)", AS_METHODPR(T, SetWheelMaxSuspensionForce, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelRadius(int wheel, float wheelRadius)
    engine->RegisterObjectMethod(className, "void SetWheelRadius(int, float)", AS_METHODPR(T, SetWheelRadius, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelRestLength(int wheel, float length)
    engine->RegisterObjectMethod(className, "void SetWheelRestLength(int, float)", AS_METHODPR(T, SetWheelRestLength, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelRollInfluence(int wheel, float rollInfluence)
    engine->RegisterObjectMethod(className, "void SetWheelRollInfluence(int, float)", AS_METHODPR(T, SetWheelRollInfluence, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelSkidInfo(int wheel, float factor)
    engine->RegisterObjectMethod(className, "void SetWheelSkidInfo(int, float)", AS_METHODPR(T, SetWheelSkidInfo, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelSkidInfoCumulative(int wheel, float skid)
    engine->RegisterObjectMethod(className, "void SetWheelSkidInfoCumulative(int, float)", AS_METHODPR(T, SetWheelSkidInfoCumulative, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::SetWheelSuspensionStiffness(int wheel, float stiffness)
    engine->RegisterObjectMethod(className, "void SetWheelSuspensionStiffness(int, float)", AS_METHODPR(T, SetWheelSuspensionStiffness, (int, float), void), AS_CALL_THISCALL);

    // void RaycastVehicle::UpdateWheelTransform(int wheel, bool interpolated)
    engine->RegisterObjectMethod(className, "void UpdateWheelTransform(int, bool)", AS_METHODPR(T, UpdateWheelTransform, (int, bool), void), AS_CALL_THISCALL);

    // bool RaycastVehicle::WheelIsGrounded(int wheel) const
    engine->RegisterObjectMethod(className, "bool WheelIsGrounded(int) const", AS_METHODPR(T, WheelIsGrounded, (int) const, bool), AS_CALL_THISCALL);

    // static const IntVector3 RaycastVehicle::RIGHT_UP_FORWARD
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 RIGHT_UP_FORWARD", (void*)&T::RIGHT_UP_FORWARD);engine->SetDefaultNamespace("");

    // static const IntVector3 RaycastVehicle::RIGHT_FORWARD_UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 RIGHT_FORWARD_UP", (void*)&T::RIGHT_FORWARD_UP);engine->SetDefaultNamespace("");

    // static const IntVector3 RaycastVehicle::UP_FORWARD_RIGHT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 UP_FORWARD_RIGHT", (void*)&T::UP_FORWARD_RIGHT);engine->SetDefaultNamespace("");

    // static const IntVector3 RaycastVehicle::UP_RIGHT_FORWARD
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 UP_RIGHT_FORWARD", (void*)&T::UP_RIGHT_FORWARD);engine->SetDefaultNamespace("");

    // static const IntVector3 RaycastVehicle::FORWARD_RIGHT_UP
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 FORWARD_RIGHT_UP", (void*)&T::FORWARD_RIGHT_UP);engine->SetDefaultNamespace("");

    // static const IntVector3 RaycastVehicle::FORWARD_UP_RIGHT
    engine->SetDefaultNamespace(className);engine->RegisterGlobalProperty("const IntVector3 FORWARD_UP_RIGHT", (void*)&T::FORWARD_UP_RIGHT);engine->SetDefaultNamespace("");

    #ifdef REGISTER_MEMBERS_MANUAL_PART_RaycastVehicle
        REGISTER_MEMBERS_MANUAL_PART_RaycastVehicle();
    #endif
}

#endif // def URHO3D_PHYSICS

#ifdef URHO3D_URHO2D

// class CollisionBox2D | File: ../Urho2D/CollisionBox2D.h
template <class T> void RegisterMembers_CollisionBox2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionShape2D<T>(engine, className);

    // float CollisionBox2D::GetAngle() const
    engine->RegisterObjectMethod(className, "float GetAngle() const", AS_METHODPR(T, GetAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_angle() const", AS_METHODPR(T, GetAngle, () const, float), AS_CALL_THISCALL);

    // const Vector2& CollisionBox2D::GetCenter() const
    engine->RegisterObjectMethod(className, "const Vector2& GetCenter() const", AS_METHODPR(T, GetCenter, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_center() const", AS_METHODPR(T, GetCenter, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& CollisionBox2D::GetSize() const
    engine->RegisterObjectMethod(className, "const Vector2& GetSize() const", AS_METHODPR(T, GetSize, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_size() const", AS_METHODPR(T, GetSize, () const, const Vector2&), AS_CALL_THISCALL);

    // void CollisionBox2D::SetAngle(float angle)
    engine->RegisterObjectMethod(className, "void SetAngle(float)", AS_METHODPR(T, SetAngle, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angle(float)", AS_METHODPR(T, SetAngle, (float), void), AS_CALL_THISCALL);

    // void CollisionBox2D::SetCenter(const Vector2& center)
    engine->RegisterObjectMethod(className, "void SetCenter(const Vector2&in)", AS_METHODPR(T, SetCenter, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_center(const Vector2&in)", AS_METHODPR(T, SetCenter, (const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionBox2D::SetCenter(float x, float y)
    engine->RegisterObjectMethod(className, "void SetCenter(float, float)", AS_METHODPR(T, SetCenter, (float, float), void), AS_CALL_THISCALL);

    // void CollisionBox2D::SetSize(const Vector2& size)
    engine->RegisterObjectMethod(className, "void SetSize(const Vector2&in)", AS_METHODPR(T, SetSize, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_size(const Vector2&in)", AS_METHODPR(T, SetSize, (const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionBox2D::SetSize(float width, float height)
    engine->RegisterObjectMethod(className, "void SetSize(float, float)", AS_METHODPR(T, SetSize, (float, float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionBox2D
        REGISTER_MEMBERS_MANUAL_PART_CollisionBox2D();
    #endif
}

// const PODVector<Vector2>& CollisionChain2D::GetVertices() const
template <class T> CScriptArray* CollisionChain2D_constspPODVectorlesVector2greamp_GetVertices_void_template(T* _ptr)
{
    const PODVector<Vector2>& result = _ptr->GetVertices();
    return VectorToArray(result, "Array<Vector2>");
}

// void CollisionChain2D::SetVertices(const PODVector<Vector2>& vertices)
template <class T> void CollisionChain2D_void_SetVertices_constspPODVectorlesVector2greamp_template(T* _ptr, CScriptArray* vertices_conv)
{
    PODVector<Vector2> vertices = ArrayToPODVector<Vector2>(vertices_conv);
    _ptr->SetVertices(vertices);
}

// class CollisionChain2D | File: ../Urho2D/CollisionChain2D.h
template <class T> void RegisterMembers_CollisionChain2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionShape2D<T>(engine, className);

    // PODVector<unsigned char> CollisionChain2D::GetVerticesAttr() const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // void CollisionChain2D::SetVerticesAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // bool CollisionChain2D::GetLoop() const
    engine->RegisterObjectMethod(className, "bool GetLoop() const", AS_METHODPR(T, GetLoop, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_loop() const", AS_METHODPR(T, GetLoop, () const, bool), AS_CALL_THISCALL);

    // const Vector2& CollisionChain2D::GetVertex(unsigned index) const
    engine->RegisterObjectMethod(className, "const Vector2& GetVertex(uint) const", AS_METHODPR(T, GetVertex, (unsigned) const, const Vector2&), AS_CALL_THISCALL);

    // unsigned CollisionChain2D::GetVertexCount() const
    engine->RegisterObjectMethod(className, "uint GetVertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_vertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);

    // const PODVector<Vector2>& CollisionChain2D::GetVertices() const
    engine->RegisterObjectMethod(className, "Array<Vector2>@ GetVertices() const", AS_FUNCTION_OBJFIRST(CollisionChain2D_constspPODVectorlesVector2greamp_GetVertices_void_template<CollisionChain2D>), AS_CALL_CDECL_OBJFIRST);

    // void CollisionChain2D::SetLoop(bool loop)
    engine->RegisterObjectMethod(className, "void SetLoop(bool)", AS_METHODPR(T, SetLoop, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_loop(bool)", AS_METHODPR(T, SetLoop, (bool), void), AS_CALL_THISCALL);

    // void CollisionChain2D::SetVertex(unsigned index, const Vector2& vertex)
    engine->RegisterObjectMethod(className, "void SetVertex(uint, const Vector2&in)", AS_METHODPR(T, SetVertex, (unsigned, const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionChain2D::SetVertexCount(unsigned count)
    engine->RegisterObjectMethod(className, "void SetVertexCount(uint)", AS_METHODPR(T, SetVertexCount, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexCount(uint)", AS_METHODPR(T, SetVertexCount, (unsigned), void), AS_CALL_THISCALL);

    // void CollisionChain2D::SetVertices(const PODVector<Vector2>& vertices)
    engine->RegisterObjectMethod(className, "void SetVertices(Array<Vector2>@+)", AS_FUNCTION_OBJFIRST(CollisionChain2D_void_SetVertices_constspPODVectorlesVector2greamp_template<CollisionChain2D>), AS_CALL_CDECL_OBJFIRST);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionChain2D
        REGISTER_MEMBERS_MANUAL_PART_CollisionChain2D();
    #endif
}

// class CollisionCircle2D | File: ../Urho2D/CollisionCircle2D.h
template <class T> void RegisterMembers_CollisionCircle2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionShape2D<T>(engine, className);

    // const Vector2& CollisionCircle2D::GetCenter() const
    engine->RegisterObjectMethod(className, "const Vector2& GetCenter() const", AS_METHODPR(T, GetCenter, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_center() const", AS_METHODPR(T, GetCenter, () const, const Vector2&), AS_CALL_THISCALL);

    // float CollisionCircle2D::GetRadius() const
    engine->RegisterObjectMethod(className, "float GetRadius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_radius() const", AS_METHODPR(T, GetRadius, () const, float), AS_CALL_THISCALL);

    // void CollisionCircle2D::SetCenter(const Vector2& center)
    engine->RegisterObjectMethod(className, "void SetCenter(const Vector2&in)", AS_METHODPR(T, SetCenter, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_center(const Vector2&in)", AS_METHODPR(T, SetCenter, (const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionCircle2D::SetCenter(float x, float y)
    engine->RegisterObjectMethod(className, "void SetCenter(float, float)", AS_METHODPR(T, SetCenter, (float, float), void), AS_CALL_THISCALL);

    // void CollisionCircle2D::SetRadius(float radius)
    engine->RegisterObjectMethod(className, "void SetRadius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_radius(float)", AS_METHODPR(T, SetRadius, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionCircle2D
        REGISTER_MEMBERS_MANUAL_PART_CollisionCircle2D();
    #endif
}

// class CollisionEdge2D | File: ../Urho2D/CollisionEdge2D.h
template <class T> void RegisterMembers_CollisionEdge2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionShape2D<T>(engine, className);

    // const Vector2& CollisionEdge2D::GetVertex1() const
    engine->RegisterObjectMethod(className, "const Vector2& GetVertex1() const", AS_METHODPR(T, GetVertex1, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_vertex1() const", AS_METHODPR(T, GetVertex1, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& CollisionEdge2D::GetVertex2() const
    engine->RegisterObjectMethod(className, "const Vector2& GetVertex2() const", AS_METHODPR(T, GetVertex2, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_vertex2() const", AS_METHODPR(T, GetVertex2, () const, const Vector2&), AS_CALL_THISCALL);

    // void CollisionEdge2D::SetVertex1(const Vector2& vertex)
    engine->RegisterObjectMethod(className, "void SetVertex1(const Vector2&in)", AS_METHODPR(T, SetVertex1, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertex1(const Vector2&in)", AS_METHODPR(T, SetVertex1, (const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionEdge2D::SetVertex2(const Vector2& vertex)
    engine->RegisterObjectMethod(className, "void SetVertex2(const Vector2&in)", AS_METHODPR(T, SetVertex2, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertex2(const Vector2&in)", AS_METHODPR(T, SetVertex2, (const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionEdge2D::SetVertices(const Vector2& vertex1, const Vector2& vertex2)
    engine->RegisterObjectMethod(className, "void SetVertices(const Vector2&in, const Vector2&in)", AS_METHODPR(T, SetVertices, (const Vector2&, const Vector2&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionEdge2D
        REGISTER_MEMBERS_MANUAL_PART_CollisionEdge2D();
    #endif
}

// const PODVector<Vector2>& CollisionPolygon2D::GetVertices() const
template <class T> CScriptArray* CollisionPolygon2D_constspPODVectorlesVector2greamp_GetVertices_void_template(T* _ptr)
{
    const PODVector<Vector2>& result = _ptr->GetVertices();
    return VectorToArray(result, "Array<Vector2>");
}

// void CollisionPolygon2D::SetVertices(const PODVector<Vector2>& vertices)
template <class T> void CollisionPolygon2D_void_SetVertices_constspPODVectorlesVector2greamp_template(T* _ptr, CScriptArray* vertices_conv)
{
    PODVector<Vector2> vertices = ArrayToPODVector<Vector2>(vertices_conv);
    _ptr->SetVertices(vertices);
}

// class CollisionPolygon2D | File: ../Urho2D/CollisionPolygon2D.h
template <class T> void RegisterMembers_CollisionPolygon2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_CollisionShape2D<T>(engine, className);

    // PODVector<unsigned char> CollisionPolygon2D::GetVerticesAttr() const
    // Error: type "PODVector<unsigned char>" can not automatically bind
    // void CollisionPolygon2D::SetVerticesAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // const Vector2& CollisionPolygon2D::GetVertex(unsigned index) const
    engine->RegisterObjectMethod(className, "const Vector2& GetVertex(uint) const", AS_METHODPR(T, GetVertex, (unsigned) const, const Vector2&), AS_CALL_THISCALL);

    // unsigned CollisionPolygon2D::GetVertexCount() const
    engine->RegisterObjectMethod(className, "uint GetVertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_vertexCount() const", AS_METHODPR(T, GetVertexCount, () const, unsigned), AS_CALL_THISCALL);

    // const PODVector<Vector2>& CollisionPolygon2D::GetVertices() const
    engine->RegisterObjectMethod(className, "Array<Vector2>@ GetVertices() const", AS_FUNCTION_OBJFIRST(CollisionPolygon2D_constspPODVectorlesVector2greamp_GetVertices_void_template<CollisionPolygon2D>), AS_CALL_CDECL_OBJFIRST);

    // void CollisionPolygon2D::SetVertex(unsigned index, const Vector2& vertex)
    engine->RegisterObjectMethod(className, "void SetVertex(uint, const Vector2&in)", AS_METHODPR(T, SetVertex, (unsigned, const Vector2&), void), AS_CALL_THISCALL);

    // void CollisionPolygon2D::SetVertexCount(unsigned count)
    engine->RegisterObjectMethod(className, "void SetVertexCount(uint)", AS_METHODPR(T, SetVertexCount, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_vertexCount(uint)", AS_METHODPR(T, SetVertexCount, (unsigned), void), AS_CALL_THISCALL);

    // void CollisionPolygon2D::SetVertices(const PODVector<Vector2>& vertices)
    engine->RegisterObjectMethod(className, "void SetVertices(Array<Vector2>@+)", AS_FUNCTION_OBJFIRST(CollisionPolygon2D_void_SetVertices_constspPODVectorlesVector2greamp_template<CollisionPolygon2D>), AS_CALL_CDECL_OBJFIRST);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_CollisionPolygon2D
        REGISTER_MEMBERS_MANUAL_PART_CollisionPolygon2D();
    #endif
}

// class ConstraintDistance2D | File: ../Urho2D/ConstraintDistance2D.h
template <class T> void RegisterMembers_ConstraintDistance2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // float ConstraintDistance2D::GetDampingRatio() const
    engine->RegisterObjectMethod(className, "float GetDampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_dampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);

    // float ConstraintDistance2D::GetFrequencyHz() const
    engine->RegisterObjectMethod(className, "float GetFrequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);

    // float ConstraintDistance2D::GetLength() const
    engine->RegisterObjectMethod(className, "float GetLength() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_length() const", AS_METHODPR(T, GetLength, () const, float), AS_CALL_THISCALL);

    // const Vector2& ConstraintDistance2D::GetOtherBodyAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOtherBodyAnchor() const", AS_METHODPR(T, GetOtherBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_otherBodyAnchor() const", AS_METHODPR(T, GetOtherBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintDistance2D::GetOwnerBodyAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOwnerBodyAnchor() const", AS_METHODPR(T, GetOwnerBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_ownerBodyAnchor() const", AS_METHODPR(T, GetOwnerBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // void ConstraintDistance2D::SetDampingRatio(float dampingRatio)
    engine->RegisterObjectMethod(className, "void SetDampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);

    // void ConstraintDistance2D::SetFrequencyHz(float frequencyHz)
    engine->RegisterObjectMethod(className, "void SetFrequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_frequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);

    // void ConstraintDistance2D::SetLength(float length)
    engine->RegisterObjectMethod(className, "void SetLength(float)", AS_METHODPR(T, SetLength, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_length(float)", AS_METHODPR(T, SetLength, (float), void), AS_CALL_THISCALL);

    // void ConstraintDistance2D::SetOtherBodyAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetOtherBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintDistance2D::SetOwnerBodyAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetOwnerBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ownerBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintDistance2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintDistance2D();
    #endif
}

// class ConstraintFriction2D | File: ../Urho2D/ConstraintFriction2D.h
template <class T> void RegisterMembers_ConstraintFriction2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // const Vector2& ConstraintFriction2D::GetAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAnchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_anchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // float ConstraintFriction2D::GetMaxForce() const
    engine->RegisterObjectMethod(className, "float GetMaxForce() const", AS_METHODPR(T, GetMaxForce, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxForce() const", AS_METHODPR(T, GetMaxForce, () const, float), AS_CALL_THISCALL);

    // float ConstraintFriction2D::GetMaxTorque() const
    engine->RegisterObjectMethod(className, "float GetMaxTorque() const", AS_METHODPR(T, GetMaxTorque, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxTorque() const", AS_METHODPR(T, GetMaxTorque, () const, float), AS_CALL_THISCALL);

    // void ConstraintFriction2D::SetAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetAnchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintFriction2D::SetMaxForce(float maxForce)
    engine->RegisterObjectMethod(className, "void SetMaxForce(float)", AS_METHODPR(T, SetMaxForce, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxForce(float)", AS_METHODPR(T, SetMaxForce, (float), void), AS_CALL_THISCALL);

    // void ConstraintFriction2D::SetMaxTorque(float maxTorque)
    engine->RegisterObjectMethod(className, "void SetMaxTorque(float)", AS_METHODPR(T, SetMaxTorque, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxTorque(float)", AS_METHODPR(T, SetMaxTorque, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintFriction2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintFriction2D();
    #endif
}

// class ConstraintGear2D | File: ../Urho2D/ConstraintGear2D.h
template <class T> void RegisterMembers_ConstraintGear2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // Constraint2D* ConstraintGear2D::GetOtherConstraint() const
    engine->RegisterObjectMethod(className, "Constraint2D@+ GetOtherConstraint() const", AS_METHODPR(T, GetOtherConstraint, () const, Constraint2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Constraint2D@+ get_otherConstraint() const", AS_METHODPR(T, GetOtherConstraint, () const, Constraint2D*), AS_CALL_THISCALL);

    // Constraint2D* ConstraintGear2D::GetOwnerConstraint() const
    engine->RegisterObjectMethod(className, "Constraint2D@+ GetOwnerConstraint() const", AS_METHODPR(T, GetOwnerConstraint, () const, Constraint2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Constraint2D@+ get_ownerConstraint() const", AS_METHODPR(T, GetOwnerConstraint, () const, Constraint2D*), AS_CALL_THISCALL);

    // float ConstraintGear2D::GetRatio() const
    engine->RegisterObjectMethod(className, "float GetRatio() const", AS_METHODPR(T, GetRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_ratio() const", AS_METHODPR(T, GetRatio, () const, float), AS_CALL_THISCALL);

    // void ConstraintGear2D::SetOtherConstraint(Constraint2D* constraint)
    engine->RegisterObjectMethod(className, "void SetOtherConstraint(Constraint2D@+)", AS_METHODPR(T, SetOtherConstraint, (Constraint2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherConstraint(Constraint2D@+)", AS_METHODPR(T, SetOtherConstraint, (Constraint2D*), void), AS_CALL_THISCALL);

    // void ConstraintGear2D::SetOwnerConstraint(Constraint2D* constraint)
    engine->RegisterObjectMethod(className, "void SetOwnerConstraint(Constraint2D@+)", AS_METHODPR(T, SetOwnerConstraint, (Constraint2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ownerConstraint(Constraint2D@+)", AS_METHODPR(T, SetOwnerConstraint, (Constraint2D*), void), AS_CALL_THISCALL);

    // void ConstraintGear2D::SetRatio(float ratio)
    engine->RegisterObjectMethod(className, "void SetRatio(float)", AS_METHODPR(T, SetRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ratio(float)", AS_METHODPR(T, SetRatio, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintGear2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintGear2D();
    #endif
}

// class ConstraintMotor2D | File: ../Urho2D/ConstraintMotor2D.h
template <class T> void RegisterMembers_ConstraintMotor2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // float ConstraintMotor2D::GetAngularOffset() const
    engine->RegisterObjectMethod(className, "float GetAngularOffset() const", AS_METHODPR(T, GetAngularOffset, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_angularOffset() const", AS_METHODPR(T, GetAngularOffset, () const, float), AS_CALL_THISCALL);

    // float ConstraintMotor2D::GetCorrectionFactor() const
    engine->RegisterObjectMethod(className, "float GetCorrectionFactor() const", AS_METHODPR(T, GetCorrectionFactor, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_correctionFactor() const", AS_METHODPR(T, GetCorrectionFactor, () const, float), AS_CALL_THISCALL);

    // const Vector2& ConstraintMotor2D::GetLinearOffset() const
    engine->RegisterObjectMethod(className, "const Vector2& GetLinearOffset() const", AS_METHODPR(T, GetLinearOffset, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_linearOffset() const", AS_METHODPR(T, GetLinearOffset, () const, const Vector2&), AS_CALL_THISCALL);

    // float ConstraintMotor2D::GetMaxForce() const
    engine->RegisterObjectMethod(className, "float GetMaxForce() const", AS_METHODPR(T, GetMaxForce, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxForce() const", AS_METHODPR(T, GetMaxForce, () const, float), AS_CALL_THISCALL);

    // float ConstraintMotor2D::GetMaxTorque() const
    engine->RegisterObjectMethod(className, "float GetMaxTorque() const", AS_METHODPR(T, GetMaxTorque, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxTorque() const", AS_METHODPR(T, GetMaxTorque, () const, float), AS_CALL_THISCALL);

    // void ConstraintMotor2D::SetAngularOffset(float angularOffset)
    engine->RegisterObjectMethod(className, "void SetAngularOffset(float)", AS_METHODPR(T, SetAngularOffset, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_angularOffset(float)", AS_METHODPR(T, SetAngularOffset, (float), void), AS_CALL_THISCALL);

    // void ConstraintMotor2D::SetCorrectionFactor(float correctionFactor)
    engine->RegisterObjectMethod(className, "void SetCorrectionFactor(float)", AS_METHODPR(T, SetCorrectionFactor, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_correctionFactor(float)", AS_METHODPR(T, SetCorrectionFactor, (float), void), AS_CALL_THISCALL);

    // void ConstraintMotor2D::SetLinearOffset(const Vector2& linearOffset)
    engine->RegisterObjectMethod(className, "void SetLinearOffset(const Vector2&in)", AS_METHODPR(T, SetLinearOffset, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_linearOffset(const Vector2&in)", AS_METHODPR(T, SetLinearOffset, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintMotor2D::SetMaxForce(float maxForce)
    engine->RegisterObjectMethod(className, "void SetMaxForce(float)", AS_METHODPR(T, SetMaxForce, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxForce(float)", AS_METHODPR(T, SetMaxForce, (float), void), AS_CALL_THISCALL);

    // void ConstraintMotor2D::SetMaxTorque(float maxTorque)
    engine->RegisterObjectMethod(className, "void SetMaxTorque(float)", AS_METHODPR(T, SetMaxTorque, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxTorque(float)", AS_METHODPR(T, SetMaxTorque, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintMotor2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintMotor2D();
    #endif
}

// class ConstraintMouse2D | File: ../Urho2D/ConstraintMouse2D.h
template <class T> void RegisterMembers_ConstraintMouse2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // float ConstraintMouse2D::GetDampingRatio() const
    engine->RegisterObjectMethod(className, "float GetDampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_dampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);

    // float ConstraintMouse2D::GetFrequencyHz() const
    engine->RegisterObjectMethod(className, "float GetFrequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);

    // float ConstraintMouse2D::GetMaxForce() const
    engine->RegisterObjectMethod(className, "float GetMaxForce() const", AS_METHODPR(T, GetMaxForce, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxForce() const", AS_METHODPR(T, GetMaxForce, () const, float), AS_CALL_THISCALL);

    // const Vector2& ConstraintMouse2D::GetTarget() const
    engine->RegisterObjectMethod(className, "const Vector2& GetTarget() const", AS_METHODPR(T, GetTarget, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_target() const", AS_METHODPR(T, GetTarget, () const, const Vector2&), AS_CALL_THISCALL);

    // void ConstraintMouse2D::SetDampingRatio(float dampingRatio)
    engine->RegisterObjectMethod(className, "void SetDampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);

    // void ConstraintMouse2D::SetFrequencyHz(float frequencyHz)
    engine->RegisterObjectMethod(className, "void SetFrequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_frequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);

    // void ConstraintMouse2D::SetMaxForce(float maxForce)
    engine->RegisterObjectMethod(className, "void SetMaxForce(float)", AS_METHODPR(T, SetMaxForce, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxForce(float)", AS_METHODPR(T, SetMaxForce, (float), void), AS_CALL_THISCALL);

    // void ConstraintMouse2D::SetTarget(const Vector2& target)
    engine->RegisterObjectMethod(className, "void SetTarget(const Vector2&in)", AS_METHODPR(T, SetTarget, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_target(const Vector2&in)", AS_METHODPR(T, SetTarget, (const Vector2&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintMouse2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintMouse2D();
    #endif
}

// class ConstraintPrismatic2D | File: ../Urho2D/ConstraintPrismatic2D.h
template <class T> void RegisterMembers_ConstraintPrismatic2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // const Vector2& ConstraintPrismatic2D::GetAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAnchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_anchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintPrismatic2D::GetAxis() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAxis() const", AS_METHODPR(T, GetAxis, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_axis() const", AS_METHODPR(T, GetAxis, () const, const Vector2&), AS_CALL_THISCALL);

    // bool ConstraintPrismatic2D::GetEnableLimit() const
    engine->RegisterObjectMethod(className, "bool GetEnableLimit() const", AS_METHODPR(T, GetEnableLimit, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableLimit() const", AS_METHODPR(T, GetEnableLimit, () const, bool), AS_CALL_THISCALL);

    // bool ConstraintPrismatic2D::GetEnableMotor() const
    engine->RegisterObjectMethod(className, "bool GetEnableMotor() const", AS_METHODPR(T, GetEnableMotor, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableMotor() const", AS_METHODPR(T, GetEnableMotor, () const, bool), AS_CALL_THISCALL);

    // float ConstraintPrismatic2D::GetLowerTranslation() const
    engine->RegisterObjectMethod(className, "float GetLowerTranslation() const", AS_METHODPR(T, GetLowerTranslation, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lowerTranslation() const", AS_METHODPR(T, GetLowerTranslation, () const, float), AS_CALL_THISCALL);

    // float ConstraintPrismatic2D::GetMaxMotorForce() const
    engine->RegisterObjectMethod(className, "float GetMaxMotorForce() const", AS_METHODPR(T, GetMaxMotorForce, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxMotorForce() const", AS_METHODPR(T, GetMaxMotorForce, () const, float), AS_CALL_THISCALL);

    // float ConstraintPrismatic2D::GetMotorSpeed() const
    engine->RegisterObjectMethod(className, "float GetMotorSpeed() const", AS_METHODPR(T, GetMotorSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_motorSpeed() const", AS_METHODPR(T, GetMotorSpeed, () const, float), AS_CALL_THISCALL);

    // float ConstraintPrismatic2D::GetUpperTranslation() const
    engine->RegisterObjectMethod(className, "float GetUpperTranslation() const", AS_METHODPR(T, GetUpperTranslation, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_upperTranslation() const", AS_METHODPR(T, GetUpperTranslation, () const, float), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetAnchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetAxis(const Vector2& axis)
    engine->RegisterObjectMethod(className, "void SetAxis(const Vector2&in)", AS_METHODPR(T, SetAxis, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_axis(const Vector2&in)", AS_METHODPR(T, SetAxis, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetEnableLimit(bool enableLimit)
    engine->RegisterObjectMethod(className, "void SetEnableLimit(bool)", AS_METHODPR(T, SetEnableLimit, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableLimit(bool)", AS_METHODPR(T, SetEnableLimit, (bool), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetEnableMotor(bool enableMotor)
    engine->RegisterObjectMethod(className, "void SetEnableMotor(bool)", AS_METHODPR(T, SetEnableMotor, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableMotor(bool)", AS_METHODPR(T, SetEnableMotor, (bool), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetLowerTranslation(float lowerTranslation)
    engine->RegisterObjectMethod(className, "void SetLowerTranslation(float)", AS_METHODPR(T, SetLowerTranslation, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lowerTranslation(float)", AS_METHODPR(T, SetLowerTranslation, (float), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetMaxMotorForce(float maxMotorForce)
    engine->RegisterObjectMethod(className, "void SetMaxMotorForce(float)", AS_METHODPR(T, SetMaxMotorForce, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxMotorForce(float)", AS_METHODPR(T, SetMaxMotorForce, (float), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetMotorSpeed(float motorSpeed)
    engine->RegisterObjectMethod(className, "void SetMotorSpeed(float)", AS_METHODPR(T, SetMotorSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_motorSpeed(float)", AS_METHODPR(T, SetMotorSpeed, (float), void), AS_CALL_THISCALL);

    // void ConstraintPrismatic2D::SetUpperTranslation(float upperTranslation)
    engine->RegisterObjectMethod(className, "void SetUpperTranslation(float)", AS_METHODPR(T, SetUpperTranslation, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_upperTranslation(float)", AS_METHODPR(T, SetUpperTranslation, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintPrismatic2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintPrismatic2D();
    #endif
}

// class ConstraintPulley2D | File: ../Urho2D/ConstraintPulley2D.h
template <class T> void RegisterMembers_ConstraintPulley2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // const Vector2& ConstraintPulley2D::GetOtherBodyAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOtherBodyAnchor() const", AS_METHODPR(T, GetOtherBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_otherBodyAnchor() const", AS_METHODPR(T, GetOtherBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintPulley2D::GetOtherBodyGroundAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOtherBodyGroundAnchor() const", AS_METHODPR(T, GetOtherBodyGroundAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_otherBodyGroundAnchor() const", AS_METHODPR(T, GetOtherBodyGroundAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintPulley2D::GetOwnerBodyAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOwnerBodyAnchor() const", AS_METHODPR(T, GetOwnerBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_ownerBodyAnchor() const", AS_METHODPR(T, GetOwnerBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintPulley2D::GetOwnerBodyGroundAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOwnerBodyGroundAnchor() const", AS_METHODPR(T, GetOwnerBodyGroundAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_ownerBodyGroundAnchor() const", AS_METHODPR(T, GetOwnerBodyGroundAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // float ConstraintPulley2D::GetRatio() const
    engine->RegisterObjectMethod(className, "float GetRatio() const", AS_METHODPR(T, GetRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_ratio() const", AS_METHODPR(T, GetRatio, () const, float), AS_CALL_THISCALL);

    // void ConstraintPulley2D::SetOtherBodyAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetOtherBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintPulley2D::SetOtherBodyGroundAnchor(const Vector2& groundAnchor)
    engine->RegisterObjectMethod(className, "void SetOtherBodyGroundAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyGroundAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherBodyGroundAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyGroundAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintPulley2D::SetOwnerBodyAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetOwnerBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ownerBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintPulley2D::SetOwnerBodyGroundAnchor(const Vector2& groundAnchor)
    engine->RegisterObjectMethod(className, "void SetOwnerBodyGroundAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyGroundAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ownerBodyGroundAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyGroundAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintPulley2D::SetRatio(float ratio)
    engine->RegisterObjectMethod(className, "void SetRatio(float)", AS_METHODPR(T, SetRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ratio(float)", AS_METHODPR(T, SetRatio, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintPulley2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintPulley2D();
    #endif
}

// class ConstraintRevolute2D | File: ../Urho2D/ConstraintRevolute2D.h
template <class T> void RegisterMembers_ConstraintRevolute2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // const Vector2& ConstraintRevolute2D::GetAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAnchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_anchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // bool ConstraintRevolute2D::GetEnableLimit() const
    engine->RegisterObjectMethod(className, "bool GetEnableLimit() const", AS_METHODPR(T, GetEnableLimit, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableLimit() const", AS_METHODPR(T, GetEnableLimit, () const, bool), AS_CALL_THISCALL);

    // bool ConstraintRevolute2D::GetEnableMotor() const
    engine->RegisterObjectMethod(className, "bool GetEnableMotor() const", AS_METHODPR(T, GetEnableMotor, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableMotor() const", AS_METHODPR(T, GetEnableMotor, () const, bool), AS_CALL_THISCALL);

    // float ConstraintRevolute2D::GetLowerAngle() const
    engine->RegisterObjectMethod(className, "float GetLowerAngle() const", AS_METHODPR(T, GetLowerAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_lowerAngle() const", AS_METHODPR(T, GetLowerAngle, () const, float), AS_CALL_THISCALL);

    // float ConstraintRevolute2D::GetMaxMotorTorque() const
    engine->RegisterObjectMethod(className, "float GetMaxMotorTorque() const", AS_METHODPR(T, GetMaxMotorTorque, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxMotorTorque() const", AS_METHODPR(T, GetMaxMotorTorque, () const, float), AS_CALL_THISCALL);

    // float ConstraintRevolute2D::GetMotorSpeed() const
    engine->RegisterObjectMethod(className, "float GetMotorSpeed() const", AS_METHODPR(T, GetMotorSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_motorSpeed() const", AS_METHODPR(T, GetMotorSpeed, () const, float), AS_CALL_THISCALL);

    // float ConstraintRevolute2D::GetUpperAngle() const
    engine->RegisterObjectMethod(className, "float GetUpperAngle() const", AS_METHODPR(T, GetUpperAngle, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_upperAngle() const", AS_METHODPR(T, GetUpperAngle, () const, float), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetAnchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetEnableLimit(bool enableLimit)
    engine->RegisterObjectMethod(className, "void SetEnableLimit(bool)", AS_METHODPR(T, SetEnableLimit, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableLimit(bool)", AS_METHODPR(T, SetEnableLimit, (bool), void), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetEnableMotor(bool enableMotor)
    engine->RegisterObjectMethod(className, "void SetEnableMotor(bool)", AS_METHODPR(T, SetEnableMotor, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableMotor(bool)", AS_METHODPR(T, SetEnableMotor, (bool), void), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetLowerAngle(float lowerAngle)
    engine->RegisterObjectMethod(className, "void SetLowerAngle(float)", AS_METHODPR(T, SetLowerAngle, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_lowerAngle(float)", AS_METHODPR(T, SetLowerAngle, (float), void), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetMaxMotorTorque(float maxMotorTorque)
    engine->RegisterObjectMethod(className, "void SetMaxMotorTorque(float)", AS_METHODPR(T, SetMaxMotorTorque, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxMotorTorque(float)", AS_METHODPR(T, SetMaxMotorTorque, (float), void), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetMotorSpeed(float motorSpeed)
    engine->RegisterObjectMethod(className, "void SetMotorSpeed(float)", AS_METHODPR(T, SetMotorSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_motorSpeed(float)", AS_METHODPR(T, SetMotorSpeed, (float), void), AS_CALL_THISCALL);

    // void ConstraintRevolute2D::SetUpperAngle(float upperAngle)
    engine->RegisterObjectMethod(className, "void SetUpperAngle(float)", AS_METHODPR(T, SetUpperAngle, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_upperAngle(float)", AS_METHODPR(T, SetUpperAngle, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintRevolute2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintRevolute2D();
    #endif
}

// class ConstraintRope2D | File: ../Urho2D/ConstraintRope2D.h
template <class T> void RegisterMembers_ConstraintRope2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // float ConstraintRope2D::GetMaxLength() const
    engine->RegisterObjectMethod(className, "float GetMaxLength() const", AS_METHODPR(T, GetMaxLength, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxLength() const", AS_METHODPR(T, GetMaxLength, () const, float), AS_CALL_THISCALL);

    // const Vector2& ConstraintRope2D::GetOtherBodyAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOtherBodyAnchor() const", AS_METHODPR(T, GetOtherBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_otherBodyAnchor() const", AS_METHODPR(T, GetOtherBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintRope2D::GetOwnerBodyAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetOwnerBodyAnchor() const", AS_METHODPR(T, GetOwnerBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_ownerBodyAnchor() const", AS_METHODPR(T, GetOwnerBodyAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // void ConstraintRope2D::SetMaxLength(float maxLength)
    engine->RegisterObjectMethod(className, "void SetMaxLength(float)", AS_METHODPR(T, SetMaxLength, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxLength(float)", AS_METHODPR(T, SetMaxLength, (float), void), AS_CALL_THISCALL);

    // void ConstraintRope2D::SetOtherBodyAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetOtherBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_otherBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOtherBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintRope2D::SetOwnerBodyAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetOwnerBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_ownerBodyAnchor(const Vector2&in)", AS_METHODPR(T, SetOwnerBodyAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintRope2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintRope2D();
    #endif
}

// class ConstraintWeld2D | File: ../Urho2D/ConstraintWeld2D.h
template <class T> void RegisterMembers_ConstraintWeld2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // const Vector2& ConstraintWeld2D::GetAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAnchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_anchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // float ConstraintWeld2D::GetDampingRatio() const
    engine->RegisterObjectMethod(className, "float GetDampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_dampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);

    // float ConstraintWeld2D::GetFrequencyHz() const
    engine->RegisterObjectMethod(className, "float GetFrequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);

    // void ConstraintWeld2D::SetAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetAnchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintWeld2D::SetDampingRatio(float dampingRatio)
    engine->RegisterObjectMethod(className, "void SetDampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);

    // void ConstraintWeld2D::SetFrequencyHz(float frequencyHz)
    engine->RegisterObjectMethod(className, "void SetFrequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_frequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintWeld2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintWeld2D();
    #endif
}

// class ConstraintWheel2D | File: ../Urho2D/ConstraintWheel2D.h
template <class T> void RegisterMembers_ConstraintWheel2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Constraint2D<T>(engine, className);

    // const Vector2& ConstraintWheel2D::GetAnchor() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAnchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_anchor() const", AS_METHODPR(T, GetAnchor, () const, const Vector2&), AS_CALL_THISCALL);

    // const Vector2& ConstraintWheel2D::GetAxis() const
    engine->RegisterObjectMethod(className, "const Vector2& GetAxis() const", AS_METHODPR(T, GetAxis, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_axis() const", AS_METHODPR(T, GetAxis, () const, const Vector2&), AS_CALL_THISCALL);

    // float ConstraintWheel2D::GetDampingRatio() const
    engine->RegisterObjectMethod(className, "float GetDampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_dampingRatio() const", AS_METHODPR(T, GetDampingRatio, () const, float), AS_CALL_THISCALL);

    // bool ConstraintWheel2D::GetEnableMotor() const
    engine->RegisterObjectMethod(className, "bool GetEnableMotor() const", AS_METHODPR(T, GetEnableMotor, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_enableMotor() const", AS_METHODPR(T, GetEnableMotor, () const, bool), AS_CALL_THISCALL);

    // float ConstraintWheel2D::GetFrequencyHz() const
    engine->RegisterObjectMethod(className, "float GetFrequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_frequencyHz() const", AS_METHODPR(T, GetFrequencyHz, () const, float), AS_CALL_THISCALL);

    // float ConstraintWheel2D::GetMaxMotorTorque() const
    engine->RegisterObjectMethod(className, "float GetMaxMotorTorque() const", AS_METHODPR(T, GetMaxMotorTorque, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_maxMotorTorque() const", AS_METHODPR(T, GetMaxMotorTorque, () const, float), AS_CALL_THISCALL);

    // float ConstraintWheel2D::GetMotorSpeed() const
    engine->RegisterObjectMethod(className, "float GetMotorSpeed() const", AS_METHODPR(T, GetMotorSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_motorSpeed() const", AS_METHODPR(T, GetMotorSpeed, () const, float), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetAnchor(const Vector2& anchor)
    engine->RegisterObjectMethod(className, "void SetAnchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_anchor(const Vector2&in)", AS_METHODPR(T, SetAnchor, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetAxis(const Vector2& axis)
    engine->RegisterObjectMethod(className, "void SetAxis(const Vector2&in)", AS_METHODPR(T, SetAxis, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_axis(const Vector2&in)", AS_METHODPR(T, SetAxis, (const Vector2&), void), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetDampingRatio(float dampingRatio)
    engine->RegisterObjectMethod(className, "void SetDampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_dampingRatio(float)", AS_METHODPR(T, SetDampingRatio, (float), void), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetEnableMotor(bool enableMotor)
    engine->RegisterObjectMethod(className, "void SetEnableMotor(bool)", AS_METHODPR(T, SetEnableMotor, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_enableMotor(bool)", AS_METHODPR(T, SetEnableMotor, (bool), void), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetFrequencyHz(float frequencyHz)
    engine->RegisterObjectMethod(className, "void SetFrequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_frequencyHz(float)", AS_METHODPR(T, SetFrequencyHz, (float), void), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetMaxMotorTorque(float maxMotorTorque)
    engine->RegisterObjectMethod(className, "void SetMaxMotorTorque(float)", AS_METHODPR(T, SetMaxMotorTorque, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_maxMotorTorque(float)", AS_METHODPR(T, SetMaxMotorTorque, (float), void), AS_CALL_THISCALL);

    // void ConstraintWheel2D::SetMotorSpeed(float motorSpeed)
    engine->RegisterObjectMethod(className, "void SetMotorSpeed(float)", AS_METHODPR(T, SetMotorSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_motorSpeed(float)", AS_METHODPR(T, SetMotorSpeed, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ConstraintWheel2D
        REGISTER_MEMBERS_MANUAL_PART_ConstraintWheel2D();
    #endif
}

// class Drawable2D | File: ../Urho2D/Drawable2D.h
template <class T> void RegisterMembers_Drawable2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // const Vector<SourceBatch2D>& Drawable2D::GetSourceBatches()
    // Error: type "const Vector<SourceBatch2D>&" can not automatically bind

    // int Drawable2D::GetLayer() const
    engine->RegisterObjectMethod(className, "int GetLayer() const", AS_METHODPR(T, GetLayer, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_layer() const", AS_METHODPR(T, GetLayer, () const, int), AS_CALL_THISCALL);

    // int Drawable2D::GetOrderInLayer() const
    engine->RegisterObjectMethod(className, "int GetOrderInLayer() const", AS_METHODPR(T, GetOrderInLayer, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_orderInLayer() const", AS_METHODPR(T, GetOrderInLayer, () const, int), AS_CALL_THISCALL);

    // void Drawable2D::SetLayer(int layer)
    engine->RegisterObjectMethod(className, "void SetLayer(int)", AS_METHODPR(T, SetLayer, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_layer(int)", AS_METHODPR(T, SetLayer, (int), void), AS_CALL_THISCALL);

    // void Drawable2D::SetOrderInLayer(int orderInLayer)
    engine->RegisterObjectMethod(className, "void SetOrderInLayer(int)", AS_METHODPR(T, SetOrderInLayer, (int), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_orderInLayer(int)", AS_METHODPR(T, SetOrderInLayer, (int), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Drawable2D
        REGISTER_MEMBERS_MANUAL_PART_Drawable2D();
    #endif
}

// class Renderer2D | File: ../Urho2D/Renderer2D.h
template <class T> void RegisterMembers_Renderer2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable<T>(engine, className);

    // void Renderer2D::AddDrawable(Drawable2D* drawable)
    engine->RegisterObjectMethod(className, "void AddDrawable(Drawable2D@+)", AS_METHODPR(T, AddDrawable, (Drawable2D*), void), AS_CALL_THISCALL);

    // bool Renderer2D::CheckVisibility(Drawable2D* drawable) const
    engine->RegisterObjectMethod(className, "bool CheckVisibility(Drawable2D@+) const", AS_METHODPR(T, CheckVisibility, (Drawable2D*) const, bool), AS_CALL_THISCALL);

    // Material* Renderer2D::GetMaterial(Texture2D* texture, BlendMode blendMode)
    engine->RegisterObjectMethod(className, "Material@+ GetMaterial(Texture2D@+, BlendMode)", AS_METHODPR(T, GetMaterial, (Texture2D*, BlendMode), Material*), AS_CALL_THISCALL);

    // void Renderer2D::RemoveDrawable(Drawable2D* drawable)
    engine->RegisterObjectMethod(className, "void RemoveDrawable(Drawable2D@+)", AS_METHODPR(T, RemoveDrawable, (Drawable2D*), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Renderer2D
        REGISTER_MEMBERS_MANUAL_PART_Renderer2D();
    #endif
}

#endif // def URHO3D_URHO2D

// const Vector<SharedPtr<AnimationState>>& AnimatedModel::GetAnimationStates() const
template <class T> CScriptArray* AnimatedModel_constspVectorlesSharedPtrlesAnimationStategregreamp_GetAnimationStates_void_template(T* _ptr)
{
    const Vector<SharedPtr<AnimationState>>& result = _ptr->GetAnimationStates();
    return VectorToHandleArray(result, "Array<AnimationState@>");
}

// const Vector<SharedPtr<VertexBuffer>>& AnimatedModel::GetMorphVertexBuffers() const
template <class T> CScriptArray* AnimatedModel_constspVectorlesSharedPtrlesVertexBuffergregreamp_GetMorphVertexBuffers_void_template(T* _ptr)
{
    const Vector<SharedPtr<VertexBuffer>>& result = _ptr->GetMorphVertexBuffers();
    return VectorToHandleArray(result, "Array<VertexBuffer@>");
}

// class AnimatedModel | File: ../Graphics/AnimatedModel.h
template <class T> void RegisterMembers_AnimatedModel(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_StaticModel<T>(engine, className);

    // VariantVector AnimatedModel::GetAnimationStatesAttr() const
    // Error: type "VariantVector" can not automatically bind
    // VariantVector AnimatedModel::GetBonesEnabledAttr() const
    // Error: type "VariantVector" can not automatically bind
    // const Vector<PODVector<unsigned>>& AnimatedModel::GetGeometryBoneMappings() const
    // Error: type "const Vector<PODVector<unsigned>>&" can not automatically bind
    // const Vector<PODVector<Matrix3x4>>& AnimatedModel::GetGeometrySkinMatrices() const
    // Error: type "const Vector<PODVector<Matrix3x4>>&" can not automatically bind
    // const Vector<ModelMorph>& AnimatedModel::GetMorphs() const
    // Error: type "const Vector<ModelMorph>&" can not automatically bind
    // const PODVector<unsigned char>& AnimatedModel::GetMorphsAttr() const
    // Error: type "const PODVector<unsigned char>&" can not automatically bind
    // void AnimatedModel::SetAnimationStatesAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind
    // void AnimatedModel::SetBonesEnabledAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind
    // void AnimatedModel::SetMorphsAttr(const PODVector<unsigned char>& value)
    // Error: type "const PODVector<unsigned char>&" can not automatically bind

    // AnimationState* AnimatedModel::AddAnimationState(Animation* animation)
    engine->RegisterObjectMethod(className, "AnimationState@+ AddAnimationState(Animation@+)", AS_METHODPR(T, AddAnimationState, (Animation*), AnimationState*), AS_CALL_THISCALL);

    // void AnimatedModel::ApplyAnimation()
    engine->RegisterObjectMethod(className, "void ApplyAnimation()", AS_METHODPR(T, ApplyAnimation, (), void), AS_CALL_THISCALL);

    // float AnimatedModel::GetAnimationLodBias() const
    engine->RegisterObjectMethod(className, "float GetAnimationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_animationLodBias() const", AS_METHODPR(T, GetAnimationLodBias, () const, float), AS_CALL_THISCALL);

    // AnimationState* AnimatedModel::GetAnimationState(Animation* animation) const
    engine->RegisterObjectMethod(className, "AnimationState@+ GetAnimationState(Animation@+) const", AS_METHODPR(T, GetAnimationState, (Animation*) const, AnimationState*), AS_CALL_THISCALL);

    // AnimationState* AnimatedModel::GetAnimationState(const String& animationName) const
    engine->RegisterObjectMethod(className, "AnimationState@+ GetAnimationState(const String&in) const", AS_METHODPR(T, GetAnimationState, (const String&) const, AnimationState*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AnimationState@+ get_animationStates(const String&in) const", AS_METHODPR(T, GetAnimationState, (const String&) const, AnimationState*), AS_CALL_THISCALL);

    // AnimationState* AnimatedModel::GetAnimationState(StringHash animationNameHash) const
    engine->RegisterObjectMethod(className, "AnimationState@+ GetAnimationState(StringHash) const", AS_METHODPR(T, GetAnimationState, (StringHash) const, AnimationState*), AS_CALL_THISCALL);

    // AnimationState* AnimatedModel::GetAnimationState(unsigned index) const
    engine->RegisterObjectMethod(className, "AnimationState@+ GetAnimationState(uint) const", AS_METHODPR(T, GetAnimationState, (unsigned) const, AnimationState*), AS_CALL_THISCALL);

    // const Vector<SharedPtr<AnimationState>>& AnimatedModel::GetAnimationStates() const
    engine->RegisterObjectMethod(className, "Array<AnimationState@>@ GetAnimationStates() const", AS_FUNCTION_OBJFIRST(AnimatedModel_constspVectorlesSharedPtrlesAnimationStategregreamp_GetAnimationStates_void_template<AnimatedModel>), AS_CALL_CDECL_OBJFIRST);

    // const Vector<SharedPtr<VertexBuffer>>& AnimatedModel::GetMorphVertexBuffers() const
    engine->RegisterObjectMethod(className, "Array<VertexBuffer@>@ GetMorphVertexBuffers() const", AS_FUNCTION_OBJFIRST(AnimatedModel_constspVectorlesSharedPtrlesVertexBuffergregreamp_GetMorphVertexBuffers_void_template<AnimatedModel>), AS_CALL_CDECL_OBJFIRST);

    // float AnimatedModel::GetMorphWeight(unsigned index) const
    engine->RegisterObjectMethod(className, "float GetMorphWeight(uint) const", AS_METHODPR(T, GetMorphWeight, (unsigned) const, float), AS_CALL_THISCALL);

    // float AnimatedModel::GetMorphWeight(const String& name) const
    engine->RegisterObjectMethod(className, "float GetMorphWeight(const String&in) const", AS_METHODPR(T, GetMorphWeight, (const String&) const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_morphWeights(const String&in) const", AS_METHODPR(T, GetMorphWeight, (const String&) const, float), AS_CALL_THISCALL);

    // float AnimatedModel::GetMorphWeight(StringHash nameHash) const
    engine->RegisterObjectMethod(className, "float GetMorphWeight(StringHash) const", AS_METHODPR(T, GetMorphWeight, (StringHash) const, float), AS_CALL_THISCALL);

    // unsigned AnimatedModel::GetNumAnimationStates() const
    engine->RegisterObjectMethod(className, "uint GetNumAnimationStates() const", AS_METHODPR(T, GetNumAnimationStates, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numAnimationStates() const", AS_METHODPR(T, GetNumAnimationStates, () const, unsigned), AS_CALL_THISCALL);

    // unsigned AnimatedModel::GetNumMorphs() const
    engine->RegisterObjectMethod(className, "uint GetNumMorphs() const", AS_METHODPR(T, GetNumMorphs, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numMorphs() const", AS_METHODPR(T, GetNumMorphs, () const, unsigned), AS_CALL_THISCALL);

    // Skeleton& AnimatedModel::GetSkeleton()
    engine->RegisterObjectMethod(className, "Skeleton& GetSkeleton()", AS_METHODPR(T, GetSkeleton, (), Skeleton&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Skeleton& get_skeleton()", AS_METHODPR(T, GetSkeleton, (), Skeleton&), AS_CALL_THISCALL);

    // bool AnimatedModel::GetUpdateInvisible() const
    engine->RegisterObjectMethod(className, "bool GetUpdateInvisible() const", AS_METHODPR(T, GetUpdateInvisible, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_updateInvisible() const", AS_METHODPR(T, GetUpdateInvisible, () const, bool), AS_CALL_THISCALL);

    // bool AnimatedModel::IsMaster() const
    engine->RegisterObjectMethod(className, "bool IsMaster() const", AS_METHODPR(T, IsMaster, () const, bool), AS_CALL_THISCALL);

    // void AnimatedModel::RemoveAllAnimationStates()
    engine->RegisterObjectMethod(className, "void RemoveAllAnimationStates()", AS_METHODPR(T, RemoveAllAnimationStates, (), void), AS_CALL_THISCALL);

    // void AnimatedModel::RemoveAnimationState(Animation* animation)
    engine->RegisterObjectMethod(className, "void RemoveAnimationState(Animation@+)", AS_METHODPR(T, RemoveAnimationState, (Animation*), void), AS_CALL_THISCALL);

    // void AnimatedModel::RemoveAnimationState(const String& animationName)
    engine->RegisterObjectMethod(className, "void RemoveAnimationState(const String&in)", AS_METHODPR(T, RemoveAnimationState, (const String&), void), AS_CALL_THISCALL);

    // void AnimatedModel::RemoveAnimationState(StringHash animationNameHash)
    engine->RegisterObjectMethod(className, "void RemoveAnimationState(StringHash)", AS_METHODPR(T, RemoveAnimationState, (StringHash), void), AS_CALL_THISCALL);

    // void AnimatedModel::RemoveAnimationState(AnimationState* state)
    engine->RegisterObjectMethod(className, "void RemoveAnimationState(AnimationState@+)", AS_METHODPR(T, RemoveAnimationState, (AnimationState*), void), AS_CALL_THISCALL);

    // void AnimatedModel::RemoveAnimationState(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveAnimationState(uint)", AS_METHODPR(T, RemoveAnimationState, (unsigned), void), AS_CALL_THISCALL);

    // void AnimatedModel::ResetMorphWeights()
    engine->RegisterObjectMethod(className, "void ResetMorphWeights()", AS_METHODPR(T, ResetMorphWeights, (), void), AS_CALL_THISCALL);

    // void AnimatedModel::SetAnimationLodBias(float bias)
    engine->RegisterObjectMethod(className, "void SetAnimationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationLodBias(float)", AS_METHODPR(T, SetAnimationLodBias, (float), void), AS_CALL_THISCALL);

    // void AnimatedModel::SetModel(Model* model, bool createBones = true)
    engine->RegisterObjectMethod(className, "void SetModel(Model@+, bool = true)", AS_METHODPR(T, SetModel, (Model*, bool), void), AS_CALL_THISCALL);

    // void AnimatedModel::SetMorphWeight(unsigned index, float weight)
    engine->RegisterObjectMethod(className, "void SetMorphWeight(uint, float)", AS_METHODPR(T, SetMorphWeight, (unsigned, float), void), AS_CALL_THISCALL);

    // void AnimatedModel::SetMorphWeight(const String& name, float weight)
    engine->RegisterObjectMethod(className, "void SetMorphWeight(const String&in, float)", AS_METHODPR(T, SetMorphWeight, (const String&, float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_morphWeights(const String&in, float)", AS_METHODPR(T, SetMorphWeight, (const String&, float), void), AS_CALL_THISCALL);

    // void AnimatedModel::SetMorphWeight(StringHash nameHash, float weight)
    engine->RegisterObjectMethod(className, "void SetMorphWeight(StringHash, float)", AS_METHODPR(T, SetMorphWeight, (StringHash, float), void), AS_CALL_THISCALL);

    // void AnimatedModel::SetUpdateInvisible(bool enable)
    engine->RegisterObjectMethod(className, "void SetUpdateInvisible(bool)", AS_METHODPR(T, SetUpdateInvisible, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_updateInvisible(bool)", AS_METHODPR(T, SetUpdateInvisible, (bool), void), AS_CALL_THISCALL);

    // void AnimatedModel::UpdateBoneBoundingBox()
    engine->RegisterObjectMethod(className, "void UpdateBoneBoundingBox()", AS_METHODPR(T, UpdateBoneBoundingBox, (), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimatedModel
        REGISTER_MEMBERS_MANUAL_PART_AnimatedModel();
    #endif
}

// class Menu | File: ../UI/Menu.h
template <class T> void RegisterMembers_Menu(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Button<T>(engine, className);

    // int Menu::GetAcceleratorKey() const
    engine->RegisterObjectMethod(className, "int GetAcceleratorKey() const", AS_METHODPR(T, GetAcceleratorKey, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_acceleratorKey() const", AS_METHODPR(T, GetAcceleratorKey, () const, int), AS_CALL_THISCALL);

    // int Menu::GetAcceleratorQualifiers() const
    engine->RegisterObjectMethod(className, "int GetAcceleratorQualifiers() const", AS_METHODPR(T, GetAcceleratorQualifiers, () const, int), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "int get_acceleratorQualifiers() const", AS_METHODPR(T, GetAcceleratorQualifiers, () const, int), AS_CALL_THISCALL);

    // UIElement* Menu::GetPopup() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetPopup() const", AS_METHODPR(T, GetPopup, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_popup() const", AS_METHODPR(T, GetPopup, () const, UIElement*), AS_CALL_THISCALL);

    // const IntVector2& Menu::GetPopupOffset() const
    engine->RegisterObjectMethod(className, "const IntVector2& GetPopupOffset() const", AS_METHODPR(T, GetPopupOffset, () const, const IntVector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntVector2& get_popupOffset() const", AS_METHODPR(T, GetPopupOffset, () const, const IntVector2&), AS_CALL_THISCALL);

    // bool Menu::GetShowPopup() const
    engine->RegisterObjectMethod(className, "bool GetShowPopup() const", AS_METHODPR(T, GetShowPopup, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_showPopup() const", AS_METHODPR(T, GetShowPopup, () const, bool), AS_CALL_THISCALL);

    // virtual void Menu::OnHidePopup()
    engine->RegisterObjectMethod(className, "void OnHidePopup()", AS_METHODPR(T, OnHidePopup, (), void), AS_CALL_THISCALL);

    // virtual void Menu::OnShowPopup()
    engine->RegisterObjectMethod(className, "void OnShowPopup()", AS_METHODPR(T, OnShowPopup, (), void), AS_CALL_THISCALL);

    // void Menu::SetAccelerator(int key, int qualifiers)
    engine->RegisterObjectMethod(className, "void SetAccelerator(int, int)", AS_METHODPR(T, SetAccelerator, (int, int), void), AS_CALL_THISCALL);

    // void Menu::SetPopup(UIElement* popup)
    engine->RegisterObjectMethod(className, "void SetPopup(UIElement@+)", AS_METHODPR(T, SetPopup, (UIElement*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_popup(UIElement@+)", AS_METHODPR(T, SetPopup, (UIElement*), void), AS_CALL_THISCALL);

    // void Menu::SetPopupOffset(const IntVector2& offset)
    engine->RegisterObjectMethod(className, "void SetPopupOffset(const IntVector2&in)", AS_METHODPR(T, SetPopupOffset, (const IntVector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_popupOffset(const IntVector2&in)", AS_METHODPR(T, SetPopupOffset, (const IntVector2&), void), AS_CALL_THISCALL);

    // void Menu::SetPopupOffset(int x, int y)
    engine->RegisterObjectMethod(className, "void SetPopupOffset(int, int)", AS_METHODPR(T, SetPopupOffset, (int, int), void), AS_CALL_THISCALL);

    // void Menu::ShowPopup(bool enable)
    engine->RegisterObjectMethod(className, "void ShowPopup(bool)", AS_METHODPR(T, ShowPopup, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_showPopup(bool)", AS_METHODPR(T, ShowPopup, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Menu
        REGISTER_MEMBERS_MANUAL_PART_Menu();
    #endif
}

// class ParticleEmitter | File: ../Graphics/ParticleEmitter.h
template <class T> void RegisterMembers_ParticleEmitter(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_BillboardSet<T>(engine, className);

    // VariantVector ParticleEmitter::GetParticleBillboardsAttr() const
    // Error: type "VariantVector" can not automatically bind
    // VariantVector ParticleEmitter::GetParticlesAttr() const
    // Error: type "VariantVector" can not automatically bind
    // void ParticleEmitter::SetParticlesAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // void ParticleEmitter::ApplyEffect()
    engine->RegisterObjectMethod(className, "void ApplyEffect()", AS_METHODPR(T, ApplyEffect, (), void), AS_CALL_THISCALL);

    // AutoRemoveMode ParticleEmitter::GetAutoRemoveMode() const
    engine->RegisterObjectMethod(className, "AutoRemoveMode GetAutoRemoveMode() const", AS_METHODPR(T, GetAutoRemoveMode, () const, AutoRemoveMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AutoRemoveMode get_autoRemoveMode() const", AS_METHODPR(T, GetAutoRemoveMode, () const, AutoRemoveMode), AS_CALL_THISCALL);

    // ParticleEffect* ParticleEmitter::GetEffect() const
    engine->RegisterObjectMethod(className, "ParticleEffect@+ GetEffect() const", AS_METHODPR(T, GetEffect, () const, ParticleEffect*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ParticleEffect@+ get_effect() const", AS_METHODPR(T, GetEffect, () const, ParticleEffect*), AS_CALL_THISCALL);

    // ResourceRef ParticleEmitter::GetEffectAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetEffectAttr() const", AS_METHODPR(T, GetEffectAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // unsigned ParticleEmitter::GetNumParticles() const
    engine->RegisterObjectMethod(className, "uint GetNumParticles() const", AS_METHODPR(T, GetNumParticles, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numParticles() const", AS_METHODPR(T, GetNumParticles, () const, unsigned), AS_CALL_THISCALL);

    // bool ParticleEmitter::GetSerializeParticles() const
    engine->RegisterObjectMethod(className, "bool GetSerializeParticles() const", AS_METHODPR(T, GetSerializeParticles, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_serializeParticles() const", AS_METHODPR(T, GetSerializeParticles, () const, bool), AS_CALL_THISCALL);

    // bool ParticleEmitter::IsEmitting() const
    engine->RegisterObjectMethod(className, "bool IsEmitting() const", AS_METHODPR(T, IsEmitting, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_emitting() const", AS_METHODPR(T, IsEmitting, () const, bool), AS_CALL_THISCALL);

    // void ParticleEmitter::RemoveAllParticles()
    engine->RegisterObjectMethod(className, "void RemoveAllParticles()", AS_METHODPR(T, RemoveAllParticles, (), void), AS_CALL_THISCALL);

    // void ParticleEmitter::Reset()
    engine->RegisterObjectMethod(className, "void Reset()", AS_METHODPR(T, Reset, (), void), AS_CALL_THISCALL);

    // void ParticleEmitter::ResetEmissionTimer()
    engine->RegisterObjectMethod(className, "void ResetEmissionTimer()", AS_METHODPR(T, ResetEmissionTimer, (), void), AS_CALL_THISCALL);

    // void ParticleEmitter::SetAutoRemoveMode(AutoRemoveMode mode)
    engine->RegisterObjectMethod(className, "void SetAutoRemoveMode(AutoRemoveMode)", AS_METHODPR(T, SetAutoRemoveMode, (AutoRemoveMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoRemoveMode(AutoRemoveMode)", AS_METHODPR(T, SetAutoRemoveMode, (AutoRemoveMode), void), AS_CALL_THISCALL);

    // void ParticleEmitter::SetEffect(ParticleEffect* effect)
    engine->RegisterObjectMethod(className, "void SetEffect(ParticleEffect@+)", AS_METHODPR(T, SetEffect, (ParticleEffect*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effect(ParticleEffect@+)", AS_METHODPR(T, SetEffect, (ParticleEffect*), void), AS_CALL_THISCALL);

    // void ParticleEmitter::SetEffectAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetEffectAttr(const ResourceRef&in)", AS_METHODPR(T, SetEffectAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void ParticleEmitter::SetEmitting(bool enable)
    engine->RegisterObjectMethod(className, "void SetEmitting(bool)", AS_METHODPR(T, SetEmitting, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_emitting(bool)", AS_METHODPR(T, SetEmitting, (bool), void), AS_CALL_THISCALL);

    // void ParticleEmitter::SetNumParticles(unsigned num)
    engine->RegisterObjectMethod(className, "void SetNumParticles(uint)", AS_METHODPR(T, SetNumParticles, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_numParticles(uint)", AS_METHODPR(T, SetNumParticles, (unsigned), void), AS_CALL_THISCALL);

    // void ParticleEmitter::SetSerializeParticles(bool enable)
    engine->RegisterObjectMethod(className, "void SetSerializeParticles(bool)", AS_METHODPR(T, SetSerializeParticles, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_serializeParticles(bool)", AS_METHODPR(T, SetSerializeParticles, (bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ParticleEmitter
        REGISTER_MEMBERS_MANUAL_PART_ParticleEmitter();
    #endif
}

// class Skybox | File: ../Graphics/Skybox.h
template <class T> void RegisterMembers_Skybox(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_StaticModel<T>(engine, className);

    // virtual void StaticModel::SetModel(Model* model)
    // Not registered because have @manualbind mark

    #ifdef REGISTER_MEMBERS_MANUAL_PART_Skybox
        REGISTER_MEMBERS_MANUAL_PART_Skybox();
    #endif
}

// class StaticModelGroup | File: ../Graphics/StaticModelGroup.h
template <class T> void RegisterMembers_StaticModelGroup(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_StaticModel<T>(engine, className);

    // const VariantVector& StaticModelGroup::GetNodeIDsAttr() const
    // Error: type "const VariantVector&" can not automatically bind
    // virtual void StaticModel::SetModel(Model* model)
    // Not registered because have @manualbind mark
    // void StaticModelGroup::SetNodeIDsAttr(const VariantVector& value)
    // Error: type "const VariantVector&" can not automatically bind

    // void StaticModelGroup::AddInstanceNode(Node* node)
    engine->RegisterObjectMethod(className, "void AddInstanceNode(Node@+)", AS_METHODPR(T, AddInstanceNode, (Node*), void), AS_CALL_THISCALL);

    // Node* StaticModelGroup::GetInstanceNode(unsigned index) const
    engine->RegisterObjectMethod(className, "Node@+ GetInstanceNode(uint) const", AS_METHODPR(T, GetInstanceNode, (unsigned) const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_instanceNodes(uint) const", AS_METHODPR(T, GetInstanceNode, (unsigned) const, Node*), AS_CALL_THISCALL);

    // unsigned StaticModelGroup::GetNumInstanceNodes() const
    engine->RegisterObjectMethod(className, "uint GetNumInstanceNodes() const", AS_METHODPR(T, GetNumInstanceNodes, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numInstanceNodes() const", AS_METHODPR(T, GetNumInstanceNodes, () const, unsigned), AS_CALL_THISCALL);

    // void StaticModelGroup::RemoveAllInstanceNodes()
    engine->RegisterObjectMethod(className, "void RemoveAllInstanceNodes()", AS_METHODPR(T, RemoveAllInstanceNodes, (), void), AS_CALL_THISCALL);

    // void StaticModelGroup::RemoveInstanceNode(Node* node)
    engine->RegisterObjectMethod(className, "void RemoveInstanceNode(Node@+)", AS_METHODPR(T, RemoveInstanceNode, (Node*), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StaticModelGroup
        REGISTER_MEMBERS_MANUAL_PART_StaticModelGroup();
    #endif
}

// class View3D | File: ../UI/View3D.h
template <class T> void RegisterMembers_View3D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Window<T>(engine, className);

    // bool View3D::GetAutoUpdate() const
    engine->RegisterObjectMethod(className, "bool GetAutoUpdate() const", AS_METHODPR(T, GetAutoUpdate, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_autoUpdate() const", AS_METHODPR(T, GetAutoUpdate, () const, bool), AS_CALL_THISCALL);

    // Node* View3D::GetCameraNode() const
    engine->RegisterObjectMethod(className, "Node@+ GetCameraNode() const", AS_METHODPR(T, GetCameraNode, () const, Node*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Node@+ get_cameraNode() const", AS_METHODPR(T, GetCameraNode, () const, Node*), AS_CALL_THISCALL);

    // Texture2D* View3D::GetDepthTexture() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetDepthTexture() const", AS_METHODPR(T, GetDepthTexture, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_depthTexture() const", AS_METHODPR(T, GetDepthTexture, () const, Texture2D*), AS_CALL_THISCALL);

    // unsigned View3D::GetFormat() const
    engine->RegisterObjectMethod(className, "uint GetFormat() const", AS_METHODPR(T, GetFormat, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_format() const", AS_METHODPR(T, GetFormat, () const, unsigned), AS_CALL_THISCALL);

    // Texture2D* View3D::GetRenderTexture() const
    engine->RegisterObjectMethod(className, "Texture2D@+ GetRenderTexture() const", AS_METHODPR(T, GetRenderTexture, () const, Texture2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Texture2D@+ get_renderTexture() const", AS_METHODPR(T, GetRenderTexture, () const, Texture2D*), AS_CALL_THISCALL);

    // Scene* View3D::GetScene() const
    engine->RegisterObjectMethod(className, "Scene@+ GetScene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Scene@+ get_scene() const", AS_METHODPR(T, GetScene, () const, Scene*), AS_CALL_THISCALL);

    // Viewport* View3D::GetViewport() const
    engine->RegisterObjectMethod(className, "Viewport@+ GetViewport() const", AS_METHODPR(T, GetViewport, () const, Viewport*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Viewport@+ get_viewport() const", AS_METHODPR(T, GetViewport, () const, Viewport*), AS_CALL_THISCALL);

    // void View3D::QueueUpdate()
    engine->RegisterObjectMethod(className, "void QueueUpdate()", AS_METHODPR(T, QueueUpdate, (), void), AS_CALL_THISCALL);

    // void View3D::SetAutoUpdate(bool enable)
    engine->RegisterObjectMethod(className, "void SetAutoUpdate(bool)", AS_METHODPR(T, SetAutoUpdate, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_autoUpdate(bool)", AS_METHODPR(T, SetAutoUpdate, (bool), void), AS_CALL_THISCALL);

    // void View3D::SetFormat(unsigned format)
    engine->RegisterObjectMethod(className, "void SetFormat(uint)", AS_METHODPR(T, SetFormat, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_format(uint)", AS_METHODPR(T, SetFormat, (unsigned), void), AS_CALL_THISCALL);

    // void View3D::SetView(Scene* scene, Camera* camera, bool ownScene = true)
    engine->RegisterObjectMethod(className, "void SetView(Scene@+, Camera@+, bool = true)", AS_METHODPR(T, SetView, (Scene*, Camera*, bool), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_View3D
        REGISTER_MEMBERS_MANUAL_PART_View3D();
    #endif
}

#ifdef URHO3D_URHO2D

// class ParticleEmitter2D | File: ../Urho2D/ParticleEmitter2D.h
template <class T> void RegisterMembers_ParticleEmitter2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable2D<T>(engine, className);

    // BlendMode ParticleEmitter2D::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BlendMode get_blendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // ParticleEffect2D* ParticleEmitter2D::GetEffect() const
    engine->RegisterObjectMethod(className, "ParticleEffect2D@+ GetEffect() const", AS_METHODPR(T, GetEffect, () const, ParticleEffect2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ParticleEffect2D@+ get_effect() const", AS_METHODPR(T, GetEffect, () const, ParticleEffect2D*), AS_CALL_THISCALL);

    // unsigned ParticleEmitter2D::GetMaxParticles() const
    engine->RegisterObjectMethod(className, "uint GetMaxParticles() const", AS_METHODPR(T, GetMaxParticles, () const, unsigned), AS_CALL_THISCALL);

    // ResourceRef ParticleEmitter2D::GetParticleEffectAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetParticleEffectAttr() const", AS_METHODPR(T, GetParticleEffectAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // Sprite2D* ParticleEmitter2D::GetSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Sprite2D@+ get_sprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // ResourceRef ParticleEmitter2D::GetSpriteAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetSpriteAttr() const", AS_METHODPR(T, GetSpriteAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // bool ParticleEmitter2D::IsEmitting() const
    engine->RegisterObjectMethod(className, "bool IsEmitting() const", AS_METHODPR(T, IsEmitting, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_emitting() const", AS_METHODPR(T, IsEmitting, () const, bool), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetBlendMode(BlendMode blendMode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetEffect(ParticleEffect2D* effect)
    engine->RegisterObjectMethod(className, "void SetEffect(ParticleEffect2D@+)", AS_METHODPR(T, SetEffect, (ParticleEffect2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_effect(ParticleEffect2D@+)", AS_METHODPR(T, SetEffect, (ParticleEffect2D*), void), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetEmitting(bool enable)
    engine->RegisterObjectMethod(className, "void SetEmitting(bool)", AS_METHODPR(T, SetEmitting, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_emitting(bool)", AS_METHODPR(T, SetEmitting, (bool), void), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetMaxParticles(unsigned maxParticles)
    engine->RegisterObjectMethod(className, "void SetMaxParticles(uint)", AS_METHODPR(T, SetMaxParticles, (unsigned), void), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetParticleEffectAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetParticleEffectAttr(const ResourceRef&in)", AS_METHODPR(T, SetParticleEffectAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetSprite(Sprite2D* sprite)
    engine->RegisterObjectMethod(className, "void SetSprite(Sprite2D@+)", AS_METHODPR(T, SetSprite, (Sprite2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sprite(Sprite2D@+)", AS_METHODPR(T, SetSprite, (Sprite2D*), void), AS_CALL_THISCALL);

    // void ParticleEmitter2D::SetSpriteAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetSpriteAttr(const ResourceRef&in)", AS_METHODPR(T, SetSpriteAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_ParticleEmitter2D
        REGISTER_MEMBERS_MANUAL_PART_ParticleEmitter2D();
    #endif
}

// class StaticSprite2D | File: ../Urho2D/StaticSprite2D.h
template <class T> void RegisterMembers_StaticSprite2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Drawable2D<T>(engine, className);

    // float StaticSprite2D::GetAlpha() const
    engine->RegisterObjectMethod(className, "float GetAlpha() const", AS_METHODPR(T, GetAlpha, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_alpha() const", AS_METHODPR(T, GetAlpha, () const, float), AS_CALL_THISCALL);

    // BlendMode StaticSprite2D::GetBlendMode() const
    engine->RegisterObjectMethod(className, "BlendMode GetBlendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "BlendMode get_blendMode() const", AS_METHODPR(T, GetBlendMode, () const, BlendMode), AS_CALL_THISCALL);

    // const Color& StaticSprite2D::GetColor() const
    engine->RegisterObjectMethod(className, "const Color& GetColor() const", AS_METHODPR(T, GetColor, () const, const Color&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Color& get_color() const", AS_METHODPR(T, GetColor, () const, const Color&), AS_CALL_THISCALL);

    // Material* StaticSprite2D::GetCustomMaterial() const
    engine->RegisterObjectMethod(className, "Material@+ GetCustomMaterial() const", AS_METHODPR(T, GetCustomMaterial, () const, Material*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Material@+ get_customMaterial() const", AS_METHODPR(T, GetCustomMaterial, () const, Material*), AS_CALL_THISCALL);

    // ResourceRef StaticSprite2D::GetCustomMaterialAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetCustomMaterialAttr() const", AS_METHODPR(T, GetCustomMaterialAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // const Rect& StaticSprite2D::GetDrawRect() const
    engine->RegisterObjectMethod(className, "const Rect& GetDrawRect() const", AS_METHODPR(T, GetDrawRect, () const, const Rect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Rect& get_drawRect() const", AS_METHODPR(T, GetDrawRect, () const, const Rect&), AS_CALL_THISCALL);

    // bool StaticSprite2D::GetFlipX() const
    engine->RegisterObjectMethod(className, "bool GetFlipX() const", AS_METHODPR(T, GetFlipX, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_flipX() const", AS_METHODPR(T, GetFlipX, () const, bool), AS_CALL_THISCALL);

    // bool StaticSprite2D::GetFlipY() const
    engine->RegisterObjectMethod(className, "bool GetFlipY() const", AS_METHODPR(T, GetFlipY, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_flipY() const", AS_METHODPR(T, GetFlipY, () const, bool), AS_CALL_THISCALL);

    // const Vector2& StaticSprite2D::GetHotSpot() const
    engine->RegisterObjectMethod(className, "const Vector2& GetHotSpot() const", AS_METHODPR(T, GetHotSpot, () const, const Vector2&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Vector2& get_hotSpot() const", AS_METHODPR(T, GetHotSpot, () const, const Vector2&), AS_CALL_THISCALL);

    // Sprite2D* StaticSprite2D::GetSprite() const
    engine->RegisterObjectMethod(className, "Sprite2D@+ GetSprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "Sprite2D@+ get_sprite() const", AS_METHODPR(T, GetSprite, () const, Sprite2D*), AS_CALL_THISCALL);

    // ResourceRef StaticSprite2D::GetSpriteAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetSpriteAttr() const", AS_METHODPR(T, GetSpriteAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // bool StaticSprite2D::GetSwapXY() const
    engine->RegisterObjectMethod(className, "bool GetSwapXY() const", AS_METHODPR(T, GetSwapXY, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_swapXY() const", AS_METHODPR(T, GetSwapXY, () const, bool), AS_CALL_THISCALL);

    // const Rect& StaticSprite2D::GetTextureRect() const
    engine->RegisterObjectMethod(className, "const Rect& GetTextureRect() const", AS_METHODPR(T, GetTextureRect, () const, const Rect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const Rect& get_textureRect() const", AS_METHODPR(T, GetTextureRect, () const, const Rect&), AS_CALL_THISCALL);

    // bool StaticSprite2D::GetUseDrawRect() const
    engine->RegisterObjectMethod(className, "bool GetUseDrawRect() const", AS_METHODPR(T, GetUseDrawRect, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useDrawRect() const", AS_METHODPR(T, GetUseDrawRect, () const, bool), AS_CALL_THISCALL);

    // bool StaticSprite2D::GetUseHotSpot() const
    engine->RegisterObjectMethod(className, "bool GetUseHotSpot() const", AS_METHODPR(T, GetUseHotSpot, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useHotSpot() const", AS_METHODPR(T, GetUseHotSpot, () const, bool), AS_CALL_THISCALL);

    // bool StaticSprite2D::GetUseTextureRect() const
    engine->RegisterObjectMethod(className, "bool GetUseTextureRect() const", AS_METHODPR(T, GetUseTextureRect, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_useTextureRect() const", AS_METHODPR(T, GetUseTextureRect, () const, bool), AS_CALL_THISCALL);

    // void StaticSprite2D::SetAlpha(float alpha)
    engine->RegisterObjectMethod(className, "void SetAlpha(float)", AS_METHODPR(T, SetAlpha, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_alpha(float)", AS_METHODPR(T, SetAlpha, (float), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetBlendMode(BlendMode blendMode)
    engine->RegisterObjectMethod(className, "void SetBlendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_blendMode(BlendMode)", AS_METHODPR(T, SetBlendMode, (BlendMode), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetColor(const Color& color)
    engine->RegisterObjectMethod(className, "void SetColor(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_color(const Color&in)", AS_METHODPR(T, SetColor, (const Color&), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetCustomMaterial(Material* customMaterial)
    engine->RegisterObjectMethod(className, "void SetCustomMaterial(Material@+)", AS_METHODPR(T, SetCustomMaterial, (Material*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_customMaterial(Material@+)", AS_METHODPR(T, SetCustomMaterial, (Material*), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetCustomMaterialAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetCustomMaterialAttr(const ResourceRef&in)", AS_METHODPR(T, SetCustomMaterialAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetDrawRect(const Rect& rect)
    engine->RegisterObjectMethod(className, "void SetDrawRect(const Rect&in)", AS_METHODPR(T, SetDrawRect, (const Rect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_drawRect(const Rect&in)", AS_METHODPR(T, SetDrawRect, (const Rect&), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetFlip(bool flipX, bool flipY, bool swapXY = false)
    engine->RegisterObjectMethod(className, "void SetFlip(bool, bool, bool = false)", AS_METHODPR(T, SetFlip, (bool, bool, bool), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetFlipX(bool flipX)
    engine->RegisterObjectMethod(className, "void SetFlipX(bool)", AS_METHODPR(T, SetFlipX, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_flipX(bool)", AS_METHODPR(T, SetFlipX, (bool), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetFlipY(bool flipY)
    engine->RegisterObjectMethod(className, "void SetFlipY(bool)", AS_METHODPR(T, SetFlipY, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_flipY(bool)", AS_METHODPR(T, SetFlipY, (bool), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetHotSpot(const Vector2& hotspot)
    engine->RegisterObjectMethod(className, "void SetHotSpot(const Vector2&in)", AS_METHODPR(T, SetHotSpot, (const Vector2&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_hotSpot(const Vector2&in)", AS_METHODPR(T, SetHotSpot, (const Vector2&), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetSprite(Sprite2D* sprite)
    engine->RegisterObjectMethod(className, "void SetSprite(Sprite2D@+)", AS_METHODPR(T, SetSprite, (Sprite2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_sprite(Sprite2D@+)", AS_METHODPR(T, SetSprite, (Sprite2D*), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetSpriteAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetSpriteAttr(const ResourceRef&in)", AS_METHODPR(T, SetSpriteAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetSwapXY(bool swapXY)
    engine->RegisterObjectMethod(className, "void SetSwapXY(bool)", AS_METHODPR(T, SetSwapXY, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_swapXY(bool)", AS_METHODPR(T, SetSwapXY, (bool), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetTextureRect(const Rect& rect)
    engine->RegisterObjectMethod(className, "void SetTextureRect(const Rect&in)", AS_METHODPR(T, SetTextureRect, (const Rect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_textureRect(const Rect&in)", AS_METHODPR(T, SetTextureRect, (const Rect&), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetUseDrawRect(bool useDrawRect)
    engine->RegisterObjectMethod(className, "void SetUseDrawRect(bool)", AS_METHODPR(T, SetUseDrawRect, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useDrawRect(bool)", AS_METHODPR(T, SetUseDrawRect, (bool), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetUseHotSpot(bool useHotSpot)
    engine->RegisterObjectMethod(className, "void SetUseHotSpot(bool)", AS_METHODPR(T, SetUseHotSpot, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useHotSpot(bool)", AS_METHODPR(T, SetUseHotSpot, (bool), void), AS_CALL_THISCALL);

    // void StaticSprite2D::SetUseTextureRect(bool useTextureRect)
    engine->RegisterObjectMethod(className, "void SetUseTextureRect(bool)", AS_METHODPR(T, SetUseTextureRect, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_useTextureRect(bool)", AS_METHODPR(T, SetUseTextureRect, (bool), void), AS_CALL_THISCALL);

    // virtual void Drawable::Update(const FrameInfo& frame)
    engine->RegisterObjectMethod(className, "void Update(const FrameInfo&in)", AS_METHODPR(T, Update, (const FrameInfo&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StaticSprite2D
        REGISTER_MEMBERS_MANUAL_PART_StaticSprite2D();
    #endif
}

#endif // def URHO3D_URHO2D

// PODVector<UIElement*> DropDownList::GetItems() const
template <class T> CScriptArray* DropDownList_PODVectorlesUIElementstargre_GetItems_void_template(T* _ptr)
{
    PODVector<UIElement*> result = _ptr->GetItems();
    return VectorToHandleArray(result, "Array<UIElement@>");
}

// class DropDownList | File: ../UI/DropDownList.h
template <class T> void RegisterMembers_DropDownList(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_Menu<T>(engine, className);

    // void DropDownList::AddItem(UIElement* item)
    engine->RegisterObjectMethod(className, "void AddItem(UIElement@+)", AS_METHODPR(T, AddItem, (UIElement*), void), AS_CALL_THISCALL);

    // UIElement* DropDownList::GetItem(unsigned index) const
    engine->RegisterObjectMethod(className, "UIElement@+ GetItem(uint) const", AS_METHODPR(T, GetItem, (unsigned) const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_items(uint) const", AS_METHODPR(T, GetItem, (unsigned) const, UIElement*), AS_CALL_THISCALL);

    // PODVector<UIElement*> DropDownList::GetItems() const
    engine->RegisterObjectMethod(className, "Array<UIElement@>@ GetItems() const", AS_FUNCTION_OBJFIRST(DropDownList_PODVectorlesUIElementstargre_GetItems_void_template<DropDownList>), AS_CALL_CDECL_OBJFIRST);

    // ListView* DropDownList::GetListView() const
    engine->RegisterObjectMethod(className, "ListView@+ GetListView() const", AS_METHODPR(T, GetListView, () const, ListView*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "ListView@+ get_listView() const", AS_METHODPR(T, GetListView, () const, ListView*), AS_CALL_THISCALL);

    // unsigned DropDownList::GetNumItems() const
    engine->RegisterObjectMethod(className, "uint GetNumItems() const", AS_METHODPR(T, GetNumItems, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_numItems() const", AS_METHODPR(T, GetNumItems, () const, unsigned), AS_CALL_THISCALL);

    // UIElement* DropDownList::GetPlaceholder() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetPlaceholder() const", AS_METHODPR(T, GetPlaceholder, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_placeholder() const", AS_METHODPR(T, GetPlaceholder, () const, UIElement*), AS_CALL_THISCALL);

    // const String& DropDownList::GetPlaceholderText() const
    engine->RegisterObjectMethod(className, "const String& GetPlaceholderText() const", AS_METHODPR(T, GetPlaceholderText, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_placeholderText() const", AS_METHODPR(T, GetPlaceholderText, () const, const String&), AS_CALL_THISCALL);

    // bool DropDownList::GetResizePopup() const
    engine->RegisterObjectMethod(className, "bool GetResizePopup() const", AS_METHODPR(T, GetResizePopup, () const, bool), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "bool get_resizePopup() const", AS_METHODPR(T, GetResizePopup, () const, bool), AS_CALL_THISCALL);

    // UIElement* DropDownList::GetSelectedItem() const
    engine->RegisterObjectMethod(className, "UIElement@+ GetSelectedItem() const", AS_METHODPR(T, GetSelectedItem, () const, UIElement*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "UIElement@+ get_selectedItem() const", AS_METHODPR(T, GetSelectedItem, () const, UIElement*), AS_CALL_THISCALL);

    // unsigned DropDownList::GetSelection() const
    engine->RegisterObjectMethod(className, "uint GetSelection() const", AS_METHODPR(T, GetSelection, () const, unsigned), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "uint get_selection() const", AS_METHODPR(T, GetSelection, () const, unsigned), AS_CALL_THISCALL);

    // void DropDownList::InsertItem(unsigned index, UIElement* item)
    engine->RegisterObjectMethod(className, "void InsertItem(uint, UIElement@+)", AS_METHODPR(T, InsertItem, (unsigned, UIElement*), void), AS_CALL_THISCALL);

    // void DropDownList::RemoveAllItems()
    engine->RegisterObjectMethod(className, "void RemoveAllItems()", AS_METHODPR(T, RemoveAllItems, (), void), AS_CALL_THISCALL);

    // void DropDownList::RemoveItem(UIElement* item)
    engine->RegisterObjectMethod(className, "void RemoveItem(UIElement@+)", AS_METHODPR(T, RemoveItem, (UIElement*), void), AS_CALL_THISCALL);

    // void DropDownList::RemoveItem(unsigned index)
    engine->RegisterObjectMethod(className, "void RemoveItem(uint)", AS_METHODPR(T, RemoveItem, (unsigned), void), AS_CALL_THISCALL);

    // void DropDownList::SetPlaceholderText(const String& text)
    engine->RegisterObjectMethod(className, "void SetPlaceholderText(const String&in)", AS_METHODPR(T, SetPlaceholderText, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_placeholderText(const String&in)", AS_METHODPR(T, SetPlaceholderText, (const String&), void), AS_CALL_THISCALL);

    // void DropDownList::SetResizePopup(bool enable)
    engine->RegisterObjectMethod(className, "void SetResizePopup(bool)", AS_METHODPR(T, SetResizePopup, (bool), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_resizePopup(bool)", AS_METHODPR(T, SetResizePopup, (bool), void), AS_CALL_THISCALL);

    // void DropDownList::SetSelection(unsigned index)
    engine->RegisterObjectMethod(className, "void SetSelection(uint)", AS_METHODPR(T, SetSelection, (unsigned), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_selection(uint)", AS_METHODPR(T, SetSelection, (unsigned), void), AS_CALL_THISCALL);

    // void DropDownList::SetSelectionAttr(unsigned index)
    engine->RegisterObjectMethod(className, "void SetSelectionAttr(uint)", AS_METHODPR(T, SetSelectionAttr, (unsigned), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_DropDownList
        REGISTER_MEMBERS_MANUAL_PART_DropDownList();
    #endif
}

#ifdef URHO3D_URHO2D

// class AnimatedSprite2D | File: ../Urho2D/AnimatedSprite2D.h
template <class T> void RegisterMembers_AnimatedSprite2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_StaticSprite2D<T>(engine, className);

    // const String& AnimatedSprite2D::GetAnimation() const
    engine->RegisterObjectMethod(className, "const String& GetAnimation() const", AS_METHODPR(T, GetAnimation, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_animation() const", AS_METHODPR(T, GetAnimation, () const, const String&), AS_CALL_THISCALL);

    // AnimationSet2D* AnimatedSprite2D::GetAnimationSet() const
    engine->RegisterObjectMethod(className, "AnimationSet2D@+ GetAnimationSet() const", AS_METHODPR(T, GetAnimationSet, () const, AnimationSet2D*), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "AnimationSet2D@+ get_animationSet() const", AS_METHODPR(T, GetAnimationSet, () const, AnimationSet2D*), AS_CALL_THISCALL);

    // ResourceRef AnimatedSprite2D::GetAnimationSetAttr() const
    engine->RegisterObjectMethod(className, "ResourceRef GetAnimationSetAttr() const", AS_METHODPR(T, GetAnimationSetAttr, () const, ResourceRef), AS_CALL_THISCALL);

    // const String& AnimatedSprite2D::GetEntity() const
    engine->RegisterObjectMethod(className, "const String& GetEntity() const", AS_METHODPR(T, GetEntity, () const, const String&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const String& get_entity() const", AS_METHODPR(T, GetEntity, () const, const String&), AS_CALL_THISCALL);

    // LoopMode2D AnimatedSprite2D::GetLoopMode() const
    engine->RegisterObjectMethod(className, "LoopMode2D GetLoopMode() const", AS_METHODPR(T, GetLoopMode, () const, LoopMode2D), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "LoopMode2D get_loopMode() const", AS_METHODPR(T, GetLoopMode, () const, LoopMode2D), AS_CALL_THISCALL);

    // float AnimatedSprite2D::GetSpeed() const
    engine->RegisterObjectMethod(className, "float GetSpeed() const", AS_METHODPR(T, GetSpeed, () const, float), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "float get_speed() const", AS_METHODPR(T, GetSpeed, () const, float), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetAnimation(const String& name, LoopMode2D loopMode = LM_DEFAULT)
    engine->RegisterObjectMethod(className, "void SetAnimation(const String&in, LoopMode2D = LM_DEFAULT)", AS_METHODPR(T, SetAnimation, (const String&, LoopMode2D), void), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetAnimationAttr(const String& name)
    engine->RegisterObjectMethod(className, "void SetAnimationAttr(const String&in)", AS_METHODPR(T, SetAnimationAttr, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animation(const String&in)", AS_METHODPR(T, SetAnimationAttr, (const String&), void), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetAnimationSet(AnimationSet2D* animationSet)
    engine->RegisterObjectMethod(className, "void SetAnimationSet(AnimationSet2D@+)", AS_METHODPR(T, SetAnimationSet, (AnimationSet2D*), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_animationSet(AnimationSet2D@+)", AS_METHODPR(T, SetAnimationSet, (AnimationSet2D*), void), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetAnimationSetAttr(const ResourceRef& value)
    engine->RegisterObjectMethod(className, "void SetAnimationSetAttr(const ResourceRef&in)", AS_METHODPR(T, SetAnimationSetAttr, (const ResourceRef&), void), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetEntity(const String& entity)
    engine->RegisterObjectMethod(className, "void SetEntity(const String&in)", AS_METHODPR(T, SetEntity, (const String&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_entity(const String&in)", AS_METHODPR(T, SetEntity, (const String&), void), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetLoopMode(LoopMode2D loopMode)
    engine->RegisterObjectMethod(className, "void SetLoopMode(LoopMode2D)", AS_METHODPR(T, SetLoopMode, (LoopMode2D), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_loopMode(LoopMode2D)", AS_METHODPR(T, SetLoopMode, (LoopMode2D), void), AS_CALL_THISCALL);

    // void AnimatedSprite2D::SetSpeed(float speed)
    engine->RegisterObjectMethod(className, "void SetSpeed(float)", AS_METHODPR(T, SetSpeed, (float), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_speed(float)", AS_METHODPR(T, SetSpeed, (float), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_AnimatedSprite2D
        REGISTER_MEMBERS_MANUAL_PART_AnimatedSprite2D();
    #endif
}

// class StretchableSprite2D | File: ../Urho2D/StretchableSprite2D.h
template <class T> void RegisterMembers_StretchableSprite2D(asIScriptEngine* engine, const char* className)
{
    RegisterMembers_StaticSprite2D<T>(engine, className);

    // const IntRect& StretchableSprite2D::GetBorder() const
    engine->RegisterObjectMethod(className, "const IntRect& GetBorder() const", AS_METHODPR(T, GetBorder, () const, const IntRect&), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "const IntRect& get_border() const", AS_METHODPR(T, GetBorder, () const, const IntRect&), AS_CALL_THISCALL);

    // void StretchableSprite2D::SetBorder(const IntRect& border)
    engine->RegisterObjectMethod(className, "void SetBorder(const IntRect&in)", AS_METHODPR(T, SetBorder, (const IntRect&), void), AS_CALL_THISCALL);
    engine->RegisterObjectMethod(className, "void set_border(const IntRect&in)", AS_METHODPR(T, SetBorder, (const IntRect&), void), AS_CALL_THISCALL);

    #ifdef REGISTER_MEMBERS_MANUAL_PART_StretchableSprite2D
        REGISTER_MEMBERS_MANUAL_PART_StretchableSprite2D();
    #endif
}

#endif // def URHO3D_URHO2D

} // namespace Urho3D
